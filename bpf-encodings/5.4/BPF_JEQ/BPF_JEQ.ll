; ModuleID = 'llvm-link'
source_filename = "llvm-link"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

module asm "\09.section \22___ksymtab_gpl+tnum_strn\22, \22a\22\09"
module asm "\09.balign 4\09\09\09\09\09"
module asm "__ksymtab_tnum_strn:\09\09\09\09"
module asm "\09.long\09tnum_strn- .\09\09\09\09"
module asm "\09.long\09__kstrtab_tnum_strn- .\09\09\09"
module asm "\09.long\090\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___ksymtab_gpl+bpf_verifier_log_write\22, \22a\22\09"
module asm "\09.balign 4\09\09\09\09\09"
module asm "__ksymtab_bpf_verifier_log_write:\09\09\09\09"
module asm "\09.long\09bpf_verifier_log_write- .\09\09\09\09"
module asm "\09.long\09__kstrtab_bpf_verifier_log_write- .\09\09\09"
module asm "\09.long\090\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"

%struct.bpf_insn = type { i8, i8, i16, i32 }
%struct.bpf_verifier_ops = type { %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.util_est*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* }
%struct.bpf_func_proto = type { i64 (i64, i64, i64, i64, i64)*, i8, i8, i32, i32, i32, i32, i32, i32 }
%struct.bpf_prog = type { i16, i16, i32, i32, i32, i32, [8 x i8], %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, i32 (i8*, %struct.bpf_insn*)*, %union.anon.146 }
%struct.bpf_prog_aux = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, %struct.bpf_prog**, i8*, %struct.latch_tree_node, %struct.list_head, %struct.bpf_prog_ops*, %struct.bpf_map**, %struct.bpf_prog*, %struct.user_struct*, i64, [2 x %struct.bpf_map*], [16 x i8], i8*, %struct.bpf_prog_offload*, %struct.btf*, %struct.util_est*, %struct.ethtool_pauseparam*, i8**, i32, i32, i32, %struct.bpf_prog_stats*, %union.anon.145 }
%struct.atomic_t = type { i32 }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.bpf_prog_ops = type { i32 (%struct.bpf_prog*, %union.bpf_attr*, %union.bpf_attr*)* }
%union.bpf_attr = type { %struct.anon.1 }
%struct.anon.1 = type { i32, i32, i64, i64, i32, i32, i64, i32, i32, [16 x i8], i32, i32, i32, i32, i64, i32, i32, i64, i32 }
%struct.bpf_map = type { %struct.bpf_map_ops*, %struct.bpf_map*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, %struct.bpf_map_memory, i8, i8, [38 x i8], %struct.atomic_t, %struct.atomic_t, %struct.work_struct, [16 x i8], [8 x i8] }
%struct.bpf_map_ops = type { i32 (%union.bpf_attr*)*, %struct.bpf_map* (%union.bpf_attr*)*, void (%struct.bpf_map*, %struct.file*)*, void (%struct.bpf_map*)*, i32 (%struct.bpf_map*, i8*, i8*)*, void (%struct.bpf_map*)*, i8* (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, %struct.file*, i32)*, void (i8*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (i8*)*, void (%struct.bpf_map*, i8*, %struct.seq_file*)*, i32 (%struct.bpf_map*, %struct.btf*, %struct.btf_type*, %struct.btf_type*)*, i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64, i32*)* }
%struct.file = type { %union.anon.12, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %union.anon.13, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i32 }
%union.anon.12 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.atomic_t, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.local_t, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.sysv_shm, %struct.list_head, %struct.list_head, %union.anon.75 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.13, i8* }
%struct.local_t = type { %union.anon.13 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, i8*, i32, i64, i64, i32, %struct.fsnotify_mark_connector*, [32 x i8], %union.anon.127, i32, i32, %struct.mutex, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.13, %union.anon.13, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [52 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, i32 (%struct.fs_context*)*, %struct.fs_parameter_description*, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.u64_stats_sync, [3 x %struct.u64_stats_sync], %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.u64_stats_sync }
%struct.fs_context = type opaque
%struct.fs_parameter_description = type opaque
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.uid_gid_extent*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.uid_gid_extent*, i32*, i8, %struct.uid_gid_extent*, i32*, i32, i32, %struct.uid_gid_extent*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, i32*, i32, %struct.srcu_struct**, i32, %struct.bpf_raw_event_map*, %struct.jump_entry*, i32, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_eval_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, %struct.thread_info*, i32, [52 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.qspinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.attribute_group**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)*, void (%struct.kobject*, %struct.atomic_t*, %struct.atomic_t*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.13, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %union.anon.13, %struct.mempolicy*, %struct.u64_stats_sync }
%struct.mm_struct = type { %struct.anon.15, [0 x i64] }
%struct.anon.15 = type { %struct.vm_area_struct*, %struct.rb_root, i64, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, i64, i64, %union.anon.13*, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.13, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, %union.anon.13, i64, i64, i64, i64, %struct.spinlock, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.atomic_t, i8, %struct.uprobes_state, %union.anon.13, %struct.work_struct }
%struct.rb_root = type { %struct.rb_node* }
%struct.mm_rss_stat = type { [4 x %union.anon.13] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i64, %union.anon.13, %struct.rw_semaphore, %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %union.anon.17, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask*, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.pid*, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.posix_cputimers, %struct.cred*, %struct.cred*, %struct.cred*, %struct.key*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.cpumask, %struct.cpumask, %struct.cpumask, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, %struct.task_struct*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, %struct.capture_control*, i64, %struct.kernel_siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.cpumask, %struct.atomic_t, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.rseq*, i32, i64, %struct.tlbflush_unmap_batch, %union.anon.12, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.uprobe_task*, i32, %struct.task_struct*, %struct.vm_struct*, %union.anon.17, i8*, %struct.thread_struct }
%struct.thread_info = type { i64, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.thread_info, i64, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [24 x i8], %struct.sched_avg }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i64, i32, i32, i64, i64, i64, %struct.util_est }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8, i8, i8 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.atomic_t, %struct.hrtimer*, %struct.timerqueue_head, i64 ()*, i64 }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, i8, i32, i16, i16, i32, i64, %struct.hrtimer*, i64, %struct.hrtimer*, [8 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i64, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.20 }
%union.anon.20 = type { %struct.anon.21 }
%struct.anon.21 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid = type { %union.anon.17, i32, [4 x %struct.hlist_head], %struct.wait_queue_head, %struct.callback_head, [1 x %struct.upid] }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.upid = type { i32, %struct.pid_namespace* }
%struct.pid_namespace = type { %struct.qspinlock, %struct.idr, %struct.callback_head, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.vfsmount*, %struct.dentry*, %struct.dentry*, %struct.fs_pin*, %struct.user_namespace*, %struct.ucounts*, %struct.work_struct, %struct.atomic_t, i32, i32, %struct.ns_common }
%struct.idr = type { %struct.xarray, i32, i32 }
%struct.xarray = type { %struct.spinlock, i32, i8* }
%struct.kmem_cache = type opaque
%struct.fs_pin = type opaque
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.atomic_t, i32, [9 x %struct.atomic_t] }
%struct.ns_common = type { %union.anon.13, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.key = type { %union.anon.17, i32, %union.anon.27, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.13, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i16, i64, %union.anon.29, %union.anon.33, %struct.key_restriction* }
%union.anon.27 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.29 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { i64, %union.anon.13, %struct.key_type*, %struct.key_tag*, i8* }
%struct.key_type = type opaque
%struct.key_tag = type { %struct.callback_head, %union.anon.17, i8 }
%union.anon.33 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.key_restriction = type { i32 (%struct.key*, %struct.key_type*, %union.key_payload*, %struct.key*)*, %struct.key*, %struct.key_type* }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type { %union.anon.17, %union.anon.17, %struct.spinlock, i32, i32, i32, %struct.spinlock, %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.llist_node, %struct.key_tag*, %struct.user_namespace*, %struct.ucounts*, %struct.idr, %struct.ns_common, %struct.list_head, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.uevent_sock*, %struct.hlist_head*, %struct.hlist_head*, i32, %struct.net_device*, %struct.list_head, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, %struct.netns_nexthop, [16 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, %struct.netns_nf_frag, %struct.ctl_table_header*, %struct.sock*, %struct.sock*, %struct.net_generic*, %struct.bpf_prog*, [56 x i8], %struct.netns_xfrm, %struct.sock*, [56 x i8] }
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.35, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.hlist_head }
%union.anon.35 = type { %struct.anon.36 }
%struct.anon.36 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.atomic_t*, %struct.atomic_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.uevent_sock = type opaque
%struct.net_device = type { [16 x i8], %struct.hlist_node, %struct.dev_ifalias*, i64, i64, i64, i32, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.126, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %union.anon.13, %union.anon.13, %union.anon.13, %struct.atomic_t, %struct.atomic_t, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.ndisc_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i32, i32, i16, i16, i8, i16, i16, [32 x i8], i8, i8, i8, i8, i16, i16, i16, %struct.spinlock, i8, i8, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, %struct.in_device*, %struct.inet6_dev*, %struct.wireless_dev*, %struct.wpan_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, %struct.bpf_prog*, i64, i32 (%struct.sk_buff**)*, i8*, %struct.mini_Qdisc*, %struct.netdev_queue*, %struct.nf_hook_entries*, [32 x i8], %struct.cpu_rmap*, %struct.hlist_node, [32 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, [16 x %struct.hlist_head], i32, %struct.spinlock, i32, %struct.xps_dev_maps*, %struct.xps_dev_maps*, %struct.mini_Qdisc*, %struct.timer_list, i32*, %struct.list_head, %struct.list_head, i8, i8, i16, i8, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.possible_net_t, %union.anon.142, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, i16, [16 x %struct.nlattr], [16 x i8], %struct.phy_device*, %struct.sfp_bus*, %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.u64_stats_sync, i8, i8, [38 x i8] }
%struct.dev_ifalias = type { %struct.callback_head, [0 x i8] }
%struct.anon.126 = type { %struct.list_head, %struct.list_head }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, %struct.net_device*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.net_device*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16, %struct.netlink_ext_ack*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.sk_buff*, %struct.nlattr**, %struct.net_device*, i8*, i16, i32, i32, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_bpf*)*, i32 (%struct.net_device*, i32, %struct.xdp_frame**, i32)*, i32 (%struct.net_device*, i32, i32)*, %struct.devlink_port* (%struct.net_device*)* }
%struct.sk_buff = type { %union.anon.40, %union.anon.43, %union.anon.13, [48 x i8], %union.anon.45, i64, i32, i32, i16, i16, i16, [0 x i8], i8, i8, [0 x i32], [0 x i8], i16, [0 x i8], i16, i16, %struct.atomic_t, i32, i32, i32, i16, i16, %struct.atomic_t, i32, %struct.atomic_t, %union.anon.51, i16, i16, i16, i16, i16, i16, i16, [0 x i32], i32, i32, i8*, i8*, i32, %union.anon.17, %struct.skb_ext* }
%union.anon.40 = type { %struct.anon.41 }
%struct.anon.41 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.42 }
%union.anon.42 = type { %struct.net_device* }
%union.anon.43 = type { %struct.sock* }
%union.anon.45 = type { %struct.anon.46 }
%struct.anon.46 = type { i64, void (%struct.sk_buff*)* }
%union.anon.51 = type { i16 }
%struct.skb_ext = type { %union.anon.17, [1 x i8], i8, [2 x i8], [0 x i8] }
%struct.ifreq = type { %union.anon.127, %union.anon.128 }
%union.anon.128 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type opaque
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.nlattr = type { i16, i16 }
%struct.netlink_ext_ack = type { i8*, %struct.nlattr*, [20 x i8], i8 }
%struct.neighbour = type opaque
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, %struct.netlink_ext_ack*, i16, i16, i8, i16, i32, i32, %union.anon.130 }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%union.anon.130 = type { [6 x i64] }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.udp_tunnel_info = type opaque
%struct.netdev_bpf = type { i32, %union.anon.131 }
%union.anon.131 = type { %struct.anon.132 }
%struct.anon.132 = type { i32, %struct.bpf_prog*, %struct.netlink_ext_ack* }
%struct.xdp_frame = type { i8*, i16, i16, i16, %struct.util_est, %struct.net_device* }
%struct.devlink_port = type opaque
%struct.ethtool_ops = type { void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*, i8*, i8*)*, i32 (%struct.net_device*, i32*, i8*, i8)*, i32 (%struct.net_device*, i32*, i8*, i8*, i32)*, i32 (%struct.net_device*, i32*, i8*, i8, i32*, i1)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)* }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, %struct.atomic_t, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip6_spec, [12 x i8] }
%struct.ethtool_tcpip6_spec = type { [4 x i32], [4 x i32], i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.ethtool_tunable = type { i32, i32, i32, i32, [0 x i8*] }
%struct.ethtool_link_ksettings = type { %struct.ethtool_link_settings, %struct.anon.137 }
%struct.ethtool_link_settings = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, [3 x i8], [7 x i32], [0 x i32] }
%struct.anon.137 = type { [2 x i64], [2 x i64], [2 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ndisc_ops = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)*, i16 (%struct.sk_buff*)* }
%struct.hh_cache = type { i32, %struct.seqlock_t, [12 x i64] }
%struct.seqlock_t = type { %struct.atomic_t, %struct.spinlock }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.in_device = type opaque
%struct.inet6_dev = type opaque
%struct.wireless_dev = type opaque
%struct.wpan_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8], %struct.xdp_rxq_info }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.xdp_rxq_info = type { %struct.net_device*, i32, i32, %struct.util_est, [40 x i8] }
%struct.nf_hook_entries = type opaque
%struct.cpu_rmap = type opaque
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, i64, i64, %struct.net_device*, [8 x i8], %struct.spinlock, i32, i64, i64, [40 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, i32, %union.anon.17, [24 x i8], %struct.sk_buff_head, %struct.sk_buff_head, %struct.gnet_stats_basic_packed, %struct.atomic_t, %struct.gnet_stats_queue, i64, %struct.Qdisc*, %struct.sk_buff_head, %struct.spinlock, %struct.spinlock, i8, %struct.callback_head, [32 x i8] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, void (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*)*, i32 (%struct.Qdisc*)*, %struct.module* }
%struct.Qdisc_class_ops = type { i32, %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**, %struct.netlink_ext_ack*)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*, %struct.netlink_ext_ack*)*, i32 (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_block* (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.tcf_block = type { %struct.mutex, %struct.list_head, i32, %union.anon.17, %struct.net*, %struct.Qdisc*, %struct.rw_semaphore, %struct.sysv_shm, %struct.list_head, i8, %struct.atomic_t, i32, i32, %struct.anon.141, %struct.callback_head, [128 x %struct.hlist_head], %struct.mutex }
%struct.anon.141 = type { %struct.tcf_chain*, %struct.list_head }
%struct.tcf_chain = type { %struct.mutex, %struct.tcf_proto*, %struct.list_head, %struct.tcf_block*, i32, i32, i32, i8, i8, %struct.tcf_proto_ops*, i8*, %struct.callback_head }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i16, i32, i8*, %struct.tcf_proto_ops*, %struct.tcf_chain*, %struct.spinlock, i8, %union.anon.17, %struct.callback_head, %struct.hlist_node }
%struct.tcf_result = type { %union.anon.138 }
%union.anon.138 = type { %struct.thread_info }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i32 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, i1, %struct.netlink_ext_ack*)*, i8* (%struct.tcf_proto*, i32)*, void (%struct.tcf_proto*, i8*)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i8**, i1, i1, %struct.netlink_ext_ack*)*, i32 (%struct.tcf_proto*, i8*, i8*, i1, %struct.netlink_ext_ack*)*, void (%struct.tcf_proto*, %struct.tcf_walker*, i1)*, i32 (%struct.tcf_proto*, i1, i32 (i32, i8*, i8*)*, i8*, %struct.netlink_ext_ack*)*, void (%struct.tcf_proto*, i8*)*, void (%struct.tcf_proto*, i8*)*, void (i8*, i32, i64)*, i8* (%struct.net*, %struct.tcf_chain*, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (i8*)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.sk_buff*, %struct.net*, i8*)*, %struct.module*, i32 }
%struct.tcf_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.gnet_stats_basic_cpu = type { %struct.gnet_stats_basic_packed, %struct.u64_stats_sync, [4 x i8] }
%struct.gnet_stats_basic_packed = type <{ i64, i32 }>
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.mini_Qdisc = type { %struct.tcf_proto*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, %struct.callback_head }
%struct.timer_list = type { %struct.hlist_node, i64, void (%struct.timer_list*)*, i32 }
%struct.netpoll_info = type opaque
%struct.possible_net_t = type { %struct.net* }
%union.anon.142 = type { i8* }
%struct.device = type { %struct.kobject, %struct.device*, %struct.device_private*, i8*, %struct.device_type*, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.mutex, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, %struct.dma_map_ops*, i64*, i64, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %union.anon.142, %struct.device_node*, %struct.fwnode_handle*, i32, i32, i32, %struct.spinlock, %struct.list_head, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, %struct.iommu_param*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.u64_stats_sync, i8 }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.attribute_group**, %struct.dev_pm_ops*, void (%struct.device*)*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, i32, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.hrtimer, i64, %struct.work_struct, %struct.wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, i32, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.device*, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, i8*, i64, i32)*, i32 (%struct.device*, i64)*, i64 (%struct.device*)*, i64 (%struct.device*)*, i64 (%struct.device*)* }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.page = type { i64, %union.anon.57, %union.anon.17, %struct.atomic_t, [8 x i8] }
%union.anon.57 = type { %struct.anon.58 }
%struct.anon.58 = type { %struct.list_head, %struct.address_space*, i64, i64 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.device_node = type opaque
%struct.fwnode_handle = type { %struct.fwnode_handle*, %struct.fwnode_operations* }
%struct.fwnode_operations = type { %struct.fwnode_handle* (%struct.fwnode_handle*)*, void (%struct.fwnode_handle*)*, i1 (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*, %struct.device*)*, i1 (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i32, i8*, i64)*, i32 (%struct.fwnode_handle*, i8*, i8**, i64)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i8*, i32, i32, %struct.fwnode_reference_args*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, i32 (%struct.fwnode_handle*, %struct.fwnode_endpoint*)* }
%struct.fwnode_reference_args = type { %struct.fwnode_handle*, i32, [8 x i64] }
%struct.fwnode_endpoint = type { i32, i32, %struct.fwnode_handle* }
%struct.class = type { i8*, %struct.module*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, void (%struct.device*, %struct.atomic_t*, %struct.atomic_t*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.iommu_param = type opaque
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.nla_policy = type { i8, i8, i16, %union.anon.142 }
%struct.phy_device = type opaque
%struct.sfp_bus = type opaque
%struct.netns_core = type { %struct.ctl_table_header*, i32, i32*, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.tcp_mib*, %struct.ipstats_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.proc_dir_entry*, %struct.udp_mib*, %struct.udp_mib*, %struct.ipstats_mib*, %union.anon.130*, %struct.icmpmsg_mib* }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [120 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.udp_mib = type { [9 x i64] }
%struct.ipstats_mib = type { [37 x i64], %struct.u64_stats_sync }
%struct.icmpmsg_mib = type { [512 x %union.anon.13] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_nexthop = type { %struct.rb_root, %struct.hlist_head*, i32, i32 }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.ip_ra_chain*, %struct.mutex, %struct.fib_rules_ops*, i8, i32, %struct.fib_table*, %struct.fib_table*, i8, %struct.hlist_head*, i8, %struct.sock*, %struct.sock**, %struct.sock*, %struct.inet_peer_base*, %struct.sock**, %struct.fqdir*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, %struct.local_ports, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [3 x i32], [3 x i32], i32, i64, %struct.inet_timewait_death_row, i32, i32, %struct.tcp_congestion_ops*, %struct.tcp_fastopen_context*, %struct.spinlock, i32, %struct.atomic_t, i64, i32, i32, i32, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.mr_table*, i32, i32, %struct.fib_notifier_ops*, i32, %struct.fib_notifier_ops*, i32, %struct.atomic_t, %struct.siphash_key_t, [16 x i8] }
%struct.ipv4_devconf = type opaque
%struct.ip_ra_chain = type opaque
%struct.fib_rules_ops = type opaque
%struct.fib_table = type opaque
%struct.inet_peer_base = type opaque
%struct.fqdir = type { i64, i64, i32, i32, %struct.inet_frags*, %struct.net*, i8, [23 x i8], %struct.rhashtable, [56 x i8], %union.anon.13, %struct.work_struct, [24 x i8] }
%struct.inet_frags = type { i32, void (%struct.inet_frag_queue*, i8*)*, void (%struct.inet_frag_queue*)*, void (%struct.timer_list*)*, %struct.kmem_cache*, i8*, %struct.rhashtable_params, %union.anon.17, %struct.completion }
%struct.inet_frag_queue = type { %struct.rhash_head, %union.anon.38, %struct.timer_list, %struct.spinlock, %union.anon.17, %struct.rb_root, %struct.sk_buff*, %struct.sk_buff*, i64, i32, i32, i8, i16, %struct.fqdir*, %struct.callback_head }
%struct.rhash_head = type { %struct.rhash_head* }
%union.anon.38 = type { %struct.frag_v6_compare_key }
%struct.frag_v6_compare_key = type { %struct.in6_addr, %struct.in6_addr, i32, i32, i32 }
%struct.in6_addr = type { %union.anon.39 }
%union.anon.39 = type { [4 x i32] }
%struct.rhashtable_params = type { i16, i16, i16, i16, i32, i16, i8, i32 (i8*, i32, i32)*, i32 (i8*, i32, i32)*, i32 (%struct.rhashtable_compare_arg*, i8*)* }
%struct.rhashtable_compare_arg = type { %struct.rhashtable*, i8* }
%struct.rhashtable = type { %struct.bucket_table*, i32, i32, %struct.rhashtable_params, i8, %struct.work_struct, %struct.mutex, %struct.spinlock, %struct.atomic_t }
%struct.bucket_table = type { i32, i32, i32, %struct.list_head, %struct.callback_head, %struct.bucket_table*, %struct.u64_stats_sync, [8 x i8], [0 x %struct.u64_stats_sync*] }
%struct.xt_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.inet_timewait_death_row = type { %struct.atomic_t, [60 x i8], %struct.inet_hashinfo*, i32, [52 x i8] }
%struct.inet_hashinfo = type opaque
%struct.tcp_congestion_ops = type opaque
%struct.tcp_fastopen_context = type opaque
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.atomic_t] }
%struct.mr_table = type opaque
%struct.fib_notifier_ops = type opaque
%struct.siphash_key_t = type { [2 x i64] }
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, %struct.fqdir*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.fib6_info*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, %struct.list_head, [16 x i8], %struct.dst_ops, %struct.rwlock_t, %struct.spinlock, i32, i64, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.sock*, %struct.atomic_t, %struct.atomic_t, %struct.seg6_pernet_data*, %struct.fib_notifier_ops*, %struct.fib_notifier_ops*, i32, %struct.anon.54, [8 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [4 x i64], i64*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8 }
%struct.ipv6_devconf = type opaque
%struct.fib6_info = type opaque
%struct.rt6_info = type opaque
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [24 x i8] }
%struct.dst_entry = type opaque
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %union.anon.17, %struct.qspinlock }
%struct.seg6_pernet_data = type opaque
%struct.anon.54 = type { %struct.hlist_head, %struct.spinlock, i32 }
%struct.netns_nf = type { %struct.proc_dir_entry*, %struct.nf_queue_handler*, [13 x %struct.nf_logger*], %struct.ctl_table_header*, [5 x %struct.nf_hook_entries*], [5 x %struct.nf_hook_entries*], i8, i8 }
%struct.nf_queue_handler = type opaque
%struct.nf_logger = type opaque
%struct.netns_xt = type { [13 x %struct.list_head], i8, i8 }
%struct.netns_ct = type { %struct.atomic_t, i32, i8, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, %struct.ct_pcpu*, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, %struct.nf_ip_net }
%struct.ct_pcpu = type { %struct.spinlock, %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ip_conntrack_stat = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.atomic_t, %struct.nf_tcp_net, %struct.kernel_cap_struct, %struct.atomic_t, %struct.atomic_t }
%struct.nf_tcp_net = type { [14 x i32], i32, i32, i32 }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.netns_nf_frag = type { %struct.fqdir* }
%struct.net_generic = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [3 x %struct.hlist_head], [3 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.xfrm_policy_hthresh, %struct.list_head, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [40 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.spinlock, %struct.mutex, [24 x i8] }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32, i8, i8, i8, i8 }
%struct.xfrm_policy_hthresh = type { %struct.work_struct, %struct.seqlock_t, i8, i8, i8, i8 }
%struct.sock = type opaque
%struct.cgroup_namespace = type { %union.anon.17, %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.signal_struct = type { %union.anon.17, %struct.atomic_t, i32, %struct.list_head, %struct.wait_queue_head, %struct.task_struct*, %struct.sigpending, %struct.hlist_head, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.tnum], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x %struct.pid*], %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.tnum], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.tnum = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %union.anon.13, %union.anon.13, %union.anon.13 }
%struct.tty_struct = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.spinlock, %union.anon.17, %struct.wait_queue_head, [64 x %struct.k_sigaction] }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.cpumask }
%struct.sigpending = type { %struct.list_head, %struct.cpumask }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root_cached = type { %struct.rb_root, %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type { %union.anon.13, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, i16, i32, i64, %struct.xarray, %struct.io_cq*, %struct.hlist_head, %struct.work_struct }
%struct.io_cq = type { %struct.request_queue*, %struct.io_context*, %struct.sysv_shm, %union.anon.75, i32 }
%struct.request_queue = type opaque
%struct.capture_control = type opaque
%struct.kernel_siginfo = type { %struct.anon.76 }
%struct.anon.76 = type { i32, i32, i32, %union.__sifields }
%union.__sifields = type { %struct.anon.80 }
%struct.anon.80 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.cpumask = type { [1 x i64] }
%struct.css_set = type { [4 x %struct.cgroup_subsys_state*], %union.anon.17, %struct.css_set*, %struct.cgroup*, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, [4 x %struct.list_head], %struct.list_head, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.cgroup*, %struct.css_set*, i8, %struct.callback_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.work_struct, %struct.rcu_work, %struct.cgroup_subsys_state* }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*, i32)*, i32 (%struct.seq_file*, %struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void ()*, i32 (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i8, i32, i8*, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.cgroup_taskset = type opaque
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, i32, %struct.atomic_t, %struct.list_head, i32, %struct.idr, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.idr, i32, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.wait_queue_head }
%struct.kernfs_syscall_ops = type { i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_node*, %struct.kernfs_root*)* }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernfs_node*, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [4 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [4 x %struct.list_head], %struct.cgroup*, %struct.cgroup*, %struct.cgroup_rstat_cpu*, %struct.list_head, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.prev_cputime, %struct.list_head, %struct.mutex, %struct.wait_queue_head, %struct.work_struct, %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.atomic_t, %struct.cgroup_freezer_state, [0 x i32] }
%struct.cgroup_file = type { %struct.kernfs_node*, i64, %struct.timer_list }
%struct.cgroup_rstat_cpu = type { %struct.u64_stats_sync, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.cgroup*, %struct.cgroup* }
%struct.cgroup_base_stat = type { %struct.task_cputime }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cgroup_freezer_state = type { i8, i32, i32, i32 }
%struct.cftype = type { [64 x i8], i64, i64, i32, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.poll_table_struct = type opaque
%struct.percpu_ref = type { %union.anon.13, i64, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head }
%struct.rcu_work = type { %struct.work_struct, %struct.callback_head, %struct.workqueue_struct* }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.atomic_t, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type { %struct.pmu*, %struct.raw_spinlock, %struct.mutex, %struct.list_head, %struct.perf_event_groups, %struct.perf_event_groups, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i32, i32, i32, i32, i32, %union.anon.17, %struct.task_struct*, i64, i64, %struct.perf_event_context*, i64, i64, i32, i8*, %struct.callback_head }
%struct.pmu = type { %struct.list_head, %struct.module*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, i8*, i32, i32, i32*, %struct.perf_cpu_context*, %struct.atomic_t, i32, i32, i32, void (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event*, %struct.mm_struct*)*, void (%struct.perf_event*, %struct.mm_struct*)*, i32 (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*)*, void (%struct.pmu*, i32)*, i32 (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event_context*, i1)*, i64, i8* (%struct.perf_event*, i8**, i32, i1)*, void (i8*)*, i32 (%struct.list_head*)*, void (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*, i64)* }
%struct.perf_cpu_context = type { %struct.perf_event_context, %struct.perf_event_context*, i32, i32, %struct.raw_spinlock, %struct.hrtimer, i64, i32, %struct.list_head, i32, i32 }
%struct.perf_event = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.rb_node, i64, %struct.list_head, %struct.hlist_node, %struct.list_head, i32, i32, i32, %struct.perf_event*, %struct.pmu*, i8*, i32, i32, %struct.local64_t, %union.anon.13, i64, i64, i64, i64, %struct.perf_event_attr, i16, i16, i16, %struct.hw_perf_event, %struct.perf_event_context*, %union.anon.13, %union.anon.13, %union.anon.13, %struct.mutex, %struct.list_head, %struct.perf_event*, i32, i32, %struct.list_head, %struct.task_struct*, %struct.mutex, %struct.atomic_t, %struct.ring_buffer*, %struct.list_head, i64, i32, %struct.wait_queue_head, %struct.fasync_struct*, i32, i32, i32, %struct.irq_work, %struct.atomic_t, %struct.perf_addr_filters_head, %struct.tnum*, i64, %struct.perf_event*, void (%struct.perf_event*)*, %struct.callback_head, %struct.pid_namespace*, i64, i64 ()*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, i8*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, %struct.bpf_prog*, %struct.trace_event_call*, %struct.event_filter*, %struct.list_head }
%struct.local64_t = type { %struct.local_t }
%struct.perf_event_attr = type { i32, i32, i64, %union.anon.13, i64, i64, i64, %struct.atomic_t, i32, %union.anon.13, %union.anon.13, i64, i64, i32, i32, i64, i32, i16, i16 }
%struct.hw_perf_event = type { %union.anon.91, %struct.task_struct*, i8*, i64, i32, %struct.local64_t, i64, i64, %struct.local64_t, i64, i64, i64, i64 }
%union.anon.91 = type { %struct.anon.92 }
%struct.anon.92 = type { i64, i64, i64, i64, i32, i32, i32, i32, %struct.hw_perf_event_extra, %struct.hw_perf_event_extra }
%struct.hw_perf_event_extra = type { i64, i32, i32, i32 }
%struct.ring_buffer = type opaque
%struct.fasync_struct = type { %struct.rwlock_t, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.irq_work = type { i64, %struct.llist_node, void (%struct.irq_work*)* }
%struct.perf_addr_filters_head = type { %struct.list_head, %struct.raw_spinlock, i32 }
%struct.perf_sample_data = type { i64, %struct.perf_raw_record*, %struct.perf_branch_stack*, i64, i64, i64, %union.anon.13, i64, i64, %struct.util_est, i64, i64, i64, %struct.util_est, %struct.perf_callchain_entry*, %struct.perf_regs, %struct.pt_regs, %struct.perf_regs, i64, i64, [48 x i8] }
%struct.perf_raw_record = type { %struct.perf_raw_frag, i32 }
%struct.perf_raw_frag = type <{ %union.anon.98, i64 (i8*, i8*, i64, i64)*, i8*, i32 }>
%union.anon.98 = type { %struct.perf_raw_frag* }
%struct.perf_branch_stack = type { i64, [0 x %struct.task_cputime] }
%struct.perf_callchain_entry = type { i64, [0 x i64] }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.perf_regs = type { i64, %struct.pt_regs* }
%struct.trace_event_call = type opaque
%struct.event_filter = type opaque
%struct.perf_event_groups = type { %struct.rb_root, i64 }
%struct.rseq = type { i32, i32, %union.anon.13, i32, [12 x i8] }
%struct.tlbflush_unmap_batch = type { %struct.arch_tlbflush_unmap_batch, i8, i8 }
%struct.arch_tlbflush_unmap_batch = type { %struct.cpumask }
%struct.pipe_inode_info = type { %struct.mutex, %struct.wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.uprobe_task = type { i32, %union.anon.104, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.104 = type { %struct.anon.105 }
%struct.anon.105 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.vm_struct = type { %struct.vm_struct*, i8*, i64, i64, %struct.page**, i32, i64, i8* }
%union.anon.17 = type { %struct.atomic_t }
%struct.thread_struct = type { [3 x %struct.rps_dev_flow], i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.13, i8, [31 x i8], %struct.fpu }
%struct.fpu = type { i32, i64, [48 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.107, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.110 }
%union.anon.107 = type { %struct.tnum }
%union.anon.110 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.completion = type { i32, %struct.wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i64 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon.13*, %union.anon.13*, %union.anon.13, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon.13*, %struct.spinlock*, %struct.page* }
%struct.mem_cgroup = type opaque
%struct.mempolicy = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.55, i8*, %union.anon.13, i16, i16, %struct.kernfs_iattrs* }
%union.anon.55 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.qspinlock = type { %union.anon.17 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.142 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.mod_arch_specific = type { i32, i32*, %struct.orc_entry* }
%struct.orc_entry = type { i16, i16, i16 }
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8*, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.srcu_struct = type { [5 x %struct.srcu_node], [3 x %struct.srcu_node*], %struct.mutex, %struct.spinlock, %struct.mutex, i32, i64, i64, i64, i64, %struct.srcu_data*, i64, %struct.mutex, %struct.completion, %struct.atomic_t, %struct.delayed_work }
%struct.srcu_node = type { %struct.spinlock, [4 x i64], [4 x i64], i64, %struct.srcu_node*, i32, i32 }
%struct.srcu_data = type { [2 x i64], [2 x i64], [32 x i8], %struct.spinlock, %struct.rcu_segcblist, i64, i64, i8, %struct.timer_list, %struct.work_struct, %struct.callback_head, %struct.srcu_node*, i64, i32, %struct.srcu_struct*, [8 x i8] }
%struct.rcu_segcblist = type { %struct.callback_head*, [4 x %struct.callback_head**], [4 x i64], i64, i64, i8, i8 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.bpf_raw_event_map = type { %struct.tracepoint*, i8*, i32, i32, [8 x i8] }
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t, %union.anon.13 }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.jump_entry = type { i32, i32, i64 }
%struct.trace_eval_map = type opaque
%struct.u64_stats_sync = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.spinlock, %struct.atomic_t, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.17, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.shrink_control = type { i32, i32, i64, i64, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.inode*, i64*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.13, %union.anon.13, %union.anon.17, %struct.raw_spinlock, %struct.list_head }
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, i8, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.rw_semaphore, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.wait_queue_head, %struct.callback_head }
%struct.rcuwait = type { %struct.task_struct* }
%struct.fsnotify_mark_connector = type opaque
%union.anon.127 = type { [16 x i8] }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i64, i32, i32, %struct.list_head, %union.anon.13* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.atomic_t, %struct.atomic_t, %struct.ns_common, i64, %struct.list_head, %struct.key*, %struct.rw_semaphore, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [9 x i32] }
%struct.uid_gid_map = type { i32, %union.anon.25 }
%union.anon.25 = type { %struct.anon.26, [48 x i8] }
%struct.anon.26 = type { %struct.uid_gid_extent*, %struct.uid_gid_extent* }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, i64, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.sysv_shm = type { %struct.list_head }
%union.anon.75 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.tnum, %struct.tnum, %struct.tnum, %struct.spinlock, i16, i8, i8, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.12, %union.anon.13, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.117, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.120, i32, i32, %struct.fsnotify_mark_connector*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.tnum*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.tnum, %struct.tnum, %struct.tnum, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.tnum, %struct.tnum, %struct.tnum, %struct.tnum, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.117 = type { %struct.file_operations* }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.xarray, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, i32, %struct.spinlock, %struct.list_head, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32, i16, i16, i32 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.59, %union.anon.13 }
%union.anon.59 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%struct.swap_info_struct = type opaque
%union.anon.120 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.kiocb*, i1)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i64, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, i64, i32)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, i8*, i32, i8, i32, i32, %struct.wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.118 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.118 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.spinlock = type { %union.anon.16 }
%union.anon.16 = type { %struct.raw_spinlock }
%union.anon.13 = type { i64 }
%struct.mutex = type { %union.anon.13, %struct.spinlock, %union.anon.17, %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %union.anon.12 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.btf_type = type { i32, i32, %struct.atomic_t }
%struct.bpf_map_memory = type { i32, %struct.user_struct* }
%struct.work_struct = type { %union.anon.13, %struct.list_head, void (%struct.work_struct*)* }
%struct.user_struct = type { %union.anon.17, %struct.atomic_t, %struct.atomic_t, %union.anon.13, i64, i64, i64, %union.anon.13, %struct.hlist_node, %struct.atomic_t, %union.anon.13, %struct.ratelimit_state }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64, i64 }
%struct.bpf_prog_offload = type { %struct.bpf_prog*, %struct.net_device*, %struct.bpf_offload_dev*, i8*, %struct.list_head, i8, i8, i8*, i32 }
%struct.bpf_offload_dev = type opaque
%struct.btf = type opaque
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.bpf_prog_stats = type { i64, i64, %struct.u64_stats_sync }
%union.anon.145 = type { %struct.work_struct }
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%union.anon.146 = type { [0 x %struct.sock_filter] }
%struct.bpf_verifier_env = type { i32, i32, %struct.bpf_prog*, %struct.bpf_verifier_ops*, %struct.bpf_verifier_stack_elem*, i32, i8, i8, %struct.bpf_verifier_state*, %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*, [64 x %struct.bpf_map*], i32, i32, i8, i8, %struct.bpf_insn_aux_data*, %struct.ethtool_pauseparam*, %struct.bpf_verifier_log, [257 x %struct.bpf_subprog_info], %struct.anon.150, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32 }
%struct.bpf_verifier_stack_elem = type { %struct.bpf_verifier_state, i32, i32, %struct.bpf_verifier_stack_elem* }
%struct.bpf_verifier_state = type { [8 x %struct.bpf_func_state*], %struct.bpf_verifier_state*, i32, i32, i32, i32, i8, i32, i32, %struct.util_est*, i32 }
%struct.bpf_func_state = type { [11 x %struct.bpf_reg_state], i32, i32, i32, i32, %struct.util_est*, i32, %struct.bpf_stack_state* }
%struct.bpf_reg_state = type { i32, %union.anon.147, i32, i32, i32, %struct.tnum, i64, i64, i64, i64, %struct.bpf_reg_state*, i32, i32, i32, i8 }
%union.anon.147 = type { %struct.bpf_map* }
%struct.bpf_stack_state = type { %struct.bpf_reg_state, [8 x i8] }
%struct.bpf_verifier_state_list = type { %struct.bpf_verifier_state, %struct.bpf_verifier_state_list*, i32, i32 }
%struct.bpf_insn_aux_data = type { %union.anon.13, i32, i32, i8, i8, i8, i8, i32 }
%struct.bpf_verifier_log = type { i32, [1024 x i8], i8*, i32, i32 }
%struct.bpf_subprog_info = type { i32, i32, i16 }
%struct.anon.150 = type { i32*, i32*, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.fd = type { %struct.file*, i32 }
%struct.bpf_insn_cbs = type { void (i8*, i8*, ...)*, i8* (i8*, %struct.bpf_insn*)*, i8* (i8*, %struct.bpf_insn*, i64)*, i8* }
%struct.bpf_array = type { %struct.bpf_map, i32, i32, i32, i8, %union.anon.151, [48 x i8] }
%union.anon.151 = type { [0 x i8*] }
%struct.bpf_call_arg_meta = type { %struct.bpf_map*, i8, i8, i32, i32, i64, i64, i32, i32 }

@llvm.compiler.used = appending global [4 x i8*] [i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_tnum_strn, i32 0, i32 0), i8* bitcast (i8** @__addressable_tnum_strn257 to i8*), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_bpf_verifier_log_write, i32 0, i32 0), i8* bitcast (i8** @__addressable_bpf_verifier_log_write354 to i8*)], section "llvm.metadata"
@.str = private unnamed_addr constant [15 x i8] c"(%#llx; %#llx)\00", align 1
@__kstrtab_tnum_strn = internal constant [10 x i8] c"tnum_strn\00", section "__ksymtab_strings", align 1
@__addressable_tnum_strn257 = internal global i8* bitcast (i32 (i8*, i64, i64, i64)* @tnum_strn to i8*), section ".discard.addressable", align 8
@bpf_verifier_vlog.__warned = internal global i8 0, section ".data.once", align 1
@.str.2 = private unnamed_addr constant [54 x i8] c"verifier log line truncated - local buffer too short\0A\00", align 1
@.str.1 = private unnamed_addr constant [22 x i8] c"kernel/bpf/verifier.c\00", align 1
@__kstrtab_bpf_verifier_log_write = internal constant [23 x i8] c"bpf_verifier_log_write\00", section "__ksymtab_strings", align 1
@__addressable_bpf_verifier_log_write354 = internal global i8* bitcast (void (%struct.bpf_verifier_env*, i8*, ...)* @bpf_verifier_log_write to i8*), section ".discard.addressable", align 8
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn = private unnamed_addr constant %struct.bpf_insn { i8 15, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn = private unnamed_addr constant %struct.bpf_insn { i8 31, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn = private unnamed_addr constant %struct.bpf_insn { i8 79, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn = private unnamed_addr constant %struct.bpf_insn { i8 95, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 111, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 127, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn = private unnamed_addr constant %struct.bpf_insn { i8 -81, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 -49, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 12, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 28, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 76, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 92, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 108, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 124, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -84, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -52, i8 33, i16 0, i32 0 }, align 4
@bpf_verifier_ops = internal constant [25 x %struct.bpf_verifier_ops*] [%struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_filter_verifier_ops, %struct.bpf_verifier_ops* @kprobe_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tracepoint_verifier_ops, %struct.bpf_verifier_ops* @xdp_verifier_ops, %struct.bpf_verifier_ops* @perf_event_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_in_verifier_ops, %struct.bpf_verifier_ops* @lwt_out_verifier_ops, %struct.bpf_verifier_ops* @lwt_xmit_verifier_ops, %struct.bpf_verifier_ops* @sock_ops_verifier_ops, %struct.bpf_verifier_ops* @sk_skb_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_msg_verifier_ops, %struct.bpf_verifier_ops* @raw_tracepoint_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_seg6local_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_reuseport_verifier_ops, %struct.bpf_verifier_ops* @flow_dissector_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @raw_tracepoint_writable_verifier_ops], align 16
@bpf_verifier_lock = internal global %struct.mutex { %union.anon.13 zeroinitializer, %struct.spinlock zeroinitializer, %union.anon.17 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*) } }, align 8
@.str.2.3 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.3 = private unnamed_addr constant [28 x i8] c"include/linux/thread_info.h\00", align 1
@.str.4 = private unnamed_addr constant [53 x i8] c"R%d tried to add from different pointers or scalars\0A\00", align 1
@.str.5 = private unnamed_addr constant [53 x i8] c"R%d tried to sub from different pointers or scalars\0A\00", align 1
@tnum_unknown = dso_local constant %struct.tnum { i64 0, i64 -1 }, align 8
@kmalloc_caches = external dso_local global [3 x [14 x %struct.kmem_cache*]], align 16
@.str.6 = private unnamed_addr constant [21 x i8] c"include/linux/slab.h\00", align 1
@sk_filter_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@kprobe_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tc_cls_act_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@xdp_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@perf_event_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_in_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_out_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_xmit_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sock_ops_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_skb_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_msg_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_seg6local_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_reuseport_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@flow_dissector_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_writable_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@.str.7 = private unnamed_addr constant [30 x i8] c"BPF_LDX uses reserved fields\0A\00", align 1
@.str.8 = private unnamed_addr constant [30 x i8] c"BPF_STX uses reserved fields\0A\00", align 1
@.str.9 = private unnamed_addr constant [27 x i8] c"invalid bpf_ld_imm64 insn\0A\00", align 1
@.str.10 = private unnamed_addr constant [32 x i8] c"unrecognized bpf_ld_imm64 insn\0A\00", align 1
@.str.11 = private unnamed_addr constant [40 x i8] c"fd %d is not pointing to valid bpf_map\0A\00", align 1
@.str.12 = private unnamed_addr constant [42 x i8] c"direct value offset of %u is not allowed\0A\00", align 1
@.str.13 = private unnamed_addr constant [50 x i8] c"no direct value access support for this map type\0A\00", align 1
@.str.14 = private unnamed_addr constant [59 x i8] c"invalid access to map value pointer, value_size=%u off=%u\0A\00", align 1
@.str.15 = private unnamed_addr constant [49 x i8] c"only one cgroup storage of each type is allowed\0A\00", align 1
@.str.16 = private unnamed_addr constant [21 x i8] c"unknown opcode %02x\0A\00", align 1
@.str.17 = private unnamed_addr constant [56 x i8] c"perf_event programs can only use preallocated hash map\0A\00", align 1
@.str.18 = private unnamed_addr constant [62 x i8] c"perf_event programs can only use preallocated inner hash map\0A\00", align 1
@.str.19 = private unnamed_addr constant [44 x i8] c"tracing progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.20 = private unnamed_addr constant [46 x i8] c"offload device mismatch between prog and map\0A\00", align 1
@bpf_map_offload_ops = external dso_local constant %struct.bpf_map_ops, align 8
@.str.21 = private unnamed_addr constant [65 x i8] c"function calls to other bpf functions are allowed for root only\0A\00", align 1
@.str.22 = private unnamed_addr constant [13 x i8] c"func#%d @%d\0A\00", align 1
@.str.23 = private unnamed_addr constant [38 x i8] c"jump out of range from insn %d to %d\0A\00", align 1
@.str.24 = private unnamed_addr constant [33 x i8] c"last insn is not an exit or jmp\0A\00", align 1
@.str.25 = private unnamed_addr constant [29 x i8] c"call to invalid destination\0A\00", align 1
@.str.26 = private unnamed_addr constant [22 x i8] c"too many subprograms\0A\00", align 1
@.str.27 = private unnamed_addr constant [63 x i8] c"number of funcs in func_info doesn't match number of subprogs\0A\00", align 1
@.str.28 = private unnamed_addr constant [31 x i8] c"invalid func info rec size %u\0A\00", align 1
@.str.29 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in func info\00", align 1
@.str.30 = private unnamed_addr constant [51 x i8] c"nonzero insn_off %u for the first func info record\00", align 1
@.str.31 = private unnamed_addr constant [69 x i8] c"same or smaller insn offset (%u) than previous func info record (%u)\00", align 1
@.str.32 = private unnamed_addr constant [67 x i8] c"func_info BTF section doesn't match subprog layout in BPF program\0A\00", align 1
@.str.33 = private unnamed_addr constant [32 x i8] c"invalid type id %d in func info\00", align 1
@.str.34 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in line_info\00", align 1
@.str.35 = private unnamed_addr constant [65 x i8] c"Invalid line_info[%u].insn_off:%u (prev_offset:%u prog->len:%u)\0A\00", align 1
@.str.36 = private unnamed_addr constant [45 x i8] c"Invalid insn code at line_info[%u].insn_off\0A\00", align 1
@.str.37 = private unnamed_addr constant [50 x i8] c"Invalid line_info[%u].line_off or .file_name_off\0A\00", align 1
@.str.38 = private unnamed_addr constant [35 x i8] c"missing bpf_line_info for func#%u\0A\00", align 1
@.str.39 = private unnamed_addr constant [58 x i8] c"missing bpf_line_info for %u funcs starting from func#%u\0A\00", align 1
@.str.40 = private unnamed_addr constant [24 x i8] c"pop stack internal bug\0A\00", align 1
@.str.41 = private unnamed_addr constant [21 x i8] c"unreachable insn %d\0A\00", align 1
@.str.42 = private unnamed_addr constant [5 x i8] c"%d: \00", align 1
@.str.43 = private unnamed_addr constant [30 x i8] c"back-edge from insn %d to %d\0A\00", align 1
@.str.44 = private unnamed_addr constant [25 x i8] c"insn state internal bug\0A\00", align 1
@.str.45 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@_ctype = external dso_local constant [0 x i8], align 1
@.str.46 = private unnamed_addr constant [33 x i8] c"invalid insn idx %d insn_cnt %d\0A\00", align 1
@.str.47 = private unnamed_addr constant [45 x i8] c"BPF program is too large. Processed %d insn\0A\00", align 1
@.str.48 = private unnamed_addr constant [24 x i8] c"\0Afrom %d to %d%s: safe\0A\00", align 1
@.str.49 = private unnamed_addr constant [25 x i8] c" (speculative execution)\00", align 1
@.str.50 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.51 = private unnamed_addr constant [10 x i8] c"%d: safe\0A\00", align 1
@.str.52 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.53 = private unnamed_addr constant [18 x i8] c"\0Afrom %d to %d%s:\00", align 1
@.str.54 = private unnamed_addr constant [3 x i8] c"; \00", align 1
@.str.55 = private unnamed_addr constant [50 x i8] c"same insn cannot be used with different pointers\0A\00", align 1
@.str.56 = private unnamed_addr constant [29 x i8] c"BPF_ST uses reserved fields\0A\00", align 1
@.str.57 = private unnamed_addr constant [42 x i8] c"BPF_ST stores into R%d %s is not allowed\0A\00", align 1
@reg_type_str = internal constant [19 x i8*] [i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.194, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.195, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.196, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.197, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.198, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.199, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.200, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.201, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.202, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.203, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.204, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.205, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.206, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.207, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.208, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.209, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.210, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.211, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.212, i32 0, i32 0)], align 16
@.str.58 = private unnamed_addr constant [31 x i8] c"BPF_CALL uses reserved fields\0A\00", align 1
@.str.59 = private unnamed_addr constant [53 x i8] c"function calls are not allowed while holding a lock\0A\00", align 1
@.str.60 = private unnamed_addr constant [29 x i8] c"BPF_JA uses reserved fields\0A\00", align 1
@.str.61 = private unnamed_addr constant [31 x i8] c"BPF_EXIT uses reserved fields\0A\00", align 1
@.str.62 = private unnamed_addr constant [28 x i8] c"bpf_spin_unlock is missing\0A\00", align 1
@.str.63 = private unnamed_addr constant [31 x i8] c"R0 leaks addr as return value\0A\00", align 1
@.str.64 = private unnamed_addr constant [21 x i8] c"invalid BPF_LD mode\0A\00", align 1
@.str.65 = private unnamed_addr constant [23 x i8] c"unknown insn class %d\0A\00", align 1
@.str.66 = private unnamed_addr constant [29 x i8] c"mark_reg_not_init(regs, %u)\0A\00", align 1
@.str.67 = private unnamed_addr constant [31 x i8] c"mark_reg_known_zero(regs, %u)\0A\00", align 1
@.str.68 = private unnamed_addr constant [35 x i8] c"infinite loop detected at insn %d\0A\00", align 1
@is_state_visited.__warned = internal global i8 0, section ".data.once", align 1
@.str.69 = private unnamed_addr constant [42 x i8] c"BUG live_done but branches_to_explore %d\0A\00", align 1
@is_state_visited.__warned.70 = internal global i8 0, section ".data.once", align 1
@.str.71 = private unnamed_addr constant [53 x i8] c"BUG is_state_visited:branches_to_explore=%d insn %d\0A\00", align 1
@.str.72 = private unnamed_addr constant [50 x i8] c"propagate_live: parent frame %d current frame %d\0A\00", align 1
@.str.73 = private unnamed_addr constant [42 x i8] c"verifier BUG type %s var_off %lld off %d\0A\00", align 1
@.str.74 = private unnamed_addr constant [17 x i8] c"propagating r%d\0A\00", align 1
@.str.75 = private unnamed_addr constant [18 x i8] c"propagating fp%d\0A\00", align 1
@__mark_chain_precision.__warned = internal global i8 0, section ".data.once", align 1
@.str.76 = private unnamed_addr constant [19 x i8] c"backtracing misuse\00", align 1
@.str.77 = private unnamed_addr constant [26 x i8] c"last_idx %d first_idx %d\0A\00", align 1
@.str.78 = private unnamed_addr constant [25 x i8] c"BUG backtracking idx %d\0A\00", align 1
@__mark_chain_precision.__warned.79 = internal global i8 0, section ".data.once", align 1
@.str.80 = private unnamed_addr constant [26 x i8] c"verifier backtracking bug\00", align 1
@.str.81 = private unnamed_addr constant [36 x i8] c"parent %s regs=%x stack=%llx marks\0A\00", align 1
@.str.82 = private unnamed_addr constant [12 x i8] c"didn't have\00", align 1
@.str.83 = private unnamed_addr constant [12 x i8] c"already had\00", align 1
@.str.84 = private unnamed_addr constant [27 x i8] c"regs=%x stack=%llx before \00", align 1
@.str.85 = private unnamed_addr constant [12 x i8] c"BUG spi %d\0A\00", align 1
@backtrack_insn.__warned = internal global i8 0, section ".data.once", align 1
@backtrack_insn.__warned.86 = internal global i8 0, section ".data.once", align 1
@.str.87 = private unnamed_addr constant [13 x i8] c"BUG regs %x\0A\00", align 1
@backtrack_insn.__warned.88 = internal global i8 0, section ".data.once", align 1
@current_task = external dso_local global %struct.task_struct*, section ".data..percpu", align 8
@.str.89 = private unnamed_addr constant [10 x i8] c" frame%d:\00", align 1
@.str.90 = private unnamed_addr constant [5 x i8] c" R%d\00", align 1
@.str.91 = private unnamed_addr constant [4 x i8] c"=%s\00", align 1
@.str.92 = private unnamed_addr constant [2 x i8] c"P\00", align 1
@.str.93 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.94 = private unnamed_addr constant [7 x i8] c"(id=%d\00", align 1
@.str.95 = private unnamed_addr constant [15 x i8] c",ref_obj_id=%d\00", align 1
@.str.96 = private unnamed_addr constant [8 x i8] c",off=%d\00", align 1
@.str.97 = private unnamed_addr constant [6 x i8] c",r=%d\00", align 1
@.str.98 = private unnamed_addr constant [13 x i8] c",ks=%d,vs=%d\00", align 1
@.str.99 = private unnamed_addr constant [10 x i8] c",imm=%llx\00", align 1
@.str.100 = private unnamed_addr constant [17 x i8] c",smin_value=%lld\00", align 1
@.str.101 = private unnamed_addr constant [17 x i8] c",smax_value=%lld\00", align 1
@.str.102 = private unnamed_addr constant [17 x i8] c",umin_value=%llu\00", align 1
@.str.103 = private unnamed_addr constant [17 x i8] c",umax_value=%llu\00", align 1
@.str.104 = private unnamed_addr constant [12 x i8] c",var_off=%s\00", align 1
@.str.105 = private unnamed_addr constant [2 x i8] c")\00", align 1
@slot_type_char = internal global [4 x i8] c"?rm0", align 1
@.str.106 = private unnamed_addr constant [6 x i8] c" fp%d\00", align 1
@.str.107 = private unnamed_addr constant [9 x i8] c" refs=%d\00", align 1
@.str.108 = private unnamed_addr constant [4 x i8] c",%d\00", align 1
@.str.109 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.110 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.111 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.112 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.113 = private unnamed_addr constant [2 x i8] c"D\00", align 1
@.str.114 = private unnamed_addr constant [30 x i8] c"BPF_NEG uses reserved fields\0A\00", align 1
@.str.115 = private unnamed_addr constant [30 x i8] c"BPF_END uses reserved fields\0A\00", align 1
@.str.116 = private unnamed_addr constant [35 x i8] c"R%d pointer arithmetic prohibited\0A\00", align 1
@.str.117 = private unnamed_addr constant [30 x i8] c"BPF_MOV uses reserved fields\0A\00", align 1
@.str.118 = private unnamed_addr constant [29 x i8] c"R%d partial copy of pointer\0A\00", align 1
@.str.119 = private unnamed_addr constant [27 x i8] c"invalid BPF_ALU opcode %x\0A\00", align 1
@.str.120 = private unnamed_addr constant [30 x i8] c"BPF_ALU uses reserved fields\0A\00", align 1
@.str.121 = private unnamed_addr constant [13 x i8] c"div by zero\0A\00", align 1
@.str.122 = private unnamed_addr constant [18 x i8] c"invalid shift %d\0A\00", align 1
@.str.123 = private unnamed_addr constant [28 x i8] c"mark_reg_unknown(regs, %u)\0A\00", align 1
@.str.124 = private unnamed_addr constant [35 x i8] c"R%d pointer %s pointer prohibited\0A\00", align 1
@bpf_alu_string = external dso_local constant [16 x i8*], align 16
@.str.125 = private unnamed_addr constant [45 x i8] c"verifier internal error: unexpected ptr_reg\0A\00", align 1
@.str.126 = private unnamed_addr constant [37 x i8] c"verifier internal error: no src_reg\0A\00", align 1
@.str.127 = private unnamed_addr constant [42 x i8] c"R%d 32-bit pointer arithmetic prohibited\0A\00", align 1
@.str.128 = private unnamed_addr constant [62 x i8] c"R%d pointer arithmetic on %s prohibited, null-check it first\0A\00", align 1
@.str.129 = private unnamed_addr constant [41 x i8] c"R%d pointer arithmetic on %s prohibited\0A\00", align 1
@.str.130 = private unnamed_addr constant [98 x i8] c"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\0A\00", align 1
@.str.131 = private unnamed_addr constant [47 x i8] c"R%d tried to add from different maps or paths\0A\00", align 1
@.str.132 = private unnamed_addr constant [47 x i8] c"R%d tried to sub from different maps or paths\0A\00", align 1
@.str.133 = private unnamed_addr constant [43 x i8] c"R%d tried to subtract pointer from scalar\0A\00", align 1
@.str.134 = private unnamed_addr constant [47 x i8] c"R%d subtraction from stack pointer prohibited\0A\00", align 1
@.str.135 = private unnamed_addr constant [47 x i8] c"R%d bitwise operator %s on pointer prohibited\0A\00", align 1
@.str.136 = private unnamed_addr constant [52 x i8] c"R%d pointer arithmetic with %s operator prohibited\0A\00", align 1
@.str.137 = private unnamed_addr constant [77 x i8] c"R%d pointer arithmetic of map value goes out of range, prohibited for !root\0A\00", align 1
@.str.138 = private unnamed_addr constant [70 x i8] c"R%d stack pointer arithmetic goes out of range, prohibited for !root\0A\00", align 1
@.str.139 = private unnamed_addr constant [49 x i8] c"math between %s pointer and %lld is not allowed\0A\00", align 1
@.str.140 = private unnamed_addr constant [37 x i8] c"%s pointer offset %d is not allowed\0A\00", align 1
@.str.141 = private unnamed_addr constant [78 x i8] c"math between %s pointer and register with unbounded min value is not allowed\0A\00", align 1
@.str.142 = private unnamed_addr constant [46 x i8] c"value %lld makes %s pointer be out of bounds\0A\00", align 1
@.str.143 = private unnamed_addr constant [42 x i8] c"The sequence of %d jumps is too complex.\0A\00", align 1
@.str.144 = private unnamed_addr constant [84 x i8] c"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\0A\00", align 1
@.str.145 = private unnamed_addr constant [45 x i8] c"R%d min value is outside of the array range\0A\00", align 1
@.str.146 = private unnamed_addr constant [84 x i8] c"R%d unbounded memory access, make sure to bounds check any array access into a map\0A\00", align 1
@.str.147 = private unnamed_addr constant [45 x i8] c"R%d max value is outside of the array range\0A\00", align 1
@.str.148 = private unnamed_addr constant [57 x i8] c"bpf_spin_lock cannot be accessed directly by load/store\0A\00", align 1
@.str.149 = private unnamed_addr constant [59 x i8] c"invalid access to map value, value_size=%d off=%d size=%d\0A\00", align 1
@.str.150 = private unnamed_addr constant [49 x i8] c"variable stack access var_off=%s off=%d size=%d\0A\00", align 1
@.str.151 = private unnamed_addr constant [30 x i8] c"invalid stack off=%d size=%d\0A\00", align 1
@.str.152 = private unnamed_addr constant [16 x i8] c"R%d is invalid\0A\00", align 1
@.str.153 = private unnamed_addr constant [14 x i8] c"R%d !read_ok\0A\00", align 1
@.str.154 = private unnamed_addr constant [28 x i8] c"frame pointer is read only\0A\00", align 1
@.str.155 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into map\0A\00", align 1
@.str.156 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into ctx\0A\00", align 1
@.str.157 = private unnamed_addr constant [26 x i8] c"cannot write into packet\0A\00", align 1
@.str.158 = private unnamed_addr constant [28 x i8] c"R%d leaks addr into packet\0A\00", align 1
@.str.159 = private unnamed_addr constant [31 x i8] c"R%d leaks addr into flow keys\0A\00", align 1
@.str.160 = private unnamed_addr constant [26 x i8] c"R%d cannot write into %s\0A\00", align 1
@.str.161 = private unnamed_addr constant [29 x i8] c"R%d invalid mem access '%s'\0A\00", align 1
@.str.162 = private unnamed_addr constant [11 x i8] c"flow keys \00", align 1
@.str.163 = private unnamed_addr constant [7 x i8] c"value \00", align 1
@.str.164 = private unnamed_addr constant [9 x i8] c"context \00", align 1
@.str.165 = private unnamed_addr constant [7 x i8] c"stack \00", align 1
@.str.166 = private unnamed_addr constant [6 x i8] c"sock \00", align 1
@.str.167 = private unnamed_addr constant [13 x i8] c"sock_common \00", align 1
@.str.168 = private unnamed_addr constant [10 x i8] c"tcp_sock \00", align 1
@.str.169 = private unnamed_addr constant [10 x i8] c"xdp_sock \00", align 1
@.str.170 = private unnamed_addr constant [50 x i8] c"misaligned packet access off %d+%s+%d+%d size %d\0A\00", align 1
@.str.171 = private unnamed_addr constant [42 x i8] c"misaligned %saccess off %s+%d+%d size %d\0A\00", align 1
@.str.172 = private unnamed_addr constant [56 x i8] c"write into map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.173 = private unnamed_addr constant [55 x i8] c"read from map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.174 = private unnamed_addr constant [55 x i8] c"dereference of modified ctx ptr R%d off=%d disallowed\0A\00", align 1
@.str.175 = private unnamed_addr constant [43 x i8] c"variable ctx access var_off=%s disallowed\0A\00", align 1
@.str.176 = private unnamed_addr constant [43 x i8] c"invalid bpf_context access off=%d size=%d\0A\00", align 1
@.str.177 = private unnamed_addr constant [45 x i8] c"attempt to corrupt spilled pointer on stack\0A\00", align 1
@.str.178 = private unnamed_addr constant [32 x i8] c"invalid size of register spill\0A\00", align 1
@.str.179 = private unnamed_addr constant [63 x i8] c"cannot spill pointers to stack into stack frame of the caller\0A\00", align 1
@.str.180 = private unnamed_addr constant [52 x i8] c"insn %d cannot access two stack slots fp%d and fp%d\00", align 1
@.str.181 = private unnamed_addr constant [42 x i8] c"invalid read from stack off %d+0 size %d\0A\00", align 1
@.str.182 = private unnamed_addr constant [31 x i8] c"invalid size of register fill\0A\00", align 1
@.str.183 = private unnamed_addr constant [24 x i8] c"corrupted spill memory\0A\00", align 1
@.str.184 = private unnamed_addr constant [43 x i8] c"invalid read from stack off %d+%d size %d\0A\00", align 1
@.str.185 = private unnamed_addr constant [37 x i8] c"R%d offset is outside of the packet\0A\00", align 1
@.str.186 = private unnamed_addr constant [66 x i8] c"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\0A\00", align 1
@.str.187 = private unnamed_addr constant [44 x i8] c"invalid access to flow keys off=%d size=%d\0A\00", align 1
@.str.188 = private unnamed_addr constant [38 x i8] c"R%d invalid %s access off=%d size=%d\0A\00", align 1
@.str.189 = private unnamed_addr constant [54 x i8] c"R%d invalid tracepoint buffer access: off=%d, size=%d\00", align 1
@.str.190 = private unnamed_addr constant [55 x i8] c"R%d invalid variable buffer offset: off=%d, var_off=%s\00", align 1
@.str.191 = private unnamed_addr constant [31 x i8] c"BPF_XADD uses reserved fields\0A\00", align 1
@.str.192 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into mem\0A\00", align 1
@.str.193 = private unnamed_addr constant [44 x i8] c"BPF_XADD stores into R%d %s is not allowed\0A\00", align 1
@.str.194 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.195 = private unnamed_addr constant [4 x i8] c"inv\00", align 1
@.str.196 = private unnamed_addr constant [4 x i8] c"ctx\00", align 1
@.str.197 = private unnamed_addr constant [8 x i8] c"map_ptr\00", align 1
@.str.198 = private unnamed_addr constant [10 x i8] c"map_value\00", align 1
@.str.199 = private unnamed_addr constant [18 x i8] c"map_value_or_null\00", align 1
@.str.200 = private unnamed_addr constant [3 x i8] c"fp\00", align 1
@.str.201 = private unnamed_addr constant [9 x i8] c"pkt_meta\00", align 1
@.str.202 = private unnamed_addr constant [4 x i8] c"pkt\00", align 1
@.str.203 = private unnamed_addr constant [8 x i8] c"pkt_end\00", align 1
@.str.204 = private unnamed_addr constant [10 x i8] c"flow_keys\00", align 1
@.str.205 = private unnamed_addr constant [5 x i8] c"sock\00", align 1
@.str.206 = private unnamed_addr constant [13 x i8] c"sock_or_null\00", align 1
@.str.207 = private unnamed_addr constant [12 x i8] c"sock_common\00", align 1
@.str.208 = private unnamed_addr constant [20 x i8] c"sock_common_or_null\00", align 1
@.str.209 = private unnamed_addr constant [9 x i8] c"tcp_sock\00", align 1
@.str.210 = private unnamed_addr constant [17 x i8] c"tcp_sock_or_null\00", align 1
@.str.211 = private unnamed_addr constant [10 x i8] c"tp_buffer\00", align 1
@.str.212 = private unnamed_addr constant [9 x i8] c"xdp_sock\00", align 1
@.str.213 = private unnamed_addr constant [41 x i8] c"the call stack of %d frames is too deep\0A\00", align 1
@.str.214 = private unnamed_addr constant [44 x i8] c"verifier bug. No program starts at insn %d\0A\00", align 1
@.str.215 = private unnamed_addr constant [42 x i8] c"verifier bug. Frame %d already allocated\0A\00", align 1
@caller_saved = internal constant [6 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5], align 16
@.str.216 = private unnamed_addr constant [9 x i8] c"caller:\0A\00", align 1
@.str.217 = private unnamed_addr constant [9 x i8] c"callee:\0A\00", align 1
@.str.218 = private unnamed_addr constant [20 x i8] c"invalid func %s#%d\0A\00", align 1
@.str.219 = private unnamed_addr constant [20 x i8] c"unknown func %s#%d\0A\00", align 1
@.str.220 = private unnamed_addr constant [69 x i8] c"cannot call GPL-restricted function from non-GPL compatible program\0A\00", align 1
@.str.221 = private unnamed_addr constant [54 x i8] c"kernel subsystem misconfigured func %s#%d: r1 != ctx\0A\00", align 1
@.str.222 = private unnamed_addr constant [43 x i8] c"kernel subsystem misconfigured func %s#%d\0A\00", align 1
@.str.223 = private unnamed_addr constant [40 x i8] c"tail_call would lead to reference leak\0A\00", align 1
@.str.224 = private unnamed_addr constant [51 x i8] c"func %s#%d reference has not been acquired before\0A\00", align 1
@.str.225 = private unnamed_addr constant [52 x i8] c"get_local_storage() doesn't support non-zero flags\0A\00", align 1
@.str.226 = private unnamed_addr constant [41 x i8] c"kernel subsystem misconfigured verifier\0A\00", align 1
@.str.227 = private unnamed_addr constant [38 x i8] c"unknown return type %d of func %s#%d\0A\00", align 1
@sysctl_perf_event_max_stack = external dso_local global i32, align 4
@.str.228 = private unnamed_addr constant [44 x i8] c"cannot get callchain buffer for func %s#%d\0A\00", align 1
@.str.229 = private unnamed_addr constant [37 x i8] c"R%d leaks addr into helper function\0A\00", align 1
@.str.230 = private unnamed_addr constant [44 x i8] c"helper access to the packet is not allowed\0A\00", align 1
@.str.231 = private unnamed_addr constant [70 x i8] c"verifier internal error: more than one arg with ref_obj_id R%d %u %u\0A\00", align 1
@.str.232 = private unnamed_addr constant [25 x i8] c"verifier internal error\0A\00", align 1
@.str.233 = private unnamed_addr constant [25 x i8] c"unsupported arg_type %d\0A\00", align 1
@.str.234 = private unnamed_addr constant [36 x i8] c"invalid map_ptr to access map->key\0A\00", align 1
@.str.235 = private unnamed_addr constant [38 x i8] c"invalid map_ptr to access map->value\0A\00", align 1
@.str.236 = private unnamed_addr constant [66 x i8] c"R%d min value is negative, either use unsigned or 'var &= const'\0A\00", align 1
@.str.237 = private unnamed_addr constant [71 x i8] c"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\0A\00", align 1
@.str.238 = private unnamed_addr constant [25 x i8] c"R%d type=%s expected=%s\0A\00", align 1
@.str.239 = private unnamed_addr constant [35 x i8] c"R%d is not a pointer to map_value\0A\00", align 1
@.str.240 = private unnamed_addr constant [82 x i8] c"R%d doesn't have constant offset. bpf_spin_lock has to be at the constant offset\0A\00", align 1
@.str.241 = private unnamed_addr constant [56 x i8] c"map '%s' has to have BTF in order to use bpf_spin_lock\0A\00", align 1
@.str.242 = private unnamed_addr constant [51 x i8] c"map '%s' has more than one 'struct bpf_spin_lock'\0A\00", align 1
@.str.243 = private unnamed_addr constant [46 x i8] c"map '%s' doesn't have 'struct bpf_spin_lock'\0A\00", align 1
@.str.244 = private unnamed_addr constant [59 x i8] c"map '%s' is not a struct type or bpf_spin_lock is mangled\0A\00", align 1
@.str.245 = private unnamed_addr constant [50 x i8] c"off %lld doesn't point to 'struct bpf_spin_lock'\0A\00", align 1
@.str.246 = private unnamed_addr constant [44 x i8] c"Locking two bpf_spin_locks are not allowed\0A\00", align 1
@.str.247 = private unnamed_addr constant [39 x i8] c"bpf_spin_unlock without taking a lock\0A\00", align 1
@.str.248 = private unnamed_addr constant [35 x i8] c"bpf_spin_unlock of different lock\0A\00", align 1
@.str.249 = private unnamed_addr constant [76 x i8] c"R%d indirect variable offset stack access prohibited for !root, var_off=%s\0A\00", align 1
@.str.250 = private unnamed_addr constant [53 x i8] c"R%d unbounded indirect variable offset stack access\0A\00", align 1
@.str.251 = private unnamed_addr constant [41 x i8] c"R%d min value is outside of stack bound\0A\00", align 1
@.str.252 = private unnamed_addr constant [41 x i8] c"R%d max value is outside of stack bound\0A\00", align 1
@.str.253 = private unnamed_addr constant [52 x i8] c"invalid indirect read from stack off %d+%d size %d\0A\00", align 1
@.str.254 = private unnamed_addr constant [56 x i8] c"invalid indirect read from stack var_off %s+%d size %d\0A\00", align 1
@.str.255 = private unnamed_addr constant [46 x i8] c"invalid stack type R%d off=%d access_size=%d\0A\00", align 1
@.str.256 = private unnamed_addr constant [50 x i8] c"invalid stack type R%d var_off=%s access_size=%d\0A\00", align 1
@.str.257 = private unnamed_addr constant [26 x i8] c"write into map forbidden\0A\00", align 1
@.str.258 = private unnamed_addr constant [62 x i8] c"tail_calls are not allowed in programs with bpf-to-bpf calls\0A\00", align 1
@.str.259 = private unnamed_addr constant [41 x i8] c"cannot pass map_type %d into func %s#%d\0A\00", align 1
@.str.260 = private unnamed_addr constant [43 x i8] c"cannot return stack pointer to the caller\0A\00", align 1
@.str.261 = private unnamed_addr constant [24 x i8] c"returning from callee:\0A\00", align 1
@.str.262 = private unnamed_addr constant [18 x i8] c"to caller at %d:\0A\00", align 1
@.str.263 = private unnamed_addr constant [42 x i8] c"Unreleased reference id=%d alloc_insn=%d\0A\00", align 1
@.str.264 = private unnamed_addr constant [59 x i8] c"At program exit the register R0 is not a known value (%s)\0A\00", align 1
@.str.265 = private unnamed_addr constant [33 x i8] c"At program exit the register R0 \00", align 1
@.str.266 = private unnamed_addr constant [13 x i8] c"has value %s\00", align 1
@.str.267 = private unnamed_addr constant [25 x i8] c"has unknown scalar value\00", align 1
@.str.268 = private unnamed_addr constant [25 x i8] c" should have been in %s\0A\00", align 1
@update_branch_counts.__warned = internal global i8 0, section ".data.once", align 1
@.str.269 = private unnamed_addr constant [49 x i8] c"BUG update_branch_counts:branches_to_explore=%d\0A\00", align 1
@.str.270 = private unnamed_addr constant [33 x i8] c"invalid BPF_JMP/JMP32 opcode %x\0A\00", align 1
@.str.271 = private unnamed_addr constant [36 x i8] c"BPF_JMP/JMP32 uses reserved fields\0A\00", align 1
@.str.272 = private unnamed_addr constant [35 x i8] c"R%d pointer comparison prohibited\0A\00", align 1
@.str.273 = private unnamed_addr constant [65 x i8] c"BPF_LD_[ABS|IND] instructions not allowed for this program type\0A\00", align 1
@.str.274 = private unnamed_addr constant [31 x i8] c"bpf verifier is misconfigured\0A\00", align 1
@.str.275 = private unnamed_addr constant [69 x i8] c"BPF_LD_[ABS|IND] instructions cannot be mixed with bpf-to-bpf calls\0A\00", align 1
@.str.276 = private unnamed_addr constant [39 x i8] c"BPF_LD_[ABS|IND] uses reserved fields\0A\00", align 1
@.str.277 = private unnamed_addr constant [57 x i8] c"BPF_LD_[ABS|IND] cannot be mixed with socket references\0A\00", align 1
@.str.278 = private unnamed_addr constant [64 x i8] c"BPF_LD_[ABS|IND] cannot be used inside bpf_spin_lock-ed region\0A\00", align 1
@.str.279 = private unnamed_addr constant [52 x i8] c"at the time of BPF_LD_ABS|IND R6 != pointer to skb\0A\00", align 1
@.str.280 = private unnamed_addr constant [25 x i8] c"invalid BPF_LD_IMM insn\0A\00", align 1
@.str.281 = private unnamed_addr constant [35 x i8] c"BPF_LD_IMM64 uses reserved fields\0A\00", align 1
@.str.282 = private unnamed_addr constant [50 x i8] c"combined stack size of %d calls is %d. Too large\0A\00", align 1
@check_max_stack_depth.__warned = internal global i8 0, section ".data.once", align 1
@.str.283 = private unnamed_addr constant [43 x i8] c"the call stack of %d frames is too deep !\0A\00", align 1
@__const.opt_hard_wire_dead_code_branches.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.opt_remove_nops.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.sanitize_dead_code.trap = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 -1, i32 0 }, align 4
@.str.284 = private unnamed_addr constant [46 x i8] c"bpf verifier narrow ctx access misconfigured\0A\00", align 1
@.str.285 = private unnamed_addr constant [47 x i8] c"insn %d cannot be patched due to 16-bit range\0A\00", align 1
@.str.286 = private unnamed_addr constant [27 x i8] c"tail_call abusing map_ptr\0A\00", align 1
@jit_subprogs.__warned = internal global i8 0, section ".data.once", align 1
@.str.287 = private unnamed_addr constant [38 x i8] c"JIT doesn't support bpf-to-bpf calls\0A\00", align 1
@get_callee_stack_depth.__warned = internal global i8 0, section ".data.once", align 1
@.str.288 = private unnamed_addr constant [29 x i8] c"verification time %lld usec\0A\00", align 1
@.str.289 = private unnamed_addr constant [13 x i8] c"stack depth \00", align 1
@.str.290 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.291 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.292 = private unnamed_addr constant [98 x i8] c"processed %d insns (limit %d) max_states_per_insn %d total_states %d peak_states %d mark_read %d\0A\00", align 1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @tnum_strn(i8* noundef %str, i64 noundef %size, i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %str.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i8*, i8** %str.addr, align 8
  %4 = load i64, i64* %size.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %5 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* noundef %3, i64 noundef %4, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str, i64 0, i64 0), i64 noundef %5, i64 noundef %6) #8
  ret i32 %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @snprintf(i8* noundef, i64 noundef, i8* noundef, ...) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_const(i64 noundef %value) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %value.addr = alloca i64, align 8
  store i64 %value, i64* %value.addr, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %0 = load i64, i64* %value.addr, align 8
  store i64 %0, i64* %value1, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  store i64 0, i64* %mask, align 8
  %1 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %2 = load { i64, i64 }, { i64, i64 }* %1, align 8
  ret { i64, i64 } %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_range(i64 noundef %min, i64 noundef %max) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %min.addr = alloca i64, align 8
  %max.addr = alloca i64, align 8
  %chi = alloca i64, align 8
  %delta = alloca i64, align 8
  %bits = alloca i8, align 1
  store i64 %min, i64* %min.addr, align 8
  store i64 %max, i64* %max.addr, align 8
  %0 = load i64, i64* %min.addr, align 8
  %1 = load i64, i64* %max.addr, align 8
  %xor = xor i64 %0, %1
  store i64 %xor, i64* %chi, align 8
  %2 = load i64, i64* %chi, align 8
  %call = call i32 @fls64___(i64 noundef %2) #8
  %conv = trunc i32 %call to i8
  store i8 %conv, i8* %bits, align 1
  %3 = load i8, i8* %bits, align 1
  %conv1 = zext i8 %3 to i32
  %cmp = icmp sgt i32 %conv1, 63
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = bitcast %struct.tnum* %retval to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i8, i8* %bits, align 1
  %conv3 = zext i8 %5 to i32
  %sh_prom = zext i32 %conv3 to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  store i64 %sub, i64* %delta, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %6 = load i64, i64* %min.addr, align 8
  %7 = load i64, i64* %delta, align 8
  %neg = xor i64 %7, -1
  %and = and i64 %6, %neg
  store i64 %and, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %8 = load i64, i64* %delta, align 8
  store i64 %8, i64* %mask, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fls64___(i64 noundef %x) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %x.addr, align 8
  %call = call i32 @generic___fls___(i64 noundef %1) #8
  %add = add i32 %call, 1
  store i32 %add, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #2

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @generic___fls___(i64 noundef %word) #0 {
entry:
  %word.addr = alloca i64, align 8
  %num = alloca i32, align 4
  store i64 %word, i64* %word.addr, align 8
  store i32 63, i32* %num, align 4
  %0 = load i64, i64* %word.addr, align 8
  %and = and i64 %0, -4294967296
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %num, align 4
  %sub = sub i32 %1, 32
  store i32 %sub, i32* %num, align 4
  %2 = load i64, i64* %word.addr, align 8
  %shl = shl i64 %2, 32
  store i64 %shl, i64* %word.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, i64* %word.addr, align 8
  %and1 = and i64 %3, -281474976710656
  %tobool2 = icmp ne i64 %and1, 0
  br i1 %tobool2, label %if.end6, label %if.then3

if.then3:                                         ; preds = %if.end
  %4 = load i32, i32* %num, align 4
  %sub4 = sub i32 %4, 16
  store i32 %sub4, i32* %num, align 4
  %5 = load i64, i64* %word.addr, align 8
  %shl5 = shl i64 %5, 16
  store i64 %shl5, i64* %word.addr, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %6 = load i64, i64* %word.addr, align 8
  %and7 = and i64 %6, -72057594037927936
  %tobool8 = icmp ne i64 %and7, 0
  br i1 %tobool8, label %if.end12, label %if.then9

if.then9:                                         ; preds = %if.end6
  %7 = load i32, i32* %num, align 4
  %sub10 = sub i32 %7, 8
  store i32 %sub10, i32* %num, align 4
  %8 = load i64, i64* %word.addr, align 8
  %shl11 = shl i64 %8, 8
  store i64 %shl11, i64* %word.addr, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end6
  %9 = load i64, i64* %word.addr, align 8
  %and13 = and i64 %9, -1152921504606846976
  %tobool14 = icmp ne i64 %and13, 0
  br i1 %tobool14, label %if.end18, label %if.then15

if.then15:                                        ; preds = %if.end12
  %10 = load i32, i32* %num, align 4
  %sub16 = sub i32 %10, 4
  store i32 %sub16, i32* %num, align 4
  %11 = load i64, i64* %word.addr, align 8
  %shl17 = shl i64 %11, 4
  store i64 %shl17, i64* %word.addr, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end12
  %12 = load i64, i64* %word.addr, align 8
  %and19 = and i64 %12, -4611686018427387904
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %if.end24, label %if.then21

if.then21:                                        ; preds = %if.end18
  %13 = load i32, i32* %num, align 4
  %sub22 = sub i32 %13, 2
  store i32 %sub22, i32* %num, align 4
  %14 = load i64, i64* %word.addr, align 8
  %shl23 = shl i64 %14, 2
  store i64 %shl23, i64* %word.addr, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end18
  %15 = load i64, i64* %word.addr, align 8
  %and25 = and i64 %15, -9223372036854775808
  %tobool26 = icmp ne i64 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.end24
  %16 = load i32, i32* %num, align 4
  %sub28 = sub i32 %16, 1
  store i32 %sub28, i32* %num, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.end24
  %17 = load i32, i32* %num, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_lshift(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %shift) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %shift.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %shift, i8* %shift.addr, align 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %3 = load i64, i64* %value1, align 8
  %4 = load i8, i8* %shift.addr, align 1
  %conv = zext i8 %4 to i32
  %sh_prom = zext i32 %conv to i64
  %shl = shl i64 %3, %sh_prom
  store i64 %shl, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask2, align 8
  %6 = load i8, i8* %shift.addr, align 1
  %conv3 = zext i8 %6 to i32
  %sh_prom4 = zext i32 %conv3 to i64
  %shl5 = shl i64 %5, %sh_prom4
  store i64 %shl5, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_rshift(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %shift) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %shift.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %shift, i8* %shift.addr, align 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %3 = load i64, i64* %value1, align 8
  %4 = load i8, i8* %shift.addr, align 1
  %conv = zext i8 %4 to i32
  %sh_prom = zext i32 %conv to i64
  %shr = lshr i64 %3, %sh_prom
  store i64 %shr, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask2, align 8
  %6 = load i8, i8* %shift.addr, align 1
  %conv3 = zext i8 %6 to i32
  %sh_prom4 = zext i32 %conv3 to i64
  %shr5 = lshr i64 %5, %sh_prom4
  store i64 %shr5, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_arshift(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %min_shift) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %min_shift.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %min_shift, i8* %min_shift.addr, align 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %3 = load i64, i64* %value1, align 8
  %4 = load i8, i8* %min_shift.addr, align 1
  %conv = zext i8 %4 to i32
  %sh_prom = zext i32 %conv to i64
  %shr = ashr i64 %3, %sh_prom
  store i64 %shr, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask2, align 8
  %6 = load i8, i8* %min_shift.addr, align 1
  %conv3 = zext i8 %6 to i32
  %sh_prom4 = zext i32 %conv3 to i64
  %shr5 = ashr i64 %5, %sh_prom4
  store i64 %shr5, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_add(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %sm = alloca i64, align 8
  %sv = alloca i64, align 8
  %sigma = alloca i64, align 8
  %chi = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %mask1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %7 = load i64, i64* %mask1, align 8
  %add = add i64 %6, %7
  store i64 %add, i64* %sm, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value, align 8
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %9 = load i64, i64* %value2, align 8
  %add3 = add i64 %8, %9
  store i64 %add3, i64* %sv, align 8
  %10 = load i64, i64* %sm, align 8
  %11 = load i64, i64* %sv, align 8
  %add4 = add i64 %10, %11
  store i64 %add4, i64* %sigma, align 8
  %12 = load i64, i64* %sigma, align 8
  %13 = load i64, i64* %sv, align 8
  %xor = xor i64 %12, %13
  store i64 %xor, i64* %chi, align 8
  %14 = load i64, i64* %chi, align 8
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %15 = load i64, i64* %mask5, align 8
  %or = or i64 %14, %15
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %16 = load i64, i64* %mask6, align 8
  %or7 = or i64 %or, %16
  store i64 %or7, i64* %mu, align 8
  %value8 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %17 = load i64, i64* %sv, align 8
  %18 = load i64, i64* %mu, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  store i64 %and, i64* %value8, align 8
  %mask9 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %19 = load i64, i64* %mu, align 8
  store i64 %19, i64* %mask9, align 8
  %20 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %21 = load { i64, i64 }, { i64, i64 }* %20, align 8
  ret { i64, i64 } %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_sub(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %dv = alloca i64, align 8
  %alpha = alloca i64, align 8
  %beta = alloca i64, align 8
  %chi = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %sub = sub i64 %6, %7
  store i64 %sub, i64* %dv, align 8
  %8 = load i64, i64* %dv, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %9 = load i64, i64* %mask, align 8
  %add = add i64 %8, %9
  store i64 %add, i64* %alpha, align 8
  %10 = load i64, i64* %dv, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %11 = load i64, i64* %mask2, align 8
  %sub3 = sub i64 %10, %11
  store i64 %sub3, i64* %beta, align 8
  %12 = load i64, i64* %alpha, align 8
  %13 = load i64, i64* %beta, align 8
  %xor = xor i64 %12, %13
  store i64 %xor, i64* %chi, align 8
  %14 = load i64, i64* %chi, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %15 = load i64, i64* %mask4, align 8
  %or = or i64 %14, %15
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %16 = load i64, i64* %mask5, align 8
  %or6 = or i64 %or, %16
  store i64 %or6, i64* %mu, align 8
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %17 = load i64, i64* %dv, align 8
  %18 = load i64, i64* %mu, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  store i64 %and, i64* %value7, align 8
  %mask8 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %19 = load i64, i64* %mu, align 8
  store i64 %19, i64* %mask8, align 8
  %20 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %21 = load { i64, i64 }, { i64, i64 }* %20, align 8
  ret { i64, i64 } %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_and(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %alpha = alloca i64, align 8
  %beta = alloca i64, align 8
  %v = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %7 = load i64, i64* %mask, align 8
  %or = or i64 %6, %7
  store i64 %or, i64* %alpha, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %8 = load i64, i64* %value1, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %or3 = or i64 %8, %9
  store i64 %or3, i64* %beta, align 8
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %10 = load i64, i64* %value4, align 8
  %value5 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %11 = load i64, i64* %value5, align 8
  %and = and i64 %10, %11
  store i64 %and, i64* %v, align 8
  %value6 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %12 = load i64, i64* %v, align 8
  store i64 %12, i64* %value6, align 8
  %mask7 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %13 = load i64, i64* %alpha, align 8
  %14 = load i64, i64* %beta, align 8
  %and8 = and i64 %13, %14
  %15 = load i64, i64* %v, align 8
  %neg = xor i64 %15, -1
  %and9 = and i64 %and8, %neg
  store i64 %and9, i64* %mask7, align 8
  %16 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %17 = load { i64, i64 }, { i64, i64 }* %16, align 8
  ret { i64, i64 } %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_or(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %v = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %or = or i64 %6, %7
  store i64 %or, i64* %v, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %or3 = or i64 %8, %9
  store i64 %or3, i64* %mu, align 8
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %10 = load i64, i64* %v, align 8
  store i64 %10, i64* %value4, align 8
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %11 = load i64, i64* %mu, align 8
  %12 = load i64, i64* %v, align 8
  %neg = xor i64 %12, -1
  %and = and i64 %11, %neg
  store i64 %and, i64* %mask5, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_xor(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %v = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %xor = xor i64 %6, %7
  store i64 %xor, i64* %v, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %or = or i64 %8, %9
  store i64 %or, i64* %mu, align 8
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %10 = load i64, i64* %v, align 8
  %11 = load i64, i64* %mu, align 8
  %neg = xor i64 %11, -1
  %and = and i64 %10, %neg
  store i64 %and, i64* %value3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %12 = load i64, i64* %mu, align 8
  store i64 %12, i64* %mask4, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_mul(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %acc = alloca %struct.tnum, align 8
  %pi = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %.compoundliteral = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %mul = mul i64 %6, %7
  store i64 %mul, i64* %pi, align 8
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 0
  %8 = load i64, i64* %pi, align 8
  store i64 %8, i64* %value2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 1
  store i64 0, i64* %mask, align 8
  %mask3 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %9 = load i64, i64* %mask3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %10 = load i64, i64* %mask4, align 8
  %value5 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %11 = load i64, i64* %value5, align 8
  %or = or i64 %10, %11
  %12 = bitcast %struct.tnum* %.compoundliteral to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %call = call { i64, i64 } @hma(i64 %14, i64 %16, i64 noundef %9, i64 noundef %or) #8
  %17 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast %struct.tnum* %acc to i8*
  %23 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %23, i64 16, i1 false)
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %24 = load i64, i64* %mask6, align 8
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %25 = load i64, i64* %value7, align 8
  %26 = bitcast %struct.tnum* %acc to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call8 = call { i64, i64 } @hma(i64 %28, i64 %30, i64 noundef %24, i64 noundef %25) #8
  %31 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call8, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call8, 1
  store i64 %35, i64* %34, align 8
  %36 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %37 = load { i64, i64 }, { i64, i64 }* %36, align 8
  ret { i64, i64 } %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i64, i64 } @hma(i64 %acc.coerce0, i64 %acc.coerce1, i64 noundef %value, i64 noundef %mask) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %acc = alloca %struct.tnum, align 8
  %value.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %.compoundliteral = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %acc to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %acc.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %acc.coerce1, i64* %2, align 8
  store i64 %value, i64* %value.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %3 = load i64, i64* %mask.addr, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i64, i64* %mask.addr, align 8
  %and = and i64 %4, 1
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 0
  store i64 0, i64* %value2, align 8
  %mask3 = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 1
  %5 = load i64, i64* %value.addr, align 8
  store i64 %5, i64* %mask3, align 8
  %6 = bitcast %struct.tnum* %acc to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %11 = bitcast %struct.tnum* %.compoundliteral to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @tnum_add(i64 %8, i64 %10, i64 %13, i64 %15) #8
  %16 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.tnum* %acc to i8*
  %22 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %23 = load i64, i64* %mask.addr, align 8
  %shr = lshr i64 %23, 1
  store i64 %shr, i64* %mask.addr, align 8
  %24 = load i64, i64* %value.addr, align 8
  %shl = shl i64 %24, 1
  store i64 %shl, i64* %value.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %25 = bitcast %struct.tnum* %retval to i8*
  %26 = bitcast %struct.tnum* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %26, i64 16, i1 false)
  %27 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %28 = load { i64, i64 }, { i64, i64 }* %27, align 8
  ret { i64, i64 } %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_intersect(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %v = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %or = or i64 %6, %7
  store i64 %or, i64* %v, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %and = and i64 %8, %9
  store i64 %and, i64* %mu, align 8
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %10 = load i64, i64* %v, align 8
  %11 = load i64, i64* %mu, align 8
  %neg = xor i64 %11, -1
  %and4 = and i64 %10, %neg
  store i64 %and4, i64* %value3, align 8
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %12 = load i64, i64* %mu, align 8
  store i64 %12, i64* %mask5, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_cast(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %size) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %size.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %size, i8* %size.addr, align 1
  %3 = load i8, i8* %size.addr, align 1
  %conv = zext i8 %3 to i32
  %mul = mul i32 %conv, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %and = and i64 %4, %sub
  store i64 %and, i64* %value, align 8
  %5 = load i8, i8* %size.addr, align 1
  %conv1 = zext i8 %5 to i32
  %mul2 = mul i32 %conv1, 8
  %sh_prom3 = zext i32 %mul2 to i64
  %shl4 = shl i64 1, %sh_prom3
  %sub5 = sub i64 %shl4, 1
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %and6 = and i64 %6, %sub5
  store i64 %and6, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to i8*
  %8 = bitcast %struct.tnum* %a to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 16, i1 false)
  %9 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @tnum_is_aligned(i64 %a.coerce0, i64 %a.coerce1, i64 noundef %size) #0 {
entry:
  %retval = alloca i1, align 1
  %a = alloca %struct.tnum, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i64, i64* %size.addr, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask, align 8
  %or = or i64 %4, %5
  %6 = load i64, i64* %size.addr, align 8
  %sub = sub i64 %6, 1
  %and = and i64 %or, %sub
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @tnum_in(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca i1, align 1
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %mask1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %7 = load i64, i64* %mask1, align 8
  %neg = xor i64 %7, -1
  %and = and i64 %6, %neg
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask2, align 8
  %neg3 = xor i64 %8, -1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %9 = load i64, i64* %value, align 8
  %and4 = and i64 %9, %neg3
  store i64 %and4, i64* %value, align 8
  %value5 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %10 = load i64, i64* %value5, align 8
  %value6 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %11 = load i64, i64* %value6, align 8
  %cmp = icmp eq i64 %10, %11
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @tnum_sbin(i8* noundef %str, i64 noundef %size, i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %str.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %n = alloca i64, align 8
  %__UNIQUE_ID___x0 = alloca i64, align 8
  %__UNIQUE_ID___y1 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 64, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64, i64* %n, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, i64* %n, align 8
  %5 = load i64, i64* %size.addr, align 8
  %cmp = icmp ult i64 %4, %5
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %for.body
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %and = and i64 %6, 1
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %7 = load i8*, i8** %str.addr, align 8
  %8 = load i64, i64* %n, align 8
  %sub = sub i64 %8, 1
  %arrayidx = getelementptr i8, i8* %7, i64 %sub
  store i8 120, i8* %arrayidx, align 1
  br label %if.end11

if.else:                                          ; preds = %if.then
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %9 = load i64, i64* %value, align 8
  %and3 = and i64 %9, 1
  %tobool4 = icmp ne i64 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %10 = load i8*, i8** %str.addr, align 8
  %11 = load i64, i64* %n, align 8
  %sub6 = sub i64 %11, 1
  %arrayidx7 = getelementptr i8, i8* %10, i64 %sub6
  store i8 49, i8* %arrayidx7, align 1
  br label %if.end

if.else8:                                         ; preds = %if.else
  %12 = load i8*, i8** %str.addr, align 8
  %13 = load i64, i64* %n, align 8
  %sub9 = sub i64 %13, 1
  %arrayidx10 = getelementptr i8, i8* %12, i64 %sub9
  store i8 48, i8* %arrayidx10, align 1
  br label %if.end

if.end:                                           ; preds = %if.else8, %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then2
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %for.body
  %mask13 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %14 = load i64, i64* %mask13, align 8
  %shr = lshr i64 %14, 1
  store i64 %shr, i64* %mask13, align 8
  %value14 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %15 = load i64, i64* %value14, align 8
  %shr15 = lshr i64 %15, 1
  store i64 %shr15, i64* %value14, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %16 = load i64, i64* %n, align 8
  %dec = add i64 %16, -1
  store i64 %dec, i64* %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8*, i8** %str.addr, align 8
  %18 = load i64, i64* %size.addr, align 8
  %sub16 = sub i64 %18, 1
  store i64 %sub16, i64* %__UNIQUE_ID___x0, align 8
  store i64 64, i64* %__UNIQUE_ID___y1, align 8
  %19 = load i64, i64* %__UNIQUE_ID___x0, align 8
  %20 = load i64, i64* %__UNIQUE_ID___y1, align 8
  %cmp17 = icmp ult i64 %19, %20
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %21 = load i64, i64* %__UNIQUE_ID___x0, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %22 = load i64, i64* %__UNIQUE_ID___y1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %21, %cond.true ], [ %22, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %23 = load i64, i64* %tmp, align 8
  %arrayidx18 = getelementptr i8, i8* %17, i64 %23
  store i8 0, i8* %arrayidx18, align 1
  ret i32 64
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_log_write(%struct.bpf_verifier_env* noundef %env, i8* noundef %fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 18
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #8
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 18
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay3) #8
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 2
  %3 = load i8*, i8** %ubuf, align 8
  %tobool1 = icmp ne i8* %3, null
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %4 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %4) #8
  %lnot = xor i1 %call, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %5
}

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_start(i8*) #3

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, %struct.__va_list_tag* noundef %args) #0 {
entry:
  %retval.i = alloca i1, align 1
  %addr.addr.i = alloca i8*, align 8
  %bytes.addr.i = alloca i64, align 8
  %is_source.addr.i = alloca i8, align 1
  %sz.i = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args.addr = alloca %struct.__va_list_tag*, align 8
  %n = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp29 = alloca i64, align 8
  %__UNIQUE_ID___x122 = alloca i32, align 4
  %__UNIQUE_ID___y123 = alloca i32, align 4
  %tmp37 = alloca i32, align 4
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  store %struct.__va_list_tag* %args, %struct.__va_list_tag** %args.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf, i64 0, i64 0
  %1 = load i8*, i8** %fmt.addr, align 8
  %2 = load %struct.__va_list_tag*, %struct.__va_list_tag** %args.addr, align 8
  %call = call i32 @vscnprintf(i8* noundef %arraydecay, i64 noundef 1024, i8* noundef %1, %struct.__va_list_tag* noundef %2) #8
  store i32 %call, i32* %n, align 4
  %3 = load i32, i32* %n, align 4
  %cmp = icmp uge i32 %3, 1023
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_once, align 4
  %4 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %5 = load i8, i8* @bpf_verifier_vlog.__warned, align 1
  %tobool2 = trunc i8 %5 to i1
  %lnot3 = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  %lnot5 = xor i1 %6, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %tobool9 = icmp ne i64 %conv, 0
  br i1 %tobool9, label %if.then, label %if.end28

if.then:                                          ; preds = %land.end
  store i8 1, i8* @bpf_verifier_vlog.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool10 = icmp ne i32 %7, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %tobool16 = icmp ne i64 %conv15, 0
  br i1 %tobool16, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then17
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.2, i64 0, i64 0)) #8
  br label %do.body18

do.body18:                                        ; preds = %do.body
  br label %do.body19

do.body19:                                        ; preds = %do.body18
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 327, i32 2313, i64 12) #9, !srcloc !5
  br label %do.end

do.end:                                           ; preds = %do.body19
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 121) #9, !srcloc !6
  br label %do.end20

do.end20:                                         ; preds = %do.end
  br label %do.end21

do.end21:                                         ; preds = %do.end20
  br label %if.end

if.end:                                           ; preds = %do.end21, %if.then
  %8 = load i32, i32* %__ret_warn_on, align 4
  %tobool22 = icmp ne i32 %8, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  store i64 %conv27, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.end, %land.end
  %10 = load i32, i32* %__ret_warn_once, align 4
  %tobool30 = icmp ne i32 %10, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  store i64 %conv35, i64* %tmp29, align 8
  %11 = load i64, i64* %tmp29, align 8
  %12 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %12, i32 0, i32 4
  %13 = load i32, i32* %len_total, align 4
  %14 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %14, i32 0, i32 3
  %15 = load i32, i32* %len_used, align 8
  %sub = sub i32 %13, %15
  %sub36 = sub i32 %sub, 1
  store i32 %sub36, i32* %__UNIQUE_ID___x122, align 4
  %16 = load i32, i32* %n, align 4
  store i32 %16, i32* %__UNIQUE_ID___y123, align 4
  %17 = load i32, i32* %__UNIQUE_ID___x122, align 4
  %18 = load i32, i32* %__UNIQUE_ID___y123, align 4
  %cmp38 = icmp ult i32 %17, %18
  br i1 %cmp38, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end28
  %19 = load i32, i32* %__UNIQUE_ID___x122, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end28
  %20 = load i32, i32* %__UNIQUE_ID___y123, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, i32* %tmp37, align 4
  %21 = load i32, i32* %tmp37, align 4
  store i32 %21, i32* %n, align 4
  %22 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf40 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %22, i32 0, i32 1
  %23 = load i32, i32* %n, align 4
  %idxprom = zext i32 %23 to i64
  %arrayidx = getelementptr [1024 x i8], [1024 x i8]* %kbuf40, i64 0, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  %24 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %24, i32 0, i32 2
  %25 = load i8*, i8** %ubuf, align 8
  %26 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used41 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %26, i32 0, i32 3
  %27 = load i32, i32* %len_used41, align 8
  %idx.ext = zext i32 %27 to i64
  %add.ptr = getelementptr i8, i8* %25, i64 %idx.ext
  %28 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf42 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %28, i32 0, i32 1
  %arraydecay43 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf42, i64 0, i64 0
  %29 = load i32, i32* %n, align 4
  %add = add i32 %29, 1
  %conv44 = zext i32 %add to i64
  store i8* %add.ptr, i8** %to.addr.i, align 8
  store i8* %arraydecay43, i8** %from.addr.i, align 8
  store i64 %conv44, i64* %n.addr.i, align 8
  %30 = load i8*, i8** %from.addr.i, align 8
  %31 = load i64, i64* %n.addr.i, align 8
  store i8* %30, i8** %addr.addr.i, align 8
  store i64 %31, i64* %bytes.addr.i, align 8
  store i8 1, i8* %is_source.addr.i, align 1
  store i32 -1, i32* %sz.i, align 4
  %32 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp sge i32 %32, 0
  br i1 %cmp.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %cond.end
  %33 = load i32, i32* %sz.i, align 4
  %conv.i52 = sext i32 %33 to i64
  %34 = load i64, i64* %bytes.addr.i, align 8
  %cmp1.i = icmp ult i64 %conv.i52, %34
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %cond.end
  %35 = phi i1 [ false, %cond.end ], [ %cmp1.i, %land.rhs.i ]
  %lnot.i53 = xor i1 %35, true
  %lnot.ext.i54 = zext i1 %35 to i32
  %conv4.i = sext i32 %lnot.ext.i54 to i64
  br i1 %35, label %if.then.i55, label %if.end10.i

if.then.i55:                                      ; preds = %land.end.i
  %36 = load i64, i64* %bytes.addr.i, align 8
  %37 = call i1 @llvm.is.constant.i64(i64 %36) #9
  br i1 %37, label %if.else.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.then.i55
  %38 = load i32, i32* %sz.i, align 4
  %39 = load i64, i64* %bytes.addr.i, align 8
  call void @copy_overflow(i32 noundef %38, i64 noundef %39) #10
  br label %if.end9.i

if.else.i:                                        ; preds = %if.then.i55
  %40 = load i8, i8* %is_source.addr.i, align 1
  %tobool6.i = trunc i8 %40 to i1
  br i1 %tobool6.i, label %if.then7.i, label %if.else8.i

if.then7.i:                                       ; preds = %if.else.i
  call void @__bad_copy_from() #10
  br label %if.end.i

if.else8.i:                                       ; preds = %if.else.i
  call void @__bad_copy_to() #10
  br label %if.end.i

if.end.i:                                         ; preds = %if.else8.i, %if.then7.i
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.end.i, %if.then5.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end10.i:                                       ; preds = %land.end.i
  %41 = load i8*, i8** %addr.addr.i, align 8
  %42 = load i64, i64* %bytes.addr.i, align 8
  %43 = load i8, i8* %is_source.addr.i, align 1
  %tobool11.i = trunc i8 %43 to i1
  call void @check_object_size(i8* noundef %41, i64 noundef %42, i1 noundef zeroext %tobool11.i) #10
  store i1 true, i1* %retval.i, align 1
  br label %check_copy_size.exit

check_copy_size.exit:                             ; preds = %if.end10.i, %if.end9.i
  %44 = load i1, i1* %retval.i, align 1
  %lnot.i = xor i1 %44, true
  %lnot.ext.i = zext i1 %44 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %44, label %if.then.i, label %copy_to_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit
  %45 = load i8*, i8** %to.addr.i, align 8
  %46 = load i8*, i8** %from.addr.i, align 8
  %47 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_to_user(i8* noundef %45, i8* noundef %46, i64 noundef %47) #10
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.then.i, %check_copy_size.exit
  %48 = load i64, i64* %n.addr.i, align 8
  %tobool46 = icmp ne i64 %48, 0
  br i1 %tobool46, label %if.else, label %if.then47

if.then47:                                        ; preds = %copy_to_user.exit
  %49 = load i32, i32* %n, align 4
  %50 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used48 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %50, i32 0, i32 3
  %51 = load i32, i32* %len_used48, align 8
  %add49 = add i32 %51, %49
  store i32 %add49, i32* %len_used48, align 8
  br label %if.end51

if.else:                                          ; preds = %copy_to_user.exit
  %52 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf50 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %52, i32 0, i32 2
  store i8* null, i8** %ubuf50, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.else, %if.then47
  ret void
}

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_end(i8*) #3

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @vscnprintf(i8* noundef, i64 noundef, i8* noundef, %struct.__va_list_tag* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__warn_printk(i8* noundef, ...) #1

; Function Attrs: convergent nofree nosync nounwind readnone willreturn
declare i1 @llvm.is.constant.i64(i64) #4

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @copy_overflow(i32 noundef %size, i64 noundef %count) #0 {
entry:
  %size.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %size, i32* %size.addr, align 4
  store i64 %count, i64* %count.addr, align 8
  store i32 1, i32* %__ret_warn_on, align 4
  %0 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, i32* %size.addr, align 4
  %2 = load i64, i64* %count.addr, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.2.3, i64 0, i64 0), i32 noundef %1, i64 noundef %2) #8
  br label %do.body3

do.body3:                                         ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %do.body3
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.3, i64 0, i64 0), i32 134, i32 2313, i64 12) #9, !srcloc !7
  br label %do.end

do.end:                                           ; preds = %do.body4
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 0) #9, !srcloc !8
  br label %do.end5

do.end5:                                          ; preds = %do.end
  br label %do.end6

do.end6:                                          ; preds = %do.end5
  br label %if.end

if.end:                                           ; preds = %do.end6, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %3, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  store i64 %conv12, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_from() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_to() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @check_object_size(i8* noundef %ptr, i64 noundef %n, i1 noundef zeroext %to_user) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %to_user.addr = alloca i8, align 1
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %frombool = zext i1 %to_user to i8
  store i8 %frombool, i8* %to_user.addr, align 1
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_to_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 3
  %1 = load i32, i32* %len_used, align 8
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 4
  %3 = load i32, i32* %len_total, align 4
  %sub = sub i32 %3, 1
  %cmp = icmp uge i32 %1, %sub
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @reg_bounds_sync___(%struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %0) #8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %1) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x136 = alloca i64, align 8
  %__UNIQUE_ID___y137 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x138 = alloca i64, align 8
  %__UNIQUE_ID___y139 = alloca i64, align 8
  %tmp7 = alloca i64, align 8
  %__UNIQUE_ID___x140 = alloca i64, align 8
  %__UNIQUE_ID___y141 = alloca i64, align 8
  %tmp22 = alloca i64, align 8
  %__UNIQUE_ID___x142 = alloca i64, align 8
  %__UNIQUE_ID___y143 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  %cmp = icmp sge i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  %cmp1 = icmp slt i64 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value2, align 8
  store i64 %5, i64* %__UNIQUE_ID___x136, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 8
  %7 = load i64, i64* %umin_value, align 8
  store i64 %7, i64* %__UNIQUE_ID___y137, align 8
  %8 = load i64, i64* %__UNIQUE_ID___x136, align 8
  %9 = load i64, i64* %__UNIQUE_ID___y137, align 8
  %cmp3 = icmp ugt i64 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i64, i64* %__UNIQUE_ID___x136, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i64, i64* %__UNIQUE_ID___y137, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 8
  store i64 %12, i64* %umin_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %12, i64* %smin_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value6, align 8
  store i64 %16, i64* %__UNIQUE_ID___x138, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 9
  %18 = load i64, i64* %umax_value, align 8
  store i64 %18, i64* %__UNIQUE_ID___y139, align 8
  %19 = load i64, i64* %__UNIQUE_ID___x138, align 8
  %20 = load i64, i64* %__UNIQUE_ID___y139, align 8
  %cmp8 = icmp ult i64 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___x138, align 8
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i64, i64* %__UNIQUE_ID___y139, align 8
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i64 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i64 %cond12, i64* %tmp7, align 8
  %23 = load i64, i64* %tmp7, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 %23, i64* %umax_value13, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 7
  store i64 %23, i64* %smax_value14, align 8
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value15, align 8
  %cmp16 = icmp sge i64 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  store i64 %29, i64* %smin_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 7
  %32 = load i64, i64* %smax_value20, align 8
  store i64 %32, i64* %__UNIQUE_ID___x140, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value21, align 8
  store i64 %34, i64* %__UNIQUE_ID___y141, align 8
  %35 = load i64, i64* %__UNIQUE_ID___x140, align 8
  %36 = load i64, i64* %__UNIQUE_ID___y141, align 8
  %cmp23 = icmp ult i64 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i64, i64* %__UNIQUE_ID___x140, align 8
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i64, i64* %__UNIQUE_ID___y141, align 8
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i64 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i64 %cond27, i64* %tmp22, align 8
  %39 = load i64, i64* %tmp22, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 9
  store i64 %39, i64* %umax_value28, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 7
  store i64 %39, i64* %smax_value29, align 8
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 8
  %43 = load i64, i64* %umin_value30, align 8
  %cmp31 = icmp slt i64 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value33, align 8
  store i64 %45, i64* %__UNIQUE_ID___x142, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 8
  %47 = load i64, i64* %umin_value34, align 8
  store i64 %47, i64* %__UNIQUE_ID___y143, align 8
  %48 = load i64, i64* %__UNIQUE_ID___x142, align 8
  %49 = load i64, i64* %__UNIQUE_ID___y143, align 8
  %cmp36 = icmp ugt i64 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i64, i64* %__UNIQUE_ID___x142, align 8
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i64, i64* %__UNIQUE_ID___y143, align 8
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i64 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i64 %cond40, i64* %tmp35, align 8
  %52 = load i64, i64* %tmp35, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  store i64 %52, i64* %umin_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 6
  store i64 %52, i64* %smin_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 9
  %56 = load i64, i64* %umax_value43, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 7
  store i64 %56, i64* %smax_value44, align 8
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %cond.end26, %cond.end11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_bound_offset(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef %3, i64 noundef %5) #8
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %16 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call2 = call { i64, i64 } @tnum_intersect(i64 %13, i64 %15, i64 %18, i64 %20) #8
  %21 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call2, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call2, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.tnum* %var_off to i8*
  %27 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %src_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %insn_bitness = alloca i64, align 8
  %dst = alloca i32, align 4
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp119 = alloca %struct.tnum, align 8
  %tmp125 = alloca %struct.tnum, align 8
  %tmp173 = alloca %struct.tnum, align 8
  %__UNIQUE_ID___x159 = alloca i64, align 8
  %__UNIQUE_ID___y160 = alloca i64, align 8
  %tmp181 = alloca i64, align 8
  %tmp214 = alloca %struct.tnum, align 8
  %__UNIQUE_ID___x161 = alloca i64, align 8
  %__UNIQUE_ID___y162 = alloca i64, align 8
  %tmp219 = alloca i64, align 8
  %tmp268 = alloca %struct.tnum, align 8
  %tmp280 = alloca %struct.tnum, align 8
  %tmp297 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 0
  %4 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %4 to i32
  %and4 = and i32 %conv3, 7
  %cmp = icmp eq i32 %and4, 7
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 64, i32 32
  %conv6 = sext i32 %cond to i64
  store i64 %conv6, i64* %insn_bitness, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg7, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv8 = zext i8 %bf.clear to i32
  store i32 %conv8, i32* %dst, align 4
  %7 = load i64, i64* %insn_bitness, align 8
  %cmp9 = icmp eq i64 %7, 32
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %8, i32 noundef 4) #8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %src_reg, i32 noundef 4) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  store i64 %9, i64* %smin_val, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 7
  %10 = load i64, i64* %smax_value, align 8
  store i64 %10, i64* %smax_val, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 8
  %11 = load i64, i64* %umin_value, align 8
  store i64 %11, i64* %umin_val, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 9
  %12 = load i64, i64* %umax_value, align 8
  store i64 %12, i64* %umax_val, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call11 = call zeroext i1 @tnum_is_const(i64 %15, i64 %17) #8
  %frombool = zext i1 %call11 to i8
  store i8 %frombool, i8* %src_known, align 1
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off12 to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call13 = call zeroext i1 @tnum_is_const(i64 %21, i64 %23) #8
  %frombool14 = zext i1 %call13 to i8
  store i8 %frombool14, i8* %dst_known, align 1
  %24 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %24 to i1
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false20

land.lhs.true:                                    ; preds = %if.end
  %25 = load i64, i64* %smin_val, align 8
  %26 = load i64, i64* %smax_val, align 8
  %cmp16 = icmp ne i64 %25, %26
  br i1 %cmp16, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %27 = load i64, i64* %umin_val, align 8
  %28 = load i64, i64* %umax_val, align 8
  %cmp18 = icmp ne i64 %27, %28
  br i1 %cmp18, label %if.then26, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false, %if.end
  %29 = load i64, i64* %smin_val, align 8
  %30 = load i64, i64* %smax_val, align 8
  %cmp21 = icmp sgt i64 %29, %30
  br i1 %cmp21, label %if.then26, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false20
  %31 = load i64, i64* %umin_val, align 8
  %32 = load i64, i64* %umax_val, align 8
  %cmp24 = icmp ugt i64 %31, %32
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %lor.lhs.false23, %lor.lhs.false20, %lor.lhs.false, %land.lhs.true
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %33) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %lor.lhs.false23
  %34 = load i8, i8* %src_known, align 1
  %tobool28 = trunc i8 %34 to i1
  br i1 %tobool28, label %if.end42, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %if.end27
  %35 = load i8, i8* %opcode, align 1
  %conv30 = zext i8 %35 to i32
  %cmp31 = icmp ne i32 %conv30, 0
  br i1 %cmp31, label %land.lhs.true33, label %if.end42

land.lhs.true33:                                  ; preds = %land.lhs.true29
  %36 = load i8, i8* %opcode, align 1
  %conv34 = zext i8 %36 to i32
  %cmp35 = icmp ne i32 %conv34, 16
  br i1 %cmp35, label %land.lhs.true37, label %if.end42

land.lhs.true37:                                  ; preds = %land.lhs.true33
  %37 = load i8, i8* %opcode, align 1
  %conv38 = zext i8 %37 to i32
  %cmp39 = icmp ne i32 %conv38, 80
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %land.lhs.true37
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %38) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %land.lhs.true37, %land.lhs.true33, %land.lhs.true29, %if.end27
  %39 = load i8, i8* %opcode, align 1
  %conv43 = zext i8 %39 to i32
  switch i32 %conv43, label %sw.default [
    i32 0, label %sw.bb
    i32 16, label %sw.bb85
    i32 32, label %sw.bb123
    i32 80, label %sw.bb160
    i32 64, label %sw.bb201
    i32 96, label %sw.bb247
    i32 112, label %sw.bb272
    i32 192, label %sw.bb287
  ]

sw.bb:                                            ; preds = %if.end42
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call44 = call i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %40, %struct.bpf_insn* noundef %41) #8
  store i32 %call44, i32* %ret, align 4
  %42 = load i32, i32* %ret, align 4
  %cmp45 = icmp slt i32 %42, 0
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %sw.bb
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.4, i64 0, i64 0), i32 noundef %45) #8
  %46 = load i32, i32* %ret, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %sw.bb
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 6
  %48 = load i64, i64* %smin_value49, align 8
  %49 = load i64, i64* %smin_val, align 8
  %call50 = call zeroext i1 @signed_add_overflows(i64 noundef %48, i64 noundef %49) #8
  br i1 %call50, label %if.then56, label %lor.lhs.false52

lor.lhs.false52:                                  ; preds = %if.end48
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 7
  %51 = load i64, i64* %smax_value53, align 8
  %52 = load i64, i64* %smax_val, align 8
  %call54 = call zeroext i1 @signed_add_overflows(i64 noundef %51, i64 noundef %52) #8
  br i1 %call54, label %if.then56, label %if.else

if.then56:                                        ; preds = %lor.lhs.false52, %if.end48
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value57, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value58, align 8
  br label %if.end62

if.else:                                          ; preds = %lor.lhs.false52
  %55 = load i64, i64* %smin_val, align 8
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 6
  %57 = load i64, i64* %smin_value59, align 8
  %add = add i64 %57, %55
  store i64 %add, i64* %smin_value59, align 8
  %58 = load i64, i64* %smax_val, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 7
  %60 = load i64, i64* %smax_value60, align 8
  %add61 = add i64 %60, %58
  store i64 %add61, i64* %smax_value60, align 8
  br label %if.end62

if.end62:                                         ; preds = %if.else, %if.then56
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 8
  %62 = load i64, i64* %umin_value63, align 8
  %63 = load i64, i64* %umin_val, align 8
  %add64 = add i64 %62, %63
  %64 = load i64, i64* %umin_val, align 8
  %cmp65 = icmp ult i64 %add64, %64
  br i1 %cmp65, label %if.then72, label %lor.lhs.false67

lor.lhs.false67:                                  ; preds = %if.end62
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 9
  %66 = load i64, i64* %umax_value68, align 8
  %67 = load i64, i64* %umax_val, align 8
  %add69 = add i64 %66, %67
  %68 = load i64, i64* %umax_val, align 8
  %cmp70 = icmp ult i64 %add69, %68
  br i1 %cmp70, label %if.then72, label %if.else75

if.then72:                                        ; preds = %lor.lhs.false67, %if.end62
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 8
  store i64 0, i64* %umin_value73, align 8
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 9
  store i64 -1, i64* %umax_value74, align 8
  br label %if.end80

if.else75:                                        ; preds = %lor.lhs.false67
  %71 = load i64, i64* %umin_val, align 8
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 8
  %73 = load i64, i64* %umin_value76, align 8
  %add77 = add i64 %73, %71
  store i64 %add77, i64* %umin_value76, align 8
  %74 = load i64, i64* %umax_val, align 8
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 9
  %76 = load i64, i64* %umax_value78, align 8
  %add79 = add i64 %76, %74
  store i64 %add79, i64* %umax_value78, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.else75, %if.then72
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 5
  %var_off83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %79 = bitcast %struct.tnum* %var_off82 to { i64, i64 }*
  %80 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %79, i32 0, i32 0
  %81 = load i64, i64* %80, align 8
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %79, i32 0, i32 1
  %83 = load i64, i64* %82, align 8
  %84 = bitcast %struct.tnum* %var_off83 to { i64, i64 }*
  %85 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 0
  %86 = load i64, i64* %85, align 8
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 1
  %88 = load i64, i64* %87, align 8
  %call84 = call { i64, i64 } @tnum_add(i64 %81, i64 %83, i64 %86, i64 %88) #8
  %89 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = extractvalue { i64, i64 } %call84, 0
  store i64 %91, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = extractvalue { i64, i64 } %call84, 1
  store i64 %93, i64* %92, align 8
  %94 = bitcast %struct.tnum* %var_off81 to i8*
  %95 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %94, i8* align 8 %95, i64 16, i1 false)
  br label %sw.epilog

sw.bb85:                                          ; preds = %if.end42
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %97 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call86 = call i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %96, %struct.bpf_insn* noundef %97) #8
  store i32 %call86, i32* %ret, align 4
  %98 = load i32, i32* %ret, align 4
  %cmp87 = icmp slt i32 %98, 0
  br i1 %cmp87, label %if.then89, label %if.end90

if.then89:                                        ; preds = %sw.bb85
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = bitcast %struct.bpf_verifier_env* %99 to i8*
  %101 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %100, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.5, i64 0, i64 0), i32 noundef %101) #8
  %102 = load i32, i32* %ret, align 4
  store i32 %102, i32* %retval, align 4
  br label %return

if.end90:                                         ; preds = %sw.bb85
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value91 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 6
  %104 = load i64, i64* %smin_value91, align 8
  %105 = load i64, i64* %smax_val, align 8
  %call92 = call zeroext i1 @signed_sub_overflows(i64 noundef %104, i64 noundef %105) #8
  br i1 %call92, label %if.then98, label %lor.lhs.false94

lor.lhs.false94:                                  ; preds = %if.end90
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 7
  %107 = load i64, i64* %smax_value95, align 8
  %108 = load i64, i64* %smin_val, align 8
  %call96 = call zeroext i1 @signed_sub_overflows(i64 noundef %107, i64 noundef %108) #8
  br i1 %call96, label %if.then98, label %if.else101

if.then98:                                        ; preds = %lor.lhs.false94, %if.end90
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value99, align 8
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %110, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value100, align 8
  br label %if.end105

if.else101:                                       ; preds = %lor.lhs.false94
  %111 = load i64, i64* %smax_val, align 8
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 6
  %113 = load i64, i64* %smin_value102, align 8
  %sub = sub i64 %113, %111
  store i64 %sub, i64* %smin_value102, align 8
  %114 = load i64, i64* %smin_val, align 8
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 7
  %116 = load i64, i64* %smax_value103, align 8
  %sub104 = sub i64 %116, %114
  store i64 %sub104, i64* %smax_value103, align 8
  br label %if.end105

if.end105:                                        ; preds = %if.else101, %if.then98
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i32 0, i32 8
  %118 = load i64, i64* %umin_value106, align 8
  %119 = load i64, i64* %umax_val, align 8
  %cmp107 = icmp ult i64 %118, %119
  br i1 %cmp107, label %if.then109, label %if.else112

if.then109:                                       ; preds = %if.end105
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %120, i32 0, i32 8
  store i64 0, i64* %umin_value110, align 8
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value111 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %121, i32 0, i32 9
  store i64 -1, i64* %umax_value111, align 8
  br label %if.end117

if.else112:                                       ; preds = %if.end105
  %122 = load i64, i64* %umax_val, align 8
  %123 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value113 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %123, i32 0, i32 8
  %124 = load i64, i64* %umin_value113, align 8
  %sub114 = sub i64 %124, %122
  store i64 %sub114, i64* %umin_value113, align 8
  %125 = load i64, i64* %umin_val, align 8
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 9
  %127 = load i64, i64* %umax_value115, align 8
  %sub116 = sub i64 %127, %125
  store i64 %sub116, i64* %umax_value115, align 8
  br label %if.end117

if.end117:                                        ; preds = %if.else112, %if.then109
  %128 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off118 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %128, i32 0, i32 5
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off120 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %129, i32 0, i32 5
  %var_off121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %130 = bitcast %struct.tnum* %var_off120 to { i64, i64 }*
  %131 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %130, i32 0, i32 0
  %132 = load i64, i64* %131, align 8
  %133 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %130, i32 0, i32 1
  %134 = load i64, i64* %133, align 8
  %135 = bitcast %struct.tnum* %var_off121 to { i64, i64 }*
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %135, i32 0, i32 0
  %137 = load i64, i64* %136, align 8
  %138 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %135, i32 0, i32 1
  %139 = load i64, i64* %138, align 8
  %call122 = call { i64, i64 } @tnum_sub(i64 %132, i64 %134, i64 %137, i64 %139) #8
  %140 = bitcast %struct.tnum* %tmp119 to { i64, i64 }*
  %141 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %140, i32 0, i32 0
  %142 = extractvalue { i64, i64 } %call122, 0
  store i64 %142, i64* %141, align 8
  %143 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %140, i32 0, i32 1
  %144 = extractvalue { i64, i64 } %call122, 1
  store i64 %144, i64* %143, align 8
  %145 = bitcast %struct.tnum* %var_off118 to i8*
  %146 = bitcast %struct.tnum* %tmp119 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %145, i8* align 8 %146, i64 16, i1 false)
  br label %sw.epilog

sw.bb123:                                         ; preds = %if.end42
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off124 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 5
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 5
  %var_off127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %149 = bitcast %struct.tnum* %var_off126 to { i64, i64 }*
  %150 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %149, i32 0, i32 0
  %151 = load i64, i64* %150, align 8
  %152 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %149, i32 0, i32 1
  %153 = load i64, i64* %152, align 8
  %154 = bitcast %struct.tnum* %var_off127 to { i64, i64 }*
  %155 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %154, i32 0, i32 0
  %156 = load i64, i64* %155, align 8
  %157 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %154, i32 0, i32 1
  %158 = load i64, i64* %157, align 8
  %call128 = call { i64, i64 } @tnum_mul(i64 %151, i64 %153, i64 %156, i64 %158) #8
  %159 = bitcast %struct.tnum* %tmp125 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = extractvalue { i64, i64 } %call128, 0
  store i64 %161, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = extractvalue { i64, i64 } %call128, 1
  store i64 %163, i64* %162, align 8
  %164 = bitcast %struct.tnum* %var_off124 to i8*
  %165 = bitcast %struct.tnum* %tmp125 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %164, i8* align 8 %165, i64 16, i1 false)
  %166 = load i64, i64* %smin_val, align 8
  %cmp129 = icmp slt i64 %166, 0
  br i1 %cmp129, label %if.then135, label %lor.lhs.false131

lor.lhs.false131:                                 ; preds = %sw.bb123
  %167 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %167, i32 0, i32 6
  %168 = load i64, i64* %smin_value132, align 8
  %cmp133 = icmp slt i64 %168, 0
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %lor.lhs.false131, %sw.bb123
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %169) #8
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %170) #8
  br label %sw.epilog

if.end136:                                        ; preds = %lor.lhs.false131
  %171 = load i64, i64* %umax_val, align 8
  %cmp137 = icmp ugt i64 %171, 4294967295
  br i1 %cmp137, label %if.then143, label %lor.lhs.false139

lor.lhs.false139:                                 ; preds = %if.end136
  %172 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value140 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %172, i32 0, i32 9
  %173 = load i64, i64* %umax_value140, align 8
  %cmp141 = icmp ugt i64 %173, 4294967295
  br i1 %cmp141, label %if.then143, label %if.end144

if.then143:                                       ; preds = %lor.lhs.false139, %if.end136
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %174) #8
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %175) #8
  br label %sw.epilog

if.end144:                                        ; preds = %lor.lhs.false139
  %176 = load i64, i64* %umin_val, align 8
  %177 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value145 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %177, i32 0, i32 8
  %178 = load i64, i64* %umin_value145, align 8
  %mul = mul i64 %178, %176
  store i64 %mul, i64* %umin_value145, align 8
  %179 = load i64, i64* %umax_val, align 8
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value146 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %180, i32 0, i32 9
  %181 = load i64, i64* %umax_value146, align 8
  %mul147 = mul i64 %181, %179
  store i64 %mul147, i64* %umax_value146, align 8
  %182 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value148 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %182, i32 0, i32 9
  %183 = load i64, i64* %umax_value148, align 8
  %cmp149 = icmp ugt i64 %183, 9223372036854775807
  br i1 %cmp149, label %if.then151, label %if.else154

if.then151:                                       ; preds = %if.end144
  %184 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value152 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %184, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value152, align 8
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value153 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %185, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value153, align 8
  br label %if.end159

if.else154:                                       ; preds = %if.end144
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value155 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i32 0, i32 8
  %187 = load i64, i64* %umin_value155, align 8
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i32 0, i32 6
  store i64 %187, i64* %smin_value156, align 8
  %189 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value157 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %189, i32 0, i32 9
  %190 = load i64, i64* %umax_value157, align 8
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %191, i32 0, i32 7
  store i64 %190, i64* %smax_value158, align 8
  br label %if.end159

if.end159:                                        ; preds = %if.else154, %if.then151
  br label %sw.epilog

sw.bb160:                                         ; preds = %if.end42
  %192 = load i8, i8* %src_known, align 1
  %tobool161 = trunc i8 %192 to i1
  br i1 %tobool161, label %land.lhs.true163, label %if.end171

land.lhs.true163:                                 ; preds = %sw.bb160
  %193 = load i8, i8* %dst_known, align 1
  %tobool164 = trunc i8 %193 to i1
  br i1 %tobool164, label %if.then166, label %if.end171

if.then166:                                       ; preds = %land.lhs.true163
  %194 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off167 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %195, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off167, i32 0, i32 0
  %196 = load i64, i64* %value, align 8
  %var_off168 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %value169 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off168, i32 0, i32 0
  %197 = load i64, i64* %value169, align 8
  %and170 = and i64 %196, %197
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %194, i64 noundef %and170) #8
  br label %sw.epilog

if.end171:                                        ; preds = %land.lhs.true163, %sw.bb160
  %198 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off172 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %198, i32 0, i32 5
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %199, i32 0, i32 5
  %var_off175 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %200 = bitcast %struct.tnum* %var_off174 to { i64, i64 }*
  %201 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %200, i32 0, i32 0
  %202 = load i64, i64* %201, align 8
  %203 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %200, i32 0, i32 1
  %204 = load i64, i64* %203, align 8
  %205 = bitcast %struct.tnum* %var_off175 to { i64, i64 }*
  %206 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %205, i32 0, i32 0
  %207 = load i64, i64* %206, align 8
  %208 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %205, i32 0, i32 1
  %209 = load i64, i64* %208, align 8
  %call176 = call { i64, i64 } @tnum_and(i64 %202, i64 %204, i64 %207, i64 %209) #8
  %210 = bitcast %struct.tnum* %tmp173 to { i64, i64 }*
  %211 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %210, i32 0, i32 0
  %212 = extractvalue { i64, i64 } %call176, 0
  store i64 %212, i64* %211, align 8
  %213 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %210, i32 0, i32 1
  %214 = extractvalue { i64, i64 } %call176, 1
  store i64 %214, i64* %213, align 8
  %215 = bitcast %struct.tnum* %var_off172 to i8*
  %216 = bitcast %struct.tnum* %tmp173 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %215, i8* align 8 %216, i64 16, i1 false)
  %217 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off177 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %217, i32 0, i32 5
  %value178 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off177, i32 0, i32 0
  %218 = load i64, i64* %value178, align 8
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value179 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %219, i32 0, i32 8
  store i64 %218, i64* %umin_value179, align 8
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value180 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %220, i32 0, i32 9
  %221 = load i64, i64* %umax_value180, align 8
  store i64 %221, i64* %__UNIQUE_ID___x159, align 8
  %222 = load i64, i64* %umax_val, align 8
  store i64 %222, i64* %__UNIQUE_ID___y160, align 8
  %223 = load i64, i64* %__UNIQUE_ID___x159, align 8
  %224 = load i64, i64* %__UNIQUE_ID___y160, align 8
  %cmp182 = icmp ult i64 %223, %224
  br i1 %cmp182, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end171
  %225 = load i64, i64* %__UNIQUE_ID___x159, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end171
  %226 = load i64, i64* %__UNIQUE_ID___y160, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond184 = phi i64 [ %225, %cond.true ], [ %226, %cond.false ]
  store i64 %cond184, i64* %tmp181, align 8
  %227 = load i64, i64* %tmp181, align 8
  %228 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value185 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %228, i32 0, i32 9
  store i64 %227, i64* %umax_value185, align 8
  %229 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value186 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %229, i32 0, i32 6
  %230 = load i64, i64* %smin_value186, align 8
  %cmp187 = icmp slt i64 %230, 0
  br i1 %cmp187, label %if.then192, label %lor.lhs.false189

lor.lhs.false189:                                 ; preds = %cond.end
  %231 = load i64, i64* %smin_val, align 8
  %cmp190 = icmp slt i64 %231, 0
  br i1 %cmp190, label %if.then192, label %if.else195

if.then192:                                       ; preds = %lor.lhs.false189, %cond.end
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value193 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %232, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value193, align 8
  %233 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value194 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %233, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value194, align 8
  br label %if.end200

if.else195:                                       ; preds = %lor.lhs.false189
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value196 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 8
  %235 = load i64, i64* %umin_value196, align 8
  %236 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value197 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %236, i32 0, i32 6
  store i64 %235, i64* %smin_value197, align 8
  %237 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value198 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %237, i32 0, i32 9
  %238 = load i64, i64* %umax_value198, align 8
  %239 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %239, i32 0, i32 7
  store i64 %238, i64* %smax_value199, align 8
  br label %if.end200

if.end200:                                        ; preds = %if.else195, %if.then192
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %240) #8
  br label %sw.epilog

sw.bb201:                                         ; preds = %if.end42
  %241 = load i8, i8* %src_known, align 1
  %tobool202 = trunc i8 %241 to i1
  br i1 %tobool202, label %land.lhs.true204, label %if.end212

land.lhs.true204:                                 ; preds = %sw.bb201
  %242 = load i8, i8* %dst_known, align 1
  %tobool205 = trunc i8 %242 to i1
  br i1 %tobool205, label %if.then207, label %if.end212

if.then207:                                       ; preds = %land.lhs.true204
  %243 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %244 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %244, i32 0, i32 5
  %value209 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off208, i32 0, i32 0
  %245 = load i64, i64* %value209, align 8
  %var_off210 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %value211 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off210, i32 0, i32 0
  %246 = load i64, i64* %value211, align 8
  %or = or i64 %245, %246
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %243, i64 noundef %or) #8
  br label %sw.epilog

if.end212:                                        ; preds = %land.lhs.true204, %sw.bb201
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off213 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i32 0, i32 5
  %248 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %248, i32 0, i32 5
  %var_off216 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %249 = bitcast %struct.tnum* %var_off215 to { i64, i64 }*
  %250 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %249, i32 0, i32 0
  %251 = load i64, i64* %250, align 8
  %252 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %249, i32 0, i32 1
  %253 = load i64, i64* %252, align 8
  %254 = bitcast %struct.tnum* %var_off216 to { i64, i64 }*
  %255 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %254, i32 0, i32 0
  %256 = load i64, i64* %255, align 8
  %257 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %254, i32 0, i32 1
  %258 = load i64, i64* %257, align 8
  %call217 = call { i64, i64 } @tnum_or(i64 %251, i64 %253, i64 %256, i64 %258) #8
  %259 = bitcast %struct.tnum* %tmp214 to { i64, i64 }*
  %260 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %259, i32 0, i32 0
  %261 = extractvalue { i64, i64 } %call217, 0
  store i64 %261, i64* %260, align 8
  %262 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %259, i32 0, i32 1
  %263 = extractvalue { i64, i64 } %call217, 1
  store i64 %263, i64* %262, align 8
  %264 = bitcast %struct.tnum* %var_off213 to i8*
  %265 = bitcast %struct.tnum* %tmp214 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %264, i8* align 8 %265, i64 16, i1 false)
  %266 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value218 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %266, i32 0, i32 8
  %267 = load i64, i64* %umin_value218, align 8
  store i64 %267, i64* %__UNIQUE_ID___x161, align 8
  %268 = load i64, i64* %umin_val, align 8
  store i64 %268, i64* %__UNIQUE_ID___y162, align 8
  %269 = load i64, i64* %__UNIQUE_ID___x161, align 8
  %270 = load i64, i64* %__UNIQUE_ID___y162, align 8
  %cmp220 = icmp ugt i64 %269, %270
  br i1 %cmp220, label %cond.true222, label %cond.false223

cond.true222:                                     ; preds = %if.end212
  %271 = load i64, i64* %__UNIQUE_ID___x161, align 8
  br label %cond.end224

cond.false223:                                    ; preds = %if.end212
  %272 = load i64, i64* %__UNIQUE_ID___y162, align 8
  br label %cond.end224

cond.end224:                                      ; preds = %cond.false223, %cond.true222
  %cond225 = phi i64 [ %271, %cond.true222 ], [ %272, %cond.false223 ]
  store i64 %cond225, i64* %tmp219, align 8
  %273 = load i64, i64* %tmp219, align 8
  %274 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value226 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %274, i32 0, i32 8
  store i64 %273, i64* %umin_value226, align 8
  %275 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off227 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %275, i32 0, i32 5
  %value228 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off227, i32 0, i32 0
  %276 = load i64, i64* %value228, align 8
  %277 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off229 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %277, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off229, i32 0, i32 1
  %278 = load i64, i64* %mask, align 8
  %or230 = or i64 %276, %278
  %279 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value231 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %279, i32 0, i32 9
  store i64 %or230, i64* %umax_value231, align 8
  %280 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value232 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %280, i32 0, i32 6
  %281 = load i64, i64* %smin_value232, align 8
  %cmp233 = icmp slt i64 %281, 0
  br i1 %cmp233, label %if.then238, label %lor.lhs.false235

lor.lhs.false235:                                 ; preds = %cond.end224
  %282 = load i64, i64* %smin_val, align 8
  %cmp236 = icmp slt i64 %282, 0
  br i1 %cmp236, label %if.then238, label %if.else241

if.then238:                                       ; preds = %lor.lhs.false235, %cond.end224
  %283 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value239 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %283, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value239, align 8
  %284 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value240 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %284, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value240, align 8
  br label %if.end246

if.else241:                                       ; preds = %lor.lhs.false235
  %285 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value242 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %285, i32 0, i32 8
  %286 = load i64, i64* %umin_value242, align 8
  %287 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value243 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %287, i32 0, i32 6
  store i64 %286, i64* %smin_value243, align 8
  %288 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value244 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %288, i32 0, i32 9
  %289 = load i64, i64* %umax_value244, align 8
  %290 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value245 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %290, i32 0, i32 7
  store i64 %289, i64* %smax_value245, align 8
  br label %if.end246

if.end246:                                        ; preds = %if.else241, %if.then238
  %291 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %291) #8
  br label %sw.epilog

sw.bb247:                                         ; preds = %if.end42
  %292 = load i64, i64* %umax_val, align 8
  %293 = load i64, i64* %insn_bitness, align 8
  %cmp248 = icmp uge i64 %292, %293
  br i1 %cmp248, label %if.then250, label %if.end251

if.then250:                                       ; preds = %sw.bb247
  %294 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %294) #8
  br label %sw.epilog

if.end251:                                        ; preds = %sw.bb247
  %295 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value252 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %295, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value252, align 8
  %296 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value253 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %296, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value253, align 8
  %297 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value254 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %297, i32 0, i32 9
  %298 = load i64, i64* %umax_value254, align 8
  %299 = load i64, i64* %umax_val, align 8
  %sub255 = sub i64 63, %299
  %shl = shl i64 1, %sub255
  %cmp256 = icmp ugt i64 %298, %shl
  br i1 %cmp256, label %if.then258, label %if.else261

if.then258:                                       ; preds = %if.end251
  %300 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value259 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %300, i32 0, i32 8
  store i64 0, i64* %umin_value259, align 8
  %301 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value260 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %301, i32 0, i32 9
  store i64 -1, i64* %umax_value260, align 8
  br label %if.end266

if.else261:                                       ; preds = %if.end251
  %302 = load i64, i64* %umin_val, align 8
  %303 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value262 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %303, i32 0, i32 8
  %304 = load i64, i64* %umin_value262, align 8
  %shl263 = shl i64 %304, %302
  store i64 %shl263, i64* %umin_value262, align 8
  %305 = load i64, i64* %umax_val, align 8
  %306 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value264 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %306, i32 0, i32 9
  %307 = load i64, i64* %umax_value264, align 8
  %shl265 = shl i64 %307, %305
  store i64 %shl265, i64* %umax_value264, align 8
  br label %if.end266

if.end266:                                        ; preds = %if.else261, %if.then258
  %308 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off267 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %308, i32 0, i32 5
  %309 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off269 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %309, i32 0, i32 5
  %310 = load i64, i64* %umin_val, align 8
  %conv270 = trunc i64 %310 to i8
  %311 = bitcast %struct.tnum* %var_off269 to { i64, i64 }*
  %312 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %311, i32 0, i32 0
  %313 = load i64, i64* %312, align 8
  %314 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %311, i32 0, i32 1
  %315 = load i64, i64* %314, align 8
  %call271 = call { i64, i64 } @tnum_lshift(i64 %313, i64 %315, i8 noundef zeroext %conv270) #8
  %316 = bitcast %struct.tnum* %tmp268 to { i64, i64 }*
  %317 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %316, i32 0, i32 0
  %318 = extractvalue { i64, i64 } %call271, 0
  store i64 %318, i64* %317, align 8
  %319 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %316, i32 0, i32 1
  %320 = extractvalue { i64, i64 } %call271, 1
  store i64 %320, i64* %319, align 8
  %321 = bitcast %struct.tnum* %var_off267 to i8*
  %322 = bitcast %struct.tnum* %tmp268 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %321, i8* align 8 %322, i64 16, i1 false)
  %323 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %323) #8
  br label %sw.epilog

sw.bb272:                                         ; preds = %if.end42
  %324 = load i64, i64* %umax_val, align 8
  %325 = load i64, i64* %insn_bitness, align 8
  %cmp273 = icmp uge i64 %324, %325
  br i1 %cmp273, label %if.then275, label %if.end276

if.then275:                                       ; preds = %sw.bb272
  %326 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %326) #8
  br label %sw.epilog

if.end276:                                        ; preds = %sw.bb272
  %327 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value277 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %327, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value277, align 8
  %328 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value278 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %328, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value278, align 8
  %329 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off279 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %329, i32 0, i32 5
  %330 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off281 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %330, i32 0, i32 5
  %331 = load i64, i64* %umin_val, align 8
  %conv282 = trunc i64 %331 to i8
  %332 = bitcast %struct.tnum* %var_off281 to { i64, i64 }*
  %333 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %332, i32 0, i32 0
  %334 = load i64, i64* %333, align 8
  %335 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %332, i32 0, i32 1
  %336 = load i64, i64* %335, align 8
  %call283 = call { i64, i64 } @tnum_rshift(i64 %334, i64 %336, i8 noundef zeroext %conv282) #8
  %337 = bitcast %struct.tnum* %tmp280 to { i64, i64 }*
  %338 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %337, i32 0, i32 0
  %339 = extractvalue { i64, i64 } %call283, 0
  store i64 %339, i64* %338, align 8
  %340 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %337, i32 0, i32 1
  %341 = extractvalue { i64, i64 } %call283, 1
  store i64 %341, i64* %340, align 8
  %342 = bitcast %struct.tnum* %var_off279 to i8*
  %343 = bitcast %struct.tnum* %tmp280 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %342, i8* align 8 %343, i64 16, i1 false)
  %344 = load i64, i64* %umax_val, align 8
  %345 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value284 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %345, i32 0, i32 8
  %346 = load i64, i64* %umin_value284, align 8
  %shr = lshr i64 %346, %344
  store i64 %shr, i64* %umin_value284, align 8
  %347 = load i64, i64* %umin_val, align 8
  %348 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value285 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %348, i32 0, i32 9
  %349 = load i64, i64* %umax_value285, align 8
  %shr286 = lshr i64 %349, %347
  store i64 %shr286, i64* %umax_value285, align 8
  %350 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %350) #8
  br label %sw.epilog

sw.bb287:                                         ; preds = %if.end42
  %351 = load i64, i64* %umax_val, align 8
  %352 = load i64, i64* %insn_bitness, align 8
  %cmp288 = icmp uge i64 %351, %352
  br i1 %cmp288, label %if.then290, label %if.end291

if.then290:                                       ; preds = %sw.bb287
  %353 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %353) #8
  br label %sw.epilog

if.end291:                                        ; preds = %sw.bb287
  %354 = load i64, i64* %umin_val, align 8
  %355 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value292 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %355, i32 0, i32 6
  %356 = load i64, i64* %smin_value292, align 8
  %shr293 = ashr i64 %356, %354
  store i64 %shr293, i64* %smin_value292, align 8
  %357 = load i64, i64* %umin_val, align 8
  %358 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value294 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %358, i32 0, i32 7
  %359 = load i64, i64* %smax_value294, align 8
  %shr295 = ashr i64 %359, %357
  store i64 %shr295, i64* %smax_value294, align 8
  %360 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off296 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %360, i32 0, i32 5
  %361 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off298 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %361, i32 0, i32 5
  %362 = load i64, i64* %umin_val, align 8
  %conv299 = trunc i64 %362 to i8
  %363 = bitcast %struct.tnum* %var_off298 to { i64, i64 }*
  %364 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %363, i32 0, i32 0
  %365 = load i64, i64* %364, align 8
  %366 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %363, i32 0, i32 1
  %367 = load i64, i64* %366, align 8
  %call300 = call { i64, i64 } @tnum_arshift(i64 %365, i64 %367, i8 noundef zeroext %conv299) #8
  %368 = bitcast %struct.tnum* %tmp297 to { i64, i64 }*
  %369 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %368, i32 0, i32 0
  %370 = extractvalue { i64, i64 } %call300, 0
  store i64 %370, i64* %369, align 8
  %371 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %368, i32 0, i32 1
  %372 = extractvalue { i64, i64 } %call300, 1
  store i64 %372, i64* %371, align 8
  %373 = bitcast %struct.tnum* %var_off296 to i8*
  %374 = bitcast %struct.tnum* %tmp297 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %373, i8* align 8 %374, i64 16, i1 false)
  %375 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value301 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %375, i32 0, i32 8
  store i64 0, i64* %umin_value301, align 8
  %376 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value302 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %376, i32 0, i32 9
  store i64 -1, i64* %umax_value302, align 8
  %377 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %377) #8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end42
  %378 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %378) #8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end291, %if.then290, %if.end276, %if.then275, %if.end266, %if.then250, %if.end246, %if.then207, %if.end200, %if.then166, %if.end159, %if.then143, %if.then135, %if.end117, %if.end80
  %379 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code303 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %379, i32 0, i32 0
  %380 = load i8, i8* %code303, align 4
  %conv304 = zext i8 %380 to i32
  %and305 = and i32 %conv304, 7
  %cmp306 = icmp ne i32 %and305, 7
  br i1 %cmp306, label %if.then308, label %if.end309

if.then308:                                       ; preds = %sw.epilog
  %381 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %381, i32 noundef 4) #8
  br label %if.end309

if.end309:                                        ; preds = %if.then308, %sw.epilog
  %382 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %382) #8
  %383 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %383) #8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end309, %if.then89, %if.then47, %if.then41, %if.then26
  %384 = load i32, i32* %retval, align 4
  ret i32 %384
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %call, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  ret %struct.bpf_reg_state* %arraydecay
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %reg, i32 noundef %size) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %size.addr = alloca i32, align 4
  %mask = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i32, i32* %size.addr, align 4
  %conv = trunc i32 %2 to i8
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_cast(i64 %5, i64 %7, i8 noundef zeroext %conv) #8
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i32, i32* %size.addr, align 4
  %mul = mul i32 %15, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  store i64 %sub, i64* %mask, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 8
  %17 = load i64, i64* %umin_value, align 8
  %18 = load i64, i64* %mask, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 9
  %20 = load i64, i64* %umax_value, align 8
  %21 = load i64, i64* %mask, align 8
  %neg2 = xor i64 %21, -1
  %and3 = and i64 %20, %neg2
  %cmp = icmp eq i64 %and, %and3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %22 = load i64, i64* %mask, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  %24 = load i64, i64* %umin_value5, align 8
  %and6 = and i64 %24, %22
  store i64 %and6, i64* %umin_value5, align 8
  %25 = load i64, i64* %mask, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value7, align 8
  %and8 = and i64 %27, %25
  store i64 %and8, i64* %umax_value7, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  store i64 0, i64* %umin_value9, align 8
  %29 = load i64, i64* %mask, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 9
  store i64 %29, i64* %umax_value10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 8
  %32 = load i64, i64* %umin_value11, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  store i64 %32, i64* %smin_value, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value12, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 7
  store i64 %35, i64* %smax_value, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %3, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 11
  store i32 0, i32* %frameno, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call1 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %1, %struct.bpf_insn* noundef %2) #8
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call2 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %3, i32 noundef 8, i32 noundef 0) #8
  store i32 %call2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose(i8* noundef %private_data, i8* noundef %fmt, ...) #0 {
entry:
  %private_data.addr = alloca i8*, align 8
  %fmt.addr = alloca i8*, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store i8* %private_data, i8** %private_data.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load i8*, i8** %private_data.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %1, %struct.bpf_verifier_env** %env, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 18
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #8
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 18
  %4 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %4, %struct.__va_list_tag* noundef %arraydecay3) #8
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp sgt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp slt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp slt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp sgt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x128 = alloca i64, align 8
  %__UNIQUE_ID___y129 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x130 = alloca i64, align 8
  %__UNIQUE_ID___y131 = alloca i64, align 8
  %tmp9 = alloca i64, align 8
  %__UNIQUE_ID___x132 = alloca i64, align 8
  %__UNIQUE_ID___y133 = alloca i64, align 8
  %tmp18 = alloca i64, align 8
  %__UNIQUE_ID___x134 = alloca i64, align 8
  %__UNIQUE_ID___y135 = alloca i64, align 8
  %tmp30 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x128, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %3 = load i64, i64* %value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 1
  %5 = load i64, i64* %mask, align 8
  %and = and i64 %5, -9223372036854775808
  %or = or i64 %3, %and
  store i64 %or, i64* %__UNIQUE_ID___y129, align 8
  %6 = load i64, i64* %__UNIQUE_ID___x128, align 8
  %7 = load i64, i64* %__UNIQUE_ID___y129, align 8
  %cmp = icmp sgt i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, i64* %__UNIQUE_ID___x128, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, i64* %__UNIQUE_ID___y129, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value2, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  store i64 %13, i64* %__UNIQUE_ID___x130, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %15 = load i64, i64* %value4, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  %17 = load i64, i64* %mask6, align 8
  %and7 = and i64 %17, 9223372036854775807
  %or8 = or i64 %15, %and7
  store i64 %or8, i64* %__UNIQUE_ID___y131, align 8
  %18 = load i64, i64* %__UNIQUE_ID___x130, align 8
  %19 = load i64, i64* %__UNIQUE_ID___y131, align 8
  %cmp10 = icmp slt i64 %18, %19
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %20 = load i64, i64* %__UNIQUE_ID___x130, align 8
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___y131, align 8
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i64 [ %20, %cond.true11 ], [ %21, %cond.false12 ]
  store i64 %cond14, i64* %tmp9, align 8
  %22 = load i64, i64* %tmp9, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 %22, i64* %smax_value15, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value, align 8
  store i64 %25, i64* %__UNIQUE_ID___x132, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 5
  %value17 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off16, i32 0, i32 0
  %27 = load i64, i64* %value17, align 8
  store i64 %27, i64* %__UNIQUE_ID___y133, align 8
  %28 = load i64, i64* %__UNIQUE_ID___x132, align 8
  %29 = load i64, i64* %__UNIQUE_ID___y133, align 8
  %cmp19 = icmp ugt i64 %28, %29
  br i1 %cmp19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end13
  %30 = load i64, i64* %__UNIQUE_ID___x132, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end13
  %31 = load i64, i64* %__UNIQUE_ID___y133, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %30, %cond.true20 ], [ %31, %cond.false21 ]
  store i64 %cond23, i64* %tmp18, align 8
  %32 = load i64, i64* %tmp18, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  store i64 %32, i64* %umin_value24, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value, align 8
  store i64 %35, i64* %__UNIQUE_ID___x134, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 5
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off25, i32 0, i32 0
  %37 = load i64, i64* %value26, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 5
  %mask28 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off27, i32 0, i32 1
  %39 = load i64, i64* %mask28, align 8
  %or29 = or i64 %37, %39
  store i64 %or29, i64* %__UNIQUE_ID___y135, align 8
  %40 = load i64, i64* %__UNIQUE_ID___x134, align 8
  %41 = load i64, i64* %__UNIQUE_ID___y135, align 8
  %cmp31 = icmp ult i64 %40, %41
  br i1 %cmp31, label %cond.true32, label %cond.false33

cond.true32:                                      ; preds = %cond.end22
  %42 = load i64, i64* %__UNIQUE_ID___x134, align 8
  br label %cond.end34

cond.false33:                                     ; preds = %cond.end22
  %43 = load i64, i64* %__UNIQUE_ID___y135, align 8
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false33, %cond.true32
  %cond35 = phi i64 [ %42, %cond.true32 ], [ %43, %cond.false33 ]
  store i64 %cond35, i64* %tmp30, align 8
  %44 = load i64, i64* %tmp30, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 9
  store i64 %44, i64* %umax_value36, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load i64, i64* %imm.addr, align 8
  %call = call { i64, i64 } @tnum_const(i64 noundef %1) #8
  %2 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.tnum* %var_off to i8*
  %8 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 16, i1 false)
  %9 = load i64, i64* %imm.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  store i64 %9, i64* %smin_value, align 8
  %11 = load i64, i64* %imm.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  store i64 %11, i64* %smax_value, align 8
  %13 = load i64, i64* %imm.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  store i64 %13, i64* %umin_value, align 8
  %15 = load i64, i64* %imm.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  store i64 %15, i64* %umax_value, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %3) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 0
  %3 = load i32, i32* %insn_idx, align 8
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  ret %struct.bpf_insn_aux_data* %arrayidx
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 14
  %1 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 8
  %cmp = icmp eq i32 %and, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %aux, i32 noundef %alu_state, i32 noundef %alu_limit) #0 {
entry:
  %retval = alloca i32, align 4
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %alu_state.addr = alloca i32, align 4
  %alu_limit.addr = alloca i32, align 4
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i32 %alu_state, i32* %alu_state.addr, align 4
  store i32 %alu_limit, i32* %alu_limit.addr, align 4
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 5
  %1 = load i8, i8* %alu_state1, align 2
  %conv = zext i8 %1 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state2 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %2, i32 0, i32 5
  %3 = load i8, i8* %alu_state2, align 2
  %conv3 = zext i8 %3 to i32
  %4 = load i32, i32* %alu_state.addr, align 4
  %cmp = icmp ne i32 %conv3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %5, i32 0, i32 0
  %alu_limit5 = bitcast %union.anon.13* %6 to i32*
  %7 = load i32, i32* %alu_limit5, align 8
  %8 = load i32, i32* %alu_limit.addr, align 4
  %cmp6 = icmp ne i32 %7, %8
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %9 = load i32, i32* %alu_state.addr, align 4
  %conv8 = trunc i32 %9 to i8
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i32 0, i32 5
  store i8 %conv8, i8* %alu_state9, align 2
  %11 = load i32, i32* %alu_limit.addr, align 4
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i32 0, i32 0
  %alu_limit10 = bitcast %union.anon.13* %13 to i32*
  store i32 %11, i32* %alu_limit10, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 29, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @push_stack___(%struct.bpf_reg_state* noundef %to, %struct.bpf_reg_state* noundef %from) #0 {
entry:
  %to.addr = alloca %struct.bpf_reg_state*, align 8
  %from.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %to, %struct.bpf_reg_state** %to.addr, align 8
  store %struct.bpf_reg_state* %from, %struct.bpf_reg_state** %from.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 %1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  store i64 %4, i64* %value3, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off4, i32 0, i32 1
  %7 = load i64, i64* %mask, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  store i64 %7, i64* %mask6, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 6
  %10 = load i64, i64* %smin_value, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value7, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  store i64 %13, i64* %smax_value8, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 8
  store i64 %16, i64* %umin_value9, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value10, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  %reg_lo = alloca %struct.bpf_reg_state, align 8
  %sval = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %0) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = bitcast %struct.bpf_reg_state* %reg_lo to i8*
  %4 = bitcast %struct.bpf_reg_state* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 104, i1 false)
  store %struct.bpf_reg_state* %reg_lo, %struct.bpf_reg_state** %reg.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %5, i32 noundef 4) #8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 8
  %9 = load i64, i64* %umin_value, align 8
  %xor = xor i64 %7, %9
  %and = and i64 %xor, 2147483648
  %tobool2 = icmp ne i64 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  store i64 -2147483648, i64* %smin_value, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  store i64 2147483647, i64* %smax_value, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.then1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value5, align 8
  %conv = trunc i64 %13 to i32
  %conv6 = sext i32 %conv to i64
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %conv6, i64* %smin_value7, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value8, align 8
  %conv9 = trunc i64 %16 to i32
  %conv10 = sext i32 %conv9 to i64
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 7
  store i64 %conv10, i64* %smax_value11, align 8
  %18 = load i64, i64* %val.addr, align 8
  %conv12 = trunc i64 %18 to i32
  %conv13 = zext i32 %conv12 to i64
  store i64 %conv13, i64* %val.addr, align 8
  %19 = load i64, i64* %val.addr, align 8
  %conv14 = trunc i64 %19 to i32
  %conv15 = sext i32 %conv14 to i64
  store i64 %conv15, i64* %sval, align 8
  br label %if.end16

if.else:                                          ; preds = %if.end
  %20 = load i64, i64* %val.addr, align 8
  store i64 %20, i64* %sval, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.end4
  %21 = load i8, i8* %opcode.addr, align 1
  %conv17 = zext i8 %21 to i32
  switch i32 %conv17, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb24
    i32 64, label %sw.bb33
    i32 32, label %sw.bb49
    i32 96, label %sw.bb60
    i32 160, label %sw.bb72
    i32 192, label %sw.bb84
    i32 48, label %sw.bb96
    i32 112, label %sw.bb108
    i32 176, label %sw.bb120
    i32 208, label %sw.bb132
  ]

sw.bb:                                            ; preds = %if.end16
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %23 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call18 = call zeroext i1 @tnum_is_const(i64 %25, i64 %27) #8
  br i1 %call18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %sw.bb
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %29 = load i64, i64* %val.addr, align 8
  %30 = bitcast %struct.tnum* %var_off20 to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call21 = call zeroext i1 @tnum_equals_const(i64 %32, i64 %34, i64 noundef %29) #8
  %lnot = xor i1 %call21, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %sw.bb
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end16
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off25 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call26 = call zeroext i1 @tnum_is_const(i64 %38, i64 %40) #8
  br i1 %call26, label %if.then27, label %if.end32

if.then27:                                        ; preds = %sw.bb24
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 5
  %42 = load i64, i64* %val.addr, align 8
  %43 = bitcast %struct.tnum* %var_off28 to { i64, i64 }*
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %43, i32 0, i32 0
  %45 = load i64, i64* %44, align 8
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %43, i32 0, i32 1
  %47 = load i64, i64* %46, align 8
  %call29 = call zeroext i1 @tnum_equals_const(i64 %45, i64 %47, i64 noundef %42) #8
  %lnot30 = xor i1 %call29, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  store i32 %lnot.ext31, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %sw.bb24
  br label %sw.epilog

sw.bb33:                                          ; preds = %if.end16
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off34, i32 0, i32 1
  %49 = load i64, i64* %mask, align 8
  %neg = xor i64 %49, -1
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off35, i32 0, i32 0
  %51 = load i64, i64* %value, align 8
  %and36 = and i64 %neg, %51
  %52 = load i64, i64* %val.addr, align 8
  %and37 = and i64 %and36, %52
  %tobool38 = icmp ne i64 %and37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %sw.bb33
  store i32 1, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %sw.bb33
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 5
  %mask42 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off41, i32 0, i32 1
  %54 = load i64, i64* %mask42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 5
  %value44 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off43, i32 0, i32 0
  %56 = load i64, i64* %value44, align 8
  %or = or i64 %54, %56
  %57 = load i64, i64* %val.addr, align 8
  %and45 = and i64 %or, %57
  %tobool46 = icmp ne i64 %and45, 0
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.end40
  store i32 0, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end40
  br label %sw.epilog

sw.bb49:                                          ; preds = %if.end16
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value50 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 8
  %59 = load i64, i64* %umin_value50, align 8
  %60 = load i64, i64* %val.addr, align 8
  %cmp = icmp ugt i64 %59, %60
  br i1 %cmp, label %if.then52, label %if.else53

if.then52:                                        ; preds = %sw.bb49
  store i32 1, i32* %retval, align 4
  br label %return

if.else53:                                        ; preds = %sw.bb49
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 9
  %62 = load i64, i64* %umax_value54, align 8
  %63 = load i64, i64* %val.addr, align 8
  %cmp55 = icmp ule i64 %62, %63
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else53
  store i32 0, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %if.else53
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  br label %sw.epilog

sw.bb60:                                          ; preds = %if.end16
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 6
  %65 = load i64, i64* %smin_value61, align 8
  %66 = load i64, i64* %sval, align 8
  %cmp62 = icmp sgt i64 %65, %66
  br i1 %cmp62, label %if.then64, label %if.else65

if.then64:                                        ; preds = %sw.bb60
  store i32 1, i32* %retval, align 4
  br label %return

if.else65:                                        ; preds = %sw.bb60
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 7
  %68 = load i64, i64* %smax_value66, align 8
  %69 = load i64, i64* %sval, align 8
  %cmp67 = icmp slt i64 %68, %69
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.else65
  store i32 0, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.else65
  br label %if.end71

if.end71:                                         ; preds = %if.end70
  br label %sw.epilog

sw.bb72:                                          ; preds = %if.end16
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 9
  %71 = load i64, i64* %umax_value73, align 8
  %72 = load i64, i64* %val.addr, align 8
  %cmp74 = icmp ult i64 %71, %72
  br i1 %cmp74, label %if.then76, label %if.else77

if.then76:                                        ; preds = %sw.bb72
  store i32 1, i32* %retval, align 4
  br label %return

if.else77:                                        ; preds = %sw.bb72
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 8
  %74 = load i64, i64* %umin_value78, align 8
  %75 = load i64, i64* %val.addr, align 8
  %cmp79 = icmp uge i64 %74, %75
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.else77
  store i32 0, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.else77
  br label %if.end83

if.end83:                                         ; preds = %if.end82
  br label %sw.epilog

sw.bb84:                                          ; preds = %if.end16
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 7
  %77 = load i64, i64* %smax_value85, align 8
  %78 = load i64, i64* %sval, align 8
  %cmp86 = icmp slt i64 %77, %78
  br i1 %cmp86, label %if.then88, label %if.else89

if.then88:                                        ; preds = %sw.bb84
  store i32 1, i32* %retval, align 4
  br label %return

if.else89:                                        ; preds = %sw.bb84
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %79, i32 0, i32 6
  %80 = load i64, i64* %smin_value90, align 8
  %81 = load i64, i64* %sval, align 8
  %cmp91 = icmp sge i64 %80, %81
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.else89
  store i32 0, i32* %retval, align 4
  br label %return

if.end94:                                         ; preds = %if.else89
  br label %if.end95

if.end95:                                         ; preds = %if.end94
  br label %sw.epilog

sw.bb96:                                          ; preds = %if.end16
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 8
  %83 = load i64, i64* %umin_value97, align 8
  %84 = load i64, i64* %val.addr, align 8
  %cmp98 = icmp uge i64 %83, %84
  br i1 %cmp98, label %if.then100, label %if.else101

if.then100:                                       ; preds = %sw.bb96
  store i32 1, i32* %retval, align 4
  br label %return

if.else101:                                       ; preds = %sw.bb96
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 9
  %86 = load i64, i64* %umax_value102, align 8
  %87 = load i64, i64* %val.addr, align 8
  %cmp103 = icmp ult i64 %86, %87
  br i1 %cmp103, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.else101
  store i32 0, i32* %retval, align 4
  br label %return

if.end106:                                        ; preds = %if.else101
  br label %if.end107

if.end107:                                        ; preds = %if.end106
  br label %sw.epilog

sw.bb108:                                         ; preds = %if.end16
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 6
  %89 = load i64, i64* %smin_value109, align 8
  %90 = load i64, i64* %sval, align 8
  %cmp110 = icmp sge i64 %89, %90
  br i1 %cmp110, label %if.then112, label %if.else113

if.then112:                                       ; preds = %sw.bb108
  store i32 1, i32* %retval, align 4
  br label %return

if.else113:                                       ; preds = %sw.bb108
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value114 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %91, i32 0, i32 7
  %92 = load i64, i64* %smax_value114, align 8
  %93 = load i64, i64* %sval, align 8
  %cmp115 = icmp slt i64 %92, %93
  br i1 %cmp115, label %if.then117, label %if.end118

if.then117:                                       ; preds = %if.else113
  store i32 0, i32* %retval, align 4
  br label %return

if.end118:                                        ; preds = %if.else113
  br label %if.end119

if.end119:                                        ; preds = %if.end118
  br label %sw.epilog

sw.bb120:                                         ; preds = %if.end16
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 9
  %95 = load i64, i64* %umax_value121, align 8
  %96 = load i64, i64* %val.addr, align 8
  %cmp122 = icmp ule i64 %95, %96
  br i1 %cmp122, label %if.then124, label %if.else125

if.then124:                                       ; preds = %sw.bb120
  store i32 1, i32* %retval, align 4
  br label %return

if.else125:                                       ; preds = %sw.bb120
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 8
  %98 = load i64, i64* %umin_value126, align 8
  %99 = load i64, i64* %val.addr, align 8
  %cmp127 = icmp ugt i64 %98, %99
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.else125
  store i32 0, i32* %retval, align 4
  br label %return

if.end130:                                        ; preds = %if.else125
  br label %if.end131

if.end131:                                        ; preds = %if.end130
  br label %sw.epilog

sw.bb132:                                         ; preds = %if.end16
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value133 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %100, i32 0, i32 7
  %101 = load i64, i64* %smax_value133, align 8
  %102 = load i64, i64* %sval, align 8
  %cmp134 = icmp sle i64 %101, %102
  br i1 %cmp134, label %if.then136, label %if.else137

if.then136:                                       ; preds = %sw.bb132
  store i32 1, i32* %retval, align 4
  br label %return

if.else137:                                       ; preds = %sw.bb132
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 6
  %104 = load i64, i64* %smin_value138, align 8
  %105 = load i64, i64* %sval, align 8
  %cmp139 = icmp sgt i64 %104, %105
  br i1 %cmp139, label %if.then141, label %if.end142

if.then141:                                       ; preds = %if.else137
  store i32 0, i32* %retval, align 4
  br label %return

if.end142:                                        ; preds = %if.else137
  br label %if.end143

if.end143:                                        ; preds = %if.end142
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end143, %if.end131, %if.end119, %if.end107, %if.end95, %if.end83, %if.end71, %if.end59, %if.end48, %if.end32, %if.end23, %if.end16
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then141, %if.then136, %if.then129, %if.then124, %if.then117, %if.then112, %if.then105, %if.then100, %if.then93, %if.then88, %if.then81, %if.then76, %if.then69, %if.then64, %if.then57, %if.then52, %if.then47, %if.then39, %if.then27, %if.then19, %if.then
  %106 = load i32, i32* %retval, align 4
  ret i32 %106
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  %sval = alloca i64, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %old_v = alloca i64, align 8
  %hi_mask = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp32 = alloca %struct.tnum, align 8
  %agg.tmp34 = alloca %struct.tnum, align 8
  %false_umax = alloca i64, align 8
  %true_umin = alloca i64, align 8
  %__UNIQUE_ID___x169 = alloca i64, align 8
  %__UNIQUE_ID___y170 = alloca i64, align 8
  %tmp62 = alloca i64, align 8
  %__UNIQUE_ID___x171 = alloca i64, align 8
  %__UNIQUE_ID___y172 = alloca i64, align 8
  %tmp70 = alloca i64, align 8
  %false_smax = alloca i64, align 8
  %true_smin = alloca i64, align 8
  %__UNIQUE_ID___x173 = alloca i64, align 8
  %__UNIQUE_ID___y174 = alloca i64, align 8
  %tmp100 = alloca i64, align 8
  %__UNIQUE_ID___x175 = alloca i64, align 8
  %__UNIQUE_ID___y176 = alloca i64, align 8
  %tmp108 = alloca i64, align 8
  %false_umin = alloca i64, align 8
  %true_umax = alloca i64, align 8
  %__UNIQUE_ID___x177 = alloca i64, align 8
  %__UNIQUE_ID___y178 = alloca i64, align 8
  %tmp143 = alloca i64, align 8
  %__UNIQUE_ID___x179 = alloca i64, align 8
  %__UNIQUE_ID___y180 = alloca i64, align 8
  %tmp152 = alloca i64, align 8
  %false_smin = alloca i64, align 8
  %true_smax = alloca i64, align 8
  %__UNIQUE_ID___x181 = alloca i64, align 8
  %__UNIQUE_ID___y182 = alloca i64, align 8
  %tmp184 = alloca i64, align 8
  %__UNIQUE_ID___x183 = alloca i64, align 8
  %__UNIQUE_ID___y184 = alloca i64, align 8
  %tmp193 = alloca i64, align 8
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %0) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %2 = load i64, i64* %val.addr, align 8
  %conv = trunc i64 %2 to i32
  %conv1 = zext i32 %conv to i64
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %3 = load i64, i64* %val.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %conv1, %cond.true ], [ %3, %cond.false ]
  store i64 %cond, i64* %val.addr, align 8
  %4 = load i8, i8* %is_jmp32.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %cond.true4, label %cond.false7

cond.true4:                                       ; preds = %cond.end
  %5 = load i64, i64* %val.addr, align 8
  %conv5 = trunc i64 %5 to i32
  %conv6 = sext i32 %conv5 to i64
  br label %cond.end8

cond.false7:                                      ; preds = %cond.end
  %6 = load i64, i64* %val.addr, align 8
  br label %cond.end8

cond.end8:                                        ; preds = %cond.false7, %cond.true4
  %cond9 = phi i64 [ %conv6, %cond.true4 ], [ %6, %cond.false7 ]
  store i64 %cond9, i64* %sval, align 8
  %7 = load i8, i8* %opcode.addr, align 1
  %conv10 = zext i8 %7 to i32
  switch i32 %conv10, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb
    i32 64, label %sw.bb24
    i32 48, label %sw.bb38
    i32 32, label %sw.bb38
    i32 112, label %sw.bb78
    i32 96, label %sw.bb78
    i32 176, label %sw.bb116
    i32 160, label %sw.bb116
    i32 208, label %sw.bb160
    i32 192, label %sw.bb160
  ]

sw.bb:                                            ; preds = %cond.end8, %cond.end8
  %8 = load i8, i8* %opcode.addr, align 1
  %conv11 = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv11, 16
  br i1 %cmp, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %sw.bb
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %sw.bb
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi %struct.bpf_reg_state* [ %9, %cond.true13 ], [ %10, %cond.false14 ]
  store %struct.bpf_reg_state* %cond16, %struct.bpf_reg_state** %reg, align 8
  %11 = load i8, i8* %is_jmp32.addr, align 1
  %tobool17 = trunc i8 %11 to i1
  br i1 %tobool17, label %if.then18, label %if.else

if.then18:                                        ; preds = %cond.end15
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %13 = load i64, i64* %value, align 8
  store i64 %13, i64* %old_v, align 8
  store i64 -4294967296, i64* %hi_mask, align 8
  %14 = load i64, i64* %old_v, align 8
  %15 = load i64, i64* %hi_mask, align 8
  %and = and i64 %14, %15
  %16 = load i64, i64* %val.addr, align 8
  %or = or i64 %and, %16
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %value20 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 0
  store i64 %or, i64* %value20, align 8
  %18 = load i64, i64* %hi_mask, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off21, i32 0, i32 1
  %20 = load i64, i64* %mask, align 8
  %and22 = and i64 %20, %18
  store i64 %and22, i64* %mask, align 8
  br label %if.end23

if.else:                                          ; preds = %cond.end15
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %22 = load i64, i64* %val.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %21, i64 noundef %22) #8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then18
  br label %sw.epilog

sw.bb24:                                          ; preds = %cond.end8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 5
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %25 = load i64, i64* %val.addr, align 8
  %neg = xor i64 %25, -1
  %call27 = call { i64, i64 } @tnum_const(i64 noundef %neg) #8
  %26 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = extractvalue { i64, i64 } %call27, 0
  store i64 %28, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = extractvalue { i64, i64 } %call27, 1
  store i64 %30, i64* %29, align 8
  %31 = bitcast %struct.tnum* %var_off26 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %36 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call28 = call { i64, i64 } @tnum_and(i64 %33, i64 %35, i64 %38, i64 %40) #8
  %41 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call28, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call28, 1
  store i64 %45, i64* %44, align 8
  %46 = bitcast %struct.tnum* %var_off25 to i8*
  %47 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %46, i8* align 8 %47, i64 16, i1 false)
  %48 = load i64, i64* %val.addr, align 8
  %call29 = call zeroext i1 @is_power_of_2(i64 noundef %48) #11
  br i1 %call29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %sw.bb24
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 5
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = load i64, i64* %val.addr, align 8
  %call35 = call { i64, i64 } @tnum_const(i64 noundef %51) #8
  %52 = bitcast %struct.tnum* %agg.tmp34 to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = extractvalue { i64, i64 } %call35, 0
  store i64 %54, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = extractvalue { i64, i64 } %call35, 1
  store i64 %56, i64* %55, align 8
  %57 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = load i64, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = load i64, i64* %60, align 8
  %62 = bitcast %struct.tnum* %agg.tmp34 to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call36 = call { i64, i64 } @tnum_or(i64 %59, i64 %61, i64 %64, i64 %66) #8
  %67 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = extractvalue { i64, i64 } %call36, 0
  store i64 %69, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = extractvalue { i64, i64 } %call36, 1
  store i64 %71, i64* %70, align 8
  %72 = bitcast %struct.tnum* %var_off31 to i8*
  %73 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %72, i8* align 8 %73, i64 16, i1 false)
  br label %if.end37

if.end37:                                         ; preds = %if.then30, %sw.bb24
  br label %sw.epilog

sw.bb38:                                          ; preds = %cond.end8, %cond.end8
  %74 = load i8, i8* %opcode.addr, align 1
  %conv39 = zext i8 %74 to i32
  %cmp40 = icmp eq i32 %conv39, 32
  br i1 %cmp40, label %cond.true42, label %cond.false43

cond.true42:                                      ; preds = %sw.bb38
  %75 = load i64, i64* %val.addr, align 8
  br label %cond.end44

cond.false43:                                     ; preds = %sw.bb38
  %76 = load i64, i64* %val.addr, align 8
  %sub = sub i64 %76, 1
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false43, %cond.true42
  %cond45 = phi i64 [ %75, %cond.true42 ], [ %sub, %cond.false43 ]
  store i64 %cond45, i64* %false_umax, align 8
  %77 = load i8, i8* %opcode.addr, align 1
  %conv46 = zext i8 %77 to i32
  %cmp47 = icmp eq i32 %conv46, 32
  br i1 %cmp47, label %cond.true49, label %cond.false50

cond.true49:                                      ; preds = %cond.end44
  %78 = load i64, i64* %val.addr, align 8
  %add = add i64 %78, 1
  br label %cond.end51

cond.false50:                                     ; preds = %cond.end44
  %79 = load i64, i64* %val.addr, align 8
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false50, %cond.true49
  %cond52 = phi i64 [ %add, %cond.true49 ], [ %79, %cond.false50 ]
  store i64 %cond52, i64* %true_umin, align 8
  %80 = load i8, i8* %is_jmp32.addr, align 1
  %tobool53 = trunc i8 %80 to i1
  br i1 %tobool53, label %if.then54, label %if.end61

if.then54:                                        ; preds = %cond.end51
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %82 = bitcast %struct.tnum* %var_off55 to { i64, i64 }*
  %83 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %82, i32 0, i32 0
  %84 = load i64, i64* %83, align 8
  %85 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %82, i32 0, i32 1
  %86 = load i64, i64* %85, align 8
  %call56 = call i64 @gen_hi_max(i64 %84, i64 %86) #8
  %87 = load i64, i64* %false_umax, align 8
  %add57 = add i64 %87, %call56
  store i64 %add57, i64* %false_umax, align 8
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 5
  %89 = bitcast %struct.tnum* %var_off58 to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = load i64, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = load i64, i64* %92, align 8
  %call59 = call i64 @gen_hi_min(i64 %91, i64 %93) #8
  %94 = load i64, i64* %true_umin, align 8
  %add60 = add i64 %94, %call59
  store i64 %add60, i64* %true_umin, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.then54, %cond.end51
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 9
  %96 = load i64, i64* %umax_value, align 8
  store i64 %96, i64* %__UNIQUE_ID___x169, align 8
  %97 = load i64, i64* %false_umax, align 8
  store i64 %97, i64* %__UNIQUE_ID___y170, align 8
  %98 = load i64, i64* %__UNIQUE_ID___x169, align 8
  %99 = load i64, i64* %__UNIQUE_ID___y170, align 8
  %cmp63 = icmp ult i64 %98, %99
  br i1 %cmp63, label %cond.true65, label %cond.false66

cond.true65:                                      ; preds = %if.end61
  %100 = load i64, i64* %__UNIQUE_ID___x169, align 8
  br label %cond.end67

cond.false66:                                     ; preds = %if.end61
  %101 = load i64, i64* %__UNIQUE_ID___y170, align 8
  br label %cond.end67

cond.end67:                                       ; preds = %cond.false66, %cond.true65
  %cond68 = phi i64 [ %100, %cond.true65 ], [ %101, %cond.false66 ]
  store i64 %cond68, i64* %tmp62, align 8
  %102 = load i64, i64* %tmp62, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 9
  store i64 %102, i64* %umax_value69, align 8
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 8
  %105 = load i64, i64* %umin_value, align 8
  store i64 %105, i64* %__UNIQUE_ID___x171, align 8
  %106 = load i64, i64* %true_umin, align 8
  store i64 %106, i64* %__UNIQUE_ID___y172, align 8
  %107 = load i64, i64* %__UNIQUE_ID___x171, align 8
  %108 = load i64, i64* %__UNIQUE_ID___y172, align 8
  %cmp71 = icmp ugt i64 %107, %108
  br i1 %cmp71, label %cond.true73, label %cond.false74

cond.true73:                                      ; preds = %cond.end67
  %109 = load i64, i64* %__UNIQUE_ID___x171, align 8
  br label %cond.end75

cond.false74:                                     ; preds = %cond.end67
  %110 = load i64, i64* %__UNIQUE_ID___y172, align 8
  br label %cond.end75

cond.end75:                                       ; preds = %cond.false74, %cond.true73
  %cond76 = phi i64 [ %109, %cond.true73 ], [ %110, %cond.false74 ]
  store i64 %cond76, i64* %tmp70, align 8
  %111 = load i64, i64* %tmp70, align 8
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 8
  store i64 %111, i64* %umin_value77, align 8
  br label %sw.epilog

sw.bb78:                                          ; preds = %cond.end8, %cond.end8
  %113 = load i8, i8* %opcode.addr, align 1
  %conv79 = zext i8 %113 to i32
  %cmp80 = icmp eq i32 %conv79, 96
  br i1 %cmp80, label %cond.true82, label %cond.false83

cond.true82:                                      ; preds = %sw.bb78
  %114 = load i64, i64* %sval, align 8
  br label %cond.end85

cond.false83:                                     ; preds = %sw.bb78
  %115 = load i64, i64* %sval, align 8
  %sub84 = sub i64 %115, 1
  br label %cond.end85

cond.end85:                                       ; preds = %cond.false83, %cond.true82
  %cond86 = phi i64 [ %114, %cond.true82 ], [ %sub84, %cond.false83 ]
  store i64 %cond86, i64* %false_smax, align 8
  %116 = load i8, i8* %opcode.addr, align 1
  %conv87 = zext i8 %116 to i32
  %cmp88 = icmp eq i32 %conv87, 96
  br i1 %cmp88, label %cond.true90, label %cond.false92

cond.true90:                                      ; preds = %cond.end85
  %117 = load i64, i64* %sval, align 8
  %add91 = add i64 %117, 1
  br label %cond.end93

cond.false92:                                     ; preds = %cond.end85
  %118 = load i64, i64* %sval, align 8
  br label %cond.end93

cond.end93:                                       ; preds = %cond.false92, %cond.true90
  %cond94 = phi i64 [ %add91, %cond.true90 ], [ %118, %cond.false92 ]
  store i64 %cond94, i64* %true_smin, align 8
  %119 = load i8, i8* %is_jmp32.addr, align 1
  %tobool95 = trunc i8 %119 to i1
  br i1 %tobool95, label %land.lhs.true, label %if.end99

land.lhs.true:                                    ; preds = %cond.end93
  %120 = load i64, i64* %sval, align 8
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call97 = call zeroext i1 @cmp_val_with_extended_s64(i64 noundef %120, %struct.bpf_reg_state* noundef %121) #8
  br i1 %call97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %land.lhs.true
  br label %sw.epilog

if.end99:                                         ; preds = %land.lhs.true, %cond.end93
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 7
  %123 = load i64, i64* %smax_value, align 8
  store i64 %123, i64* %__UNIQUE_ID___x173, align 8
  %124 = load i64, i64* %false_smax, align 8
  store i64 %124, i64* %__UNIQUE_ID___y174, align 8
  %125 = load i64, i64* %__UNIQUE_ID___x173, align 8
  %126 = load i64, i64* %__UNIQUE_ID___y174, align 8
  %cmp101 = icmp slt i64 %125, %126
  br i1 %cmp101, label %cond.true103, label %cond.false104

cond.true103:                                     ; preds = %if.end99
  %127 = load i64, i64* %__UNIQUE_ID___x173, align 8
  br label %cond.end105

cond.false104:                                    ; preds = %if.end99
  %128 = load i64, i64* %__UNIQUE_ID___y174, align 8
  br label %cond.end105

cond.end105:                                      ; preds = %cond.false104, %cond.true103
  %cond106 = phi i64 [ %127, %cond.true103 ], [ %128, %cond.false104 ]
  store i64 %cond106, i64* %tmp100, align 8
  %129 = load i64, i64* %tmp100, align 8
  %130 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %130, i32 0, i32 7
  store i64 %129, i64* %smax_value107, align 8
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i32 0, i32 6
  %132 = load i64, i64* %smin_value, align 8
  store i64 %132, i64* %__UNIQUE_ID___x175, align 8
  %133 = load i64, i64* %true_smin, align 8
  store i64 %133, i64* %__UNIQUE_ID___y176, align 8
  %134 = load i64, i64* %__UNIQUE_ID___x175, align 8
  %135 = load i64, i64* %__UNIQUE_ID___y176, align 8
  %cmp109 = icmp sgt i64 %134, %135
  br i1 %cmp109, label %cond.true111, label %cond.false112

cond.true111:                                     ; preds = %cond.end105
  %136 = load i64, i64* %__UNIQUE_ID___x175, align 8
  br label %cond.end113

cond.false112:                                    ; preds = %cond.end105
  %137 = load i64, i64* %__UNIQUE_ID___y176, align 8
  br label %cond.end113

cond.end113:                                      ; preds = %cond.false112, %cond.true111
  %cond114 = phi i64 [ %136, %cond.true111 ], [ %137, %cond.false112 ]
  store i64 %cond114, i64* %tmp108, align 8
  %138 = load i64, i64* %tmp108, align 8
  %139 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %139, i32 0, i32 6
  store i64 %138, i64* %smin_value115, align 8
  br label %sw.epilog

sw.bb116:                                         ; preds = %cond.end8, %cond.end8
  %140 = load i8, i8* %opcode.addr, align 1
  %conv117 = zext i8 %140 to i32
  %cmp118 = icmp eq i32 %conv117, 160
  br i1 %cmp118, label %cond.true120, label %cond.false121

cond.true120:                                     ; preds = %sw.bb116
  %141 = load i64, i64* %val.addr, align 8
  br label %cond.end123

cond.false121:                                    ; preds = %sw.bb116
  %142 = load i64, i64* %val.addr, align 8
  %add122 = add i64 %142, 1
  br label %cond.end123

cond.end123:                                      ; preds = %cond.false121, %cond.true120
  %cond124 = phi i64 [ %141, %cond.true120 ], [ %add122, %cond.false121 ]
  store i64 %cond124, i64* %false_umin, align 8
  %143 = load i8, i8* %opcode.addr, align 1
  %conv125 = zext i8 %143 to i32
  %cmp126 = icmp eq i32 %conv125, 160
  br i1 %cmp126, label %cond.true128, label %cond.false130

cond.true128:                                     ; preds = %cond.end123
  %144 = load i64, i64* %val.addr, align 8
  %sub129 = sub i64 %144, 1
  br label %cond.end131

cond.false130:                                    ; preds = %cond.end123
  %145 = load i64, i64* %val.addr, align 8
  br label %cond.end131

cond.end131:                                      ; preds = %cond.false130, %cond.true128
  %cond132 = phi i64 [ %sub129, %cond.true128 ], [ %145, %cond.false130 ]
  store i64 %cond132, i64* %true_umax, align 8
  %146 = load i8, i8* %is_jmp32.addr, align 1
  %tobool133 = trunc i8 %146 to i1
  br i1 %tobool133, label %if.then134, label %if.end141

if.then134:                                       ; preds = %cond.end131
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 5
  %148 = bitcast %struct.tnum* %var_off135 to { i64, i64 }*
  %149 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %148, i32 0, i32 0
  %150 = load i64, i64* %149, align 8
  %151 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %148, i32 0, i32 1
  %152 = load i64, i64* %151, align 8
  %call136 = call i64 @gen_hi_min(i64 %150, i64 %152) #8
  %153 = load i64, i64* %false_umin, align 8
  %add137 = add i64 %153, %call136
  store i64 %add137, i64* %false_umin, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 5
  %155 = bitcast %struct.tnum* %var_off138 to { i64, i64 }*
  %156 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %155, i32 0, i32 0
  %157 = load i64, i64* %156, align 8
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %155, i32 0, i32 1
  %159 = load i64, i64* %158, align 8
  %call139 = call i64 @gen_hi_max(i64 %157, i64 %159) #8
  %160 = load i64, i64* %true_umax, align 8
  %add140 = add i64 %160, %call139
  store i64 %add140, i64* %true_umax, align 8
  br label %if.end141

if.end141:                                        ; preds = %if.then134, %cond.end131
  %161 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value142 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %161, i32 0, i32 8
  %162 = load i64, i64* %umin_value142, align 8
  store i64 %162, i64* %__UNIQUE_ID___x177, align 8
  %163 = load i64, i64* %false_umin, align 8
  store i64 %163, i64* %__UNIQUE_ID___y178, align 8
  %164 = load i64, i64* %__UNIQUE_ID___x177, align 8
  %165 = load i64, i64* %__UNIQUE_ID___y178, align 8
  %cmp144 = icmp ugt i64 %164, %165
  br i1 %cmp144, label %cond.true146, label %cond.false147

cond.true146:                                     ; preds = %if.end141
  %166 = load i64, i64* %__UNIQUE_ID___x177, align 8
  br label %cond.end148

cond.false147:                                    ; preds = %if.end141
  %167 = load i64, i64* %__UNIQUE_ID___y178, align 8
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false147, %cond.true146
  %cond149 = phi i64 [ %166, %cond.true146 ], [ %167, %cond.false147 ]
  store i64 %cond149, i64* %tmp143, align 8
  %168 = load i64, i64* %tmp143, align 8
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %169, i32 0, i32 8
  store i64 %168, i64* %umin_value150, align 8
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %170, i32 0, i32 9
  %171 = load i64, i64* %umax_value151, align 8
  store i64 %171, i64* %__UNIQUE_ID___x179, align 8
  %172 = load i64, i64* %true_umax, align 8
  store i64 %172, i64* %__UNIQUE_ID___y180, align 8
  %173 = load i64, i64* %__UNIQUE_ID___x179, align 8
  %174 = load i64, i64* %__UNIQUE_ID___y180, align 8
  %cmp153 = icmp ult i64 %173, %174
  br i1 %cmp153, label %cond.true155, label %cond.false156

cond.true155:                                     ; preds = %cond.end148
  %175 = load i64, i64* %__UNIQUE_ID___x179, align 8
  br label %cond.end157

cond.false156:                                    ; preds = %cond.end148
  %176 = load i64, i64* %__UNIQUE_ID___y180, align 8
  br label %cond.end157

cond.end157:                                      ; preds = %cond.false156, %cond.true155
  %cond158 = phi i64 [ %175, %cond.true155 ], [ %176, %cond.false156 ]
  store i64 %cond158, i64* %tmp152, align 8
  %177 = load i64, i64* %tmp152, align 8
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value159 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 9
  store i64 %177, i64* %umax_value159, align 8
  br label %sw.epilog

sw.bb160:                                         ; preds = %cond.end8, %cond.end8
  %179 = load i8, i8* %opcode.addr, align 1
  %conv161 = zext i8 %179 to i32
  %cmp162 = icmp eq i32 %conv161, 192
  br i1 %cmp162, label %cond.true164, label %cond.false165

cond.true164:                                     ; preds = %sw.bb160
  %180 = load i64, i64* %sval, align 8
  br label %cond.end167

cond.false165:                                    ; preds = %sw.bb160
  %181 = load i64, i64* %sval, align 8
  %add166 = add i64 %181, 1
  br label %cond.end167

cond.end167:                                      ; preds = %cond.false165, %cond.true164
  %cond168 = phi i64 [ %180, %cond.true164 ], [ %add166, %cond.false165 ]
  store i64 %cond168, i64* %false_smin, align 8
  %182 = load i8, i8* %opcode.addr, align 1
  %conv169 = zext i8 %182 to i32
  %cmp170 = icmp eq i32 %conv169, 192
  br i1 %cmp170, label %cond.true172, label %cond.false174

cond.true172:                                     ; preds = %cond.end167
  %183 = load i64, i64* %sval, align 8
  %sub173 = sub i64 %183, 1
  br label %cond.end175

cond.false174:                                    ; preds = %cond.end167
  %184 = load i64, i64* %sval, align 8
  br label %cond.end175

cond.end175:                                      ; preds = %cond.false174, %cond.true172
  %cond176 = phi i64 [ %sub173, %cond.true172 ], [ %184, %cond.false174 ]
  store i64 %cond176, i64* %true_smax, align 8
  %185 = load i8, i8* %is_jmp32.addr, align 1
  %tobool177 = trunc i8 %185 to i1
  br i1 %tobool177, label %land.lhs.true179, label %if.end182

land.lhs.true179:                                 ; preds = %cond.end175
  %186 = load i64, i64* %sval, align 8
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call180 = call zeroext i1 @cmp_val_with_extended_s64(i64 noundef %186, %struct.bpf_reg_state* noundef %187) #8
  br i1 %call180, label %if.end182, label %if.then181

if.then181:                                       ; preds = %land.lhs.true179
  br label %sw.epilog

if.end182:                                        ; preds = %land.lhs.true179, %cond.end175
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value183 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i32 0, i32 6
  %189 = load i64, i64* %smin_value183, align 8
  store i64 %189, i64* %__UNIQUE_ID___x181, align 8
  %190 = load i64, i64* %false_smin, align 8
  store i64 %190, i64* %__UNIQUE_ID___y182, align 8
  %191 = load i64, i64* %__UNIQUE_ID___x181, align 8
  %192 = load i64, i64* %__UNIQUE_ID___y182, align 8
  %cmp185 = icmp sgt i64 %191, %192
  br i1 %cmp185, label %cond.true187, label %cond.false188

cond.true187:                                     ; preds = %if.end182
  %193 = load i64, i64* %__UNIQUE_ID___x181, align 8
  br label %cond.end189

cond.false188:                                    ; preds = %if.end182
  %194 = load i64, i64* %__UNIQUE_ID___y182, align 8
  br label %cond.end189

cond.end189:                                      ; preds = %cond.false188, %cond.true187
  %cond190 = phi i64 [ %193, %cond.true187 ], [ %194, %cond.false188 ]
  store i64 %cond190, i64* %tmp184, align 8
  %195 = load i64, i64* %tmp184, align 8
  %196 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %196, i32 0, i32 6
  store i64 %195, i64* %smin_value191, align 8
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %197, i32 0, i32 7
  %198 = load i64, i64* %smax_value192, align 8
  store i64 %198, i64* %__UNIQUE_ID___x183, align 8
  %199 = load i64, i64* %true_smax, align 8
  store i64 %199, i64* %__UNIQUE_ID___y184, align 8
  %200 = load i64, i64* %__UNIQUE_ID___x183, align 8
  %201 = load i64, i64* %__UNIQUE_ID___y184, align 8
  %cmp194 = icmp slt i64 %200, %201
  br i1 %cmp194, label %cond.true196, label %cond.false197

cond.true196:                                     ; preds = %cond.end189
  %202 = load i64, i64* %__UNIQUE_ID___x183, align 8
  br label %cond.end198

cond.false197:                                    ; preds = %cond.end189
  %203 = load i64, i64* %__UNIQUE_ID___y184, align 8
  br label %cond.end198

cond.end198:                                      ; preds = %cond.false197, %cond.true196
  %cond199 = phi i64 [ %202, %cond.true196 ], [ %203, %cond.false197 ]
  store i64 %cond199, i64* %tmp193, align 8
  %204 = load i64, i64* %tmp193, align 8
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %205, i32 0, i32 7
  store i64 %204, i64* %smax_value200, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %cond.end198, %if.then181, %cond.end157, %cond.end113, %if.then98, %cond.end75, %if.end37, %if.end23
  %206 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %206) #8
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %207) #8
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %208) #8
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %209) #8
  %210 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %210) #8
  %211 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %211) #8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  %sval = alloca i64, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %old_v = alloca i64, align 8
  %hi_mask = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp32 = alloca %struct.tnum, align 8
  %agg.tmp34 = alloca %struct.tnum, align 8
  %false_umin = alloca i64, align 8
  %true_umax = alloca i64, align 8
  %__UNIQUE_ID___x185 = alloca i64, align 8
  %__UNIQUE_ID___y186 = alloca i64, align 8
  %tmp62 = alloca i64, align 8
  %__UNIQUE_ID___x187 = alloca i64, align 8
  %__UNIQUE_ID___y188 = alloca i64, align 8
  %tmp70 = alloca i64, align 8
  %false_smin = alloca i64, align 8
  %true_smax = alloca i64, align 8
  %__UNIQUE_ID___x189 = alloca i64, align 8
  %__UNIQUE_ID___y190 = alloca i64, align 8
  %tmp100 = alloca i64, align 8
  %__UNIQUE_ID___x191 = alloca i64, align 8
  %__UNIQUE_ID___y192 = alloca i64, align 8
  %tmp108 = alloca i64, align 8
  %false_umax = alloca i64, align 8
  %true_umin = alloca i64, align 8
  %__UNIQUE_ID___x193 = alloca i64, align 8
  %__UNIQUE_ID___y194 = alloca i64, align 8
  %tmp143 = alloca i64, align 8
  %__UNIQUE_ID___x195 = alloca i64, align 8
  %__UNIQUE_ID___y196 = alloca i64, align 8
  %tmp152 = alloca i64, align 8
  %false_smax = alloca i64, align 8
  %true_smin = alloca i64, align 8
  %__UNIQUE_ID___x197 = alloca i64, align 8
  %__UNIQUE_ID___y198 = alloca i64, align 8
  %tmp184 = alloca i64, align 8
  %__UNIQUE_ID___x199 = alloca i64, align 8
  %__UNIQUE_ID___y200 = alloca i64, align 8
  %tmp193 = alloca i64, align 8
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %0) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %2 = load i64, i64* %val.addr, align 8
  %conv = trunc i64 %2 to i32
  %conv1 = zext i32 %conv to i64
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %3 = load i64, i64* %val.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %conv1, %cond.true ], [ %3, %cond.false ]
  store i64 %cond, i64* %val.addr, align 8
  %4 = load i8, i8* %is_jmp32.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %cond.true4, label %cond.false7

cond.true4:                                       ; preds = %cond.end
  %5 = load i64, i64* %val.addr, align 8
  %conv5 = trunc i64 %5 to i32
  %conv6 = sext i32 %conv5 to i64
  br label %cond.end8

cond.false7:                                      ; preds = %cond.end
  %6 = load i64, i64* %val.addr, align 8
  br label %cond.end8

cond.end8:                                        ; preds = %cond.false7, %cond.true4
  %cond9 = phi i64 [ %conv6, %cond.true4 ], [ %6, %cond.false7 ]
  store i64 %cond9, i64* %sval, align 8
  %7 = load i8, i8* %opcode.addr, align 1
  %conv10 = zext i8 %7 to i32
  switch i32 %conv10, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb
    i32 64, label %sw.bb24
    i32 48, label %sw.bb38
    i32 32, label %sw.bb38
    i32 112, label %sw.bb78
    i32 96, label %sw.bb78
    i32 176, label %sw.bb116
    i32 160, label %sw.bb116
    i32 208, label %sw.bb160
    i32 192, label %sw.bb160
  ]

sw.bb:                                            ; preds = %cond.end8, %cond.end8
  %8 = load i8, i8* %opcode.addr, align 1
  %conv11 = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv11, 16
  br i1 %cmp, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %sw.bb
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %sw.bb
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi %struct.bpf_reg_state* [ %9, %cond.true13 ], [ %10, %cond.false14 ]
  store %struct.bpf_reg_state* %cond16, %struct.bpf_reg_state** %reg, align 8
  %11 = load i8, i8* %is_jmp32.addr, align 1
  %tobool17 = trunc i8 %11 to i1
  br i1 %tobool17, label %if.then18, label %if.else

if.then18:                                        ; preds = %cond.end15
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %13 = load i64, i64* %value, align 8
  store i64 %13, i64* %old_v, align 8
  store i64 -4294967296, i64* %hi_mask, align 8
  %14 = load i64, i64* %old_v, align 8
  %15 = load i64, i64* %hi_mask, align 8
  %and = and i64 %14, %15
  %16 = load i64, i64* %val.addr, align 8
  %or = or i64 %and, %16
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %value20 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 0
  store i64 %or, i64* %value20, align 8
  %18 = load i64, i64* %hi_mask, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off21, i32 0, i32 1
  %20 = load i64, i64* %mask, align 8
  %and22 = and i64 %20, %18
  store i64 %and22, i64* %mask, align 8
  br label %if.end23

if.else:                                          ; preds = %cond.end15
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %22 = load i64, i64* %val.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %21, i64 noundef %22) #8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then18
  br label %sw.epilog

sw.bb24:                                          ; preds = %cond.end8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 5
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %25 = load i64, i64* %val.addr, align 8
  %neg = xor i64 %25, -1
  %call27 = call { i64, i64 } @tnum_const(i64 noundef %neg) #8
  %26 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = extractvalue { i64, i64 } %call27, 0
  store i64 %28, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = extractvalue { i64, i64 } %call27, 1
  store i64 %30, i64* %29, align 8
  %31 = bitcast %struct.tnum* %var_off26 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %36 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call28 = call { i64, i64 } @tnum_and(i64 %33, i64 %35, i64 %38, i64 %40) #8
  %41 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call28, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call28, 1
  store i64 %45, i64* %44, align 8
  %46 = bitcast %struct.tnum* %var_off25 to i8*
  %47 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %46, i8* align 8 %47, i64 16, i1 false)
  %48 = load i64, i64* %val.addr, align 8
  %call29 = call zeroext i1 @is_power_of_2(i64 noundef %48) #11
  br i1 %call29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %sw.bb24
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 5
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = load i64, i64* %val.addr, align 8
  %call35 = call { i64, i64 } @tnum_const(i64 noundef %51) #8
  %52 = bitcast %struct.tnum* %agg.tmp34 to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = extractvalue { i64, i64 } %call35, 0
  store i64 %54, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = extractvalue { i64, i64 } %call35, 1
  store i64 %56, i64* %55, align 8
  %57 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = load i64, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = load i64, i64* %60, align 8
  %62 = bitcast %struct.tnum* %agg.tmp34 to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call36 = call { i64, i64 } @tnum_or(i64 %59, i64 %61, i64 %64, i64 %66) #8
  %67 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = extractvalue { i64, i64 } %call36, 0
  store i64 %69, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = extractvalue { i64, i64 } %call36, 1
  store i64 %71, i64* %70, align 8
  %72 = bitcast %struct.tnum* %var_off31 to i8*
  %73 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %72, i8* align 8 %73, i64 16, i1 false)
  br label %if.end37

if.end37:                                         ; preds = %if.then30, %sw.bb24
  br label %sw.epilog

sw.bb38:                                          ; preds = %cond.end8, %cond.end8
  %74 = load i8, i8* %opcode.addr, align 1
  %conv39 = zext i8 %74 to i32
  %cmp40 = icmp eq i32 %conv39, 32
  br i1 %cmp40, label %cond.true42, label %cond.false43

cond.true42:                                      ; preds = %sw.bb38
  %75 = load i64, i64* %val.addr, align 8
  br label %cond.end44

cond.false43:                                     ; preds = %sw.bb38
  %76 = load i64, i64* %val.addr, align 8
  %add = add i64 %76, 1
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false43, %cond.true42
  %cond45 = phi i64 [ %75, %cond.true42 ], [ %add, %cond.false43 ]
  store i64 %cond45, i64* %false_umin, align 8
  %77 = load i8, i8* %opcode.addr, align 1
  %conv46 = zext i8 %77 to i32
  %cmp47 = icmp eq i32 %conv46, 32
  br i1 %cmp47, label %cond.true49, label %cond.false50

cond.true49:                                      ; preds = %cond.end44
  %78 = load i64, i64* %val.addr, align 8
  %sub = sub i64 %78, 1
  br label %cond.end51

cond.false50:                                     ; preds = %cond.end44
  %79 = load i64, i64* %val.addr, align 8
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false50, %cond.true49
  %cond52 = phi i64 [ %sub, %cond.true49 ], [ %79, %cond.false50 ]
  store i64 %cond52, i64* %true_umax, align 8
  %80 = load i8, i8* %is_jmp32.addr, align 1
  %tobool53 = trunc i8 %80 to i1
  br i1 %tobool53, label %if.then54, label %if.end61

if.then54:                                        ; preds = %cond.end51
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %82 = bitcast %struct.tnum* %var_off55 to { i64, i64 }*
  %83 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %82, i32 0, i32 0
  %84 = load i64, i64* %83, align 8
  %85 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %82, i32 0, i32 1
  %86 = load i64, i64* %85, align 8
  %call56 = call i64 @gen_hi_min(i64 %84, i64 %86) #8
  %87 = load i64, i64* %false_umin, align 8
  %add57 = add i64 %87, %call56
  store i64 %add57, i64* %false_umin, align 8
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 5
  %89 = bitcast %struct.tnum* %var_off58 to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = load i64, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = load i64, i64* %92, align 8
  %call59 = call i64 @gen_hi_max(i64 %91, i64 %93) #8
  %94 = load i64, i64* %true_umax, align 8
  %add60 = add i64 %94, %call59
  store i64 %add60, i64* %true_umax, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.then54, %cond.end51
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 8
  %96 = load i64, i64* %umin_value, align 8
  store i64 %96, i64* %__UNIQUE_ID___x185, align 8
  %97 = load i64, i64* %false_umin, align 8
  store i64 %97, i64* %__UNIQUE_ID___y186, align 8
  %98 = load i64, i64* %__UNIQUE_ID___x185, align 8
  %99 = load i64, i64* %__UNIQUE_ID___y186, align 8
  %cmp63 = icmp ugt i64 %98, %99
  br i1 %cmp63, label %cond.true65, label %cond.false66

cond.true65:                                      ; preds = %if.end61
  %100 = load i64, i64* %__UNIQUE_ID___x185, align 8
  br label %cond.end67

cond.false66:                                     ; preds = %if.end61
  %101 = load i64, i64* %__UNIQUE_ID___y186, align 8
  br label %cond.end67

cond.end67:                                       ; preds = %cond.false66, %cond.true65
  %cond68 = phi i64 [ %100, %cond.true65 ], [ %101, %cond.false66 ]
  store i64 %cond68, i64* %tmp62, align 8
  %102 = load i64, i64* %tmp62, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 8
  store i64 %102, i64* %umin_value69, align 8
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 9
  %105 = load i64, i64* %umax_value, align 8
  store i64 %105, i64* %__UNIQUE_ID___x187, align 8
  %106 = load i64, i64* %true_umax, align 8
  store i64 %106, i64* %__UNIQUE_ID___y188, align 8
  %107 = load i64, i64* %__UNIQUE_ID___x187, align 8
  %108 = load i64, i64* %__UNIQUE_ID___y188, align 8
  %cmp71 = icmp ult i64 %107, %108
  br i1 %cmp71, label %cond.true73, label %cond.false74

cond.true73:                                      ; preds = %cond.end67
  %109 = load i64, i64* %__UNIQUE_ID___x187, align 8
  br label %cond.end75

cond.false74:                                     ; preds = %cond.end67
  %110 = load i64, i64* %__UNIQUE_ID___y188, align 8
  br label %cond.end75

cond.end75:                                       ; preds = %cond.false74, %cond.true73
  %cond76 = phi i64 [ %109, %cond.true73 ], [ %110, %cond.false74 ]
  store i64 %cond76, i64* %tmp70, align 8
  %111 = load i64, i64* %tmp70, align 8
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 9
  store i64 %111, i64* %umax_value77, align 8
  br label %sw.epilog

sw.bb78:                                          ; preds = %cond.end8, %cond.end8
  %113 = load i8, i8* %opcode.addr, align 1
  %conv79 = zext i8 %113 to i32
  %cmp80 = icmp eq i32 %conv79, 96
  br i1 %cmp80, label %cond.true82, label %cond.false83

cond.true82:                                      ; preds = %sw.bb78
  %114 = load i64, i64* %sval, align 8
  br label %cond.end85

cond.false83:                                     ; preds = %sw.bb78
  %115 = load i64, i64* %sval, align 8
  %add84 = add i64 %115, 1
  br label %cond.end85

cond.end85:                                       ; preds = %cond.false83, %cond.true82
  %cond86 = phi i64 [ %114, %cond.true82 ], [ %add84, %cond.false83 ]
  store i64 %cond86, i64* %false_smin, align 8
  %116 = load i8, i8* %opcode.addr, align 1
  %conv87 = zext i8 %116 to i32
  %cmp88 = icmp eq i32 %conv87, 96
  br i1 %cmp88, label %cond.true90, label %cond.false92

cond.true90:                                      ; preds = %cond.end85
  %117 = load i64, i64* %sval, align 8
  %sub91 = sub i64 %117, 1
  br label %cond.end93

cond.false92:                                     ; preds = %cond.end85
  %118 = load i64, i64* %sval, align 8
  br label %cond.end93

cond.end93:                                       ; preds = %cond.false92, %cond.true90
  %cond94 = phi i64 [ %sub91, %cond.true90 ], [ %118, %cond.false92 ]
  store i64 %cond94, i64* %true_smax, align 8
  %119 = load i8, i8* %is_jmp32.addr, align 1
  %tobool95 = trunc i8 %119 to i1
  br i1 %tobool95, label %land.lhs.true, label %if.end99

land.lhs.true:                                    ; preds = %cond.end93
  %120 = load i64, i64* %sval, align 8
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call97 = call zeroext i1 @cmp_val_with_extended_s64(i64 noundef %120, %struct.bpf_reg_state* noundef %121) #8
  br i1 %call97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %land.lhs.true
  br label %sw.epilog

if.end99:                                         ; preds = %land.lhs.true, %cond.end93
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 6
  %123 = load i64, i64* %smin_value, align 8
  store i64 %123, i64* %__UNIQUE_ID___x189, align 8
  %124 = load i64, i64* %false_smin, align 8
  store i64 %124, i64* %__UNIQUE_ID___y190, align 8
  %125 = load i64, i64* %__UNIQUE_ID___x189, align 8
  %126 = load i64, i64* %__UNIQUE_ID___y190, align 8
  %cmp101 = icmp sgt i64 %125, %126
  br i1 %cmp101, label %cond.true103, label %cond.false104

cond.true103:                                     ; preds = %if.end99
  %127 = load i64, i64* %__UNIQUE_ID___x189, align 8
  br label %cond.end105

cond.false104:                                    ; preds = %if.end99
  %128 = load i64, i64* %__UNIQUE_ID___y190, align 8
  br label %cond.end105

cond.end105:                                      ; preds = %cond.false104, %cond.true103
  %cond106 = phi i64 [ %127, %cond.true103 ], [ %128, %cond.false104 ]
  store i64 %cond106, i64* %tmp100, align 8
  %129 = load i64, i64* %tmp100, align 8
  %130 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %130, i32 0, i32 6
  store i64 %129, i64* %smin_value107, align 8
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i32 0, i32 7
  %132 = load i64, i64* %smax_value, align 8
  store i64 %132, i64* %__UNIQUE_ID___x191, align 8
  %133 = load i64, i64* %true_smax, align 8
  store i64 %133, i64* %__UNIQUE_ID___y192, align 8
  %134 = load i64, i64* %__UNIQUE_ID___x191, align 8
  %135 = load i64, i64* %__UNIQUE_ID___y192, align 8
  %cmp109 = icmp slt i64 %134, %135
  br i1 %cmp109, label %cond.true111, label %cond.false112

cond.true111:                                     ; preds = %cond.end105
  %136 = load i64, i64* %__UNIQUE_ID___x191, align 8
  br label %cond.end113

cond.false112:                                    ; preds = %cond.end105
  %137 = load i64, i64* %__UNIQUE_ID___y192, align 8
  br label %cond.end113

cond.end113:                                      ; preds = %cond.false112, %cond.true111
  %cond114 = phi i64 [ %136, %cond.true111 ], [ %137, %cond.false112 ]
  store i64 %cond114, i64* %tmp108, align 8
  %138 = load i64, i64* %tmp108, align 8
  %139 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %139, i32 0, i32 7
  store i64 %138, i64* %smax_value115, align 8
  br label %sw.epilog

sw.bb116:                                         ; preds = %cond.end8, %cond.end8
  %140 = load i8, i8* %opcode.addr, align 1
  %conv117 = zext i8 %140 to i32
  %cmp118 = icmp eq i32 %conv117, 160
  br i1 %cmp118, label %cond.true120, label %cond.false121

cond.true120:                                     ; preds = %sw.bb116
  %141 = load i64, i64* %val.addr, align 8
  br label %cond.end123

cond.false121:                                    ; preds = %sw.bb116
  %142 = load i64, i64* %val.addr, align 8
  %sub122 = sub i64 %142, 1
  br label %cond.end123

cond.end123:                                      ; preds = %cond.false121, %cond.true120
  %cond124 = phi i64 [ %141, %cond.true120 ], [ %sub122, %cond.false121 ]
  store i64 %cond124, i64* %false_umax, align 8
  %143 = load i8, i8* %opcode.addr, align 1
  %conv125 = zext i8 %143 to i32
  %cmp126 = icmp eq i32 %conv125, 160
  br i1 %cmp126, label %cond.true128, label %cond.false130

cond.true128:                                     ; preds = %cond.end123
  %144 = load i64, i64* %val.addr, align 8
  %add129 = add i64 %144, 1
  br label %cond.end131

cond.false130:                                    ; preds = %cond.end123
  %145 = load i64, i64* %val.addr, align 8
  br label %cond.end131

cond.end131:                                      ; preds = %cond.false130, %cond.true128
  %cond132 = phi i64 [ %add129, %cond.true128 ], [ %145, %cond.false130 ]
  store i64 %cond132, i64* %true_umin, align 8
  %146 = load i8, i8* %is_jmp32.addr, align 1
  %tobool133 = trunc i8 %146 to i1
  br i1 %tobool133, label %if.then134, label %if.end141

if.then134:                                       ; preds = %cond.end131
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 5
  %148 = bitcast %struct.tnum* %var_off135 to { i64, i64 }*
  %149 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %148, i32 0, i32 0
  %150 = load i64, i64* %149, align 8
  %151 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %148, i32 0, i32 1
  %152 = load i64, i64* %151, align 8
  %call136 = call i64 @gen_hi_max(i64 %150, i64 %152) #8
  %153 = load i64, i64* %false_umax, align 8
  %add137 = add i64 %153, %call136
  store i64 %add137, i64* %false_umax, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 5
  %155 = bitcast %struct.tnum* %var_off138 to { i64, i64 }*
  %156 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %155, i32 0, i32 0
  %157 = load i64, i64* %156, align 8
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %155, i32 0, i32 1
  %159 = load i64, i64* %158, align 8
  %call139 = call i64 @gen_hi_min(i64 %157, i64 %159) #8
  %160 = load i64, i64* %true_umin, align 8
  %add140 = add i64 %160, %call139
  store i64 %add140, i64* %true_umin, align 8
  br label %if.end141

if.end141:                                        ; preds = %if.then134, %cond.end131
  %161 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value142 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %161, i32 0, i32 9
  %162 = load i64, i64* %umax_value142, align 8
  store i64 %162, i64* %__UNIQUE_ID___x193, align 8
  %163 = load i64, i64* %false_umax, align 8
  store i64 %163, i64* %__UNIQUE_ID___y194, align 8
  %164 = load i64, i64* %__UNIQUE_ID___x193, align 8
  %165 = load i64, i64* %__UNIQUE_ID___y194, align 8
  %cmp144 = icmp ult i64 %164, %165
  br i1 %cmp144, label %cond.true146, label %cond.false147

cond.true146:                                     ; preds = %if.end141
  %166 = load i64, i64* %__UNIQUE_ID___x193, align 8
  br label %cond.end148

cond.false147:                                    ; preds = %if.end141
  %167 = load i64, i64* %__UNIQUE_ID___y194, align 8
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false147, %cond.true146
  %cond149 = phi i64 [ %166, %cond.true146 ], [ %167, %cond.false147 ]
  store i64 %cond149, i64* %tmp143, align 8
  %168 = load i64, i64* %tmp143, align 8
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %169, i32 0, i32 9
  store i64 %168, i64* %umax_value150, align 8
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %170, i32 0, i32 8
  %171 = load i64, i64* %umin_value151, align 8
  store i64 %171, i64* %__UNIQUE_ID___x195, align 8
  %172 = load i64, i64* %true_umin, align 8
  store i64 %172, i64* %__UNIQUE_ID___y196, align 8
  %173 = load i64, i64* %__UNIQUE_ID___x195, align 8
  %174 = load i64, i64* %__UNIQUE_ID___y196, align 8
  %cmp153 = icmp ugt i64 %173, %174
  br i1 %cmp153, label %cond.true155, label %cond.false156

cond.true155:                                     ; preds = %cond.end148
  %175 = load i64, i64* %__UNIQUE_ID___x195, align 8
  br label %cond.end157

cond.false156:                                    ; preds = %cond.end148
  %176 = load i64, i64* %__UNIQUE_ID___y196, align 8
  br label %cond.end157

cond.end157:                                      ; preds = %cond.false156, %cond.true155
  %cond158 = phi i64 [ %175, %cond.true155 ], [ %176, %cond.false156 ]
  store i64 %cond158, i64* %tmp152, align 8
  %177 = load i64, i64* %tmp152, align 8
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value159 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 8
  store i64 %177, i64* %umin_value159, align 8
  br label %sw.epilog

sw.bb160:                                         ; preds = %cond.end8, %cond.end8
  %179 = load i8, i8* %opcode.addr, align 1
  %conv161 = zext i8 %179 to i32
  %cmp162 = icmp eq i32 %conv161, 192
  br i1 %cmp162, label %cond.true164, label %cond.false165

cond.true164:                                     ; preds = %sw.bb160
  %180 = load i64, i64* %sval, align 8
  br label %cond.end167

cond.false165:                                    ; preds = %sw.bb160
  %181 = load i64, i64* %sval, align 8
  %sub166 = sub i64 %181, 1
  br label %cond.end167

cond.end167:                                      ; preds = %cond.false165, %cond.true164
  %cond168 = phi i64 [ %180, %cond.true164 ], [ %sub166, %cond.false165 ]
  store i64 %cond168, i64* %false_smax, align 8
  %182 = load i8, i8* %opcode.addr, align 1
  %conv169 = zext i8 %182 to i32
  %cmp170 = icmp eq i32 %conv169, 192
  br i1 %cmp170, label %cond.true172, label %cond.false174

cond.true172:                                     ; preds = %cond.end167
  %183 = load i64, i64* %sval, align 8
  %add173 = add i64 %183, 1
  br label %cond.end175

cond.false174:                                    ; preds = %cond.end167
  %184 = load i64, i64* %sval, align 8
  br label %cond.end175

cond.end175:                                      ; preds = %cond.false174, %cond.true172
  %cond176 = phi i64 [ %add173, %cond.true172 ], [ %184, %cond.false174 ]
  store i64 %cond176, i64* %true_smin, align 8
  %185 = load i8, i8* %is_jmp32.addr, align 1
  %tobool177 = trunc i8 %185 to i1
  br i1 %tobool177, label %land.lhs.true179, label %if.end182

land.lhs.true179:                                 ; preds = %cond.end175
  %186 = load i64, i64* %sval, align 8
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call180 = call zeroext i1 @cmp_val_with_extended_s64(i64 noundef %186, %struct.bpf_reg_state* noundef %187) #8
  br i1 %call180, label %if.end182, label %if.then181

if.then181:                                       ; preds = %land.lhs.true179
  br label %sw.epilog

if.end182:                                        ; preds = %land.lhs.true179, %cond.end175
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value183 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i32 0, i32 7
  %189 = load i64, i64* %smax_value183, align 8
  store i64 %189, i64* %__UNIQUE_ID___x197, align 8
  %190 = load i64, i64* %false_smax, align 8
  store i64 %190, i64* %__UNIQUE_ID___y198, align 8
  %191 = load i64, i64* %__UNIQUE_ID___x197, align 8
  %192 = load i64, i64* %__UNIQUE_ID___y198, align 8
  %cmp185 = icmp slt i64 %191, %192
  br i1 %cmp185, label %cond.true187, label %cond.false188

cond.true187:                                     ; preds = %if.end182
  %193 = load i64, i64* %__UNIQUE_ID___x197, align 8
  br label %cond.end189

cond.false188:                                    ; preds = %if.end182
  %194 = load i64, i64* %__UNIQUE_ID___y198, align 8
  br label %cond.end189

cond.end189:                                      ; preds = %cond.false188, %cond.true187
  %cond190 = phi i64 [ %193, %cond.true187 ], [ %194, %cond.false188 ]
  store i64 %cond190, i64* %tmp184, align 8
  %195 = load i64, i64* %tmp184, align 8
  %196 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %196, i32 0, i32 7
  store i64 %195, i64* %smax_value191, align 8
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %197, i32 0, i32 6
  %198 = load i64, i64* %smin_value192, align 8
  store i64 %198, i64* %__UNIQUE_ID___x199, align 8
  %199 = load i64, i64* %true_smin, align 8
  store i64 %199, i64* %__UNIQUE_ID___y200, align 8
  %200 = load i64, i64* %__UNIQUE_ID___x199, align 8
  %201 = load i64, i64* %__UNIQUE_ID___y200, align 8
  %cmp194 = icmp sgt i64 %200, %201
  br i1 %cmp194, label %cond.true196, label %cond.false197

cond.true196:                                     ; preds = %cond.end189
  %202 = load i64, i64* %__UNIQUE_ID___x199, align 8
  br label %cond.end198

cond.false197:                                    ; preds = %cond.end189
  %203 = load i64, i64* %__UNIQUE_ID___y200, align 8
  br label %cond.end198

cond.end198:                                      ; preds = %cond.false197, %cond.true196
  %cond199 = phi i64 [ %202, %cond.true196 ], [ %203, %cond.false197 ]
  store i64 %cond199, i64* %tmp193, align 8
  %204 = load i64, i64* %tmp193, align 8
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %205, i32 0, i32 6
  store i64 %204, i64* %smin_value200, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %cond.end198, %if.then181, %cond.end157, %cond.end113, %if.then98, %cond.end75, %if.end37, %if.end23
  %206 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %206) #8
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %207) #8
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %208) #8
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %209) #8
  %210 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %210) #8
  %211 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %211) #8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_combine_min_max(%struct.bpf_reg_state* noundef %true_src, %struct.bpf_reg_state* noundef %true_dst, %struct.bpf_reg_state* noundef %false_src, %struct.bpf_reg_state* noundef %false_dst, i8 noundef zeroext %opcode) #0 {
entry:
  %true_src.addr = alloca %struct.bpf_reg_state*, align 8
  %true_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %false_src.addr = alloca %struct.bpf_reg_state*, align 8
  %false_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %opcode.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_src, %struct.bpf_reg_state** %true_src.addr, align 8
  store %struct.bpf_reg_state* %true_dst, %struct.bpf_reg_state** %true_dst.addr, align 8
  store %struct.bpf_reg_state* %false_src, %struct.bpf_reg_state** %false_src.addr, align 8
  store %struct.bpf_reg_state* %false_dst, %struct.bpf_reg_state** %false_dst.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_src.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %1, %struct.bpf_reg_state* noundef %2) #8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_src.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef %4) #8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x201 = alloca i64, align 8
  %__UNIQUE_ID___y202 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x203 = alloca i64, align 8
  %__UNIQUE_ID___y204 = alloca i64, align 8
  %tmp5 = alloca i64, align 8
  %__UNIQUE_ID___x205 = alloca i64, align 8
  %__UNIQUE_ID___y206 = alloca i64, align 8
  %tmp14 = alloca i64, align 8
  %__UNIQUE_ID___x207 = alloca i64, align 8
  %__UNIQUE_ID___y208 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  %tmp32 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x201, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  store i64 %3, i64* %__UNIQUE_ID___y202, align 8
  %4 = load i64, i64* %__UNIQUE_ID___x201, align 8
  %5 = load i64, i64* %__UNIQUE_ID___y202, align 8
  %cmp = icmp ugt i64 %4, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___x201, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i64, i64* %__UNIQUE_ID___y202, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 8
  store i64 %8, i64* %umin_value2, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  store i64 %8, i64* %umin_value3, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value, align 8
  store i64 %12, i64* %__UNIQUE_ID___x203, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 9
  %14 = load i64, i64* %umax_value4, align 8
  store i64 %14, i64* %__UNIQUE_ID___y204, align 8
  %15 = load i64, i64* %__UNIQUE_ID___x203, align 8
  %16 = load i64, i64* %__UNIQUE_ID___y204, align 8
  %cmp6 = icmp ult i64 %15, %16
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %17 = load i64, i64* %__UNIQUE_ID___x203, align 8
  br label %cond.end9

cond.false8:                                      ; preds = %cond.end
  %18 = load i64, i64* %__UNIQUE_ID___y204, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true7
  %cond10 = phi i64 [ %17, %cond.true7 ], [ %18, %cond.false8 ]
  store i64 %cond10, i64* %tmp5, align 8
  %19 = load i64, i64* %tmp5, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value11, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 9
  store i64 %19, i64* %umax_value12, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value, align 8
  store i64 %23, i64* %__UNIQUE_ID___x205, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 6
  %25 = load i64, i64* %smin_value13, align 8
  store i64 %25, i64* %__UNIQUE_ID___y206, align 8
  %26 = load i64, i64* %__UNIQUE_ID___x205, align 8
  %27 = load i64, i64* %__UNIQUE_ID___y206, align 8
  %cmp15 = icmp sgt i64 %26, %27
  br i1 %cmp15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.end9
  %28 = load i64, i64* %__UNIQUE_ID___x205, align 8
  br label %cond.end18

cond.false17:                                     ; preds = %cond.end9
  %29 = load i64, i64* %__UNIQUE_ID___y206, align 8
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false17, %cond.true16
  %cond19 = phi i64 [ %28, %cond.true16 ], [ %29, %cond.false17 ]
  store i64 %cond19, i64* %tmp14, align 8
  %30 = load i64, i64* %tmp14, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 6
  store i64 %30, i64* %smin_value20, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %30, i64* %smin_value21, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 7
  %34 = load i64, i64* %smax_value, align 8
  store i64 %34, i64* %__UNIQUE_ID___x207, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  %36 = load i64, i64* %smax_value22, align 8
  store i64 %36, i64* %__UNIQUE_ID___y208, align 8
  %37 = load i64, i64* %__UNIQUE_ID___x207, align 8
  %38 = load i64, i64* %__UNIQUE_ID___y208, align 8
  %cmp24 = icmp slt i64 %37, %38
  br i1 %cmp24, label %cond.true25, label %cond.false26

cond.true25:                                      ; preds = %cond.end18
  %39 = load i64, i64* %__UNIQUE_ID___x207, align 8
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end18
  %40 = load i64, i64* %__UNIQUE_ID___y208, align 8
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true25
  %cond28 = phi i64 [ %39, %cond.true25 ], [ %40, %cond.false26 ]
  store i64 %cond28, i64* %tmp23, align 8
  %41 = load i64, i64* %tmp23, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 7
  store i64 %41, i64* %smax_value29, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %41, i64* %smax_value30, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 5
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 5
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 5
  %48 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = bitcast %struct.tnum* %var_off34 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call = call { i64, i64 } @tnum_intersect(i64 %50, i64 %52, i64 %55, i64 %57) #8
  %58 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 0
  %60 = extractvalue { i64, i64 } %call, 0
  store i64 %60, i64* %59, align 8
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 1
  %62 = extractvalue { i64, i64 } %call, 1
  store i64 %62, i64* %61, align 8
  %63 = bitcast %struct.tnum* %var_off31 to i8*
  %64 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %63, i8* align 8 %64, i64 16, i1 false)
  %65 = bitcast %struct.tnum* %var_off to i8*
  %66 = bitcast %struct.tnum* %var_off31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 %66, i64 16, i1 false)
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %67) #8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %68) #8
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %69) #8
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %70) #8
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %71) #8
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %72) #8
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %73) #8
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %74) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_pointer_value(i1 noundef zeroext %allow_ptr_leaks, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i1, align 1
  %allow_ptr_leaks.addr = alloca i8, align 1
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %frombool = zext i1 %allow_ptr_leaks to i8
  store i8 %frombool, i8* %allow_ptr_leaks.addr, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load i8, i8* %allow_ptr_leaks.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %2, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, i1* %retval, align 1
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal zeroext i1 @is_power_of_2(i64 noundef %n) #5 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %n.addr, align 8
  %2 = load i64, i64* %n.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %cmp1 = icmp eq i64 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @gen_hi_min(i64 %var.coerce0, i64 %var.coerce1) #0 {
entry:
  %var = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %var to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %var.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %var.coerce1, i64* %2, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var, i32 0, i32 0
  %3 = load i64, i64* %value, align 8
  %and = and i64 %3, -4294967296
  ret i64 %and
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @gen_hi_max(i64 %var.coerce0, i64 %var.coerce1) #0 {
entry:
  %var = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %var to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %var.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %var.coerce1, i64* %2, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var, i32 0, i32 0
  %3 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var, i32 0, i32 1
  %4 = load i64, i64* %mask, align 8
  %or = or i64 %3, %4
  %and = and i64 %or, -4294967296
  ret i64 %and
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @cmp_val_with_extended_s64(i64 noundef %sval, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %sval.addr = alloca i64, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store i64 %sval, i64* %sval.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load i64, i64* %sval.addr, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp sge i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 6
  %2 = load i64, i64* %smin_value, align 8
  %cmp2 = icmp sge i64 %2, 0
  br i1 %cmp2, label %land.lhs.true4, label %lor.rhs

land.lhs.true4:                                   ; preds = %land.lhs.true
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 7
  %4 = load i64, i64* %smax_value, align 8
  %cmp5 = icmp sle i64 %4, 2147483647
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %5 = load i64, i64* %sval.addr, align 8
  %conv7 = trunc i64 %5 to i32
  %cmp8 = icmp slt i32 %conv7, 0
  br i1 %cmp8, label %land.lhs.true10, label %land.end

land.lhs.true10:                                  ; preds = %lor.rhs
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  %7 = load i64, i64* %smax_value11, align 8
  %cmp12 = icmp sle i64 %7, 0
  br i1 %cmp12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true10
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value14, align 8
  %cmp15 = icmp sge i64 %9, -2147483648
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true10, %lor.rhs
  %10 = phi i1 [ false, %land.lhs.true10 ], [ false, %lor.rhs ], [ %cmp15, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true4
  %11 = phi i1 [ true, %land.lhs.true4 ], [ %10, %land.end ]
  ret i1 %11
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_equals_const(i64 %a.coerce0, i64 %a.coerce1, i64 noundef %b) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %b.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i64 %b, i64* %b.addr, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #8
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value, align 8
  %9 = load i64, i64* %b.addr, align 8
  %cmp = icmp eq i64 %8, %9
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %10 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 45, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 61, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 93, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -83, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -67, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 109, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 125, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -51, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -35, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 30, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 46, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 62, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 94, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -82, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -66, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 110, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 126, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -50, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -34, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %pred, align 4
  br label %if.end29

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call23 = call zeroext i1 @tnum_is_const(i64 %20, i64 %22) #8
  br i1 %call23, label %if.then25, label %if.end

if.then25:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off26, i32 0, i32 0
  %25 = load i64, i64* %value, align 8
  %26 = load i8, i8* %opcode, align 1
  %27 = load i8, i8* %is_jmp32, align 1
  %tobool27 = trunc i8 %27 to i1
  %call28 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %23, i64 noundef %25, i8 noundef zeroext %26, i1 noundef zeroext %tobool27) #8
  store i32 %call28, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then25, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end, %if.then
  %28 = load i32, i32* %pred, align 4
  %cmp30 = icmp eq i32 %28, 1
  br i1 %cmp30, label %if.then32, label %if.else33

if.then32:                                        ; preds = %if.end29
  br label %if.end117

if.else33:                                        ; preds = %if.end29
  %29 = load i32, i32* %pred, align 4
  %cmp34 = icmp eq i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else33
  br label %if.end117

if.end37:                                         ; preds = %if.else33
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code39, align 4
  %conv40 = zext i8 %30 to i32
  %and41 = and i32 %conv40, 8
  %cmp42 = icmp eq i32 %and41, 8
  br i1 %cmp42, label %if.then44, label %if.else108

if.then44:                                        ; preds = %if.end38
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %32 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %33 = bitcast %struct.bpf_reg_state* %31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %33, i64 104, i1 false)
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %35 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %36 = bitcast %struct.bpf_reg_state* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %37, i32 noundef 4) #8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %38, i32 noundef 4) #8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type45, align 8
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %land.lhs.true48, label %if.end107

land.lhs.true48:                                  ; preds = %if.then44
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %42, 1
  br i1 %cmp50, label %if.then52, label %if.end107

if.then52:                                        ; preds = %land.lhs.true48
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %44 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %46, i64 %48) #8
  br i1 %call54, label %if.then62, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then52
  %49 = load i8, i8* %is_jmp32, align 1
  %tobool56 = trunc i8 %49 to i1
  br i1 %tobool56, label %land.lhs.true58, label %if.else70

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off59 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call60 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call60, label %if.then62, label %if.else70

if.then62:                                        ; preds = %land.lhs.true58, %if.then52
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %58 = load i8, i8* %is_jmp32, align 1
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value66 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off65, i32 0, i32 0
  %60 = load i64, i64* %value66, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 5
  %value68 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off67, i32 0, i32 0
  %62 = load i64, i64* %value68, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %60, %cond.true ], [ %62, %cond.false ]
  %63 = load i8, i8* %opcode, align 1
  %64 = load i8, i8* %is_jmp32, align 1
  %tobool69 = trunc i8 %64 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57, i64 noundef %cond, i8 noundef zeroext %63, i1 noundef zeroext %tobool69) #8
  br label %if.end106

if.else70:                                        ; preds = %land.lhs.true58, %lor.lhs.false
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = load i64, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = load i64, i64* %69, align 8
  %call72 = call zeroext i1 @tnum_is_const(i64 %68, i64 %70) #8
  br i1 %call72, label %if.then81, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %if.else70
  %71 = load i8, i8* %is_jmp32, align 1
  %tobool75 = trunc i8 %71 to i1
  br i1 %tobool75, label %land.lhs.true77, label %if.else93

land.lhs.true77:                                  ; preds = %lor.lhs.false74
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 5
  %73 = bitcast %struct.tnum* %var_off78 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call79 = call zeroext i1 @tnum_is_const(i64 %75, i64 %77) #8
  br i1 %call79, label %if.then81, label %if.else93

if.then81:                                        ; preds = %land.lhs.true77, %if.else70
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %80 to i1
  br i1 %tobool82, label %cond.true84, label %cond.false87

cond.true84:                                      ; preds = %if.then81
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value86 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off85, i32 0, i32 0
  %82 = load i64, i64* %value86, align 8
  br label %cond.end90

cond.false87:                                     ; preds = %if.then81
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 5
  %value89 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off88, i32 0, i32 0
  %84 = load i64, i64* %value89, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false87, %cond.true84
  %cond91 = phi i64 [ %82, %cond.true84 ], [ %84, %cond.false87 ]
  %85 = load i8, i8* %opcode, align 1
  %86 = load i8, i8* %is_jmp32, align 1
  %tobool92 = trunc i8 %86 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %78, %struct.bpf_reg_state* noundef %79, i64 noundef %cond91, i8 noundef zeroext %85, i1 noundef zeroext %tobool92) #8
  br label %if.end105

if.else93:                                        ; preds = %land.lhs.true77, %lor.lhs.false74
  %87 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %87 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else93
  %88 = load i8, i8* %opcode, align 1
  %conv96 = zext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 16
  br i1 %cmp97, label %if.then103, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %land.lhs.true95
  %89 = load i8, i8* %opcode, align 1
  %conv100 = zext i8 %89 to i32
  %cmp101 = icmp eq i32 %conv100, 80
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.lhs.false99, %land.lhs.true95
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %94 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i8 noundef zeroext %94) #8
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %lor.lhs.false99, %if.else93
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %cond.end90
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %cond.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %land.lhs.true48, %if.then44
  br label %if.end117

if.else108:                                       ; preds = %if.end38
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %96, 1
  br i1 %cmp110, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.else108
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %99 = load i32, i32* %imm113, align 4
  %conv114 = sext i32 %99 to i64
  %100 = load i8, i8* %opcode, align 1
  %101 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %101 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98, i64 noundef %conv114, i8 noundef zeroext %100, i1 noundef zeroext %tobool115) #8
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.else108
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end107, %if.then36, %if.then32
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check(%struct.bpf_prog** noundef %prog, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval = alloca i32, align 4
  %prog.addr = alloca %struct.bpf_prog**, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %start_time = alloca i64, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %log = alloca %struct.bpf_verifier_log*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %ret = alloca i32, align 4
  %is_priv = alloca i8, align 1
  store %struct.bpf_prog** %prog, %struct.bpf_prog*** %prog.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  %call = call i64 @ktime_get_ns() #8
  store i64 %call, i64* %start_time, align 8
  store i32 -22, i32* %ret, align 4
  %call1 = call i8* @kzalloc(i64 noundef 4816, i32 noundef 3264) #8
  %0 = bitcast i8* %call1 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %0, %struct.bpf_verifier_env** %env, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %tobool = icmp ne %struct.bpf_verifier_env* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 18
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %3 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %3, align 8
  %len3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len3, align 4
  store i32 %5, i32* %len, align 4
  %6 = load i32, i32* %len, align 4
  %conv = sext i32 %6 to i64
  %call4 = call i64 @array_size(i64 noundef 24, i64 noundef %conv) #8
  %call5 = call i8* @vzalloc(i64 noundef %call4) #8
  %7 = bitcast i8* %call5 to %struct.bpf_insn_aux_data*
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 16
  store %struct.bpf_insn_aux_data* %7, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store i32 -12, i32* %ret, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 16
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data6, align 8
  %tobool7 = icmp ne %struct.bpf_insn_aux_data* %10, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %err_free_env

if.end9:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 16
  %15 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data11, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %15, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  store i32 %13, i32* %orig_idx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %18, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  store %struct.bpf_prog* %19, %struct.bpf_prog** %prog12, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 2
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %22, i32 0, i32 2
  %23 = load i32, i32* %type, align 4
  %idxprom14 = zext i32 %23 to i64
  %arrayidx15 = getelementptr [25 x %struct.bpf_verifier_ops*], [25 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom14
  %24 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx15, align 8
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 3
  store %struct.bpf_verifier_ops* %24, %struct.bpf_verifier_ops** %ops, align 8
  %call16 = call zeroext i1 @capable(i32 noundef 21) #8
  %frombool = zext i1 %call16 to i8
  store i8 %frombool, i8* %is_priv, align 1
  %26 = load i8, i8* %is_priv, align 1
  %tobool17 = trunc i8 %26 to i1
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %for.end
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #8
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %for.end
  %27 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %28 = bitcast %union.bpf_attr* %27 to %struct.anon.1*
  %log_level = getelementptr inbounds %struct.anon.1, %struct.anon.1* %28, i32 0, i32 4
  %29 = load i32, i32* %log_level, align 8
  %tobool20 = icmp ne i32 %29, 0
  br i1 %tobool20, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end19
  %30 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %31 = bitcast %union.bpf_attr* %30 to %struct.anon.1*
  %log_buf = getelementptr inbounds %struct.anon.1, %struct.anon.1* %31, i32 0, i32 6
  %32 = load i64, i64* %log_buf, align 8
  %tobool21 = icmp ne i64 %32, 0
  br i1 %tobool21, label %if.then24, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %lor.lhs.false
  %33 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %34 = bitcast %union.bpf_attr* %33 to %struct.anon.1*
  %log_size = getelementptr inbounds %struct.anon.1, %struct.anon.1* %34, i32 0, i32 5
  %35 = load i32, i32* %log_size, align 4
  %tobool23 = icmp ne i32 %35, 0
  br i1 %tobool23, label %if.then24, label %if.end46

if.then24:                                        ; preds = %lor.lhs.false22, %lor.lhs.false, %if.end19
  %36 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %37 = bitcast %union.bpf_attr* %36 to %struct.anon.1*
  %log_level25 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %37, i32 0, i32 4
  %38 = load i32, i32* %log_level25, align 8
  %39 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %39, i32 0, i32 0
  store i32 %38, i32* %level, align 8
  %40 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %41 = bitcast %union.bpf_attr* %40 to %struct.anon.1*
  %log_buf26 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %41, i32 0, i32 6
  %42 = load i64, i64* %log_buf26, align 8
  %43 = inttoptr i64 %42 to i8*
  %44 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %44, i32 0, i32 2
  store i8* %43, i8** %ubuf, align 8
  %45 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %46 = bitcast %union.bpf_attr* %45 to %struct.anon.1*
  %log_size27 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %46, i32 0, i32 5
  %47 = load i32, i32* %log_size27, align 4
  %48 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %48, i32 0, i32 4
  store i32 %47, i32* %len_total, align 4
  store i32 -22, i32* %ret, align 4
  %49 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total28 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %49, i32 0, i32 4
  %50 = load i32, i32* %len_total28, align 4
  %cmp29 = icmp ult i32 %50, 128
  br i1 %cmp29, label %if.then44, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %if.then24
  %51 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total32 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %51, i32 0, i32 4
  %52 = load i32, i32* %len_total32, align 4
  %cmp33 = icmp ugt i32 %52, 1073741823
  br i1 %cmp33, label %if.then44, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %lor.lhs.false31
  %53 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level36 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %53, i32 0, i32 0
  %54 = load i32, i32* %level36, align 8
  %tobool37 = icmp ne i32 %54, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then44

lor.lhs.false38:                                  ; preds = %lor.lhs.false35
  %55 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf39 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %55, i32 0, i32 2
  %56 = load i8*, i8** %ubuf39, align 8
  %tobool40 = icmp ne i8* %56, null
  br i1 %tobool40, label %lor.lhs.false41, label %if.then44

lor.lhs.false41:                                  ; preds = %lor.lhs.false38
  %57 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level42 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %57, i32 0, i32 0
  %58 = load i32, i32* %level42, align 8
  %and = and i32 %58, -8
  %tobool43 = icmp ne i32 %and, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %lor.lhs.false41, %lor.lhs.false38, %lor.lhs.false35, %lor.lhs.false31, %if.then24
  br label %err_unlock

if.end45:                                         ; preds = %lor.lhs.false41
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %lor.lhs.false22
  %59 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %60 = bitcast %union.bpf_attr* %59 to %struct.anon.1*
  %prog_flags = getelementptr inbounds %struct.anon.1, %struct.anon.1* %60, i32 0, i32 8
  %61 = load i32, i32* %prog_flags, align 4
  %and47 = and i32 %61, 1
  %tobool48 = icmp ne i32 %and47, 0
  %lnot = xor i1 %tobool48, true
  %lnot49 = xor i1 %lnot, true
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %62, i32 0, i32 6
  %frombool50 = zext i1 %lnot49 to i8
  store i8 %frombool50, i8* %strict_alignment, align 4
  %63 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %64 = bitcast %union.bpf_attr* %63 to %struct.anon.1*
  %prog_flags51 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %64, i32 0, i32 8
  %65 = load i32, i32* %prog_flags51, align 4
  %and52 = and i32 %65, 2
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.end46
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment55 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %66, i32 0, i32 6
  store i8 0, i8* %strict_alignment55, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %if.end46
  %67 = load i8, i8* %is_priv, align 1
  %tobool57 = trunc i8 %67 to i1
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %68, i32 0, i32 14
  %frombool58 = zext i1 %tobool57 to i8
  store i8 %frombool58, i8* %allow_ptr_leaks, align 8
  %69 = load i8, i8* %is_priv, align 1
  %tobool59 = trunc i8 %69 to i1
  br i1 %tobool59, label %if.then60, label %if.end65

if.then60:                                        ; preds = %if.end56
  %70 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %71 = bitcast %union.bpf_attr* %70 to %struct.anon.1*
  %prog_flags61 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %71, i32 0, i32 8
  %72 = load i32, i32* %prog_flags61, align 4
  %and62 = and i32 %72, 8
  %tobool63 = icmp ne i32 %and62, 0
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 7
  %frombool64 = zext i1 %tobool63 to i8
  store i8 %frombool64, i8* %test_state_freq, align 1
  br label %if.end65

if.end65:                                         ; preds = %if.then60, %if.end56
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call66 = call i32 @replace_map_fd_with_map_ptr(%struct.bpf_verifier_env* noundef %74) #8
  store i32 %call66, i32* %ret, align 4
  %75 = load i32, i32* %ret, align 4
  %cmp67 = icmp slt i32 %75, 0
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end65
  br label %skip_full_check

if.end70:                                         ; preds = %if.end65
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog71 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 2
  %77 = load %struct.bpf_prog*, %struct.bpf_prog** %prog71, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %77, i32 0, i32 7
  %78 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call72 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %78) #8
  br i1 %call72, label %if.then73, label %if.end79

if.then73:                                        ; preds = %if.end70
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog74 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 2
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %prog74, align 8
  %call75 = call i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef %80) #8
  store i32 %call75, i32* %ret, align 4
  %81 = load i32, i32* %ret, align 4
  %tobool76 = icmp ne i32 %81, 0
  br i1 %tobool76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.then73
  br label %skip_full_check

if.end78:                                         ; preds = %if.then73
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.end70
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call80 = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %82) #8
  %conv81 = zext i32 %call80 to i64
  %call82 = call i8* @kvcalloc(i64 noundef %conv81, i64 noundef 8, i32 noundef 1051840) #8
  %83 = bitcast i8* %call82 to %struct.bpf_verifier_state_list**
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %84, i32 0, i32 9
  store %struct.bpf_verifier_state_list** %83, %struct.bpf_verifier_state_list*** %explored_states, align 8
  store i32 -12, i32* %ret, align 4
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states83 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %85, i32 0, i32 9
  %86 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states83, align 8
  %tobool84 = icmp ne %struct.bpf_verifier_state_list** %86, null
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %if.end79
  br label %skip_full_check

if.end86:                                         ; preds = %if.end79
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call87 = call i32 @check_subprogs(%struct.bpf_verifier_env* noundef %87) #8
  store i32 %call87, i32* %ret, align 4
  %88 = load i32, i32* %ret, align 4
  %cmp88 = icmp slt i32 %88, 0
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.end86
  br label %skip_full_check

if.end91:                                         ; preds = %if.end86
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %90 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %91 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %call92 = call i32 @check_btf_info(%struct.bpf_verifier_env* noundef %89, %union.bpf_attr* noundef %90, %union.bpf_attr* noundef %91) #8
  store i32 %call92, i32* %ret, align 4
  %92 = load i32, i32* %ret, align 4
  %cmp93 = icmp slt i32 %92, 0
  br i1 %cmp93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.end91
  br label %skip_full_check

if.end96:                                         ; preds = %if.end91
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call97 = call i32 @check_cfg(%struct.bpf_verifier_env* noundef %93) #8
  store i32 %call97, i32* %ret, align 4
  %94 = load i32, i32* %ret, align 4
  %cmp98 = icmp slt i32 %94, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.end96
  br label %skip_full_check

if.end101:                                        ; preds = %if.end96
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call102 = call i32 @do_check(%struct.bpf_verifier_env* noundef %95) #8
  store i32 %call102, i32* %ret, align 4
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %96, i32 0, i32 8
  %97 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %tobool103 = icmp ne %struct.bpf_verifier_state* %97, null
  br i1 %tobool103, label %if.then104, label %if.end107

if.then104:                                       ; preds = %if.end101
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %cur_state105 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 8
  %99 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state105, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %99, i1 noundef zeroext true) #8
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %cur_state106 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %100, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state106, align 8
  br label %if.end107

if.end107:                                        ; preds = %if.then104, %if.end101
  %101 = load i32, i32* %ret, align 4
  %cmp108 = icmp eq i32 %101, 0
  br i1 %cmp108, label %land.lhs.true, label %if.end116

land.lhs.true:                                    ; preds = %if.end107
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog110 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %102, i32 0, i32 2
  %103 = load %struct.bpf_prog*, %struct.bpf_prog** %prog110, align 8
  %aux111 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %103, i32 0, i32 7
  %104 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux111, align 8
  %call112 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %104) #8
  br i1 %call112, label %if.then114, label %if.end116

if.then114:                                       ; preds = %land.lhs.true
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call115 = call i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef %105) #8
  store i32 %call115, i32* %ret, align 4
  br label %if.end116

if.end116:                                        ; preds = %if.then114, %land.lhs.true, %if.end107
  br label %skip_full_check

skip_full_check:                                  ; preds = %if.end116, %if.then100, %if.then95, %if.then90, %if.then85, %if.then77, %if.then69
  br label %while.cond

while.cond:                                       ; preds = %while.body, %skip_full_check
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call117 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %106, i32* noundef null, i32* noundef null) #8
  %tobool118 = icmp ne i32 %call117, 0
  %lnot119 = xor i1 %tobool118, true
  br i1 %lnot119, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @free_states(%struct.bpf_verifier_env* noundef %107) #8
  %108 = load i32, i32* %ret, align 4
  %cmp120 = icmp eq i32 %108, 0
  br i1 %cmp120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %while.end
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call123 = call i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %109) #8
  store i32 %call123, i32* %ret, align 4
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %while.end
  %110 = load i8, i8* %is_priv, align 1
  %tobool125 = trunc i8 %110 to i1
  br i1 %tobool125, label %if.then126, label %if.else

if.then126:                                       ; preds = %if.end124
  %111 = load i32, i32* %ret, align 4
  %cmp127 = icmp eq i32 %111, 0
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.then126
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %112) #8
  br label %if.end130

if.end130:                                        ; preds = %if.then129, %if.then126
  %113 = load i32, i32* %ret, align 4
  %cmp131 = icmp eq i32 %113, 0
  br i1 %cmp131, label %if.then133, label %if.end135

if.then133:                                       ; preds = %if.end130
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call134 = call i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %114) #8
  store i32 %call134, i32* %ret, align 4
  br label %if.end135

if.end135:                                        ; preds = %if.then133, %if.end130
  %115 = load i32, i32* %ret, align 4
  %cmp136 = icmp eq i32 %115, 0
  br i1 %cmp136, label %if.then138, label %if.end140

if.then138:                                       ; preds = %if.end135
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call139 = call i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %116) #8
  store i32 %call139, i32* %ret, align 4
  br label %if.end140

if.end140:                                        ; preds = %if.then138, %if.end135
  br label %if.end145

if.else:                                          ; preds = %if.end124
  %117 = load i32, i32* %ret, align 4
  %cmp141 = icmp eq i32 %117, 0
  br i1 %cmp141, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.else
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %118) #8
  br label %if.end144

if.end144:                                        ; preds = %if.then143, %if.else
  br label %if.end145

if.end145:                                        ; preds = %if.end144, %if.end140
  %119 = load i32, i32* %ret, align 4
  %cmp146 = icmp eq i32 %119, 0
  br i1 %cmp146, label %if.then148, label %if.end150

if.then148:                                       ; preds = %if.end145
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call149 = call i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %120) #8
  store i32 %call149, i32* %ret, align 4
  br label %if.end150

if.end150:                                        ; preds = %if.then148, %if.end145
  %121 = load i32, i32* %ret, align 4
  %cmp151 = icmp eq i32 %121, 0
  br i1 %cmp151, label %if.then153, label %if.end155

if.then153:                                       ; preds = %if.end150
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call154 = call i32 @fixup_bpf_calls(%struct.bpf_verifier_env* noundef %122) #8
  store i32 %call154, i32* %ret, align 4
  br label %if.end155

if.end155:                                        ; preds = %if.then153, %if.end150
  %123 = load i32, i32* %ret, align 4
  %cmp156 = icmp eq i32 %123, 0
  br i1 %cmp156, label %land.lhs.true158, label %if.end172

land.lhs.true158:                                 ; preds = %if.end155
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog159 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %124, i32 0, i32 2
  %125 = load %struct.bpf_prog*, %struct.bpf_prog** %prog159, align 8
  %aux160 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %125, i32 0, i32 7
  %126 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux160, align 8
  %call161 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %126) #8
  br i1 %call161, label %if.end172, label %if.then162

if.then162:                                       ; preds = %land.lhs.true158
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %128 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %call163 = call i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %127, %union.bpf_attr* noundef %128) #8
  store i32 %call163, i32* %ret, align 4
  %call164 = call zeroext i1 @bpf_jit_needs_zext() #8
  br i1 %call164, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then162
  %129 = load i32, i32* %ret, align 4
  %tobool166 = icmp ne i32 %129, 0
  %lnot167 = xor i1 %tobool166, true
  %lnot.ext = zext i1 %lnot167 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then162
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %lnot.ext, %cond.true ], [ 0, %cond.false ]
  %tobool168 = icmp ne i32 %cond, 0
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog169 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %130, i32 0, i32 2
  %131 = load %struct.bpf_prog*, %struct.bpf_prog** %prog169, align 8
  %aux170 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %131, i32 0, i32 7
  %132 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux170, align 8
  %verifier_zext = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %132, i32 0, i32 9
  %frombool171 = zext i1 %tobool168 to i8
  store i8 %frombool171, i8* %verifier_zext, align 4
  br label %if.end172

if.end172:                                        ; preds = %cond.end, %land.lhs.true158, %if.end155
  %133 = load i32, i32* %ret, align 4
  %cmp173 = icmp eq i32 %133, 0
  br i1 %cmp173, label %if.then175, label %if.end177

if.then175:                                       ; preds = %if.end172
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call176 = call i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %134) #8
  store i32 %call176, i32* %ret, align 4
  br label %if.end177

if.end177:                                        ; preds = %if.then175, %if.end172
  %call178 = call i64 @ktime_get_ns() #8
  %135 = load i64, i64* %start_time, align 8
  %sub = sub i64 %call178, %135
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %136, i32 0, i32 26
  store i64 %sub, i64* %verification_time, align 8
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @print_verification_stats(%struct.bpf_verifier_env* noundef %137) #8
  %138 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level179 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %138, i32 0, i32 0
  %139 = load i32, i32* %level179, align 8
  %tobool180 = icmp ne i32 %139, 0
  br i1 %tobool180, label %land.lhs.true181, label %if.end185

land.lhs.true181:                                 ; preds = %if.end177
  %140 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %call182 = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %140) #8
  br i1 %call182, label %if.then184, label %if.end185

if.then184:                                       ; preds = %land.lhs.true181
  store i32 -28, i32* %ret, align 4
  br label %if.end185

if.end185:                                        ; preds = %if.then184, %land.lhs.true181, %if.end177
  %141 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level186 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %141, i32 0, i32 0
  %142 = load i32, i32* %level186, align 8
  %tobool187 = icmp ne i32 %142, 0
  br i1 %tobool187, label %land.lhs.true188, label %if.end192

land.lhs.true188:                                 ; preds = %if.end185
  %143 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf189 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %143, i32 0, i32 2
  %144 = load i8*, i8** %ubuf189, align 8
  %tobool190 = icmp ne i8* %144, null
  br i1 %tobool190, label %if.end192, label %if.then191

if.then191:                                       ; preds = %land.lhs.true188
  store i32 -14, i32* %ret, align 4
  br label %err_release_maps

if.end192:                                        ; preds = %land.lhs.true188, %if.end185
  %145 = load i32, i32* %ret, align 4
  %cmp193 = icmp eq i32 %145, 0
  br i1 %cmp193, label %land.lhs.true195, label %if.end219

land.lhs.true195:                                 ; preds = %if.end192
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %146, i32 0, i32 12
  %147 = load i32, i32* %used_map_cnt, align 8
  %tobool196 = icmp ne i32 %147, 0
  br i1 %tobool196, label %if.then197, label %if.end219

if.then197:                                       ; preds = %land.lhs.true195
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt198 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %148, i32 0, i32 12
  %149 = load i32, i32* %used_map_cnt198, align 8
  %conv199 = zext i32 %149 to i64
  %call200 = call i8* @kmalloc_array(i64 noundef %conv199, i64 noundef 8, i32 noundef 3264) #8
  %150 = bitcast i8* %call200 to %struct.bpf_map**
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog201 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %151, i32 0, i32 2
  %152 = load %struct.bpf_prog*, %struct.bpf_prog** %prog201, align 8
  %aux202 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %152, i32 0, i32 7
  %153 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux202, align 8
  %used_maps = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %153, i32 0, i32 16
  store %struct.bpf_map** %150, %struct.bpf_map*** %used_maps, align 8
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog203 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 2
  %155 = load %struct.bpf_prog*, %struct.bpf_prog** %prog203, align 8
  %aux204 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %155, i32 0, i32 7
  %156 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux204, align 8
  %used_maps205 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %156, i32 0, i32 16
  %157 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps205, align 8
  %tobool206 = icmp ne %struct.bpf_map** %157, null
  br i1 %tobool206, label %if.end208, label %if.then207

if.then207:                                       ; preds = %if.then197
  store i32 -12, i32* %ret, align 4
  br label %err_release_maps

if.end208:                                        ; preds = %if.then197
  %158 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog209 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %158, i32 0, i32 2
  %159 = load %struct.bpf_prog*, %struct.bpf_prog** %prog209, align 8
  %aux210 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %159, i32 0, i32 7
  %160 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux210, align 8
  %used_maps211 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %160, i32 0, i32 16
  %161 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps211, align 8
  %162 = bitcast %struct.bpf_map** %161 to i8*
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_maps212 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %163, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps212, i64 0, i64 0
  %164 = bitcast %struct.bpf_map** %arraydecay to i8*
  %165 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt213 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %165, i32 0, i32 12
  %166 = load i32, i32* %used_map_cnt213, align 8
  %conv214 = zext i32 %166 to i64
  %mul = mul i64 8, %conv214
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %162, i8* align 8 %164, i64 %mul, i1 false)
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt215 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %167, i32 0, i32 12
  %168 = load i32, i32* %used_map_cnt215, align 8
  %169 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog216 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %169, i32 0, i32 2
  %170 = load %struct.bpf_prog*, %struct.bpf_prog** %prog216, align 8
  %aux217 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %170, i32 0, i32 7
  %171 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux217, align 8
  %used_map_cnt218 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %171, i32 0, i32 1
  store i32 %168, i32* %used_map_cnt218, align 4
  %172 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %172) #8
  br label %if.end219

if.end219:                                        ; preds = %if.end208, %land.lhs.true195, %if.end192
  %173 = load i32, i32* %ret, align 4
  %cmp220 = icmp eq i32 %173, 0
  br i1 %cmp220, label %if.then222, label %if.end223

if.then222:                                       ; preds = %if.end219
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @adjust_btf_func(%struct.bpf_verifier_env* noundef %174) #8
  br label %if.end223

if.end223:                                        ; preds = %if.then222, %if.end219
  br label %err_release_maps

err_release_maps:                                 ; preds = %if.end223, %if.then207, %if.then191
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog224 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %175, i32 0, i32 2
  %176 = load %struct.bpf_prog*, %struct.bpf_prog** %prog224, align 8
  %aux225 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %176, i32 0, i32 7
  %177 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux225, align 8
  %used_maps226 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %177, i32 0, i32 16
  %178 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps226, align 8
  %tobool227 = icmp ne %struct.bpf_map** %178, null
  br i1 %tobool227, label %if.end229, label %if.then228

if.then228:                                       ; preds = %err_release_maps
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @release_maps(%struct.bpf_verifier_env* noundef %179) #8
  br label %if.end229

if.end229:                                        ; preds = %if.then228, %err_release_maps
  %180 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog230 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %180, i32 0, i32 2
  %181 = load %struct.bpf_prog*, %struct.bpf_prog** %prog230, align 8
  %182 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  store %struct.bpf_prog* %181, %struct.bpf_prog** %182, align 8
  br label %err_unlock

err_unlock:                                       ; preds = %if.end229, %if.then44
  %183 = load i8, i8* %is_priv, align 1
  %tobool231 = trunc i8 %183 to i1
  br i1 %tobool231, label %if.end233, label %if.then232

if.then232:                                       ; preds = %err_unlock
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #8
  br label %if.end233

if.end233:                                        ; preds = %if.then232, %err_unlock
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data234 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %184, i32 0, i32 16
  %185 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data234, align 8
  %186 = bitcast %struct.bpf_insn_aux_data* %185 to i8*
  call void @vfree(i8* noundef %186) #8
  br label %err_free_env

err_free_env:                                     ; preds = %if.end233, %if.then8
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %188 = bitcast %struct.bpf_verifier_env* %187 to i8*
  call void @kfree(i8* noundef %188) #8
  %189 = load i32, i32* %ret, align 4
  store i32 %189, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free_env, %if.then
  %190 = load i32, i32* %retval, align 4
  ret i32 %190
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_get_ns() #0 {
entry:
  %call = call i64 @ktime_get() #8
  %call1 = call i64 @ktime_to_ns(i64 noundef %call) #8
  ret i64 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kzalloc(i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval.i11 = alloca i32, align 4
  %flags.addr.i12 = alloca i32, align 4
  %retval.i4 = alloca i32, align 4
  %size.addr.i5 = alloca i64, align 8
  %size.addr.i1 = alloca i64, align 8
  %flags.addr.i2 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 256
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64, i64* %size.addr.i, align 8
  %3 = call i1 @llvm.is.constant.i64(i64 %2) #9
  br i1 %3, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %entry
  %4 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %4, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %5 = load i64, i64* %size.addr.i, align 8
  %6 = load i32, i32* %flags.addr.i, align 4
  store i64 %5, i64* %size.addr.i1, align 8
  store i32 %6, i32* %flags.addr.i2, align 4
  %7 = load i64, i64* %size.addr.i1, align 8
  %call.i3 = call i32 @get_order(i64 noundef %7) #11
  store i32 %call.i3, i32* %order.i, align 4
  %8 = load i64, i64* %size.addr.i1, align 8
  %9 = load i32, i32* %flags.addr.i2, align 4
  %10 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %8, i32 noundef %9, i32 noundef %10) #10
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %11 = load i64, i64* %size.addr.i, align 8
  store i64 %11, i64* %size.addr.i5, align 8
  %12 = load i64, i64* %size.addr.i5, align 8
  %tobool.i6 = icmp ne i64 %12, 0
  br i1 %tobool.i6, label %if.end.i9, label %if.then.i7

if.then.i7:                                       ; preds = %if.end.i
  store i32 0, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end.i9:                                        ; preds = %if.end.i
  %13 = load i64, i64* %size.addr.i5, align 8
  %cmp.i8 = icmp ule i64 %13, 8
  br i1 %cmp.i8, label %if.then1.i10, label %if.end2.i

if.then1.i10:                                     ; preds = %if.end.i9
  store i32 3, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i9
  %14 = load i64, i64* %size.addr.i5, align 8
  %cmp3.i = icmp ugt i64 %14, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %15 = load i64, i64* %size.addr.i5, align 8
  %cmp4.i = icmp ule i64 %15, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %16 = load i64, i64* %size.addr.i5, align 8
  %cmp7.i = icmp ugt i64 %16, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %17 = load i64, i64* %size.addr.i5, align 8
  %cmp9.i = icmp ule i64 %17, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %18 = load i64, i64* %size.addr.i5, align 8
  %cmp12.i = icmp ule i64 %18, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %19 = load i64, i64* %size.addr.i5, align 8
  %cmp15.i = icmp ule i64 %19, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %20 = load i64, i64* %size.addr.i5, align 8
  %cmp18.i = icmp ule i64 %20, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %21 = load i64, i64* %size.addr.i5, align 8
  %cmp21.i = icmp ule i64 %21, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %22 = load i64, i64* %size.addr.i5, align 8
  %cmp24.i = icmp ule i64 %22, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %23 = load i64, i64* %size.addr.i5, align 8
  %cmp27.i = icmp ule i64 %23, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %24 = load i64, i64* %size.addr.i5, align 8
  %cmp30.i = icmp ule i64 %24, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %25 = load i64, i64* %size.addr.i5, align 8
  %cmp33.i = icmp ule i64 %25, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %26 = load i64, i64* %size.addr.i5, align 8
  %cmp36.i = icmp ule i64 %26, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %27 = load i64, i64* %size.addr.i5, align 8
  %cmp39.i = icmp ule i64 %27, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %28 = load i64, i64* %size.addr.i5, align 8
  %cmp42.i = icmp ule i64 %28, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %29 = load i64, i64* %size.addr.i5, align 8
  %cmp45.i = icmp ule i64 %29, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %30 = load i64, i64* %size.addr.i5, align 8
  %cmp48.i = icmp ule i64 %30, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %31 = load i64, i64* %size.addr.i5, align 8
  %cmp51.i = icmp ule i64 %31, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %32 = load i64, i64* %size.addr.i5, align 8
  %cmp54.i = icmp ule i64 %32, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %33 = load i64, i64* %size.addr.i5, align 8
  %cmp57.i = icmp ule i64 %33, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %34 = load i64, i64* %size.addr.i5, align 8
  %cmp60.i = icmp ule i64 %34, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %35 = load i64, i64* %size.addr.i5, align 8
  %cmp63.i = icmp ule i64 %35, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %36 = load i64, i64* %size.addr.i5, align 8
  %cmp66.i = icmp ule i64 %36, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %37 = load i64, i64* %size.addr.i5, align 8
  %cmp69.i = icmp ule i64 %37, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %38 = load i64, i64* %size.addr.i5, align 8
  %cmp72.i = icmp ule i64 %38, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %39 = load i64, i64* %size.addr.i5, align 8
  %cmp75.i = icmp ule i64 %39, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %40 = load i64, i64* %size.addr.i5, align 8
  %cmp78.i = icmp ule i64 %40, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %41 = load i64, i64* %size.addr.i5, align 8
  %cmp81.i = icmp ule i64 %41, 67108864
  br i1 %cmp81.i, label %if.then82.i, label %if.end83.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 26, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end83.i:                                       ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i64 0, i64 0), i32 386, i32 0, i64 12) #9, !srcloc !9
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.unreachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 15) #9, !srcloc !10
  unreachable

kmalloc_index.exit:                               ; preds = %if.then82.i, %if.then79.i, %if.then76.i, %if.then73.i, %if.then70.i, %if.then67.i, %if.then64.i, %if.then61.i, %if.then58.i, %if.then55.i, %if.then52.i, %if.then49.i, %if.then46.i, %if.then43.i, %if.then40.i, %if.then37.i, %if.then34.i, %if.then31.i, %if.then28.i, %if.then25.i, %if.then22.i, %if.then19.i, %if.then16.i, %if.then13.i, %if.then10.i, %if.then5.i, %if.then1.i10, %if.then.i7
  %42 = load i32, i32* %retval.i4, align 4
  store i32 %42, i32* %index.i, align 4
  %43 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %43, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %kmalloc_index.exit
  %44 = load i32, i32* %flags.addr.i, align 4
  store i32 %44, i32* %flags.addr.i12, align 4
  %45 = load i32, i32* %flags.addr.i12, align 4
  %and.i = and i32 %45, 17
  %cmp.i13 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i13, true
  %lnot.ext.i = zext i1 %cmp.i13 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i13, label %if.then.i14, label %if.end.i15

if.then.i14:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

if.end.i15:                                       ; preds = %if.end4.i
  %46 = load i32, i32* %flags.addr.i12, align 4
  %and2.i = and i32 %46, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  %47 = zext i1 %tobool3.i to i64
  %cond.i = select i1 %tobool3.i, i32 2, i32 1
  store i32 %cond.i, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.end.i15, %if.then.i14
  %48 = load i32, i32* %retval.i11, align 4
  %idxprom.i = zext i32 %48 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %49 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %49 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %50 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %51 = load i32, i32* %flags.addr.i, align 4
  %52 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %50, i32 noundef %51, i64 noundef %52) #10
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %entry
  %53 = load i64, i64* %size.addr.i, align 8
  %54 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %53, i32 noundef %54) #10
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.end9.i, %kmalloc_type.exit, %if.then3.i, %if.then1.i
  %55 = load i8*, i8** %retval.i, align 8
  ret i8* %55
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @array_size(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i64, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %b.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %bytes, align 8
  store i64 %10, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, i64* %retval, align 8
  ret i64 %11
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @vzalloc(i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @capable(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_lock(%struct.mutex* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @replace_map_fd_with_map_ptr(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %f = alloca %struct.fd, align 8
  %addr = alloca i64, align 8
  %tmp = alloca %struct.fd, align 8
  %off131 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %2 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %7) #8
  store i32 %call, i32* %err, align 4
  %8 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %err, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc199, %if.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end202

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 0
  %13 = load i8, i8* %code, align 4
  %conv = zext i8 %13 to i32
  %and = and i32 %conv, 7
  %cmp3 = icmp eq i32 %and, 1
  br i1 %cmp3, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %for.body
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %15 to i32
  %and7 = and i32 %conv6, 224
  %cmp8 = icmp ne i32 %and7, 96
  br i1 %cmp8, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 3
  %17 = load i32, i32* %imm, align 4
  %cmp10 = icmp ne i32 %17, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.7, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false, %for.body
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 0
  %21 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %21 to i32
  %and16 = and i32 %conv15, 7
  %cmp17 = icmp eq i32 %and16, 3
  br i1 %cmp17, label %land.lhs.true19, label %if.end36

land.lhs.true19:                                  ; preds = %if.end13
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code20 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 0
  %23 = load i8, i8* %code20, align 4
  %conv21 = zext i8 %23 to i32
  %and22 = and i32 %conv21, 224
  %cmp23 = icmp ne i32 %and22, 96
  br i1 %cmp23, label %land.lhs.true25, label %lor.lhs.false31

land.lhs.true25:                                  ; preds = %land.lhs.true19
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 0
  %25 = load i8, i8* %code26, align 4
  %conv27 = zext i8 %25 to i32
  %and28 = and i32 %conv27, 224
  %cmp29 = icmp ne i32 %and28, 192
  br i1 %cmp29, label %if.then35, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %land.lhs.true25, %land.lhs.true19
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm32 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 3
  %27 = load i32, i32* %imm32, align 4
  %cmp33 = icmp ne i32 %27, 0
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %lor.lhs.false31, %land.lhs.true25
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.8, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %lor.lhs.false31, %if.end13
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %30, i64 0
  %code37 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %31 = load i8, i8* %code37, align 4
  %conv38 = zext i8 %31 to i32
  %cmp39 = icmp eq i32 %conv38, 24
  br i1 %cmp39, label %if.then41, label %if.end192

if.then41:                                        ; preds = %if.end36
  %32 = load i32, i32* %i, align 4
  %33 = load i32, i32* %insn_cnt, align 4
  %sub = sub i32 %33, 1
  %cmp42 = icmp eq i32 %32, %sub
  br i1 %cmp42, label %if.then66, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %if.then41
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %34, i64 1
  %code46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx45, i32 0, i32 0
  %35 = load i8, i8* %code46, align 4
  %conv47 = zext i8 %35 to i32
  %cmp48 = icmp ne i32 %conv47, 0
  br i1 %cmp48, label %if.then66, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %lor.lhs.false44
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx51 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %36, i64 1
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx51, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv52 = zext i8 %bf.clear to i32
  %cmp53 = icmp ne i32 %conv52, 0
  br i1 %cmp53, label %if.then66, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false50
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx56 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %37, i64 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx56, i32 0, i32 1
  %bf.load57 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load57, 4
  %conv58 = zext i8 %bf.lshr to i32
  %cmp59 = icmp ne i32 %conv58, 0
  br i1 %cmp59, label %if.then66, label %lor.lhs.false61

lor.lhs.false61:                                  ; preds = %lor.lhs.false55
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx62 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %38, i64 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx62, i32 0, i32 2
  %39 = load i16, i16* %off, align 2
  %conv63 = sext i16 %39 to i32
  %cmp64 = icmp ne i32 %conv63, 0
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %lor.lhs.false61, %lor.lhs.false55, %lor.lhs.false50, %lor.lhs.false44, %if.then41
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.9, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %lor.lhs.false61
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx68 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %42, i64 0
  %src_reg69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx68, i32 0, i32 1
  %bf.load70 = load i8, i8* %src_reg69, align 1
  %bf.lshr71 = lshr i8 %bf.load70, 4
  %conv72 = zext i8 %bf.lshr71 to i32
  %cmp73 = icmp eq i32 %conv72, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end67
  br label %next_insn

if.end76:                                         ; preds = %if.end67
  %43 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx77 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %43, i64 0
  %src_reg78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx77, i32 0, i32 1
  %bf.load79 = load i8, i8* %src_reg78, align 1
  %bf.lshr80 = lshr i8 %bf.load79, 4
  %conv81 = zext i8 %bf.lshr80 to i32
  %cmp82 = icmp ne i32 %conv81, 1
  br i1 %cmp82, label %land.lhs.true84, label %lor.lhs.false92

land.lhs.true84:                                  ; preds = %if.end76
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx85 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %44, i64 0
  %src_reg86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx85, i32 0, i32 1
  %bf.load87 = load i8, i8* %src_reg86, align 1
  %bf.lshr88 = lshr i8 %bf.load87, 4
  %conv89 = zext i8 %bf.lshr88 to i32
  %cmp90 = icmp ne i32 %conv89, 2
  br i1 %cmp90, label %if.then105, label %lor.lhs.false92

lor.lhs.false92:                                  ; preds = %land.lhs.true84, %if.end76
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx93 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %45, i64 0
  %src_reg94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx93, i32 0, i32 1
  %bf.load95 = load i8, i8* %src_reg94, align 1
  %bf.lshr96 = lshr i8 %bf.load95, 4
  %conv97 = zext i8 %bf.lshr96 to i32
  %cmp98 = icmp eq i32 %conv97, 1
  br i1 %cmp98, label %land.lhs.true100, label %if.end106

land.lhs.true100:                                 ; preds = %lor.lhs.false92
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx101 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %46, i64 1
  %imm102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx101, i32 0, i32 3
  %47 = load i32, i32* %imm102, align 4
  %cmp103 = icmp ne i32 %47, 0
  br i1 %cmp103, label %if.then105, label %if.end106

if.then105:                                       ; preds = %land.lhs.true100, %land.lhs.true84
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.10, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end106:                                        ; preds = %land.lhs.true100, %lor.lhs.false92
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx107 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %50, i64 0
  %imm108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx107, i32 0, i32 3
  %51 = load i32, i32* %imm108, align 4
  %call109 = call { %struct.file*, i32 } @fdget(i32 noundef %51) #8
  %52 = bitcast %struct.fd* %tmp to { %struct.file*, i32 }*
  %53 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %52, i32 0, i32 0
  %54 = extractvalue { %struct.file*, i32 } %call109, 0
  store %struct.file* %54, %struct.file** %53, align 8
  %55 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %52, i32 0, i32 1
  %56 = extractvalue { %struct.file*, i32 } %call109, 1
  store i32 %56, i32* %55, align 8
  %57 = bitcast %struct.fd* %f to i8*
  %58 = bitcast %struct.fd* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %57, i8* align 8 %58, i64 16, i1 false)
  %59 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %60 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %59, i32 0, i32 0
  %61 = load %struct.file*, %struct.file** %60, align 8
  %62 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %59, i32 0, i32 1
  %63 = load i32, i32* %62, align 8
  %call110 = call %struct.bpf_map* @__bpf_map_get(%struct.file* %61, i32 %63) #8
  store %struct.bpf_map* %call110, %struct.bpf_map** %map, align 8
  %64 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %65 = bitcast %struct.bpf_map* %64 to i8*
  %call111 = call zeroext i1 @IS_ERR(i8* noundef %65) #8
  br i1 %call111, label %if.then112, label %if.end117

if.then112:                                       ; preds = %if.end106
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx113 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %68, i64 0
  %imm114 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx113, i32 0, i32 3
  %69 = load i32, i32* %imm114, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.11, i64 0, i64 0), i32 noundef %69) #8
  %70 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %71 = bitcast %struct.bpf_map* %70 to i8*
  %call115 = call i64 @PTR_ERR(i8* noundef %71) #8
  %conv116 = trunc i64 %call115 to i32
  store i32 %conv116, i32* %retval, align 4
  br label %return

if.end117:                                        ; preds = %if.end106
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog118 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 2
  %75 = load %struct.bpf_prog*, %struct.bpf_prog** %prog118, align 8
  %call119 = call i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %72, %struct.bpf_map* noundef %73, %struct.bpf_prog* noundef %75) #8
  store i32 %call119, i32* %err, align 4
  %76 = load i32, i32* %err, align 4
  %tobool120 = icmp ne i32 %76, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end117
  %77 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %78 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %77, i32 0, i32 0
  %79 = load %struct.file*, %struct.file** %78, align 8
  %80 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %77, i32 0, i32 1
  %81 = load i32, i32* %80, align 8
  call void @fdput(%struct.file* %79, i32 %81) #8
  %82 = load i32, i32* %err, align 4
  store i32 %82, i32* %retval, align 4
  br label %return

if.end122:                                        ; preds = %if.end117
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 16
  %84 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %85 = load i32, i32* %i, align 4
  %idxprom = sext i32 %85 to i64
  %arrayidx123 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %84, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx123, %struct.bpf_insn_aux_data** %aux, align 8
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg124 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %86, i32 0, i32 1
  %bf.load125 = load i8, i8* %src_reg124, align 1
  %bf.lshr126 = lshr i8 %bf.load125, 4
  %conv127 = zext i8 %bf.lshr126 to i32
  %cmp128 = icmp eq i32 %conv127, 1
  br i1 %cmp128, label %if.then130, label %if.else

if.then130:                                       ; preds = %if.end122
  %87 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %88 = ptrtoint %struct.bpf_map* %87 to i64
  store i64 %88, i64* %addr, align 8
  br label %if.end148

if.else:                                          ; preds = %if.end122
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx132 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %89, i64 1
  %imm133 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx132, i32 0, i32 3
  %90 = load i32, i32* %imm133, align 4
  store i32 %90, i32* %off131, align 4
  %91 = load i32, i32* %off131, align 4
  %cmp134 = icmp uge i32 %91, 536870912
  br i1 %cmp134, label %if.then136, label %if.end137

if.then136:                                       ; preds = %if.else
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  %94 = load i32, i32* %off131, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %93, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.12, i64 0, i64 0), i32 noundef %94) #8
  %95 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %96 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %95, i32 0, i32 0
  %97 = load %struct.file*, %struct.file** %96, align 8
  %98 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %95, i32 0, i32 1
  %99 = load i32, i32* %98, align 8
  call void @fdput(%struct.file* %97, i32 %99) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end137:                                        ; preds = %if.else
  %100 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %100, i32 0, i32 0
  %101 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %101, i32 0, i32 19
  %102 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool138 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %102, null
  br i1 %tobool138, label %if.end140, label %if.then139

if.then139:                                       ; preds = %if.end137
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %104 = bitcast %struct.bpf_verifier_env* %103 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %104, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.13, i64 0, i64 0)) #8
  %105 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %106 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %105, i32 0, i32 0
  %107 = load %struct.file*, %struct.file** %106, align 8
  %108 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %105, i32 0, i32 1
  %109 = load i32, i32* %108, align 8
  call void @fdput(%struct.file* %107, i32 %109) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end140:                                        ; preds = %if.end137
  %110 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops141 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %110, i32 0, i32 0
  %111 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops141, align 64
  %map_direct_value_addr142 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %111, i32 0, i32 19
  %112 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr142, align 8
  %113 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %114 = load i32, i32* %off131, align 4
  %call143 = call i32 %112(%struct.bpf_map* noundef %113, i64* noundef %addr, i32 noundef %114) #8
  store i32 %call143, i32* %err, align 4
  %115 = load i32, i32* %err, align 4
  %tobool144 = icmp ne i32 %115, 0
  br i1 %tobool144, label %if.then145, label %if.end146

if.then145:                                       ; preds = %if.end140
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = bitcast %struct.bpf_verifier_env* %116 to i8*
  %118 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %118, i32 0, i32 5
  %119 = load i32, i32* %value_size, align 32
  %120 = load i32, i32* %off131, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %117, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.14, i64 0, i64 0), i32 noundef %119, i32 noundef %120) #8
  %121 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %122 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %121, i32 0, i32 0
  %123 = load %struct.file*, %struct.file** %122, align 8
  %124 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %121, i32 0, i32 1
  %125 = load i32, i32* %124, align 8
  call void @fdput(%struct.file* %123, i32 %125) #8
  %126 = load i32, i32* %err, align 4
  store i32 %126, i32* %retval, align 4
  br label %return

if.end146:                                        ; preds = %if.end140
  %127 = load i32, i32* %off131, align 4
  %128 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %129 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %128, i32 0, i32 0
  %130 = bitcast %union.anon.13* %129 to %struct.util_est*
  %map_off = getelementptr inbounds %struct.util_est, %struct.util_est* %130, i32 0, i32 1
  store i32 %127, i32* %map_off, align 4
  %131 = load i32, i32* %off131, align 4
  %conv147 = zext i32 %131 to i64
  %132 = load i64, i64* %addr, align 8
  %add = add i64 %132, %conv147
  store i64 %add, i64* %addr, align 8
  br label %if.end148

if.end148:                                        ; preds = %if.end146, %if.then130
  %133 = load i64, i64* %addr, align 8
  %conv149 = trunc i64 %133 to i32
  %134 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx150 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %134, i64 0
  %imm151 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx150, i32 0, i32 3
  store i32 %conv149, i32* %imm151, align 4
  %135 = load i64, i64* %addr, align 8
  %shr = lshr i64 %135, 32
  %conv152 = trunc i64 %shr to i32
  %136 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx153 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %136, i64 1
  %imm154 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx153, i32 0, i32 3
  store i32 %conv152, i32* %imm154, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond155

for.cond155:                                      ; preds = %for.inc, %if.end148
  %137 = load i32, i32* %j, align 4
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %138, i32 0, i32 12
  %139 = load i32, i32* %used_map_cnt, align 8
  %cmp156 = icmp ult i32 %137, %139
  br i1 %cmp156, label %for.body158, label %for.end

for.body158:                                      ; preds = %for.cond155
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %140, i32 0, i32 11
  %141 = load i32, i32* %j, align 4
  %idxprom159 = sext i32 %141 to i64
  %arrayidx160 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom159
  %142 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx160, align 8
  %143 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp161 = icmp eq %struct.bpf_map* %142, %143
  br i1 %cmp161, label %if.then163, label %if.end164

if.then163:                                       ; preds = %for.body158
  %144 = load i32, i32* %j, align 4
  %145 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %146 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %145, i32 0, i32 0
  %147 = bitcast %union.anon.13* %146 to %struct.util_est*
  %map_index = getelementptr inbounds %struct.util_est, %struct.util_est* %147, i32 0, i32 0
  store i32 %144, i32* %map_index, align 8
  %148 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %149 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %148, i32 0, i32 0
  %150 = load %struct.file*, %struct.file** %149, align 8
  %151 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %148, i32 0, i32 1
  %152 = load i32, i32* %151, align 8
  call void @fdput(%struct.file* %150, i32 %152) #8
  br label %next_insn

if.end164:                                        ; preds = %for.body158
  br label %for.inc

for.inc:                                          ; preds = %if.end164
  %153 = load i32, i32* %j, align 4
  %inc = add i32 %153, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond155

for.end:                                          ; preds = %for.cond155
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt165 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 12
  %155 = load i32, i32* %used_map_cnt165, align 8
  %cmp166 = icmp uge i32 %155, 64
  br i1 %cmp166, label %if.then168, label %if.end169

if.then168:                                       ; preds = %for.end
  %156 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %157 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %156, i32 0, i32 0
  %158 = load %struct.file*, %struct.file** %157, align 8
  %159 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %156, i32 0, i32 1
  %160 = load i32, i32* %159, align 8
  call void @fdput(%struct.file* %158, i32 %160) #8
  store i32 -7, i32* %retval, align 4
  br label %return

if.end169:                                        ; preds = %for.end
  %161 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call170 = call %struct.bpf_map* @bpf_map_inc(%struct.bpf_map* noundef %161, i1 noundef zeroext false) #8
  store %struct.bpf_map* %call170, %struct.bpf_map** %map, align 8
  %162 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %163 = bitcast %struct.bpf_map* %162 to i8*
  %call171 = call zeroext i1 @IS_ERR(i8* noundef %163) #8
  br i1 %call171, label %if.then172, label %if.end175

if.then172:                                       ; preds = %if.end169
  %164 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %165 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %164, i32 0, i32 0
  %166 = load %struct.file*, %struct.file** %165, align 8
  %167 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %164, i32 0, i32 1
  %168 = load i32, i32* %167, align 8
  call void @fdput(%struct.file* %166, i32 %168) #8
  %169 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %170 = bitcast %struct.bpf_map* %169 to i8*
  %call173 = call i64 @PTR_ERR(i8* noundef %170) #8
  %conv174 = trunc i64 %call173 to i32
  store i32 %conv174, i32* %retval, align 4
  br label %return

if.end175:                                        ; preds = %if.end169
  %171 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt176 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %171, i32 0, i32 12
  %172 = load i32, i32* %used_map_cnt176, align 8
  %173 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %174 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %173, i32 0, i32 0
  %175 = bitcast %union.anon.13* %174 to %struct.util_est*
  %map_index177 = getelementptr inbounds %struct.util_est, %struct.util_est* %175, i32 0, i32 0
  store i32 %172, i32* %map_index177, align 8
  %176 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps178 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %177, i32 0, i32 11
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt179 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %178, i32 0, i32 12
  %179 = load i32, i32* %used_map_cnt179, align 8
  %inc180 = add i32 %179, 1
  store i32 %inc180, i32* %used_map_cnt179, align 8
  %idxprom181 = zext i32 %179 to i64
  %arrayidx182 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps178, i64 0, i64 %idxprom181
  store %struct.bpf_map* %176, %struct.bpf_map** %arrayidx182, align 8
  %180 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call183 = call zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %180) #8
  br i1 %call183, label %land.lhs.true185, label %if.end190

land.lhs.true185:                                 ; preds = %if.end175
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog186 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %181, i32 0, i32 2
  %182 = load %struct.bpf_prog*, %struct.bpf_prog** %prog186, align 8
  %183 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call187 = call i32 @bpf_cgroup_storage_assign(%struct.bpf_prog* noundef %182, %struct.bpf_map* noundef %183) #8
  %tobool188 = icmp ne i32 %call187, 0
  br i1 %tobool188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %land.lhs.true185
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %185 = bitcast %struct.bpf_verifier_env* %184 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %185, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.15, i64 0, i64 0)) #8
  %186 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %187 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %186, i32 0, i32 0
  %188 = load %struct.file*, %struct.file** %187, align 8
  %189 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %186, i32 0, i32 1
  %190 = load i32, i32* %189, align 8
  call void @fdput(%struct.file* %188, i32 %190) #8
  store i32 -16, i32* %retval, align 4
  br label %return

if.end190:                                        ; preds = %land.lhs.true185, %if.end175
  %191 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %192 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %191, i32 0, i32 0
  %193 = load %struct.file*, %struct.file** %192, align 8
  %194 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %191, i32 0, i32 1
  %195 = load i32, i32* %194, align 8
  call void @fdput(%struct.file* %193, i32 %195) #8
  br label %next_insn

next_insn:                                        ; preds = %if.end190, %if.then163, %if.then75
  %196 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %196, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  %197 = load i32, i32* %i, align 4
  %inc191 = add i32 %197, 1
  store i32 %inc191, i32* %i, align 4
  br label %for.inc199

if.end192:                                        ; preds = %if.end36
  %198 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code193 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %198, i32 0, i32 0
  %199 = load i8, i8* %code193, align 4
  %call194 = call zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext %199) #8
  br i1 %call194, label %if.end198, label %if.then195

if.then195:                                       ; preds = %if.end192
  %200 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %201 = bitcast %struct.bpf_verifier_env* %200 to i8*
  %202 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code196 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %202, i32 0, i32 0
  %203 = load i8, i8* %code196, align 4
  %conv197 = zext i8 %203 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %201, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.16, i64 0, i64 0), i32 noundef %conv197) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end198:                                        ; preds = %if.end192
  br label %for.inc199

for.inc199:                                       ; preds = %if.end198, %next_insn
  %204 = load i32, i32* %i, align 4
  %inc200 = add i32 %204, 1
  store i32 %inc200, i32* %i, align 4
  %205 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr201 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %205, i32 1
  store %struct.bpf_insn* %incdec.ptr201, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end202:                                       ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end202, %if.then195, %if.then189, %if.then172, %if.then168, %if.then145, %if.then139, %if.then136, %if.then121, %if.then112, %if.then105, %if.then66, %if.then35, %if.then12, %if.then
  %206 = load i32, i32* %retval, align 4
  ret i32 %206
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  %0 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux.addr, align 8
  %offload_requested = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %0, i32 0, i32 10
  %1 = load i8, i8* %offload_requested, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @state_htab_size(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call i8* @kvmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #8
  ret i8* %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %off = alloca i32, align 4
  %cur_subprog = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %code52 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %cur_subprog, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 19
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %3 to [0 x %struct.bpf_insn]*
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 4
  %6 = load i32, i32* %len, align 4
  store i32 %6, i32* %insn_cnt, align 4
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %7, i32 noundef 0) #8
  store i32 %call, i32* %ret, align 4
  %8 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %ret, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %insn_cnt, align 4
  %cmp3 = icmp slt i32 %10, %11
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %12, i64 %idxprom
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %14 = load i8, i8* %code, align 4
  %conv = zext i8 %14 to i32
  %cmp4 = icmp ne i32 %conv, 133
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.inc

if.end7:                                          ; preds = %for.body
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %15, i64 %idxprom8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx9, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv10 = zext i8 %bf.lshr to i32
  %cmp11 = icmp ne i32 %conv10, 1
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end7
  br label %for.inc

if.end14:                                         ; preds = %if.end7
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 14
  %18 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %18 to i1
  br i1 %tobool, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end14
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.21, i64 0, i64 0)) #8
  store i32 -1, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end14
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom17 = sext i32 %24 to i64
  %arrayidx18 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %23, i64 %idxprom17
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx18, i32 0, i32 3
  %25 = load i32, i32* %imm, align 4
  %add = add i32 %22, %25
  %add19 = add i32 %add, 1
  %call20 = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %21, i32 noundef %add19) #8
  store i32 %call20, i32* %ret, align 4
  %26 = load i32, i32* %ret, align 4
  %cmp21 = icmp slt i32 %26, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end16
  %27 = load i32, i32* %ret, align 4
  store i32 %27, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end16
  br label %for.inc

for.inc:                                          ; preds = %if.end24, %if.then13, %if.then6
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %29 = load i32, i32* %insn_cnt, align 4
  %30 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 21
  %32 = load i32, i32* %subprog_cnt, align 8
  %idxprom25 = zext i32 %32 to i64
  %arrayidx26 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %30, i64 %idxprom25
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx26, i32 0, i32 0
  store i32 %29, i32* %start, align 4
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %34 = load i32, i32* %level, align 8
  %and = and i32 %34, 2
  %tobool27 = icmp ne i32 %and, 0
  br i1 %tobool27, label %if.then28, label %if.end40

if.then28:                                        ; preds = %for.end
  store i32 0, i32* %i, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc37, %if.then28
  %35 = load i32, i32* %i, align 4
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 21
  %37 = load i32, i32* %subprog_cnt30, align 8
  %cmp31 = icmp ult i32 %35, %37
  br i1 %cmp31, label %for.body33, label %for.end39

for.body33:                                       ; preds = %for.cond29
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = bitcast %struct.bpf_verifier_env* %38 to i8*
  %40 = load i32, i32* %i, align 4
  %41 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %42 = load i32, i32* %i, align 4
  %idxprom34 = sext i32 %42 to i64
  %arrayidx35 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %41, i64 %idxprom34
  %start36 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx35, i32 0, i32 0
  %43 = load i32, i32* %start36, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %39, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i64 0, i64 0), i32 noundef %40, i32 noundef %43) #8
  br label %for.inc37

for.inc37:                                        ; preds = %for.body33
  %44 = load i32, i32* %i, align 4
  %inc38 = add i32 %44, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond29

for.end39:                                        ; preds = %for.cond29
  br label %if.end40

if.end40:                                         ; preds = %for.end39, %for.end
  %45 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %46 = load i32, i32* %cur_subprog, align 4
  %idxprom41 = sext i32 %46 to i64
  %arrayidx42 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %45, i64 %idxprom41
  %start43 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx42, i32 0, i32 0
  %47 = load i32, i32* %start43, align 4
  store i32 %47, i32* %subprog_start, align 4
  %48 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %49 = load i32, i32* %cur_subprog, align 4
  %add44 = add i32 %49, 1
  %idxprom45 = sext i32 %add44 to i64
  %arrayidx46 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %48, i64 %idxprom45
  %start47 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx46, i32 0, i32 0
  %50 = load i32, i32* %start47, align 4
  store i32 %50, i32* %subprog_end, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond48

for.cond48:                                       ; preds = %for.inc112, %if.end40
  %51 = load i32, i32* %i, align 4
  %52 = load i32, i32* %insn_cnt, align 4
  %cmp49 = icmp slt i32 %51, %52
  br i1 %cmp49, label %for.body51, label %for.end114

for.body51:                                       ; preds = %for.cond48
  %53 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %54 = load i32, i32* %i, align 4
  %idxprom53 = sext i32 %54 to i64
  %arrayidx54 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %53, i64 %idxprom53
  %code55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx54, i32 0, i32 0
  %55 = load i8, i8* %code55, align 4
  store i8 %55, i8* %code52, align 1
  %56 = load i8, i8* %code52, align 1
  %conv56 = zext i8 %56 to i32
  %and57 = and i32 %conv56, 7
  %cmp58 = icmp ne i32 %and57, 5
  br i1 %cmp58, label %land.lhs.true, label %if.end65

land.lhs.true:                                    ; preds = %for.body51
  %57 = load i8, i8* %code52, align 1
  %conv60 = zext i8 %57 to i32
  %and61 = and i32 %conv60, 7
  %cmp62 = icmp ne i32 %and61, 6
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %land.lhs.true
  br label %next

if.end65:                                         ; preds = %land.lhs.true, %for.body51
  %58 = load i8, i8* %code52, align 1
  %conv66 = zext i8 %58 to i32
  %and67 = and i32 %conv66, 240
  %cmp68 = icmp eq i32 %and67, 144
  br i1 %cmp68, label %if.then74, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end65
  %59 = load i8, i8* %code52, align 1
  %conv70 = zext i8 %59 to i32
  %and71 = and i32 %conv70, 240
  %cmp72 = icmp eq i32 %and71, 128
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %lor.lhs.false, %if.end65
  br label %next

if.end75:                                         ; preds = %lor.lhs.false
  %60 = load i32, i32* %i, align 4
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %62 = load i32, i32* %i, align 4
  %idxprom76 = sext i32 %62 to i64
  %arrayidx77 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %61, i64 %idxprom76
  %off78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx77, i32 0, i32 2
  %63 = load i16, i16* %off78, align 2
  %conv79 = sext i16 %63 to i32
  %add80 = add i32 %60, %conv79
  %add81 = add i32 %add80, 1
  store i32 %add81, i32* %off, align 4
  %64 = load i32, i32* %off, align 4
  %65 = load i32, i32* %subprog_start, align 4
  %cmp82 = icmp slt i32 %64, %65
  br i1 %cmp82, label %if.then87, label %lor.lhs.false84

lor.lhs.false84:                                  ; preds = %if.end75
  %66 = load i32, i32* %off, align 4
  %67 = load i32, i32* %subprog_end, align 4
  %cmp85 = icmp sge i32 %66, %67
  br i1 %cmp85, label %if.then87, label %if.end88

if.then87:                                        ; preds = %lor.lhs.false84, %if.end75
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = bitcast %struct.bpf_verifier_env* %68 to i8*
  %70 = load i32, i32* %i, align 4
  %71 = load i32, i32* %off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %69, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23, i64 0, i64 0), i32 noundef %70, i32 noundef %71) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end88:                                         ; preds = %lor.lhs.false84
  br label %next

next:                                             ; preds = %if.end88, %if.then74, %if.then64
  %72 = load i32, i32* %i, align 4
  %73 = load i32, i32* %subprog_end, align 4
  %sub = sub i32 %73, 1
  %cmp89 = icmp eq i32 %72, %sub
  br i1 %cmp89, label %if.then91, label %if.end111

if.then91:                                        ; preds = %next
  %74 = load i8, i8* %code52, align 1
  %conv92 = zext i8 %74 to i32
  %cmp93 = icmp ne i32 %conv92, 149
  br i1 %cmp93, label %land.lhs.true95, label %if.end100

land.lhs.true95:                                  ; preds = %if.then91
  %75 = load i8, i8* %code52, align 1
  %conv96 = zext i8 %75 to i32
  %cmp97 = icmp ne i32 %conv96, 5
  br i1 %cmp97, label %if.then99, label %if.end100

if.then99:                                        ; preds = %land.lhs.true95
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = bitcast %struct.bpf_verifier_env* %76 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %77, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.24, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end100:                                        ; preds = %land.lhs.true95, %if.then91
  %78 = load i32, i32* %subprog_end, align 4
  store i32 %78, i32* %subprog_start, align 4
  %79 = load i32, i32* %cur_subprog, align 4
  %inc101 = add i32 %79, 1
  store i32 %inc101, i32* %cur_subprog, align 4
  %80 = load i32, i32* %cur_subprog, align 4
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt102 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 21
  %82 = load i32, i32* %subprog_cnt102, align 8
  %cmp103 = icmp ult i32 %80, %82
  br i1 %cmp103, label %if.then105, label %if.end110

if.then105:                                       ; preds = %if.end100
  %83 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %84 = load i32, i32* %cur_subprog, align 4
  %add106 = add i32 %84, 1
  %idxprom107 = sext i32 %add106 to i64
  %arrayidx108 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %83, i64 %idxprom107
  %start109 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx108, i32 0, i32 0
  %85 = load i32, i32* %start109, align 4
  store i32 %85, i32* %subprog_end, align 4
  br label %if.end110

if.end110:                                        ; preds = %if.then105, %if.end100
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %next
  br label %for.inc112

for.inc112:                                       ; preds = %if.end111
  %86 = load i32, i32* %i, align 4
  %inc113 = add i32 %86, 1
  store i32 %inc113, i32* %i, align 4
  br label %for.cond48

for.end114:                                       ; preds = %for.cond48
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end114, %if.then99, %if.then87, %if.then23, %if.then15, %if.then
  %87 = load i32, i32* %retval, align 4
  ret i32 %87
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_info(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %btf = alloca %struct.btf*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  %0 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %1 = bitcast %union.bpf_attr* %0 to %struct.anon.1*
  %func_info_cnt = getelementptr inbounds %struct.anon.1, %struct.anon.1* %1, i32 0, i32 15
  %2 = load i32, i32* %func_info_cnt, align 8
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.1*
  %line_info_cnt = getelementptr inbounds %struct.anon.1, %struct.anon.1* %4, i32 0, i32 18
  %5 = load i32, i32* %line_info_cnt, align 8
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %6 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %7 = bitcast %union.bpf_attr* %6 to %struct.anon.1*
  %prog_btf_fd = getelementptr inbounds %struct.anon.1, %struct.anon.1* %7, i32 0, i32 12
  %8 = load i32, i32* %prog_btf_fd, align 8
  %call = call %struct.btf* @btf_get_by_fd(i32 noundef %8) #8
  store %struct.btf* %call, %struct.btf** %btf, align 8
  %9 = load %struct.btf*, %struct.btf** %btf, align 8
  %10 = bitcast %struct.btf* %9 to i8*
  %call2 = call zeroext i1 @IS_ERR(i8* noundef %10) #8
  br i1 %call2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %11 = load %struct.btf*, %struct.btf** %btf, align 8
  %12 = bitcast %struct.btf* %11 to i8*
  %call4 = call i64 @PTR_ERR(i8* noundef %12) #8
  %conv = trunc i64 %call4 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %13 = load %struct.btf*, %struct.btf** %btf, align 8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 7
  %16 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf6 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %16, i32 0, i32 24
  store %struct.btf* %13, %struct.btf** %btf6, align 8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %19 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %call7 = call i32 @check_btf_func(%struct.bpf_verifier_env* noundef %17, %union.bpf_attr* noundef %18, %union.bpf_attr* noundef %19) #8
  store i32 %call7, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool8 = icmp ne i32 %20, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end5
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %24 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %call11 = call i32 @check_btf_line(%struct.bpf_verifier_env* noundef %22, %union.bpf_attr* noundef %23, %union.bpf_attr* noundef %24) #8
  store i32 %call11, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool12 = icmp ne i32 %25, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %26 = load i32, i32* %err, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end10
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then9, %if.then3, %if.then
  %27 = load i32, i32* %retval, align 4
  ret i32 %27
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cfg(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %opcode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %2 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i32 0, i32* %ret, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %conv = sext i32 %6 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv, i64 noundef 4, i32 noundef 3264) #8
  %7 = bitcast i8* %call to i32*
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 20
  %insn_state2 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg, i32 0, i32 0
  store i32* %7, i32** %insn_state2, align 8
  store i32* %7, i32** %insn_state, align 8
  %9 = load i32*, i32** %insn_state, align 8
  %tobool = icmp ne i32* %9, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i32, i32* %insn_cnt, align 4
  %conv3 = sext i32 %10 to i64
  %call4 = call i8* @kvcalloc(i64 noundef %conv3, i64 noundef 4, i32 noundef 3264) #8
  %11 = bitcast i8* %call4 to i32*
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 20
  %insn_stack6 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg5, i32 0, i32 1
  store i32* %11, i32** %insn_stack6, align 8
  store i32* %11, i32** %insn_stack, align 8
  %13 = load i32*, i32** %insn_stack, align 8
  %tobool7 = icmp ne i32* %13, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  %14 = load i32*, i32** %insn_state, align 8
  %15 = bitcast i32* %14 to i8*
  call void @kvfree(i8* noundef %15) #8
  store i32 -12, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %16 = load i32*, i32** %insn_state, align 8
  %arrayidx = getelementptr i32, i32* %16, i64 0
  store i32 16, i32* %arrayidx, align 4
  %17 = load i32*, i32** %insn_stack, align 8
  %arrayidx10 = getelementptr i32, i32* %17, i64 0
  store i32 0, i32* %arrayidx10, align 4
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 20
  %cur_stack = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg11, i32 0, i32 2
  store i32 1, i32* %cur_stack, align 8
  br label %peek_stack

peek_stack:                                       ; preds = %if.end176, %if.then161, %if.then146, %if.then130, %if.then106, %if.then76, %if.then50, %if.end9
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 20
  %cur_stack13 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg12, i32 0, i32 2
  %20 = load i32, i32* %cur_stack13, align 8
  %cmp = icmp eq i32 %20, 0
  br i1 %cmp, label %if.then15, label %if.end16

if.then15:                                        ; preds = %peek_stack
  br label %check_state

if.end16:                                         ; preds = %peek_stack
  %21 = load i32*, i32** %insn_stack, align 8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg17 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 20
  %cur_stack18 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg17, i32 0, i32 2
  %23 = load i32, i32* %cur_stack18, align 8
  %sub = sub i32 %23, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx19 = getelementptr i32, i32* %21, i64 %idxprom
  %24 = load i32, i32* %arrayidx19, align 4
  store i32 %24, i32* %t, align 4
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %26 = load i32, i32* %t, align 4
  %idxprom20 = sext i32 %26 to i64
  %arrayidx21 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %25, i64 %idxprom20
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx21, i32 0, i32 0
  %27 = load i8, i8* %code, align 4
  %conv22 = zext i8 %27 to i32
  %and = and i32 %conv22, 7
  %cmp23 = icmp eq i32 %and, 5
  br i1 %cmp23, label %if.then32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end16
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %29 = load i32, i32* %t, align 4
  %idxprom25 = sext i32 %29 to i64
  %arrayidx26 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %28, i64 %idxprom25
  %code27 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx26, i32 0, i32 0
  %30 = load i8, i8* %code27, align 4
  %conv28 = zext i8 %30 to i32
  %and29 = and i32 %conv28, 7
  %cmp30 = icmp eq i32 %and29, 6
  br i1 %cmp30, label %if.then32, label %if.else156

if.then32:                                        ; preds = %lor.lhs.false, %if.end16
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %32 = load i32, i32* %t, align 4
  %idxprom33 = sext i32 %32 to i64
  %arrayidx34 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %31, i64 %idxprom33
  %code35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx34, i32 0, i32 0
  %33 = load i8, i8* %code35, align 4
  %conv36 = zext i8 %33 to i32
  %and37 = and i32 %conv36, 240
  %conv38 = trunc i32 %and37 to i8
  store i8 %conv38, i8* %opcode, align 1
  %34 = load i8, i8* %opcode, align 1
  %conv39 = zext i8 %34 to i32
  %cmp40 = icmp eq i32 %conv39, 144
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.then32
  br label %mark_explored

if.else:                                          ; preds = %if.then32
  %35 = load i8, i8* %opcode, align 1
  %conv43 = zext i8 %35 to i32
  %cmp44 = icmp eq i32 %conv43, 128
  br i1 %cmp44, label %if.then46, label %if.else84

if.then46:                                        ; preds = %if.else
  %36 = load i32, i32* %t, align 4
  %37 = load i32, i32* %t, align 4
  %add = add i32 %37, 1
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call47 = call i32 @push_insn(i32 noundef %36, i32 noundef %add, i32 noundef 1, %struct.bpf_verifier_env* noundef %38, i1 noundef zeroext false) #8
  store i32 %call47, i32* %ret, align 4
  %39 = load i32, i32* %ret, align 4
  %cmp48 = icmp eq i32 %39, 1
  br i1 %cmp48, label %if.then50, label %if.else51

if.then50:                                        ; preds = %if.then46
  br label %peek_stack

if.else51:                                        ; preds = %if.then46
  %40 = load i32, i32* %ret, align 4
  %cmp52 = icmp slt i32 %40, 0
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.else51
  br label %err_free

if.end55:                                         ; preds = %if.else51
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  %41 = load i32, i32* %t, align 4
  %add57 = add i32 %41, 1
  %42 = load i32, i32* %insn_cnt, align 4
  %cmp58 = icmp slt i32 %add57, %42
  br i1 %cmp58, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.end56
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load i32, i32* %t, align 4
  %add61 = add i32 %44, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %43, i32 noundef %add61) #8
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.end56
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %46 = load i32, i32* %t, align 4
  %idxprom63 = sext i32 %46 to i64
  %arrayidx64 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %45, i64 %idxprom63
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx64, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv65 = zext i8 %bf.lshr to i32
  %cmp66 = icmp eq i32 %conv65, 1
  br i1 %cmp66, label %if.then68, label %if.end83

if.then68:                                        ; preds = %if.end62
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load i32, i32* %t, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %47, i32 noundef %48) #8
  %49 = load i32, i32* %t, align 4
  %50 = load i32, i32* %t, align 4
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %52 = load i32, i32* %t, align 4
  %idxprom69 = sext i32 %52 to i64
  %arrayidx70 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %51, i64 %idxprom69
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx70, i32 0, i32 3
  %53 = load i32, i32* %imm, align 4
  %add71 = add i32 %50, %53
  %add72 = add i32 %add71, 1
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call73 = call i32 @push_insn(i32 noundef %49, i32 noundef %add72, i32 noundef 2, %struct.bpf_verifier_env* noundef %54, i1 noundef zeroext false) #8
  store i32 %call73, i32* %ret, align 4
  %55 = load i32, i32* %ret, align 4
  %cmp74 = icmp eq i32 %55, 1
  br i1 %cmp74, label %if.then76, label %if.else77

if.then76:                                        ; preds = %if.then68
  br label %peek_stack

if.else77:                                        ; preds = %if.then68
  %56 = load i32, i32* %ret, align 4
  %cmp78 = icmp slt i32 %56, 0
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.else77
  br label %err_free

if.end81:                                         ; preds = %if.else77
  br label %if.end82

if.end82:                                         ; preds = %if.end81
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.end62
  br label %if.end154

if.else84:                                        ; preds = %if.else
  %57 = load i8, i8* %opcode, align 1
  %conv85 = zext i8 %57 to i32
  %cmp86 = icmp eq i32 %conv85, 0
  br i1 %cmp86, label %if.then88, label %if.else125

if.then88:                                        ; preds = %if.else84
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %59 = load i32, i32* %t, align 4
  %idxprom89 = sext i32 %59 to i64
  %arrayidx90 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %58, i64 %idxprom89
  %code91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx90, i32 0, i32 0
  %60 = load i8, i8* %code91, align 4
  %conv92 = zext i8 %60 to i32
  %and93 = and i32 %conv92, 8
  %cmp94 = icmp ne i32 %and93, 0
  br i1 %cmp94, label %if.then96, label %if.end97

if.then96:                                        ; preds = %if.then88
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end97:                                         ; preds = %if.then88
  %61 = load i32, i32* %t, align 4
  %62 = load i32, i32* %t, align 4
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %64 = load i32, i32* %t, align 4
  %idxprom98 = sext i32 %64 to i64
  %arrayidx99 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %63, i64 %idxprom98
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx99, i32 0, i32 2
  %65 = load i16, i16* %off, align 2
  %conv100 = sext i16 %65 to i32
  %add101 = add i32 %62, %conv100
  %add102 = add i32 %add101, 1
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call103 = call i32 @push_insn(i32 noundef %61, i32 noundef %add102, i32 noundef 1, %struct.bpf_verifier_env* noundef %66, i1 noundef zeroext true) #8
  store i32 %call103, i32* %ret, align 4
  %67 = load i32, i32* %ret, align 4
  %cmp104 = icmp eq i32 %67, 1
  br i1 %cmp104, label %if.then106, label %if.else107

if.then106:                                       ; preds = %if.end97
  br label %peek_stack

if.else107:                                       ; preds = %if.end97
  %68 = load i32, i32* %ret, align 4
  %cmp108 = icmp slt i32 %68, 0
  br i1 %cmp108, label %if.then110, label %if.end111

if.then110:                                       ; preds = %if.else107
  br label %err_free

if.end111:                                        ; preds = %if.else107
  br label %if.end112

if.end112:                                        ; preds = %if.end111
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load i32, i32* %t, align 4
  %71 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %72 = load i32, i32* %t, align 4
  %idxprom113 = sext i32 %72 to i64
  %arrayidx114 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %71, i64 %idxprom113
  %off115 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx114, i32 0, i32 2
  %73 = load i16, i16* %off115, align 2
  %conv116 = sext i16 %73 to i32
  %add117 = add i32 %70, %conv116
  %add118 = add i32 %add117, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %69, i32 noundef %add118) #8
  %74 = load i32, i32* %t, align 4
  %add119 = add i32 %74, 1
  %75 = load i32, i32* %insn_cnt, align 4
  %cmp120 = icmp slt i32 %add119, %75
  br i1 %cmp120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %if.end112
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = load i32, i32* %t, align 4
  %add123 = add i32 %77, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %76, i32 noundef %add123) #8
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %if.end112
  br label %if.end153

if.else125:                                       ; preds = %if.else84
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = load i32, i32* %t, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %78, i32 noundef %79) #8
  %80 = load i32, i32* %t, align 4
  %81 = load i32, i32* %t, align 4
  %add126 = add i32 %81, 1
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call127 = call i32 @push_insn(i32 noundef %80, i32 noundef %add126, i32 noundef 1, %struct.bpf_verifier_env* noundef %82, i1 noundef zeroext true) #8
  store i32 %call127, i32* %ret, align 4
  %83 = load i32, i32* %ret, align 4
  %cmp128 = icmp eq i32 %83, 1
  br i1 %cmp128, label %if.then130, label %if.else131

if.then130:                                       ; preds = %if.else125
  br label %peek_stack

if.else131:                                       ; preds = %if.else125
  %84 = load i32, i32* %ret, align 4
  %cmp132 = icmp slt i32 %84, 0
  br i1 %cmp132, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.else131
  br label %err_free

if.end135:                                        ; preds = %if.else131
  br label %if.end136

if.end136:                                        ; preds = %if.end135
  %85 = load i32, i32* %t, align 4
  %86 = load i32, i32* %t, align 4
  %87 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %88 = load i32, i32* %t, align 4
  %idxprom137 = sext i32 %88 to i64
  %arrayidx138 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %87, i64 %idxprom137
  %off139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx138, i32 0, i32 2
  %89 = load i16, i16* %off139, align 2
  %conv140 = sext i16 %89 to i32
  %add141 = add i32 %86, %conv140
  %add142 = add i32 %add141, 1
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call143 = call i32 @push_insn(i32 noundef %85, i32 noundef %add142, i32 noundef 2, %struct.bpf_verifier_env* noundef %90, i1 noundef zeroext true) #8
  store i32 %call143, i32* %ret, align 4
  %91 = load i32, i32* %ret, align 4
  %cmp144 = icmp eq i32 %91, 1
  br i1 %cmp144, label %if.then146, label %if.else147

if.then146:                                       ; preds = %if.end136
  br label %peek_stack

if.else147:                                       ; preds = %if.end136
  %92 = load i32, i32* %ret, align 4
  %cmp148 = icmp slt i32 %92, 0
  br i1 %cmp148, label %if.then150, label %if.end151

if.then150:                                       ; preds = %if.else147
  br label %err_free

if.end151:                                        ; preds = %if.else147
  br label %if.end152

if.end152:                                        ; preds = %if.end151
  br label %if.end153

if.end153:                                        ; preds = %if.end152, %if.end124
  br label %if.end154

if.end154:                                        ; preds = %if.end153, %if.end83
  br label %if.end155

if.end155:                                        ; preds = %if.end154
  br label %if.end168

if.else156:                                       ; preds = %lor.lhs.false
  %93 = load i32, i32* %t, align 4
  %94 = load i32, i32* %t, align 4
  %add157 = add i32 %94, 1
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call158 = call i32 @push_insn(i32 noundef %93, i32 noundef %add157, i32 noundef 1, %struct.bpf_verifier_env* noundef %95, i1 noundef zeroext false) #8
  store i32 %call158, i32* %ret, align 4
  %96 = load i32, i32* %ret, align 4
  %cmp159 = icmp eq i32 %96, 1
  br i1 %cmp159, label %if.then161, label %if.else162

if.then161:                                       ; preds = %if.else156
  br label %peek_stack

if.else162:                                       ; preds = %if.else156
  %97 = load i32, i32* %ret, align 4
  %cmp163 = icmp slt i32 %97, 0
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.else162
  br label %err_free

if.end166:                                        ; preds = %if.else162
  br label %if.end167

if.end167:                                        ; preds = %if.end166
  br label %if.end168

if.end168:                                        ; preds = %if.end167, %if.end155
  br label %mark_explored

mark_explored:                                    ; preds = %if.end168, %if.then42
  %98 = load i32*, i32** %insn_state, align 8
  %99 = load i32, i32* %t, align 4
  %idxprom169 = sext i32 %99 to i64
  %arrayidx170 = getelementptr i32, i32* %98, i64 %idxprom169
  store i32 32, i32* %arrayidx170, align 4
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg171 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %100, i32 0, i32 20
  %cur_stack172 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg171, i32 0, i32 2
  %101 = load i32, i32* %cur_stack172, align 8
  %dec = add i32 %101, -1
  store i32 %dec, i32* %cur_stack172, align 8
  %cmp173 = icmp sle i32 %101, 0
  br i1 %cmp173, label %if.then175, label %if.end176

if.then175:                                       ; preds = %mark_explored
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = bitcast %struct.bpf_verifier_env* %102 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %103, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.40, i64 0, i64 0)) #8
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end176:                                        ; preds = %mark_explored
  br label %peek_stack

check_state:                                      ; preds = %if.then15
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %check_state
  %104 = load i32, i32* %i, align 4
  %105 = load i32, i32* %insn_cnt, align 4
  %cmp177 = icmp slt i32 %104, %105
  br i1 %cmp177, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %106 = load i32*, i32** %insn_state, align 8
  %107 = load i32, i32* %i, align 4
  %idxprom179 = sext i32 %107 to i64
  %arrayidx180 = getelementptr i32, i32* %106, i64 %idxprom179
  %108 = load i32, i32* %arrayidx180, align 4
  %cmp181 = icmp ne i32 %108, 32
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %for.body
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %110 = bitcast %struct.bpf_verifier_env* %109 to i8*
  %111 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %110, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.41, i64 0, i64 0), i32 noundef %111) #8
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end184:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end184
  %112 = load i32, i32* %i, align 4
  %inc = add i32 %112, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %ret, align 4
  br label %err_free

err_free:                                         ; preds = %for.end, %if.then183, %if.then175, %if.then165, %if.then150, %if.then134, %if.then110, %if.then96, %if.then80, %if.then54
  %113 = load i32*, i32** %insn_state, align 8
  %114 = bitcast i32* %113 to i8*
  call void @kvfree(i8* noundef %114) #8
  %115 = load i32*, i32** %insn_stack, align 8
  %116 = bitcast i32* %115 to i8*
  call void @kvfree(i8* noundef %116) #8
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg185 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %117, i32 0, i32 20
  %insn_stack186 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg185, i32 0, i32 1
  store i32* null, i32** %insn_stack186, align 8
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg187 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %118, i32 0, i32 20
  %insn_state188 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg187, i32 0, i32 0
  store i32* null, i32** %insn_state188, align 8
  %119 = load i32, i32* %ret, align 4
  store i32 %119, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.then8, %if.then
  %120 = load i32, i32* %retval, align 4
  ret i32 %120
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %pfo_ret__.i.i = alloca %struct.task_struct*, align 8
  %tmp.i.i = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %insn_cnt = alloca i32, align 4
  %do_print_state = alloca i8, align 1
  %prev_insn_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %err = alloca i32, align 4
  %tmp = alloca i32, align 4
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %prev_src_type = alloca i32*, align 8
  %src_reg_type = alloca i32, align 4
  %prev_dst_type = alloca i32*, align 8
  %dst_reg_type = alloca i32, align 4
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %2 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i8 0, i8* %do_print_state, align 1
  store i32 -1, i32* %prev_insn_idx, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 17
  store %struct.ethtool_pauseparam* null, %struct.ethtool_pauseparam** %prev_linfo, align 8
  %call = call i8* @kzalloc(i64 noundef 120, i32 noundef 3264) #8
  %7 = bitcast i8* %call to %struct.bpf_verifier_state*
  store %struct.bpf_verifier_state* %7, %struct.bpf_verifier_state** %state, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 4
  store i32 0, i32* %curframe, align 8
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 6
  store i8 0, i8* %speculative, align 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 2
  store i32 1, i32* %branches, align 8
  %call2 = call i8* @kzalloc(i64 noundef 1184, i32 noundef 3264) #8
  %12 = bitcast i8* %call2 to %struct.bpf_func_state*
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  store %struct.bpf_func_state* %12, %struct.bpf_func_state** %arrayidx, align 8
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 0
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 0
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  %tobool5 = icmp ne %struct.bpf_func_state* %15, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %17 = bitcast %struct.bpf_verifier_state* %16 to i8*
  call void @kfree(i8* noundef %17) #8
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 8
  store %struct.bpf_verifier_state* %18, %struct.bpf_verifier_state** %cur_state, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 0
  %arrayidx9 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame8, i64 0, i64 0
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx9, align 8
  call void @init_func_state(%struct.bpf_verifier_env* noundef %20, %struct.bpf_func_state* noundef %22, i32 noundef -1, i32 noundef 0, i32 noundef 0) #8
  br label %for.cond

for.cond:                                         ; preds = %if.end558, %if.else501, %if.end474, %if.end423, %if.end187, %if.end7
  %23 = load i32, i32* %prev_insn_idx, align 4
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 1
  store i32 %23, i32* %prev_insn_idx10, align 4
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 0
  %26 = load i32, i32* %insn_idx, align 8
  %27 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp uge i32 %26, %27
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %for.cond
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 0
  %31 = load i32, i32* %insn_idx12, align 8
  %32 = load i32, i32* %insn_cnt, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.46, i64 0, i64 0), i32 noundef %31, i32 noundef %32) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %for.cond
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 0
  %35 = load i32, i32* %insn_idx14, align 8
  %idxprom = zext i32 %35 to i64
  %arrayidx15 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i64 %idxprom
  store %struct.bpf_insn* %arrayidx15, %struct.bpf_insn** %insn, align 8
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 0
  %37 = load i8, i8* %code, align 4
  %conv = zext i8 %37 to i32
  %and = and i32 %conv, 7
  %conv16 = trunc i32 %and to i8
  store i8 %conv16, i8* %class, align 1
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 23
  %39 = load i32, i32* %insn_processed, align 8
  %inc = add i32 %39, 1
  store i32 %inc, i32* %insn_processed, align 8
  %cmp17 = icmp ugt i32 %inc, 1000000
  br i1 %cmp17, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end13
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 23
  %43 = load i32, i32* %insn_processed20, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.47, i64 0, i64 0), i32 noundef %43) #8
  store i32 -7, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end13
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx22 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 0
  %46 = load i32, i32* %insn_idx22, align 8
  %call23 = call i32 @is_state_visited(%struct.bpf_verifier_env* noundef %44, i32 noundef %46) #8
  store i32 %call23, i32* %err, align 4
  %47 = load i32, i32* %err, align 4
  %cmp24 = icmp slt i32 %47, 0
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end21
  %48 = load i32, i32* %err, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end21
  %49 = load i32, i32* %err, align 4
  %cmp28 = icmp eq i32 %49, 1
  br i1 %cmp28, label %if.then30, label %if.end45

if.then30:                                        ; preds = %if.end27
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %51 = load i32, i32* %level, align 8
  %and31 = and i32 %51, 3
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end44

if.then33:                                        ; preds = %if.then30
  %52 = load i8, i8* %do_print_state, align 1
  %tobool34 = trunc i8 %52 to i1
  br i1 %tobool34, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.then33
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx36 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 1
  %56 = load i32, i32* %prev_insn_idx36, align 4
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx37 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 0
  %58 = load i32, i32* %insn_idx37, align 8
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state38 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %59, i32 0, i32 8
  %60 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state38, align 8
  %speculative39 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %60, i32 0, i32 6
  %61 = load i8, i8* %speculative39, align 8
  %tobool40 = trunc i8 %61 to i1
  %62 = zext i1 %tobool40 to i64
  %cond = select i1 %tobool40, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.49, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.50, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.48, i64 0, i64 0), i32 noundef %56, i32 noundef %58, i8* noundef %cond) #8
  br label %if.end43

if.else:                                          ; preds = %if.then33
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = bitcast %struct.bpf_verifier_env* %63 to i8*
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx42 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %65, i32 0, i32 0
  %66 = load i32, i32* %insn_idx42, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %64, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.51, i64 0, i64 0), i32 noundef %66) #8
  br label %if.end43

if.end43:                                         ; preds = %if.else, %if.then35
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.then30
  br label %process_bpf_exit

if.end45:                                         ; preds = %if.end27
  %67 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #12, !srcloc !11
  store %struct.task_struct* %67, %struct.task_struct** %pfo_ret__.i, align 8
  %68 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %68, %struct.task_struct** %tmp.i, align 8
  %69 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call47 = call i32 @signal_pending(%struct.task_struct* noundef %69) #8
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end45
  store i32 -11, i32* %retval, align 4
  br label %return

if.end50:                                         ; preds = %if.end45
  %70 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #12, !srcloc !11
  store %struct.task_struct* %70, %struct.task_struct** %pfo_ret__.i.i, align 8
  %71 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i.i, align 8
  store %struct.task_struct* %71, %struct.task_struct** %tmp.i.i, align 8
  %72 = load %struct.task_struct*, %struct.task_struct** %tmp.i.i, align 8
  %73 = bitcast %struct.task_struct* %72 to %struct.thread_info*
  %call1.i = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %73, i32 noundef 3) #10
  %tobool.i = icmp ne i32 %call1.i, 0
  %lnot.i = xor i1 %tobool.i, true
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %tobool.i, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.end50
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 9478, i32 noundef 0) #8
  %call53 = call i32 @_cond_resched() #8
  store i32 %call53, i32* %tmp, align 4
  %74 = load i32, i32* %tmp, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.end50
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log55 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 18
  %level56 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log55, i32 0, i32 0
  %76 = load i32, i32* %level56, align 8
  %and57 = and i32 %76, 2
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end54
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log59 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %77, i32 0, i32 18
  %level60 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log59, i32 0, i32 0
  %78 = load i32, i32* %level60, align 8
  %and61 = and i32 %78, 3
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %land.lhs.true, label %if.end85

land.lhs.true:                                    ; preds = %lor.lhs.false
  %79 = load i8, i8* %do_print_state, align 1
  %tobool63 = trunc i8 %79 to i1
  br i1 %tobool63, label %if.then65, label %if.end85

if.then65:                                        ; preds = %land.lhs.true, %if.end54
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log66 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %80, i32 0, i32 18
  %level67 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log66, i32 0, i32 0
  %81 = load i32, i32* %level67, align 8
  %and68 = and i32 %81, 2
  %tobool69 = icmp ne i32 %and68, 0
  br i1 %tobool69, label %if.then70, label %if.else72

if.then70:                                        ; preds = %if.then65
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = bitcast %struct.bpf_verifier_env* %82 to i8*
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx71 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %84, i32 0, i32 0
  %85 = load i32, i32* %insn_idx71, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %83, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.52, i64 0, i64 0), i32 noundef %85) #8
  br label %if.end80

if.else72:                                        ; preds = %if.then65
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %87 = bitcast %struct.bpf_verifier_env* %86 to i8*
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx73 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %88, i32 0, i32 1
  %89 = load i32, i32* %prev_insn_idx73, align 4
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx74 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %90, i32 0, i32 0
  %91 = load i32, i32* %insn_idx74, align 8
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %92, i32 0, i32 8
  %93 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state75, align 8
  %speculative76 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %93, i32 0, i32 6
  %94 = load i8, i8* %speculative76, align 8
  %tobool77 = trunc i8 %94 to i1
  %95 = zext i1 %tobool77 to i64
  %cond79 = select i1 %tobool77, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.49, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.50, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %87, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.53, i64 0, i64 0), i32 noundef %89, i32 noundef %91, i8* noundef %cond79) #8
  br label %if.end80

if.end80:                                         ; preds = %if.else72, %if.then70
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %97 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame81 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %97, i32 0, i32 0
  %98 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe82 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %98, i32 0, i32 4
  %99 = load i32, i32* %curframe82, align 8
  %idxprom83 = zext i32 %99 to i64
  %arrayidx84 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame81, i64 0, i64 %idxprom83
  %100 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx84, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %96, %struct.bpf_func_state* noundef %100) #8
  store i8 0, i8* %do_print_state, align 1
  br label %if.end85

if.end85:                                         ; preds = %if.end80, %land.lhs.true, %lor.lhs.false
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log86 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 18
  %level87 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log86, i32 0, i32 0
  %102 = load i32, i32* %level87, align 8
  %and88 = and i32 %102, 3
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.then90, label %if.end94

if.then90:                                        ; preds = %if.end85
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* null, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %104 = bitcast %struct.bpf_verifier_env* %103 to i8*
  store i8* %104, i8** %private_data, align 8
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx91 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %106, i32 0, i32 0
  %107 = load i32, i32* %insn_idx91, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %105, i32 noundef %107, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.54, i64 0, i64 0)) #8
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %109 = bitcast %struct.bpf_verifier_env* %108 to i8*
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx92 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %110, i32 0, i32 0
  %111 = load i32, i32* %insn_idx92, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %109, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i64 0, i64 0), i32 noundef %111) #8
  %112 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 14
  %114 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool93 = trunc i8 %114 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %112, i1 noundef zeroext %tobool93) #8
  br label %if.end94

if.end94:                                         ; preds = %if.then90, %if.end85
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog95 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 2
  %116 = load %struct.bpf_prog*, %struct.bpf_prog** %prog95, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %116, i32 0, i32 7
  %117 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call96 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %117) #8
  br i1 %call96, label %if.then97, label %if.end104

if.then97:                                        ; preds = %if.end94
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx98 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %119, i32 0, i32 0
  %120 = load i32, i32* %insn_idx98, align 8
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx99 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 1
  %122 = load i32, i32* %prev_insn_idx99, align 4
  %call100 = call i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef %118, i32 noundef %120, i32 noundef %122) #8
  store i32 %call100, i32* %err, align 4
  %123 = load i32, i32* %err, align 4
  %tobool101 = icmp ne i32 %123, 0
  br i1 %tobool101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.then97
  %124 = load i32, i32* %err, align 4
  store i32 %124, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %if.then97
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.end94
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call105 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %125) #8
  store %struct.bpf_reg_state* %call105, %struct.bpf_reg_state** %regs, align 8
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %126, i32 0, i32 16
  %127 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx106 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %128, i32 0, i32 0
  %129 = load i32, i32* %insn_idx106, align 8
  %idxprom107 = zext i32 %129 to i64
  %arrayidx108 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %127, i64 %idxprom107
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx108, i32 0, i32 3
  store i8 1, i8* %seen, align 8
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx109 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %130, i32 0, i32 0
  %131 = load i32, i32* %insn_idx109, align 8
  store i32 %131, i32* %prev_insn_idx, align 4
  %132 = load i8, i8* %class, align 1
  %conv110 = zext i8 %132 to i32
  %cmp111 = icmp eq i32 %conv110, 4
  br i1 %cmp111, label %if.then117, label %lor.lhs.false113

lor.lhs.false113:                                 ; preds = %if.end104
  %133 = load i8, i8* %class, align 1
  %conv114 = zext i8 %133 to i32
  %cmp115 = icmp eq i32 %conv114, 7
  br i1 %cmp115, label %if.then117, label %if.else122

if.then117:                                       ; preds = %lor.lhs.false113, %if.end104
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %135 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call118 = call i32 @check_alu_op(%struct.bpf_verifier_env* noundef %134, %struct.bpf_insn* noundef %135) #8
  store i32 %call118, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool119 = icmp ne i32 %136, 0
  br i1 %tobool119, label %if.then120, label %if.end121

if.then120:                                       ; preds = %if.then117
  %137 = load i32, i32* %err, align 4
  store i32 %137, i32* %retval, align 4
  br label %return

if.end121:                                        ; preds = %if.then117
  br label %if.end558

if.else122:                                       ; preds = %lor.lhs.false113
  %138 = load i8, i8* %class, align 1
  %conv123 = zext i8 %138 to i32
  %cmp124 = icmp eq i32 %conv123, 1
  br i1 %cmp124, label %if.then126, label %if.else172

if.then126:                                       ; preds = %if.else122
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %140 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %140, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv127 = zext i8 %bf.lshr to i32
  %call128 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %139, i32 noundef %conv127, i32 noundef 0) #8
  store i32 %call128, i32* %err, align 4
  %141 = load i32, i32* %err, align 4
  %tobool129 = icmp ne i32 %141, 0
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %if.then126
  %142 = load i32, i32* %err, align 4
  store i32 %142, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %if.then126
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %144, i32 0, i32 1
  %bf.load132 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load132, 15
  %conv133 = zext i8 %bf.clear to i32
  %call134 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %143, i32 noundef %conv133, i32 noundef 2) #8
  store i32 %call134, i32* %err, align 4
  %145 = load i32, i32* %err, align 4
  %tobool135 = icmp ne i32 %145, 0
  br i1 %tobool135, label %if.then136, label %if.end137

if.then136:                                       ; preds = %if.end131
  %146 = load i32, i32* %err, align 4
  store i32 %146, i32* %retval, align 4
  br label %return

if.end137:                                        ; preds = %if.end131
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %148 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %148, i32 0, i32 1
  %bf.load139 = load i8, i8* %src_reg138, align 1
  %bf.lshr140 = lshr i8 %bf.load139, 4
  %idxprom141 = zext i8 %bf.lshr140 to i64
  %arrayidx142 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i64 %idxprom141
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx142, i32 0, i32 0
  %149 = load i32, i32* %type, align 8
  store i32 %149, i32* %src_reg_type, align 4
  %150 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx143 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %151, i32 0, i32 0
  %152 = load i32, i32* %insn_idx143, align 8
  %153 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg144 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %153, i32 0, i32 1
  %bf.load145 = load i8, i8* %src_reg144, align 1
  %bf.lshr146 = lshr i8 %bf.load145, 4
  %conv147 = zext i8 %bf.lshr146 to i32
  %154 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %154, i32 0, i32 2
  %155 = load i16, i16* %off, align 2
  %conv148 = sext i16 %155 to i32
  %156 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code149 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %156, i32 0, i32 0
  %157 = load i8, i8* %code149, align 4
  %conv150 = zext i8 %157 to i32
  %and151 = and i32 %conv150, 24
  %158 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg152 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %158, i32 0, i32 1
  %bf.load153 = load i8, i8* %dst_reg152, align 1
  %bf.clear154 = and i8 %bf.load153, 15
  %conv155 = zext i8 %bf.clear154 to i32
  %call156 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %150, i32 noundef %152, i32 noundef %conv147, i32 noundef %conv148, i32 noundef %and151, i32 noundef 1, i32 noundef %conv155, i1 noundef zeroext false) #8
  store i32 %call156, i32* %err, align 4
  %159 = load i32, i32* %err, align 4
  %tobool157 = icmp ne i32 %159, 0
  br i1 %tobool157, label %if.then158, label %if.end159

if.then158:                                       ; preds = %if.end137
  %160 = load i32, i32* %err, align 4
  store i32 %160, i32* %retval, align 4
  br label %return

if.end159:                                        ; preds = %if.end137
  %161 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data160 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %161, i32 0, i32 16
  %162 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data160, align 8
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx161 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %163, i32 0, i32 0
  %164 = load i32, i32* %insn_idx161, align 8
  %idxprom162 = zext i32 %164 to i64
  %arrayidx163 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %162, i64 %idxprom162
  %165 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx163, i32 0, i32 0
  %ptr_type = bitcast %union.anon.13* %165 to i32*
  store i32* %ptr_type, i32** %prev_src_type, align 8
  %166 = load i32*, i32** %prev_src_type, align 8
  %167 = load i32, i32* %166, align 4
  %cmp164 = icmp eq i32 %167, 0
  br i1 %cmp164, label %if.then166, label %if.else167

if.then166:                                       ; preds = %if.end159
  %168 = load i32, i32* %src_reg_type, align 4
  %169 = load i32*, i32** %prev_src_type, align 8
  store i32 %168, i32* %169, align 4
  br label %if.end171

if.else167:                                       ; preds = %if.end159
  %170 = load i32, i32* %src_reg_type, align 4
  %171 = load i32*, i32** %prev_src_type, align 8
  %172 = load i32, i32* %171, align 4
  %call168 = call zeroext i1 @reg_type_mismatch(i32 noundef %170, i32 noundef %172) #8
  br i1 %call168, label %if.then169, label %if.end170

if.then169:                                       ; preds = %if.else167
  %173 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %174 = bitcast %struct.bpf_verifier_env* %173 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %174, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.55, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end170:                                        ; preds = %if.else167
  br label %if.end171

if.end171:                                        ; preds = %if.end170, %if.then166
  br label %if.end557

if.else172:                                       ; preds = %if.else122
  %175 = load i8, i8* %class, align 1
  %conv173 = zext i8 %175 to i32
  %cmp174 = icmp eq i32 %conv173, 3
  br i1 %cmp174, label %if.then176, label %if.else244

if.then176:                                       ; preds = %if.else172
  %176 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code177 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %176, i32 0, i32 0
  %177 = load i8, i8* %code177, align 4
  %conv178 = zext i8 %177 to i32
  %and179 = and i32 %conv178, 224
  %cmp180 = icmp eq i32 %and179, 192
  br i1 %cmp180, label %if.then182, label %if.end190

if.then182:                                       ; preds = %if.then176
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx183 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %179, i32 0, i32 0
  %180 = load i32, i32* %insn_idx183, align 8
  %181 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call184 = call i32 @check_xadd(%struct.bpf_verifier_env* noundef %178, i32 noundef %180, %struct.bpf_insn* noundef %181) #8
  store i32 %call184, i32* %err, align 4
  %182 = load i32, i32* %err, align 4
  %tobool185 = icmp ne i32 %182, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.then182
  %183 = load i32, i32* %err, align 4
  store i32 %183, i32* %retval, align 4
  br label %return

if.end187:                                        ; preds = %if.then182
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx188 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %184, i32 0, i32 0
  %185 = load i32, i32* %insn_idx188, align 8
  %inc189 = add i32 %185, 1
  store i32 %inc189, i32* %insn_idx188, align 8
  br label %for.cond

if.end190:                                        ; preds = %if.then176
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %187 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg191 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %187, i32 0, i32 1
  %bf.load192 = load i8, i8* %src_reg191, align 1
  %bf.lshr193 = lshr i8 %bf.load192, 4
  %conv194 = zext i8 %bf.lshr193 to i32
  %call195 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %186, i32 noundef %conv194, i32 noundef 0) #8
  store i32 %call195, i32* %err, align 4
  %188 = load i32, i32* %err, align 4
  %tobool196 = icmp ne i32 %188, 0
  br i1 %tobool196, label %if.then197, label %if.end198

if.then197:                                       ; preds = %if.end190
  %189 = load i32, i32* %err, align 4
  store i32 %189, i32* %retval, align 4
  br label %return

if.end198:                                        ; preds = %if.end190
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %191 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg199 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %191, i32 0, i32 1
  %bf.load200 = load i8, i8* %dst_reg199, align 1
  %bf.clear201 = and i8 %bf.load200, 15
  %conv202 = zext i8 %bf.clear201 to i32
  %call203 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %190, i32 noundef %conv202, i32 noundef 0) #8
  store i32 %call203, i32* %err, align 4
  %192 = load i32, i32* %err, align 4
  %tobool204 = icmp ne i32 %192, 0
  br i1 %tobool204, label %if.then205, label %if.end206

if.then205:                                       ; preds = %if.end198
  %193 = load i32, i32* %err, align 4
  store i32 %193, i32* %retval, align 4
  br label %return

if.end206:                                        ; preds = %if.end198
  %194 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %195 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg207 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %195, i32 0, i32 1
  %bf.load208 = load i8, i8* %dst_reg207, align 1
  %bf.clear209 = and i8 %bf.load208, 15
  %idxprom210 = zext i8 %bf.clear209 to i64
  %arrayidx211 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %194, i64 %idxprom210
  %type212 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx211, i32 0, i32 0
  %196 = load i32, i32* %type212, align 8
  store i32 %196, i32* %dst_reg_type, align 4
  %197 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx213 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %198, i32 0, i32 0
  %199 = load i32, i32* %insn_idx213, align 8
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg214 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 1
  %bf.load215 = load i8, i8* %dst_reg214, align 1
  %bf.clear216 = and i8 %bf.load215, 15
  %conv217 = zext i8 %bf.clear216 to i32
  %201 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %201, i32 0, i32 2
  %202 = load i16, i16* %off218, align 2
  %conv219 = sext i16 %202 to i32
  %203 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code220 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %203, i32 0, i32 0
  %204 = load i8, i8* %code220, align 4
  %conv221 = zext i8 %204 to i32
  %and222 = and i32 %conv221, 24
  %205 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg223 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %205, i32 0, i32 1
  %bf.load224 = load i8, i8* %src_reg223, align 1
  %bf.lshr225 = lshr i8 %bf.load224, 4
  %conv226 = zext i8 %bf.lshr225 to i32
  %call227 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %197, i32 noundef %199, i32 noundef %conv217, i32 noundef %conv219, i32 noundef %and222, i32 noundef 2, i32 noundef %conv226, i1 noundef zeroext false) #8
  store i32 %call227, i32* %err, align 4
  %206 = load i32, i32* %err, align 4
  %tobool228 = icmp ne i32 %206, 0
  br i1 %tobool228, label %if.then229, label %if.end230

if.then229:                                       ; preds = %if.end206
  %207 = load i32, i32* %err, align 4
  store i32 %207, i32* %retval, align 4
  br label %return

if.end230:                                        ; preds = %if.end206
  %208 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data231 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %208, i32 0, i32 16
  %209 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data231, align 8
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx232 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %210, i32 0, i32 0
  %211 = load i32, i32* %insn_idx232, align 8
  %idxprom233 = zext i32 %211 to i64
  %arrayidx234 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %209, i64 %idxprom233
  %212 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx234, i32 0, i32 0
  %ptr_type235 = bitcast %union.anon.13* %212 to i32*
  store i32* %ptr_type235, i32** %prev_dst_type, align 8
  %213 = load i32*, i32** %prev_dst_type, align 8
  %214 = load i32, i32* %213, align 4
  %cmp236 = icmp eq i32 %214, 0
  br i1 %cmp236, label %if.then238, label %if.else239

if.then238:                                       ; preds = %if.end230
  %215 = load i32, i32* %dst_reg_type, align 4
  %216 = load i32*, i32** %prev_dst_type, align 8
  store i32 %215, i32* %216, align 4
  br label %if.end243

if.else239:                                       ; preds = %if.end230
  %217 = load i32, i32* %dst_reg_type, align 4
  %218 = load i32*, i32** %prev_dst_type, align 8
  %219 = load i32, i32* %218, align 4
  %call240 = call zeroext i1 @reg_type_mismatch(i32 noundef %217, i32 noundef %219) #8
  br i1 %call240, label %if.then241, label %if.end242

if.then241:                                       ; preds = %if.else239
  %220 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %221 = bitcast %struct.bpf_verifier_env* %220 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %221, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.55, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end242:                                        ; preds = %if.else239
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.then238
  br label %if.end556

if.else244:                                       ; preds = %if.else172
  %222 = load i8, i8* %class, align 1
  %conv245 = zext i8 %222 to i32
  %cmp246 = icmp eq i32 %conv245, 2
  br i1 %cmp246, label %if.then248, label %if.else304

if.then248:                                       ; preds = %if.else244
  %223 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code249 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %223, i32 0, i32 0
  %224 = load i8, i8* %code249, align 4
  %conv250 = zext i8 %224 to i32
  %and251 = and i32 %conv250, 224
  %cmp252 = icmp ne i32 %and251, 96
  br i1 %cmp252, label %if.then261, label %lor.lhs.false254

lor.lhs.false254:                                 ; preds = %if.then248
  %225 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg255 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %225, i32 0, i32 1
  %bf.load256 = load i8, i8* %src_reg255, align 1
  %bf.lshr257 = lshr i8 %bf.load256, 4
  %conv258 = zext i8 %bf.lshr257 to i32
  %cmp259 = icmp ne i32 %conv258, 0
  br i1 %cmp259, label %if.then261, label %if.end262

if.then261:                                       ; preds = %lor.lhs.false254, %if.then248
  %226 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %227 = bitcast %struct.bpf_verifier_env* %226 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %227, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.56, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end262:                                        ; preds = %lor.lhs.false254
  %228 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %229 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg263 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %229, i32 0, i32 1
  %bf.load264 = load i8, i8* %dst_reg263, align 1
  %bf.clear265 = and i8 %bf.load264, 15
  %conv266 = zext i8 %bf.clear265 to i32
  %call267 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %228, i32 noundef %conv266, i32 noundef 0) #8
  store i32 %call267, i32* %err, align 4
  %230 = load i32, i32* %err, align 4
  %tobool268 = icmp ne i32 %230, 0
  br i1 %tobool268, label %if.then269, label %if.end270

if.then269:                                       ; preds = %if.end262
  %231 = load i32, i32* %err, align 4
  store i32 %231, i32* %retval, align 4
  br label %return

if.end270:                                        ; preds = %if.end262
  %232 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %233 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %233, i32 0, i32 1
  %bf.load272 = load i8, i8* %dst_reg271, align 1
  %bf.clear273 = and i8 %bf.load272, 15
  %conv274 = zext i8 %bf.clear273 to i32
  %call275 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %232, i32 noundef %conv274) #8
  br i1 %call275, label %if.then276, label %if.end289

if.then276:                                       ; preds = %if.end270
  %234 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %235 = bitcast %struct.bpf_verifier_env* %234 to i8*
  %236 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg277 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %236, i32 0, i32 1
  %bf.load278 = load i8, i8* %dst_reg277, align 1
  %bf.clear279 = and i8 %bf.load278, 15
  %conv280 = zext i8 %bf.clear279 to i32
  %237 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %238 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg281 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %238, i32 0, i32 1
  %bf.load282 = load i8, i8* %dst_reg281, align 1
  %bf.clear283 = and i8 %bf.load282, 15
  %conv284 = zext i8 %bf.clear283 to i32
  %call285 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %237, i32 noundef %conv284) #8
  %type286 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call285, i32 0, i32 0
  %239 = load i32, i32* %type286, align 8
  %idxprom287 = zext i32 %239 to i64
  %arrayidx288 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom287
  %240 = load i8*, i8** %arrayidx288, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %235, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.57, i64 0, i64 0), i32 noundef %conv280, i8* noundef %240) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end289:                                        ; preds = %if.end270
  %241 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %242 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx290 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %242, i32 0, i32 0
  %243 = load i32, i32* %insn_idx290, align 8
  %244 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %244, i32 0, i32 1
  %bf.load292 = load i8, i8* %dst_reg291, align 1
  %bf.clear293 = and i8 %bf.load292, 15
  %conv294 = zext i8 %bf.clear293 to i32
  %245 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off295 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %245, i32 0, i32 2
  %246 = load i16, i16* %off295, align 2
  %conv296 = sext i16 %246 to i32
  %247 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code297 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %247, i32 0, i32 0
  %248 = load i8, i8* %code297, align 4
  %conv298 = zext i8 %248 to i32
  %and299 = and i32 %conv298, 24
  %call300 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %241, i32 noundef %243, i32 noundef %conv294, i32 noundef %conv296, i32 noundef %and299, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #8
  store i32 %call300, i32* %err, align 4
  %249 = load i32, i32* %err, align 4
  %tobool301 = icmp ne i32 %249, 0
  br i1 %tobool301, label %if.then302, label %if.end303

if.then302:                                       ; preds = %if.end289
  %250 = load i32, i32* %err, align 4
  store i32 %250, i32* %retval, align 4
  br label %return

if.end303:                                        ; preds = %if.end289
  br label %if.end555

if.else304:                                       ; preds = %if.else244
  %251 = load i8, i8* %class, align 1
  %conv305 = zext i8 %251 to i32
  %cmp306 = icmp eq i32 %conv305, 5
  br i1 %cmp306, label %if.then312, label %lor.lhs.false308

lor.lhs.false308:                                 ; preds = %if.else304
  %252 = load i8, i8* %class, align 1
  %conv309 = zext i8 %252 to i32
  %cmp310 = icmp eq i32 %conv309, 6
  br i1 %cmp310, label %if.then312, label %if.else511

if.then312:                                       ; preds = %lor.lhs.false308, %if.else304
  %253 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %253, i32 0, i32 0
  %254 = load i8, i8* %code313, align 4
  %conv314 = zext i8 %254 to i32
  %and315 = and i32 %conv314, 240
  %conv316 = trunc i32 %and315 to i8
  store i8 %conv316, i8* %opcode, align 1
  %255 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %255, i32 0, i32 25
  %256 = load i32, i32* %jmps_processed, align 8
  %inc317 = add i32 %256, 1
  store i32 %inc317, i32* %jmps_processed, align 8
  %257 = load i8, i8* %opcode, align 1
  %conv318 = zext i8 %257 to i32
  %cmp319 = icmp eq i32 %conv318, 128
  br i1 %cmp319, label %if.then321, label %if.else390

if.then321:                                       ; preds = %if.then312
  %258 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code322 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %258, i32 0, i32 0
  %259 = load i8, i8* %code322, align 4
  %conv323 = zext i8 %259 to i32
  %and324 = and i32 %conv323, 8
  %cmp325 = icmp ne i32 %and324, 0
  br i1 %cmp325, label %if.then357, label %lor.lhs.false327

lor.lhs.false327:                                 ; preds = %if.then321
  %260 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %260, i32 0, i32 2
  %261 = load i16, i16* %off328, align 2
  %conv329 = sext i16 %261 to i32
  %cmp330 = icmp ne i32 %conv329, 0
  br i1 %cmp330, label %if.then357, label %lor.lhs.false332

lor.lhs.false332:                                 ; preds = %lor.lhs.false327
  %262 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg333 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %262, i32 0, i32 1
  %bf.load334 = load i8, i8* %src_reg333, align 1
  %bf.lshr335 = lshr i8 %bf.load334, 4
  %conv336 = zext i8 %bf.lshr335 to i32
  %cmp337 = icmp ne i32 %conv336, 0
  br i1 %cmp337, label %land.lhs.true339, label %lor.lhs.false346

land.lhs.true339:                                 ; preds = %lor.lhs.false332
  %263 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg340 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %263, i32 0, i32 1
  %bf.load341 = load i8, i8* %src_reg340, align 1
  %bf.lshr342 = lshr i8 %bf.load341, 4
  %conv343 = zext i8 %bf.lshr342 to i32
  %cmp344 = icmp ne i32 %conv343, 1
  br i1 %cmp344, label %if.then357, label %lor.lhs.false346

lor.lhs.false346:                                 ; preds = %land.lhs.true339, %lor.lhs.false332
  %264 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg347 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %264, i32 0, i32 1
  %bf.load348 = load i8, i8* %dst_reg347, align 1
  %bf.clear349 = and i8 %bf.load348, 15
  %conv350 = zext i8 %bf.clear349 to i32
  %cmp351 = icmp ne i32 %conv350, 0
  br i1 %cmp351, label %if.then357, label %lor.lhs.false353

lor.lhs.false353:                                 ; preds = %lor.lhs.false346
  %265 = load i8, i8* %class, align 1
  %conv354 = zext i8 %265 to i32
  %cmp355 = icmp eq i32 %conv354, 6
  br i1 %cmp355, label %if.then357, label %if.end358

if.then357:                                       ; preds = %lor.lhs.false353, %lor.lhs.false346, %land.lhs.true339, %lor.lhs.false327, %if.then321
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %267 = bitcast %struct.bpf_verifier_env* %266 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %267, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.58, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end358:                                        ; preds = %lor.lhs.false353
  %268 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state359 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %268, i32 0, i32 8
  %269 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state359, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %269, i32 0, i32 5
  %270 = load i32, i32* %active_spin_lock, align 4
  %tobool360 = icmp ne i32 %270, 0
  br i1 %tobool360, label %land.lhs.true361, label %if.end372

land.lhs.true361:                                 ; preds = %if.end358
  %271 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg362 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %271, i32 0, i32 1
  %bf.load363 = load i8, i8* %src_reg362, align 1
  %bf.lshr364 = lshr i8 %bf.load363, 4
  %conv365 = zext i8 %bf.lshr364 to i32
  %cmp366 = icmp eq i32 %conv365, 1
  br i1 %cmp366, label %if.then371, label %lor.lhs.false368

lor.lhs.false368:                                 ; preds = %land.lhs.true361
  %272 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %272, i32 0, i32 3
  %273 = load i32, i32* %imm, align 4
  %cmp369 = icmp ne i32 %273, 94
  br i1 %cmp369, label %if.then371, label %if.end372

if.then371:                                       ; preds = %lor.lhs.false368, %land.lhs.true361
  %274 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %275 = bitcast %struct.bpf_verifier_env* %274 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %275, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.59, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end372:                                        ; preds = %lor.lhs.false368, %if.end358
  %276 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg373 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %276, i32 0, i32 1
  %bf.load374 = load i8, i8* %src_reg373, align 1
  %bf.lshr375 = lshr i8 %bf.load374, 4
  %conv376 = zext i8 %bf.lshr375 to i32
  %cmp377 = icmp eq i32 %conv376, 1
  br i1 %cmp377, label %if.then379, label %if.else382

if.then379:                                       ; preds = %if.end372
  %277 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %278 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx380 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %279, i32 0, i32 0
  %call381 = call i32 @check_func_call(%struct.bpf_verifier_env* noundef %277, %struct.bpf_insn* noundef %278, i32* noundef %insn_idx380) #8
  store i32 %call381, i32* %err, align 4
  br label %if.end386

if.else382:                                       ; preds = %if.end372
  %280 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %281 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm383 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %281, i32 0, i32 3
  %282 = load i32, i32* %imm383, align 4
  %283 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx384 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %283, i32 0, i32 0
  %284 = load i32, i32* %insn_idx384, align 8
  %call385 = call i32 @check_helper_call(%struct.bpf_verifier_env* noundef %280, i32 noundef %282, i32 noundef %284) #8
  store i32 %call385, i32* %err, align 4
  br label %if.end386

if.end386:                                        ; preds = %if.else382, %if.then379
  %285 = load i32, i32* %err, align 4
  %tobool387 = icmp ne i32 %285, 0
  br i1 %tobool387, label %if.then388, label %if.end389

if.then388:                                       ; preds = %if.end386
  %286 = load i32, i32* %err, align 4
  store i32 %286, i32* %retval, align 4
  br label %return

if.end389:                                        ; preds = %if.end386
  br label %if.end510

if.else390:                                       ; preds = %if.then312
  %287 = load i8, i8* %opcode, align 1
  %conv391 = zext i8 %287 to i32
  %cmp392 = icmp eq i32 %conv391, 0
  br i1 %cmp392, label %if.then394, label %if.else428

if.then394:                                       ; preds = %if.else390
  %288 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code395 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %288, i32 0, i32 0
  %289 = load i8, i8* %code395, align 4
  %conv396 = zext i8 %289 to i32
  %and397 = and i32 %conv396, 8
  %cmp398 = icmp ne i32 %and397, 0
  br i1 %cmp398, label %if.then422, label %lor.lhs.false400

lor.lhs.false400:                                 ; preds = %if.then394
  %290 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm401 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %290, i32 0, i32 3
  %291 = load i32, i32* %imm401, align 4
  %cmp402 = icmp ne i32 %291, 0
  br i1 %cmp402, label %if.then422, label %lor.lhs.false404

lor.lhs.false404:                                 ; preds = %lor.lhs.false400
  %292 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg405 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %292, i32 0, i32 1
  %bf.load406 = load i8, i8* %src_reg405, align 1
  %bf.lshr407 = lshr i8 %bf.load406, 4
  %conv408 = zext i8 %bf.lshr407 to i32
  %cmp409 = icmp ne i32 %conv408, 0
  br i1 %cmp409, label %if.then422, label %lor.lhs.false411

lor.lhs.false411:                                 ; preds = %lor.lhs.false404
  %293 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg412 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %293, i32 0, i32 1
  %bf.load413 = load i8, i8* %dst_reg412, align 1
  %bf.clear414 = and i8 %bf.load413, 15
  %conv415 = zext i8 %bf.clear414 to i32
  %cmp416 = icmp ne i32 %conv415, 0
  br i1 %cmp416, label %if.then422, label %lor.lhs.false418

lor.lhs.false418:                                 ; preds = %lor.lhs.false411
  %294 = load i8, i8* %class, align 1
  %conv419 = zext i8 %294 to i32
  %cmp420 = icmp eq i32 %conv419, 6
  br i1 %cmp420, label %if.then422, label %if.end423

if.then422:                                       ; preds = %lor.lhs.false418, %lor.lhs.false411, %lor.lhs.false404, %lor.lhs.false400, %if.then394
  %295 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %296 = bitcast %struct.bpf_verifier_env* %295 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %296, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.60, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end423:                                        ; preds = %lor.lhs.false418
  %297 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off424 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %297, i32 0, i32 2
  %298 = load i16, i16* %off424, align 2
  %conv425 = sext i16 %298 to i32
  %add = add i32 %conv425, 1
  %299 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx426 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %299, i32 0, i32 0
  %300 = load i32, i32* %insn_idx426, align 8
  %add427 = add i32 %300, %add
  store i32 %add427, i32* %insn_idx426, align 8
  br label %for.cond

if.else428:                                       ; preds = %if.else390
  %301 = load i8, i8* %opcode, align 1
  %conv429 = zext i8 %301 to i32
  %cmp430 = icmp eq i32 %conv429, 144
  br i1 %cmp430, label %if.then432, label %if.else502

if.then432:                                       ; preds = %if.else428
  %302 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code433 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %302, i32 0, i32 0
  %303 = load i8, i8* %code433, align 4
  %conv434 = zext i8 %303 to i32
  %and435 = and i32 %conv434, 8
  %cmp436 = icmp ne i32 %and435, 0
  br i1 %cmp436, label %if.then460, label %lor.lhs.false438

lor.lhs.false438:                                 ; preds = %if.then432
  %304 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm439 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %304, i32 0, i32 3
  %305 = load i32, i32* %imm439, align 4
  %cmp440 = icmp ne i32 %305, 0
  br i1 %cmp440, label %if.then460, label %lor.lhs.false442

lor.lhs.false442:                                 ; preds = %lor.lhs.false438
  %306 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg443 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %306, i32 0, i32 1
  %bf.load444 = load i8, i8* %src_reg443, align 1
  %bf.lshr445 = lshr i8 %bf.load444, 4
  %conv446 = zext i8 %bf.lshr445 to i32
  %cmp447 = icmp ne i32 %conv446, 0
  br i1 %cmp447, label %if.then460, label %lor.lhs.false449

lor.lhs.false449:                                 ; preds = %lor.lhs.false442
  %307 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg450 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %307, i32 0, i32 1
  %bf.load451 = load i8, i8* %dst_reg450, align 1
  %bf.clear452 = and i8 %bf.load451, 15
  %conv453 = zext i8 %bf.clear452 to i32
  %cmp454 = icmp ne i32 %conv453, 0
  br i1 %cmp454, label %if.then460, label %lor.lhs.false456

lor.lhs.false456:                                 ; preds = %lor.lhs.false449
  %308 = load i8, i8* %class, align 1
  %conv457 = zext i8 %308 to i32
  %cmp458 = icmp eq i32 %conv457, 6
  br i1 %cmp458, label %if.then460, label %if.end461

if.then460:                                       ; preds = %lor.lhs.false456, %lor.lhs.false449, %lor.lhs.false442, %lor.lhs.false438, %if.then432
  %309 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %310 = bitcast %struct.bpf_verifier_env* %309 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %310, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.61, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end461:                                        ; preds = %lor.lhs.false456
  %311 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state462 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %311, i32 0, i32 8
  %312 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state462, align 8
  %active_spin_lock463 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %312, i32 0, i32 5
  %313 = load i32, i32* %active_spin_lock463, align 4
  %tobool464 = icmp ne i32 %313, 0
  br i1 %tobool464, label %if.then465, label %if.end466

if.then465:                                       ; preds = %if.end461
  %314 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %315 = bitcast %struct.bpf_verifier_env* %314 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %315, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.62, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end466:                                        ; preds = %if.end461
  %316 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe467 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %316, i32 0, i32 4
  %317 = load i32, i32* %curframe467, align 8
  %tobool468 = icmp ne i32 %317, 0
  br i1 %tobool468, label %if.then469, label %if.end475

if.then469:                                       ; preds = %if.end466
  %318 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %319 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx470 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %319, i32 0, i32 0
  %call471 = call i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %318, i32* noundef %insn_idx470) #8
  store i32 %call471, i32* %err, align 4
  %320 = load i32, i32* %err, align 4
  %tobool472 = icmp ne i32 %320, 0
  br i1 %tobool472, label %if.then473, label %if.end474

if.then473:                                       ; preds = %if.then469
  %321 = load i32, i32* %err, align 4
  store i32 %321, i32* %retval, align 4
  br label %return

if.end474:                                        ; preds = %if.then469
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.end475:                                        ; preds = %if.end466
  %322 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call476 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %322) #8
  store i32 %call476, i32* %err, align 4
  %323 = load i32, i32* %err, align 4
  %tobool477 = icmp ne i32 %323, 0
  br i1 %tobool477, label %if.then478, label %if.end479

if.then478:                                       ; preds = %if.end475
  %324 = load i32, i32* %err, align 4
  store i32 %324, i32* %retval, align 4
  br label %return

if.end479:                                        ; preds = %if.end475
  %325 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call480 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %325, i32 noundef 0, i32 noundef 0) #8
  store i32 %call480, i32* %err, align 4
  %326 = load i32, i32* %err, align 4
  %tobool481 = icmp ne i32 %326, 0
  br i1 %tobool481, label %if.then482, label %if.end483

if.then482:                                       ; preds = %if.end479
  %327 = load i32, i32* %err, align 4
  store i32 %327, i32* %retval, align 4
  br label %return

if.end483:                                        ; preds = %if.end479
  %328 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call484 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %328, i32 noundef 0) #8
  br i1 %call484, label %if.then485, label %if.end486

if.then485:                                       ; preds = %if.end483
  %329 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %330 = bitcast %struct.bpf_verifier_env* %329 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %330, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.63, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end486:                                        ; preds = %if.end483
  %331 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call487 = call i32 @check_return_code(%struct.bpf_verifier_env* noundef %331) #8
  store i32 %call487, i32* %err, align 4
  %332 = load i32, i32* %err, align 4
  %tobool488 = icmp ne i32 %332, 0
  br i1 %tobool488, label %if.then489, label %if.end490

if.then489:                                       ; preds = %if.end486
  %333 = load i32, i32* %err, align 4
  store i32 %333, i32* %retval, align 4
  br label %return

if.end490:                                        ; preds = %if.end486
  br label %process_bpf_exit

process_bpf_exit:                                 ; preds = %if.end490, %if.end44
  %334 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %335 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state491 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %335, i32 0, i32 8
  %336 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state491, align 8
  call void @update_branch_counts(%struct.bpf_verifier_env* noundef %334, %struct.bpf_verifier_state* noundef %336) #8
  %337 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %338 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx492 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %338, i32 0, i32 0
  %call493 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %337, i32* noundef %prev_insn_idx, i32* noundef %insn_idx492) #8
  store i32 %call493, i32* %err, align 4
  %339 = load i32, i32* %err, align 4
  %cmp494 = icmp slt i32 %339, 0
  br i1 %cmp494, label %if.then496, label %if.else501

if.then496:                                       ; preds = %process_bpf_exit
  %340 = load i32, i32* %err, align 4
  %cmp497 = icmp ne i32 %340, -2
  br i1 %cmp497, label %if.then499, label %if.end500

if.then499:                                       ; preds = %if.then496
  %341 = load i32, i32* %err, align 4
  store i32 %341, i32* %retval, align 4
  br label %return

if.end500:                                        ; preds = %if.then496
  br label %for.end

if.else501:                                       ; preds = %process_bpf_exit
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.else502:                                       ; preds = %if.else428
  %342 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %343 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %344 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx503 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %344, i32 0, i32 0
  %call504 = call i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %342, %struct.bpf_insn* noundef %343, i32* noundef %insn_idx503) #8
  store i32 %call504, i32* %err, align 4
  %345 = load i32, i32* %err, align 4
  %tobool505 = icmp ne i32 %345, 0
  br i1 %tobool505, label %if.then506, label %if.end507

if.then506:                                       ; preds = %if.else502
  %346 = load i32, i32* %err, align 4
  store i32 %346, i32* %retval, align 4
  br label %return

if.end507:                                        ; preds = %if.else502
  br label %if.end508

if.end508:                                        ; preds = %if.end507
  br label %if.end509

if.end509:                                        ; preds = %if.end508
  br label %if.end510

if.end510:                                        ; preds = %if.end509, %if.end389
  br label %if.end554

if.else511:                                       ; preds = %lor.lhs.false308
  %347 = load i8, i8* %class, align 1
  %conv512 = zext i8 %347 to i32
  %cmp513 = icmp eq i32 %conv512, 0
  br i1 %cmp513, label %if.then515, label %if.else551

if.then515:                                       ; preds = %if.else511
  %348 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code516 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %348, i32 0, i32 0
  %349 = load i8, i8* %code516, align 4
  %conv517 = zext i8 %349 to i32
  %and518 = and i32 %conv517, 224
  %conv519 = trunc i32 %and518 to i8
  store i8 %conv519, i8* %mode, align 1
  %350 = load i8, i8* %mode, align 1
  %conv520 = zext i8 %350 to i32
  %cmp521 = icmp eq i32 %conv520, 32
  br i1 %cmp521, label %if.then527, label %lor.lhs.false523

lor.lhs.false523:                                 ; preds = %if.then515
  %351 = load i8, i8* %mode, align 1
  %conv524 = zext i8 %351 to i32
  %cmp525 = icmp eq i32 %conv524, 64
  br i1 %cmp525, label %if.then527, label %if.else532

if.then527:                                       ; preds = %lor.lhs.false523, %if.then515
  %352 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %353 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call528 = call i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %352, %struct.bpf_insn* noundef %353) #8
  store i32 %call528, i32* %err, align 4
  %354 = load i32, i32* %err, align 4
  %tobool529 = icmp ne i32 %354, 0
  br i1 %tobool529, label %if.then530, label %if.end531

if.then530:                                       ; preds = %if.then527
  %355 = load i32, i32* %err, align 4
  store i32 %355, i32* %retval, align 4
  br label %return

if.end531:                                        ; preds = %if.then527
  br label %if.end550

if.else532:                                       ; preds = %lor.lhs.false523
  %356 = load i8, i8* %mode, align 1
  %conv533 = zext i8 %356 to i32
  %cmp534 = icmp eq i32 %conv533, 0
  br i1 %cmp534, label %if.then536, label %if.else548

if.then536:                                       ; preds = %if.else532
  %357 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %358 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call537 = call i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %357, %struct.bpf_insn* noundef %358) #8
  store i32 %call537, i32* %err, align 4
  %359 = load i32, i32* %err, align 4
  %tobool538 = icmp ne i32 %359, 0
  br i1 %tobool538, label %if.then539, label %if.end540

if.then539:                                       ; preds = %if.then536
  %360 = load i32, i32* %err, align 4
  store i32 %360, i32* %retval, align 4
  br label %return

if.end540:                                        ; preds = %if.then536
  %361 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx541 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %361, i32 0, i32 0
  %362 = load i32, i32* %insn_idx541, align 8
  %inc542 = add i32 %362, 1
  store i32 %inc542, i32* %insn_idx541, align 8
  %363 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data543 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %363, i32 0, i32 16
  %364 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data543, align 8
  %365 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx544 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %365, i32 0, i32 0
  %366 = load i32, i32* %insn_idx544, align 8
  %idxprom545 = zext i32 %366 to i64
  %arrayidx546 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %364, i64 %idxprom545
  %seen547 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx546, i32 0, i32 3
  store i8 1, i8* %seen547, align 8
  br label %if.end549

if.else548:                                       ; preds = %if.else532
  %367 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %368 = bitcast %struct.bpf_verifier_env* %367 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %368, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.64, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end549:                                        ; preds = %if.end540
  br label %if.end550

if.end550:                                        ; preds = %if.end549, %if.end531
  br label %if.end553

if.else551:                                       ; preds = %if.else511
  %369 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %370 = bitcast %struct.bpf_verifier_env* %369 to i8*
  %371 = load i8, i8* %class, align 1
  %conv552 = zext i8 %371 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %370, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.65, i64 0, i64 0), i32 noundef %conv552) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end553:                                        ; preds = %if.end550
  br label %if.end554

if.end554:                                        ; preds = %if.end553, %if.end510
  br label %if.end555

if.end555:                                        ; preds = %if.end554, %if.end303
  br label %if.end556

if.end556:                                        ; preds = %if.end555, %if.end243
  br label %if.end557

if.end557:                                        ; preds = %if.end556, %if.end171
  br label %if.end558

if.end558:                                        ; preds = %if.end557, %if.end121
  %372 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx559 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %372, i32 0, i32 0
  %373 = load i32, i32* %insn_idx559, align 8
  %inc560 = add i32 %373, 1
  store i32 %inc560, i32* %insn_idx559, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end500
  %374 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %374, i32 0, i32 19
  %arrayidx561 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx561, i32 0, i32 2
  %375 = load i16, i16* %stack_depth, align 8
  %conv562 = zext i16 %375 to i32
  %376 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog563 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %376, i32 0, i32 2
  %377 = load %struct.bpf_prog*, %struct.bpf_prog** %prog563, align 8
  %aux564 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %377, i32 0, i32 7
  %378 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux564, align 8
  %stack_depth565 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %378, i32 0, i32 5
  store i32 %conv562, i32* %stack_depth565, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.else551, %if.else548, %if.then539, %if.then530, %if.then506, %if.then499, %if.then489, %if.then485, %if.then482, %if.then478, %if.then473, %if.then465, %if.then460, %if.then422, %if.then388, %if.then371, %if.then357, %if.then302, %if.then276, %if.then269, %if.then261, %if.then241, %if.then229, %if.then205, %if.then197, %if.then186, %if.then169, %if.then158, %if.then136, %if.then130, %if.then120, %if.then102, %if.then49, %if.then26, %if.then19, %if.then11, %if.then6, %if.then
  %379 = load i32, i32* %retval, align 4
  ret i32 %379
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext %free_self) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  %free_self.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %frombool = zext i1 %free_self to i8
  store i8 %frombool, i8* %free_self.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %5) #8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame1, i64 0, i64 %idxprom2
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %9) #8
  %10 = load i8, i8* %free_self.addr, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %12 = bitcast %struct.bpf_verifier_state* %11 to i8*
  call void @kfree(i8* noundef %12) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @pop_stack(%struct.bpf_verifier_env* noundef %env, i32* noundef %prev_insn_idx, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prev_insn_idx.addr = alloca i32*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %head = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %prev_insn_idx, i32** %prev_insn_idx.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 4
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head1, align 8
  store %struct.bpf_verifier_stack_elem* %3, %struct.bpf_verifier_stack_elem** %head, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head2, align 8
  %cmp = icmp eq %struct.bpf_verifier_stack_elem* %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %8 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %8, i32 0, i32 0
  %call = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %7, %struct.bpf_verifier_state* noundef %st) #8
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then3
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %11 = load i32*, i32** %insn_idx.addr, align 8
  %tobool8 = icmp ne i32* %11, null
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %12 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %insn_idx10 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %12, i32 0, i32 1
  %13 = load i32, i32* %insn_idx10, align 8
  %14 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %13, i32* %14, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %15 = load i32*, i32** %prev_insn_idx.addr, align 8
  %tobool12 = icmp ne i32* %15, null
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %16 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %prev_insn_idx14 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %16, i32 0, i32 2
  %17 = load i32, i32* %prev_insn_idx14, align 4
  %18 = load i32*, i32** %prev_insn_idx.addr, align 8
  store i32 %17, i32* %18, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  %19 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %19, i32 0, i32 3
  %20 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %next, align 8
  store %struct.bpf_verifier_stack_elem* %20, %struct.bpf_verifier_stack_elem** %elem, align 8
  %21 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st16 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %21, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %st16, i1 noundef zeroext false) #8
  %22 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %23 = bitcast %struct.bpf_verifier_stack_elem* %22 to i8*
  call void @kfree(i8* noundef %23) #8
  %24 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head17 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %24, %struct.bpf_verifier_stack_elem** %head17, align 8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 5
  %27 = load i32, i32* %stack_size, align 8
  %dec = add i32 %27, -1
  store i32 %dec, i32* %stack_size, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then5, %if.then
  %28 = load i32, i32* %retval, align 4
  ret i32 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_states(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sln = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 10
  %1 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  store %struct.bpf_verifier_state_list* %1, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %3, i32 0, i32 1
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  store %struct.bpf_verifier_state_list* %4, %struct.bpf_verifier_state_list** %sln, align 8
  %5 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %5, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext false) #8
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %7 = bitcast %struct.bpf_verifier_state_list* %6 to i8*
  call void @kfree(i8* noundef %7) #8
  %8 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %8, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 9
  %10 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %tobool1 = icmp ne %struct.bpf_verifier_state_list** %10, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %return

if.end:                                           ; preds = %while.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %12) #8
  %cmp = icmp ult i32 %11, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 9
  %14 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states2, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %14, i64 %idxprom
  %16 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %arrayidx, align 8
  store %struct.bpf_verifier_state_list* %16, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond3

while.cond3:                                      ; preds = %while.body5, %for.body
  %17 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool4 = icmp ne %struct.bpf_verifier_state_list* %17, null
  br i1 %tobool4, label %while.body5, label %while.end8

while.body5:                                      ; preds = %while.cond3
  %18 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next6 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %18, i32 0, i32 1
  %19 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next6, align 8
  store %struct.bpf_verifier_state_list* %19, %struct.bpf_verifier_state_list** %sln, align 8
  %20 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state7 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %20, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state7, i1 noundef zeroext false) #8
  %21 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %22 = bitcast %struct.bpf_verifier_state_list* %21 to i8*
  call void @kfree(i8* noundef %22) #8
  %23 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %23, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond3

while.end8:                                       ; preds = %while.cond3
  br label %for.inc

for.inc:                                          ; preds = %while.end8
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 9
  %26 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states9, align 8
  %27 = bitcast %struct.bpf_verifier_state_list** %26 to i8*
  call void @kvfree(i8* noundef %27) #8
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %depth = alloca i32, align 4
  %frame = alloca i32, align 4
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %ret_insn = alloca [8 x i32], align 16
  %ret_prog = alloca [8 x i32], align 16
  %__UNIQUE_ID___x153 = alloca i32, align 4
  %__UNIQUE_ID___y154 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp57 = alloca i64, align 8
  %tmp65 = alloca i64, align 8
  %__UNIQUE_ID___x156 = alloca i32, align 4
  %__UNIQUE_ID___y157 = alloca i32, align 4
  %tmp86 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %depth, align 4
  store i32 0, i32* %frame, align 4
  store i32 0, i32* %idx, align 4
  store i32 0, i32* %i, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 19
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %3 to [0 x %struct.bpf_insn]*
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  br label %process_func

process_func:                                     ; preds = %if.end76, %entry
  %4 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %5 = load i32, i32* %idx, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %6 = load i16, i16* %stack_depth, align 4
  %conv = zext i16 %6 to i32
  store i32 %conv, i32* %__UNIQUE_ID___x153, align 4
  store i32 1, i32* %__UNIQUE_ID___y154, align 4
  %7 = load i32, i32* %__UNIQUE_ID___x153, align 4
  %8 = load i32, i32* %__UNIQUE_ID___y154, align 4
  %cmp = icmp ugt i32 %7, %8
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %process_func
  %9 = load i32, i32* %__UNIQUE_ID___x153, align 4
  br label %cond.end

cond.false:                                       ; preds = %process_func
  %10 = load i32, i32* %__UNIQUE_ID___y154, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %9, %cond.true ], [ %10, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %11 = load i32, i32* %tmp, align 4
  %sub = sub i32 %11, 1
  %or = or i32 %sub, 31
  %add = add i32 %or, 1
  %12 = load i32, i32* %depth, align 4
  %add3 = add i32 %12, %add
  store i32 %add3, i32* %depth, align 4
  %13 = load i32, i32* %depth, align 4
  %cmp4 = icmp sgt i32 %13, 512
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %frame, align 4
  %add6 = add i32 %16, 1
  %17 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.282, i64 0, i64 0), i32 noundef %add6, i32 noundef %17) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  br label %continue_func

continue_func:                                    ; preds = %cond.end91, %if.end
  %18 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %19 = load i32, i32* %idx, align 4
  %add7 = add i32 %19, 1
  %idxprom8 = sext i32 %add7 to i64
  %arrayidx9 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %18, i64 %idxprom8
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx9, i32 0, i32 0
  %20 = load i32, i32* %start, align 4
  store i32 %20, i32* %subprog_end, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %continue_func
  %21 = load i32, i32* %i, align 4
  %22 = load i32, i32* %subprog_end, align 4
  %cmp10 = icmp slt i32 %21, %22
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %24 to i64
  %arrayidx13 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %23, i64 %idxprom12
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx13, i32 0, i32 0
  %25 = load i8, i8* %code, align 4
  %conv14 = zext i8 %25 to i32
  %cmp15 = icmp ne i32 %conv14, 133
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  br label %for.inc

if.end18:                                         ; preds = %for.body
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %27 to i64
  %arrayidx20 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %26, i64 %idxprom19
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx20, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv21 = zext i8 %bf.lshr to i32
  %cmp22 = icmp ne i32 %conv21, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end18
  br label %for.inc

if.end25:                                         ; preds = %if.end18
  %28 = load i32, i32* %i, align 4
  %add26 = add i32 %28, 1
  %29 = load i32, i32* %frame, align 4
  %idxprom27 = sext i32 %29 to i64
  %arrayidx28 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom27
  store i32 %add26, i32* %arrayidx28, align 4
  %30 = load i32, i32* %idx, align 4
  %31 = load i32, i32* %frame, align 4
  %idxprom29 = sext i32 %31 to i64
  %arrayidx30 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom29
  store i32 %30, i32* %arrayidx30, align 4
  %32 = load i32, i32* %i, align 4
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %34 = load i32, i32* %i, align 4
  %idxprom31 = sext i32 %34 to i64
  %arrayidx32 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i64 %idxprom31
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx32, i32 0, i32 3
  %35 = load i32, i32* %imm, align 4
  %add33 = add i32 %32, %35
  %add34 = add i32 %add33, 1
  store i32 %add34, i32* %i, align 4
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load i32, i32* %i, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %36, i32 noundef %37) #8
  store i32 %call, i32* %idx, align 4
  %38 = load i32, i32* %idx, align 4
  %cmp35 = icmp slt i32 %38, 0
  br i1 %cmp35, label %if.then37, label %if.end72

if.then37:                                        ; preds = %if.end25
  store i32 1, i32* %__ret_warn_once, align 4
  %39 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %39, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then37
  %40 = load i8, i8* @check_max_stack_depth.__warned, align 1
  %tobool38 = trunc i8 %40 to i1
  %lnot = xor i1 %tobool38, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then37
  %41 = phi i1 [ false, %if.then37 ], [ %lnot, %land.rhs ]
  %lnot39 = xor i1 %41, true
  %lnot40 = xor i1 %lnot39, true
  %lnot.ext = zext i1 %lnot40 to i32
  %conv41 = sext i32 %lnot.ext to i64
  %tobool42 = icmp ne i64 %conv41, 0
  br i1 %tobool42, label %if.then43, label %if.end64

if.then43:                                        ; preds = %land.end
  store i8 1, i8* @check_max_stack_depth.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %42 = load i32, i32* %__ret_warn_on, align 4
  %tobool44 = icmp ne i32 %42, 0
  %lnot45 = xor i1 %tobool44, true
  %lnot47 = xor i1 %lnot45, true
  %lnot.ext48 = zext i1 %lnot47 to i32
  %conv49 = sext i32 %lnot.ext48 to i64
  %tobool50 = icmp ne i64 %conv49, 0
  br i1 %tobool50, label %if.then51, label %if.end56

if.then51:                                        ; preds = %if.then43
  br label %do.body

do.body:                                          ; preds = %if.then51
  %43 = load i32, i32* %i, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.214, i64 0, i64 0), i32 noundef %43) #8
  br label %do.body52

do.body52:                                        ; preds = %do.body
  br label %do.body53

do.body53:                                        ; preds = %do.body52
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2722, i32 2313, i64 12) #9, !srcloc !12
  br label %do.end

do.end:                                           ; preds = %do.body53
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 155) #9, !srcloc !13
  br label %do.end54

do.end54:                                         ; preds = %do.end
  br label %do.end55

do.end55:                                         ; preds = %do.end54
  br label %if.end56

if.end56:                                         ; preds = %do.end55, %if.then43
  %44 = load i32, i32* %__ret_warn_on, align 4
  %tobool58 = icmp ne i32 %44, 0
  %lnot59 = xor i1 %tobool58, true
  %lnot61 = xor i1 %lnot59, true
  %lnot.ext62 = zext i1 %lnot61 to i32
  %conv63 = sext i32 %lnot.ext62 to i64
  store i64 %conv63, i64* %tmp57, align 8
  %45 = load i64, i64* %tmp57, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.end56, %land.end
  %46 = load i32, i32* %__ret_warn_once, align 4
  %tobool66 = icmp ne i32 %46, 0
  %lnot67 = xor i1 %tobool66, true
  %lnot69 = xor i1 %lnot67, true
  %lnot.ext70 = zext i1 %lnot69 to i32
  %conv71 = sext i32 %lnot.ext70 to i64
  store i64 %conv71, i64* %tmp65, align 8
  %47 = load i64, i64* %tmp65, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end72:                                         ; preds = %if.end25
  %48 = load i32, i32* %frame, align 4
  %inc = add i32 %48, 1
  store i32 %inc, i32* %frame, align 4
  %49 = load i32, i32* %frame, align 4
  %cmp73 = icmp sge i32 %49, 8
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end72
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  %52 = load i32, i32* %frame, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.283, i64 0, i64 0), i32 noundef %52) #8
  store i32 -7, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %if.end72
  br label %process_func

for.inc:                                          ; preds = %if.then24, %if.then17
  %53 = load i32, i32* %i, align 4
  %inc77 = add i32 %53, 1
  store i32 %inc77, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %54 = load i32, i32* %frame, align 4
  %cmp78 = icmp eq i32 %54, 0
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %for.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %for.end
  %55 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %56 = load i32, i32* %idx, align 4
  %idxprom82 = sext i32 %56 to i64
  %arrayidx83 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %55, i64 %idxprom82
  %stack_depth84 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx83, i32 0, i32 2
  %57 = load i16, i16* %stack_depth84, align 4
  %conv85 = zext i16 %57 to i32
  store i32 %conv85, i32* %__UNIQUE_ID___x156, align 4
  store i32 1, i32* %__UNIQUE_ID___y157, align 4
  %58 = load i32, i32* %__UNIQUE_ID___x156, align 4
  %59 = load i32, i32* %__UNIQUE_ID___y157, align 4
  %cmp87 = icmp ugt i32 %58, %59
  br i1 %cmp87, label %cond.true89, label %cond.false90

cond.true89:                                      ; preds = %if.end81
  %60 = load i32, i32* %__UNIQUE_ID___x156, align 4
  br label %cond.end91

cond.false90:                                     ; preds = %if.end81
  %61 = load i32, i32* %__UNIQUE_ID___y157, align 4
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false90, %cond.true89
  %cond92 = phi i32 [ %60, %cond.true89 ], [ %61, %cond.false90 ]
  store i32 %cond92, i32* %tmp86, align 4
  %62 = load i32, i32* %tmp86, align 4
  %sub93 = sub i32 %62, 1
  %or94 = or i32 %sub93, 31
  %add95 = add i32 %or94, 1
  %63 = load i32, i32* %depth, align 4
  %sub96 = sub i32 %63, %add95
  store i32 %sub96, i32* %depth, align 4
  %64 = load i32, i32* %frame, align 4
  %dec = add i32 %64, -1
  store i32 %dec, i32* %frame, align 4
  %65 = load i32, i32* %frame, align 4
  %idxprom97 = sext i32 %65 to i64
  %arrayidx98 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom97
  %66 = load i32, i32* %arrayidx98, align 4
  store i32 %66, i32* %i, align 4
  %67 = load i32, i32* %frame, align 4
  %idxprom99 = sext i32 %67 to i64
  %arrayidx100 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom99
  %68 = load i32, i32* %arrayidx100, align 4
  store i32 %68, i32* %idx, align 4
  br label %continue_func

return:                                           ; preds = %if.then80, %if.then75, %if.end64, %if.then
  %69 = load i32, i32* %retval, align 4
  ret i32 %69
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_hard_wire_dead_code_branches.ja, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %5 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  store i32 %8, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 0
  %12 = load i8, i8* %code, align 4
  %call = call zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %12) #8
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %13 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %14 = load i32, i32* %i, align 4
  %add = add i32 %14, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %13, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %15 = load i8, i8* %seen, align 8
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 2
  %17 = load i16, i16* %off, align 2
  %off3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 %17, i16* %off3, align 2
  br label %if.end15

if.else:                                          ; preds = %if.end
  %18 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %19 = load i32, i32* %i, align 4
  %add4 = add i32 %19, 1
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 2
  %21 = load i16, i16* %off5, align 2
  %conv = sext i16 %21 to i32
  %add6 = add i32 %add4, %conv
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %18, i64 %idxprom7
  %seen9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx8, i32 0, i32 3
  %22 = load i8, i8* %seen9, align 8
  %tobool10 = trunc i8 %22 to i1
  br i1 %tobool10, label %if.else13, label %if.then11

if.then11:                                        ; preds = %if.else
  %off12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 0, i16* %off12, align 2
  br label %if.end14

if.else13:                                        ; preds = %if.else
  br label %for.inc

if.end14:                                         ; preds = %if.then11
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then2
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %23, i32 0, i32 2
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %prog16, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %24, i32 0, i32 7
  %25 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call17 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %25) #8
  br i1 %call17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load i32, i32* %i, align 4
  call void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef %26, i32 noundef %27, %struct.bpf_insn* noundef %ja) #8
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %29 = bitcast %struct.bpf_insn* %28 to i8*
  %30 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %29, i8* align 4 %30, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.else13, %if.then
  %31 = load i32, i32* %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, i32* %i, align 4
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %32, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %j, align 4
  %add = add i32 %7, %8
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp1 = icmp slt i32 %add, %9
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %j, align 4
  %add2 = add i32 %11, %12
  %idxprom = sext i32 %add2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %13 = load i8, i8* %seen, align 8
  %tobool = trunc i8 %13 to i1
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load i32, i32* %j, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %j, align 4
  br label %while.cond

while.end:                                        ; preds = %land.end
  %16 = load i32, i32* %j, align 4
  %tobool3 = icmp ne i32 %16, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.inc

if.end:                                           ; preds = %while.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %i, align 4
  %19 = load i32, i32* %j, align 4
  %call = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #8
  store i32 %call, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %20, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog7, align 8
  %len8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 4
  %24 = load i32, i32* %len8, align 4
  store i32 %24, i32* %insn_cnt, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end6, %if.then
  %25 = load i32, i32* %i, align 4
  %inc9 = add i32 %25, 1
  store i32 %inc9, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_remove_nops.ja, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %3 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 4
  %6 = load i32, i32* %len, align 4
  store i32 %6, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %9, i64 %idxprom
  %11 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %12 = bitcast %struct.bpf_insn* %ja to i8*
  %call = call i32 @memcmp(i8* noundef %11, i8* noundef %12, i64 noundef 8) #8
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load i32, i32* %i, align 4
  %call2 = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %13, i32 noundef %14, i32 noundef 1) #8
  store i32 %call2, i32* %err, align 4
  %15 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %15, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %16 = load i32, i32* %err, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %17 = load i32, i32* %insn_cnt, align 4
  %dec = add i32 %17, -1
  store i32 %dec, i32* %insn_cnt, align 4
  %18 = load i32, i32* %i, align 4
  %dec6 = add i32 %18, -1
  store i32 %dec6, i32* %i, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end5, %if.then
  %19 = load i32, i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4
  %20 = load i32, i32* %retval, align 4
  ret i32 %20
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %trap = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.sanitize_dead_code.trap, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %5 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  store i32 %8, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %11, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %13 = load i8, i8* %seen, align 8
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %15 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %15 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %14, i64 %idx.ext
  %16 = bitcast %struct.bpf_insn* %add.ptr to i8*
  %17 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %16, i8* align 4 %17, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ops = alloca %struct.bpf_verifier_ops*, align 8
  %i = alloca i32, align 4
  %cnt = alloca i32, align 4
  %size = alloca i32, align 4
  %ctx_field_size = alloca i32, align 4
  %delta = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %insn = alloca %struct.bpf_insn*, align 8
  %target_size = alloca i32, align 4
  %size_default = alloca i32, align 4
  %off = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %type = alloca i32, align 4
  %is_narrower_load = alloca i8, align 1
  %convert_ctx_access = alloca i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, align 8
  %patch = alloca [2 x %struct.bpf_insn], align 16
  %__size = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp167 = alloca i64, align 8
  %tmp174 = alloca i32, align 4
  %size_code = alloca i8, align 1
  %shift = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral253 = alloca %struct.bpf_insn, align 4
  %.compoundliteral277 = alloca %struct.bpf_insn, align 4
  %.compoundliteral298 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 3
  %1 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops1, align 8
  store %struct.bpf_verifier_ops* %1, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  %5 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %5, i32 0, i32 2
  %6 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %6, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 15
  %8 = load i8, i8* %seen_direct_write, align 1
  %tobool2 = trunc i8 %8 to i1
  br i1 %tobool2, label %if.then, label %if.end22

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue3 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 2
  %10 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue3, align 8
  %tobool4 = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %10, null
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %13 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue6 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %13, i32 0, i32 2
  %14 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue6, align 8
  %arraydecay = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 15
  %16 = load i8, i8* %seen_direct_write7, align 1
  %tobool8 = trunc i8 %16 to i1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  %call = call i32 %14(%struct.bpf_insn* noundef %arraydecay, i1 noundef zeroext %tobool8, %struct.bpf_prog* noundef %18) #8
  store i32 %call, i32* %cnt, align 4
  %19 = load i32, i32* %cnt, align 4
  %conv = sext i32 %19 to i64
  %cmp = icmp uge i64 %conv, 16
  br i1 %cmp, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %22 = load i32, i32* %cnt, align 4
  %tobool12 = icmp ne i32 %22, 0
  br i1 %tobool12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %if.else
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %arraydecay14 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %24 = load i32, i32* %cnt, align 4
  %call15 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %23, i32 noundef 0, %struct.bpf_insn* noundef %arraydecay14, i32 noundef %24) #8
  store %struct.bpf_prog* %call15, %struct.bpf_prog** %new_prog, align 8
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool16 = icmp ne %struct.bpf_prog* %25, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.then13
  store i32 -12, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then13
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  store %struct.bpf_prog* %26, %struct.bpf_prog** %prog19, align 8
  %28 = load i32, i32* %cnt, align 4
  %sub = sub i32 %28, 1
  %29 = load i32, i32* %delta, align 4
  %add = add i32 %29, %sub
  store i32 %add, i32* %delta, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %lor.lhs.false
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog23, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %31, i32 0, i32 7
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call24 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %32) #8
  br i1 %call24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end22
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 2
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog27, align 8
  %35 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %35 to [0 x %struct.bpf_insn]*
  %arraydecay28 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %36 = load i32, i32* %delta, align 4
  %idx.ext = sext i32 %36 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay28, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %37 = load i32, i32* %i, align 4
  %38 = load i32, i32* %insn_cnt, align 4
  %cmp29 = icmp slt i32 %37, %38
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 0
  %40 = load i8, i8* %code, align 4
  %conv31 = zext i8 %40 to i32
  %cmp32 = icmp eq i32 %conv31, 113
  br i1 %cmp32, label %if.then49, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %for.body
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code35, align 4
  %conv36 = zext i8 %42 to i32
  %cmp37 = icmp eq i32 %conv36, 105
  br i1 %cmp37, label %if.then49, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %43 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %43, i32 0, i32 0
  %44 = load i8, i8* %code40, align 4
  %conv41 = zext i8 %44 to i32
  %cmp42 = icmp eq i32 %conv41, 97
  br i1 %cmp42, label %if.then49, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false39
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code45 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 0
  %46 = load i8, i8* %code45, align 4
  %conv46 = zext i8 %46 to i32
  %cmp47 = icmp eq i32 %conv46, 121
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %lor.lhs.false44, %lor.lhs.false39, %lor.lhs.false34, %for.body
  store i32 1, i32* %type, align 4
  br label %if.end73

if.else50:                                        ; preds = %lor.lhs.false44
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %47, i32 0, i32 0
  %48 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %48 to i32
  %cmp53 = icmp eq i32 %conv52, 115
  br i1 %cmp53, label %if.then70, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %if.else50
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %49, i32 0, i32 0
  %50 = load i8, i8* %code56, align 4
  %conv57 = zext i8 %50 to i32
  %cmp58 = icmp eq i32 %conv57, 107
  br i1 %cmp58, label %if.then70, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %lor.lhs.false55
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 0
  %52 = load i8, i8* %code61, align 4
  %conv62 = zext i8 %52 to i32
  %cmp63 = icmp eq i32 %conv62, 99
  br i1 %cmp63, label %if.then70, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %lor.lhs.false60
  %53 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %53, i32 0, i32 0
  %54 = load i8, i8* %code66, align 4
  %conv67 = zext i8 %54 to i32
  %cmp68 = icmp eq i32 %conv67, 123
  br i1 %cmp68, label %if.then70, label %if.else71

if.then70:                                        ; preds = %lor.lhs.false65, %lor.lhs.false60, %lor.lhs.false55, %if.else50
  store i32 2, i32* %type, align 4
  br label %if.end72

if.else71:                                        ; preds = %lor.lhs.false65
  br label %for.inc

if.end72:                                         ; preds = %if.then70
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.then49
  %55 = load i32, i32* %type, align 4
  %cmp74 = icmp eq i32 %55, 2
  br i1 %cmp74, label %land.lhs.true, label %if.end105

land.lhs.true:                                    ; preds = %if.end73
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %56, i32 0, i32 16
  %57 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %58 = load i32, i32* %i, align 4
  %59 = load i32, i32* %delta, align 4
  %add76 = add i32 %58, %59
  %idxprom = sext i32 %add76 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %57, i64 %idxprom
  %sanitize_stack_off = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 2
  %60 = load i32, i32* %sanitize_stack_off, align 4
  %tobool77 = icmp ne i32 %60, 0
  br i1 %tobool77, label %if.then78, label %if.end105

if.then78:                                        ; preds = %land.lhs.true
  %arrayinit.begin = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %code79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  store i8 122, i8* %code79, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 10
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load80 = load i8, i8* %src_reg, align 1
  %bf.clear81 = and i8 %bf.load80, 15
  %bf.set82 = or i8 %bf.clear81, 0
  store i8 %bf.set82, i8* %src_reg, align 1
  %off83 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data84 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 16
  %62 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data84, align 8
  %63 = load i32, i32* %i, align 4
  %64 = load i32, i32* %delta, align 4
  %add85 = add i32 %63, %64
  %idxprom86 = sext i32 %add85 to i64
  %arrayidx87 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %62, i64 %idxprom86
  %sanitize_stack_off88 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx87, i32 0, i32 2
  %65 = load i32, i32* %sanitize_stack_off88, align 4
  %conv89 = trunc i32 %65 to i16
  store i16 %conv89, i16* %off83, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %67 = bitcast %struct.bpf_insn* %arrayinit.element to i8*
  %68 = bitcast %struct.bpf_insn* %66 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %67, i8* align 4 %68, i64 8, i1 false)
  store i32 2, i32* %cnt, align 4
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load i32, i32* %i, align 4
  %71 = load i32, i32* %delta, align 4
  %add90 = add i32 %70, %71
  %arraydecay91 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %72 = load i32, i32* %cnt, align 4
  %call92 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %69, i32 noundef %add90, %struct.bpf_insn* noundef %arraydecay91, i32 noundef %72) #8
  store %struct.bpf_prog* %call92, %struct.bpf_prog** %new_prog, align 8
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool93 = icmp ne %struct.bpf_prog* %73, null
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %if.then78
  store i32 -12, i32* %retval, align 4
  br label %return

if.end95:                                         ; preds = %if.then78
  %74 = load i32, i32* %cnt, align 4
  %sub96 = sub i32 %74, 1
  %75 = load i32, i32* %delta, align 4
  %add97 = add i32 %75, %sub96
  store i32 %add97, i32* %delta, align 4
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog98 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %77, i32 0, i32 2
  store %struct.bpf_prog* %76, %struct.bpf_prog** %prog98, align 8
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %79 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %78, i32 0, i32 10
  %insnsi99 = bitcast %union.anon.146* %79 to [0 x %struct.bpf_insn]*
  %arraydecay100 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi99, i64 0, i64 0
  %80 = load i32, i32* %i, align 4
  %idx.ext101 = sext i32 %80 to i64
  %add.ptr102 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay100, i64 %idx.ext101
  %81 = load i32, i32* %delta, align 4
  %idx.ext103 = sext i32 %81 to i64
  %add.ptr104 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr102, i64 %idx.ext103
  store %struct.bpf_insn* %add.ptr104, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end105:                                        ; preds = %land.lhs.true, %if.end73
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data106 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 16
  %83 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data106, align 8
  %84 = load i32, i32* %i, align 4
  %85 = load i32, i32* %delta, align 4
  %add107 = add i32 %84, %85
  %idxprom108 = sext i32 %add107 to i64
  %arrayidx109 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %83, i64 %idxprom108
  %86 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx109, i32 0, i32 0
  %ptr_type = bitcast %union.anon.13* %86 to i32*
  %87 = load i32, i32* %ptr_type, align 8
  switch i32 %87, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb115
    i32 13, label %sw.bb115
    i32 15, label %sw.bb116
    i32 18, label %sw.bb117
  ]

sw.bb:                                            ; preds = %if.end105
  %88 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access110 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %88, i32 0, i32 4
  %89 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access110, align 8
  %tobool111 = icmp ne i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %89, null
  br i1 %tobool111, label %if.end113, label %if.then112

if.then112:                                       ; preds = %sw.bb
  br label %for.inc

if.end113:                                        ; preds = %sw.bb
  %90 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access114 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %90, i32 0, i32 4
  %91 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access114, align 8
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %91, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb115:                                         ; preds = %if.end105, %if.end105
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb116:                                         ; preds = %if.end105
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_tcp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb117:                                         ; preds = %if.end105
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_xdp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end105
  br label %for.inc

sw.epilog:                                        ; preds = %sw.bb117, %sw.bb116, %sw.bb115, %if.end113
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data118 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %92, i32 0, i32 16
  %93 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data118, align 8
  %94 = load i32, i32* %i, align 4
  %95 = load i32, i32* %delta, align 4
  %add119 = add i32 %94, %95
  %idxprom120 = sext i32 %add119 to i64
  %arrayidx121 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %93, i64 %idxprom120
  %ctx_field_size122 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx121, i32 0, i32 1
  %96 = load i32, i32* %ctx_field_size122, align 8
  store i32 %96, i32* %ctx_field_size, align 4
  store i32 -22, i32* %bytes, align 4
  %97 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code123 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %97, i32 0, i32 0
  %98 = load i8, i8* %code123, align 4
  %conv124 = zext i8 %98 to i32
  %and = and i32 %conv124, 24
  %cmp125 = icmp eq i32 %and, 16
  br i1 %cmp125, label %if.then127, label %if.else128

if.then127:                                       ; preds = %sw.epilog
  store i32 1, i32* %bytes, align 4
  br label %if.end152

if.else128:                                       ; preds = %sw.epilog
  %99 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code129 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %99, i32 0, i32 0
  %100 = load i8, i8* %code129, align 4
  %conv130 = zext i8 %100 to i32
  %and131 = and i32 %conv130, 24
  %cmp132 = icmp eq i32 %and131, 8
  br i1 %cmp132, label %if.then134, label %if.else135

if.then134:                                       ; preds = %if.else128
  store i32 2, i32* %bytes, align 4
  br label %if.end151

if.else135:                                       ; preds = %if.else128
  %101 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %101, i32 0, i32 0
  %102 = load i8, i8* %code136, align 4
  %conv137 = zext i8 %102 to i32
  %and138 = and i32 %conv137, 24
  %cmp139 = icmp eq i32 %and138, 0
  br i1 %cmp139, label %if.then141, label %if.else142

if.then141:                                       ; preds = %if.else135
  store i32 4, i32* %bytes, align 4
  br label %if.end150

if.else142:                                       ; preds = %if.else135
  %103 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code143 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %103, i32 0, i32 0
  %104 = load i8, i8* %code143, align 4
  %conv144 = zext i8 %104 to i32
  %and145 = and i32 %conv144, 24
  %cmp146 = icmp eq i32 %and145, 24
  br i1 %cmp146, label %if.then148, label %if.end149

if.then148:                                       ; preds = %if.else142
  store i32 8, i32* %bytes, align 4
  br label %if.end149

if.end149:                                        ; preds = %if.then148, %if.else142
  br label %if.end150

if.end150:                                        ; preds = %if.end149, %if.then141
  br label %if.end151

if.end151:                                        ; preds = %if.end150, %if.then134
  br label %if.end152

if.end152:                                        ; preds = %if.end151, %if.then127
  %105 = load i32, i32* %bytes, align 4
  store i32 %105, i32* %tmp, align 4
  %106 = load i32, i32* %tmp, align 4
  store i32 %106, i32* %__size, align 4
  %107 = load i32, i32* %__size, align 4
  %cmp153 = icmp slt i32 %107, 0
  %lnot = xor i1 %cmp153, true
  %lnot155 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot155 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %108 = load i32, i32* %__ret_warn_on, align 4
  %tobool156 = icmp ne i32 %108, 0
  %lnot157 = xor i1 %tobool156, true
  %lnot159 = xor i1 %lnot157, true
  %lnot.ext160 = zext i1 %lnot159 to i32
  %conv161 = sext i32 %lnot.ext160 to i64
  %tobool162 = icmp ne i64 %conv161, 0
  br i1 %tobool162, label %if.then163, label %if.end166

if.then163:                                       ; preds = %if.end152
  br label %do.body

do.body:                                          ; preds = %if.then163
  br label %do.body164

do.body164:                                       ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10529, i32 2305, i64 12) #9, !srcloc !14
  br label %do.end

do.end:                                           ; preds = %do.body164
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 220) #9, !srcloc !15
  br label %do.end165

do.end165:                                        ; preds = %do.end
  br label %if.end166

if.end166:                                        ; preds = %do.end165, %if.end152
  %109 = load i32, i32* %__ret_warn_on, align 4
  %tobool168 = icmp ne i32 %109, 0
  %lnot169 = xor i1 %tobool168, true
  %lnot171 = xor i1 %lnot169, true
  %lnot.ext172 = zext i1 %lnot171 to i32
  %conv173 = sext i32 %lnot.ext172 to i64
  store i64 %conv173, i64* %tmp167, align 8
  %110 = load i64, i64* %tmp167, align 8
  %111 = load i32, i32* %__size, align 4
  store i32 %111, i32* %tmp174, align 4
  %112 = load i32, i32* %tmp174, align 4
  store i32 %112, i32* %size, align 4
  %113 = load i32, i32* %size, align 4
  %114 = load i32, i32* %ctx_field_size, align 4
  %cmp175 = icmp slt i32 %113, %114
  %frombool = zext i1 %cmp175 to i8
  store i8 %frombool, i8* %is_narrower_load, align 1
  %115 = load i32, i32* %ctx_field_size, align 4
  %call177 = call i32 @bpf_ctx_off_adjust_machine(i32 noundef %115) #8
  store i32 %call177, i32* %size_default, align 4
  %116 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off178 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %116, i32 0, i32 2
  %117 = load i16, i16* %off178, align 2
  %conv179 = sext i16 %117 to i32
  store i32 %conv179, i32* %off, align 4
  %118 = load i8, i8* %is_narrower_load, align 1
  %tobool180 = trunc i8 %118 to i1
  br i1 %tobool180, label %if.then181, label %if.end202

if.then181:                                       ; preds = %if.end166
  %119 = load i32, i32* %type, align 4
  %cmp182 = icmp eq i32 %119, 2
  br i1 %cmp182, label %if.then184, label %if.end185

if.then184:                                       ; preds = %if.then181
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %121 = bitcast %struct.bpf_verifier_env* %120 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %121, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.284, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end185:                                        ; preds = %if.then181
  store i8 8, i8* %size_code, align 1
  %122 = load i32, i32* %ctx_field_size, align 4
  %cmp186 = icmp eq i32 %122, 4
  br i1 %cmp186, label %if.then188, label %if.else189

if.then188:                                       ; preds = %if.end185
  store i8 0, i8* %size_code, align 1
  br label %if.end194

if.else189:                                       ; preds = %if.end185
  %123 = load i32, i32* %ctx_field_size, align 4
  %cmp190 = icmp eq i32 %123, 8
  br i1 %cmp190, label %if.then192, label %if.end193

if.then192:                                       ; preds = %if.else189
  store i8 24, i8* %size_code, align 1
  br label %if.end193

if.end193:                                        ; preds = %if.then192, %if.else189
  br label %if.end194

if.end194:                                        ; preds = %if.end193, %if.then188
  %124 = load i32, i32* %off, align 4
  %125 = load i32, i32* %size_default, align 4
  %sub195 = sub i32 %125, 1
  %neg = xor i32 %sub195, -1
  %and196 = and i32 %124, %neg
  %conv197 = trunc i32 %and196 to i16
  %126 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off198 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %126, i32 0, i32 2
  store i16 %conv197, i16* %off198, align 2
  %127 = load i8, i8* %size_code, align 1
  %conv199 = zext i8 %127 to i32
  %or = or i32 97, %conv199
  %conv200 = trunc i32 %or to i8
  %128 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code201 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %128, i32 0, i32 0
  store i8 %conv200, i8* %code201, align 4
  br label %if.end202

if.end202:                                        ; preds = %if.end194, %if.end166
  store i32 0, i32* %target_size, align 4
  %129 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  %130 = load i32, i32* %type, align 4
  %131 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay203 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog204 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %132, i32 0, i32 2
  %133 = load %struct.bpf_prog*, %struct.bpf_prog** %prog204, align 8
  %call205 = call i32 %129(i32 noundef %130, %struct.bpf_insn* noundef %131, %struct.bpf_insn* noundef %arraydecay203, %struct.bpf_prog* noundef %133, i32* noundef %target_size) #8
  store i32 %call205, i32* %cnt, align 4
  %134 = load i32, i32* %cnt, align 4
  %cmp206 = icmp eq i32 %134, 0
  br i1 %cmp206, label %if.then216, label %lor.lhs.false208

lor.lhs.false208:                                 ; preds = %if.end202
  %135 = load i32, i32* %cnt, align 4
  %conv209 = sext i32 %135 to i64
  %cmp210 = icmp uge i64 %conv209, 16
  br i1 %cmp210, label %if.then216, label %lor.lhs.false212

lor.lhs.false212:                                 ; preds = %lor.lhs.false208
  %136 = load i32, i32* %ctx_field_size, align 4
  %tobool213 = icmp ne i32 %136, 0
  br i1 %tobool213, label %land.lhs.true214, label %if.end217

land.lhs.true214:                                 ; preds = %lor.lhs.false212
  %137 = load i32, i32* %target_size, align 4
  %tobool215 = icmp ne i32 %137, 0
  br i1 %tobool215, label %if.end217, label %if.then216

if.then216:                                       ; preds = %land.lhs.true214, %lor.lhs.false208, %if.end202
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = bitcast %struct.bpf_verifier_env* %138 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %139, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end217:                                        ; preds = %land.lhs.true214, %lor.lhs.false212
  %140 = load i8, i8* %is_narrower_load, align 1
  %tobool218 = trunc i8 %140 to i1
  br i1 %tobool218, label %land.lhs.true220, label %if.end319

land.lhs.true220:                                 ; preds = %if.end217
  %141 = load i32, i32* %size, align 4
  %142 = load i32, i32* %target_size, align 4
  %cmp221 = icmp ult i32 %141, %142
  br i1 %cmp221, label %if.then223, label %if.end319

if.then223:                                       ; preds = %land.lhs.true220
  %143 = load i32, i32* %off, align 4
  %144 = load i32, i32* %size, align 4
  %145 = load i32, i32* %size_default, align 4
  %call224 = call zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %143, i32 noundef %144, i32 noundef %145) #8
  %conv225 = zext i8 %call224 to i32
  %mul = mul i32 %conv225, 8
  %conv226 = trunc i32 %mul to i8
  store i8 %conv226, i8* %shift, align 1
  %146 = load i32, i32* %ctx_field_size, align 4
  %cmp227 = icmp sle i32 %146, 4
  br i1 %cmp227, label %if.then229, label %if.else271

if.then229:                                       ; preds = %if.then223
  %147 = load i8, i8* %shift, align 1
  %tobool230 = icmp ne i8 %147, 0
  br i1 %tobool230, label %if.then231, label %if.end249

if.then231:                                       ; preds = %if.then229
  %148 = load i32, i32* %cnt, align 4
  %inc = add i32 %148, 1
  store i32 %inc, i32* %cnt, align 4
  %idxprom232 = sext i32 %148 to i64
  %arrayidx233 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom232
  %code234 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 116, i8* %code234, align 4
  %dst_reg235 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %149 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg236 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %149, i32 0, i32 1
  %bf.load237 = load i8, i8* %dst_reg236, align 1
  %bf.clear238 = and i8 %bf.load237, 15
  %bf.load239 = load i8, i8* %dst_reg235, align 1
  %bf.value = and i8 %bf.clear238, 15
  %bf.clear240 = and i8 %bf.load239, -16
  %bf.set241 = or i8 %bf.clear240, %bf.value
  store i8 %bf.set241, i8* %dst_reg235, align 1
  %src_reg242 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load243 = load i8, i8* %src_reg242, align 1
  %bf.clear244 = and i8 %bf.load243, 15
  %bf.set245 = or i8 %bf.clear244, 0
  store i8 %bf.set245, i8* %src_reg242, align 1
  %off246 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off246, align 2
  %imm247 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  %150 = load i8, i8* %shift, align 1
  %conv248 = zext i8 %150 to i32
  store i32 %conv248, i32* %imm247, align 4
  %151 = bitcast %struct.bpf_insn* %arrayidx233 to i8*
  %152 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %151, i8* align 4 %152, i64 8, i1 false)
  br label %if.end249

if.end249:                                        ; preds = %if.then231, %if.then229
  %153 = load i32, i32* %cnt, align 4
  %inc250 = add i32 %153, 1
  store i32 %inc250, i32* %cnt, align 4
  %idxprom251 = sext i32 %153 to i64
  %arrayidx252 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom251
  %code254 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral253, i32 0, i32 0
  store i8 84, i8* %code254, align 4
  %dst_reg255 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral253, i32 0, i32 1
  %154 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg256 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %154, i32 0, i32 1
  %bf.load257 = load i8, i8* %dst_reg256, align 1
  %bf.clear258 = and i8 %bf.load257, 15
  %bf.load259 = load i8, i8* %dst_reg255, align 1
  %bf.value260 = and i8 %bf.clear258, 15
  %bf.clear261 = and i8 %bf.load259, -16
  %bf.set262 = or i8 %bf.clear261, %bf.value260
  store i8 %bf.set262, i8* %dst_reg255, align 1
  %src_reg263 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral253, i32 0, i32 1
  %bf.load264 = load i8, i8* %src_reg263, align 1
  %bf.clear265 = and i8 %bf.load264, 15
  %bf.set266 = or i8 %bf.clear265, 0
  store i8 %bf.set266, i8* %src_reg263, align 1
  %off267 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral253, i32 0, i32 2
  store i16 0, i16* %off267, align 2
  %imm268 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral253, i32 0, i32 3
  %155 = load i32, i32* %size, align 4
  %mul269 = mul i32 %155, 8
  %shl = shl i32 1, %mul269
  %sub270 = sub i32 %shl, 1
  store i32 %sub270, i32* %imm268, align 4
  %156 = bitcast %struct.bpf_insn* %arrayidx252 to i8*
  %157 = bitcast %struct.bpf_insn* %.compoundliteral253 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %156, i8* align 4 %157, i64 8, i1 false)
  br label %if.end318

if.else271:                                       ; preds = %if.then223
  %158 = load i8, i8* %shift, align 1
  %tobool272 = icmp ne i8 %158, 0
  br i1 %tobool272, label %if.then273, label %if.end294

if.then273:                                       ; preds = %if.else271
  %159 = load i32, i32* %cnt, align 4
  %inc274 = add i32 %159, 1
  store i32 %inc274, i32* %cnt, align 4
  %idxprom275 = sext i32 %159 to i64
  %arrayidx276 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom275
  %code278 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral277, i32 0, i32 0
  store i8 119, i8* %code278, align 4
  %dst_reg279 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral277, i32 0, i32 1
  %160 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %160, i32 0, i32 1
  %bf.load281 = load i8, i8* %dst_reg280, align 1
  %bf.clear282 = and i8 %bf.load281, 15
  %bf.load283 = load i8, i8* %dst_reg279, align 1
  %bf.value284 = and i8 %bf.clear282, 15
  %bf.clear285 = and i8 %bf.load283, -16
  %bf.set286 = or i8 %bf.clear285, %bf.value284
  store i8 %bf.set286, i8* %dst_reg279, align 1
  %src_reg287 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral277, i32 0, i32 1
  %bf.load288 = load i8, i8* %src_reg287, align 1
  %bf.clear289 = and i8 %bf.load288, 15
  %bf.set290 = or i8 %bf.clear289, 0
  store i8 %bf.set290, i8* %src_reg287, align 1
  %off291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral277, i32 0, i32 2
  store i16 0, i16* %off291, align 2
  %imm292 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral277, i32 0, i32 3
  %161 = load i8, i8* %shift, align 1
  %conv293 = zext i8 %161 to i32
  store i32 %conv293, i32* %imm292, align 4
  %162 = bitcast %struct.bpf_insn* %arrayidx276 to i8*
  %163 = bitcast %struct.bpf_insn* %.compoundliteral277 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %162, i8* align 4 %163, i64 8, i1 false)
  br label %if.end294

if.end294:                                        ; preds = %if.then273, %if.else271
  %164 = load i32, i32* %cnt, align 4
  %inc295 = add i32 %164, 1
  store i32 %inc295, i32* %cnt, align 4
  %idxprom296 = sext i32 %164 to i64
  %arrayidx297 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom296
  %code299 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral298, i32 0, i32 0
  store i8 87, i8* %code299, align 4
  %dst_reg300 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral298, i32 0, i32 1
  %165 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg301 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %165, i32 0, i32 1
  %bf.load302 = load i8, i8* %dst_reg301, align 1
  %bf.clear303 = and i8 %bf.load302, 15
  %bf.load304 = load i8, i8* %dst_reg300, align 1
  %bf.value305 = and i8 %bf.clear303, 15
  %bf.clear306 = and i8 %bf.load304, -16
  %bf.set307 = or i8 %bf.clear306, %bf.value305
  store i8 %bf.set307, i8* %dst_reg300, align 1
  %src_reg308 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral298, i32 0, i32 1
  %bf.load309 = load i8, i8* %src_reg308, align 1
  %bf.clear310 = and i8 %bf.load309, 15
  %bf.set311 = or i8 %bf.clear310, 0
  store i8 %bf.set311, i8* %src_reg308, align 1
  %off312 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral298, i32 0, i32 2
  store i16 0, i16* %off312, align 2
  %imm313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral298, i32 0, i32 3
  %166 = load i32, i32* %size, align 4
  %mul314 = mul i32 %166, 8
  %sh_prom = zext i32 %mul314 to i64
  %shl315 = shl i64 1, %sh_prom
  %sub316 = sub i64 %shl315, 1
  %conv317 = trunc i64 %sub316 to i32
  store i32 %conv317, i32* %imm313, align 4
  %167 = bitcast %struct.bpf_insn* %arrayidx297 to i8*
  %168 = bitcast %struct.bpf_insn* %.compoundliteral298 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %167, i8* align 4 %168, i64 8, i1 false)
  br label %if.end318

if.end318:                                        ; preds = %if.end294, %if.end249
  br label %if.end319

if.end319:                                        ; preds = %if.end318, %land.lhs.true220, %if.end217
  %169 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %170 = load i32, i32* %i, align 4
  %171 = load i32, i32* %delta, align 4
  %add320 = add i32 %170, %171
  %arraydecay321 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %172 = load i32, i32* %cnt, align 4
  %call322 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %169, i32 noundef %add320, %struct.bpf_insn* noundef %arraydecay321, i32 noundef %172) #8
  store %struct.bpf_prog* %call322, %struct.bpf_prog** %new_prog, align 8
  %173 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool323 = icmp ne %struct.bpf_prog* %173, null
  br i1 %tobool323, label %if.end325, label %if.then324

if.then324:                                       ; preds = %if.end319
  store i32 -12, i32* %retval, align 4
  br label %return

if.end325:                                        ; preds = %if.end319
  %174 = load i32, i32* %cnt, align 4
  %sub326 = sub i32 %174, 1
  %175 = load i32, i32* %delta, align 4
  %add327 = add i32 %175, %sub326
  store i32 %add327, i32* %delta, align 4
  %176 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog328 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %177, i32 0, i32 2
  store %struct.bpf_prog* %176, %struct.bpf_prog** %prog328, align 8
  %178 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %179 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %178, i32 0, i32 10
  %insnsi329 = bitcast %union.anon.146* %179 to [0 x %struct.bpf_insn]*
  %arraydecay330 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi329, i64 0, i64 0
  %180 = load i32, i32* %i, align 4
  %idx.ext331 = sext i32 %180 to i64
  %add.ptr332 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay330, i64 %idx.ext331
  %181 = load i32, i32* %delta, align 4
  %idx.ext333 = sext i32 %181 to i64
  %add.ptr334 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr332, i64 %idx.ext333
  store %struct.bpf_insn* %add.ptr334, %struct.bpf_insn** %insn, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end325, %sw.default, %if.then112, %if.end95, %if.else71
  %182 = load i32, i32* %i, align 4
  %inc335 = add i32 %182, 1
  store i32 %inc335, i32* %i, align 4
  %183 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %183, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then324, %if.then216, %if.then184, %if.then94, %if.then25, %if.then17, %if.then11, %if.then5
  %184 = load i32, i32* %retval, align 4
  ret i32 %184
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_bpf_calls(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %fn = alloca %struct.bpf_func_proto*, align 8
  %insn_cnt = alloca i32, align 4
  %ops = alloca %struct.bpf_map_ops*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %new_prog = alloca %struct.bpf_prog*, align 8
  %map_ptr = alloca %struct.bpf_map*, align 8
  %i = alloca i32, align 4
  %cnt = alloca i32, align 4
  %delta = alloca i32, align 4
  %is64 = alloca i8, align 1
  %mask_and_div = alloca [5 x %struct.bpf_insn], align 16
  %mask_and_mod = alloca [3 x %struct.bpf_insn], align 16
  %patchlet = alloca %struct.bpf_insn*, align 8
  %code_add = alloca i8, align 1
  %code_sub = alloca i8, align 1
  %insn_buf215 = alloca [16 x %struct.bpf_insn], align 16
  %patch = alloca %struct.bpf_insn*, align 8
  %issrc = alloca i8, align 1
  %isneg = alloca i8, align 1
  %off_reg = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral265 = alloca %struct.bpf_insn, align 4
  %.compoundliteral279 = alloca %struct.bpf_insn, align 4
  %.compoundliteral295 = alloca %struct.bpf_insn, align 4
  %.compoundliteral311 = alloca %struct.bpf_insn, align 4
  %.compoundliteral324 = alloca %struct.bpf_insn, align 4
  %.compoundliteral339 = alloca %struct.bpf_insn, align 4
  %.compoundliteral360 = alloca %struct.bpf_insn, align 4
  %.compoundliteral393 = alloca %struct.bpf_insn, align 4
  %.compoundliteral486 = alloca %struct.bpf_insn, align 4
  %.compoundliteral499 = alloca %struct.bpf_insn, align 4
  %__mptr = alloca i8*, align 8
  %tmp = alloca %struct.bpf_array*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %3 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i32 0, i32* %delta, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %cmp2 = icmp eq i32 %conv, 159
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code4 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 0
  %11 = load i8, i8* %code4, align 4
  %conv5 = zext i8 %11 to i32
  %cmp6 = icmp eq i32 %conv5, 63
  br i1 %cmp6, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 0
  %13 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %13 to i32
  %cmp11 = icmp eq i32 %conv10, 156
  br i1 %cmp11, label %if.then, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false8
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %15 to i32
  %cmp16 = icmp eq i32 %conv15, 60
  br i1 %cmp16, label %if.then, label %if.end160

if.then:                                          ; preds = %lor.lhs.false13, %lor.lhs.false8, %lor.lhs.false, %for.body
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code18, align 4
  %conv19 = zext i8 %17 to i32
  %and = and i32 %conv19, 7
  %cmp20 = icmp eq i32 %and, 7
  %frombool = zext i1 %cmp20 to i8
  store i8 %frombool, i8* %is64, align 1
  %arrayinit.begin = getelementptr inbounds [5 x %struct.bpf_insn], [5 x %struct.bpf_insn]* %mask_and_div, i64 0, i64 0
  %code22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  store i8 -68, i8* %code22, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.load23 = load i8, i8* %dst_reg, align 1
  %bf.value = and i8 %bf.lshr, 15
  %bf.clear = and i8 %bf.load23, -16
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg25 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 1
  %bf.load26 = load i8, i8* %src_reg25, align 1
  %bf.lshr27 = lshr i8 %bf.load26, 4
  %bf.load28 = load i8, i8* %src_reg24, align 1
  %bf.value29 = and i8 %bf.lshr27, 15
  %bf.shl = shl i8 %bf.value29, 4
  %bf.clear30 = and i8 %bf.load28, 15
  %bf.set31 = or i8 %bf.clear30, %bf.shl
  store i8 %bf.set31, i8* %src_reg24, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code32 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 85, i8* %code32, align 8
  %dst_reg33 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load35 = load i8, i8* %src_reg34, align 1
  %bf.lshr36 = lshr i8 %bf.load35, 4
  %bf.load37 = load i8, i8* %dst_reg33, align 1
  %bf.value38 = and i8 %bf.lshr36, 15
  %bf.clear39 = and i8 %bf.load37, -16
  %bf.set40 = or i8 %bf.clear39, %bf.value38
  store i8 %bf.set40, i8* %dst_reg33, align 1
  %src_reg41 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load42 = load i8, i8* %src_reg41, align 1
  %bf.clear43 = and i8 %bf.load42, 15
  %bf.set44 = or i8 %bf.clear43, 0
  store i8 %bf.set44, i8* %src_reg41, align 1
  %off45 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 2, i16* %off45, align 2
  %imm46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 0, i32* %imm46, align 4
  %arrayinit.element47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i64 1
  %code48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element47, i32 0, i32 0
  store i8 -84, i8* %code48, align 8
  %dst_reg49 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element47, i32 0, i32 1
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg50 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 1
  %bf.load51 = load i8, i8* %dst_reg50, align 1
  %bf.clear52 = and i8 %bf.load51, 15
  %bf.load53 = load i8, i8* %dst_reg49, align 1
  %bf.value54 = and i8 %bf.clear52, 15
  %bf.clear55 = and i8 %bf.load53, -16
  %bf.set56 = or i8 %bf.clear55, %bf.value54
  store i8 %bf.set56, i8* %dst_reg49, align 1
  %src_reg57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element47, i32 0, i32 1
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg58 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 1
  %bf.load59 = load i8, i8* %dst_reg58, align 1
  %bf.clear60 = and i8 %bf.load59, 15
  %bf.load61 = load i8, i8* %src_reg57, align 1
  %bf.value62 = and i8 %bf.clear60, 15
  %bf.shl63 = shl i8 %bf.value62, 4
  %bf.clear64 = and i8 %bf.load61, 15
  %bf.set65 = or i8 %bf.clear64, %bf.shl63
  store i8 %bf.set65, i8* %src_reg57, align 1
  %off66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element47, i32 0, i32 2
  store i16 0, i16* %off66, align 2
  %imm67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element47, i32 0, i32 3
  store i32 0, i32* %imm67, align 4
  %arrayinit.element68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element47, i64 1
  %code69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element68, i32 0, i32 0
  store i8 5, i8* %code69, align 8
  %dst_reg70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element68, i32 0, i32 1
  %bf.load71 = load i8, i8* %dst_reg70, align 1
  %bf.clear72 = and i8 %bf.load71, -16
  %bf.set73 = or i8 %bf.clear72, 0
  store i8 %bf.set73, i8* %dst_reg70, align 1
  %src_reg74 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element68, i32 0, i32 1
  %bf.load75 = load i8, i8* %src_reg74, align 1
  %bf.clear76 = and i8 %bf.load75, 15
  %bf.set77 = or i8 %bf.clear76, 0
  store i8 %bf.set77, i8* %src_reg74, align 1
  %off78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element68, i32 0, i32 2
  store i16 1, i16* %off78, align 2
  %imm79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element68, i32 0, i32 3
  store i32 0, i32* %imm79, align 4
  %arrayinit.element80 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element68, i64 1
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %24 = bitcast %struct.bpf_insn* %arrayinit.element80 to i8*
  %25 = bitcast %struct.bpf_insn* %23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 4 %25, i64 8, i1 false)
  %arrayinit.begin81 = getelementptr inbounds [3 x %struct.bpf_insn], [3 x %struct.bpf_insn]* %mask_and_mod, i64 0, i64 0
  %code82 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin81, i32 0, i32 0
  store i8 -68, i8* %code82, align 8
  %dst_reg83 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin81, i32 0, i32 1
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg84 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 1
  %bf.load85 = load i8, i8* %src_reg84, align 1
  %bf.lshr86 = lshr i8 %bf.load85, 4
  %bf.load87 = load i8, i8* %dst_reg83, align 1
  %bf.value88 = and i8 %bf.lshr86, 15
  %bf.clear89 = and i8 %bf.load87, -16
  %bf.set90 = or i8 %bf.clear89, %bf.value88
  store i8 %bf.set90, i8* %dst_reg83, align 1
  %src_reg91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin81, i32 0, i32 1
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg92 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load93 = load i8, i8* %src_reg92, align 1
  %bf.lshr94 = lshr i8 %bf.load93, 4
  %bf.load95 = load i8, i8* %src_reg91, align 1
  %bf.value96 = and i8 %bf.lshr94, 15
  %bf.shl97 = shl i8 %bf.value96, 4
  %bf.clear98 = and i8 %bf.load95, 15
  %bf.set99 = or i8 %bf.clear98, %bf.shl97
  store i8 %bf.set99, i8* %src_reg91, align 1
  %off100 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin81, i32 0, i32 2
  store i16 0, i16* %off100, align 2
  %imm101 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin81, i32 0, i32 3
  store i32 0, i32* %imm101, align 4
  %arrayinit.element102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin81, i64 1
  %code103 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element102, i32 0, i32 0
  store i8 21, i8* %code103, align 8
  %dst_reg104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element102, i32 0, i32 1
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load106 = load i8, i8* %src_reg105, align 1
  %bf.lshr107 = lshr i8 %bf.load106, 4
  %bf.load108 = load i8, i8* %dst_reg104, align 1
  %bf.value109 = and i8 %bf.lshr107, 15
  %bf.clear110 = and i8 %bf.load108, -16
  %bf.set111 = or i8 %bf.clear110, %bf.value109
  store i8 %bf.set111, i8* %dst_reg104, align 1
  %src_reg112 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element102, i32 0, i32 1
  %bf.load113 = load i8, i8* %src_reg112, align 1
  %bf.clear114 = and i8 %bf.load113, 15
  %bf.set115 = or i8 %bf.clear114, 0
  store i8 %bf.set115, i8* %src_reg112, align 1
  %off116 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element102, i32 0, i32 2
  store i16 1, i16* %off116, align 2
  %imm117 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element102, i32 0, i32 3
  store i32 0, i32* %imm117, align 4
  %arrayinit.element118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element102, i64 1
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %30 = bitcast %struct.bpf_insn* %arrayinit.element118 to i8*
  %31 = bitcast %struct.bpf_insn* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 4 %31, i64 8, i1 false)
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code119 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 0
  %33 = load i8, i8* %code119, align 4
  %conv120 = zext i8 %33 to i32
  %cmp121 = icmp eq i32 %conv120, 63
  br i1 %cmp121, label %if.then128, label %lor.lhs.false123

lor.lhs.false123:                                 ; preds = %if.then
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code124 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 0
  %35 = load i8, i8* %code124, align 4
  %conv125 = zext i8 %35 to i32
  %cmp126 = icmp eq i32 %conv125, 60
  br i1 %cmp126, label %if.then128, label %if.else

if.then128:                                       ; preds = %lor.lhs.false123, %if.then
  %arraydecay129 = getelementptr inbounds [5 x %struct.bpf_insn], [5 x %struct.bpf_insn]* %mask_and_div, i64 0, i64 0
  %36 = load i8, i8* %is64, align 1
  %tobool = trunc i8 %36 to i1
  %37 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %idx.ext = sext i32 %cond to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay129, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %patchlet, align 8
  %38 = load i8, i8* %is64, align 1
  %tobool131 = trunc i8 %38 to i1
  %39 = zext i1 %tobool131 to i64
  %cond133 = select i1 %tobool131, i32 1, i32 0
  %conv134 = sext i32 %cond133 to i64
  %sub = sub i64 5, %conv134
  %conv135 = trunc i64 %sub to i32
  store i32 %conv135, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false123
  %arraydecay136 = getelementptr inbounds [3 x %struct.bpf_insn], [3 x %struct.bpf_insn]* %mask_and_mod, i64 0, i64 0
  %40 = load i8, i8* %is64, align 1
  %tobool137 = trunc i8 %40 to i1
  %41 = zext i1 %tobool137 to i64
  %cond139 = select i1 %tobool137, i32 1, i32 0
  %idx.ext140 = sext i32 %cond139 to i64
  %add.ptr141 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay136, i64 %idx.ext140
  store %struct.bpf_insn* %add.ptr141, %struct.bpf_insn** %patchlet, align 8
  %42 = load i8, i8* %is64, align 1
  %tobool142 = trunc i8 %42 to i1
  %43 = zext i1 %tobool142 to i64
  %cond144 = select i1 %tobool142, i32 1, i32 0
  %conv145 = sext i32 %cond144 to i64
  %sub146 = sub i64 3, %conv145
  %conv147 = trunc i64 %sub146 to i32
  store i32 %conv147, i32* %cnt, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then128
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load i32, i32* %i, align 4
  %46 = load i32, i32* %delta, align 4
  %add = add i32 %45, %46
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %patchlet, align 8
  %48 = load i32, i32* %cnt, align 4
  %call = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %44, i32 noundef %add, %struct.bpf_insn* noundef %47, i32 noundef %48) #8
  store %struct.bpf_prog* %call, %struct.bpf_prog** %new_prog, align 8
  %49 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool148 = icmp ne %struct.bpf_prog* %49, null
  br i1 %tobool148, label %if.end150, label %if.then149

if.then149:                                       ; preds = %if.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end150:                                        ; preds = %if.end
  %50 = load i32, i32* %cnt, align 4
  %sub151 = sub i32 %50, 1
  %51 = load i32, i32* %delta, align 4
  %add152 = add i32 %51, %sub151
  store i32 %add152, i32* %delta, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %52, %struct.bpf_prog** %prog, align 8
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog153 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 2
  store %struct.bpf_prog* %52, %struct.bpf_prog** %prog153, align 8
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %55 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 10
  %insnsi154 = bitcast %union.anon.146* %55 to [0 x %struct.bpf_insn]*
  %arraydecay155 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi154, i64 0, i64 0
  %56 = load i32, i32* %i, align 4
  %idx.ext156 = sext i32 %56 to i64
  %add.ptr157 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay155, i64 %idx.ext156
  %57 = load i32, i32* %delta, align 4
  %idx.ext158 = sext i32 %57 to i64
  %add.ptr159 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr157, i64 %idx.ext158
  store %struct.bpf_insn* %add.ptr159, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end160:                                        ; preds = %lor.lhs.false13
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code161 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %58, i32 0, i32 0
  %59 = load i8, i8* %code161, align 4
  %conv162 = zext i8 %59 to i32
  %and163 = and i32 %conv162, 7
  %cmp164 = icmp eq i32 %and163, 0
  br i1 %cmp164, label %land.lhs.true, label %if.end204

land.lhs.true:                                    ; preds = %if.end160
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code166 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 0
  %61 = load i8, i8* %code166, align 4
  %conv167 = zext i8 %61 to i32
  %and168 = and i32 %conv167, 224
  %cmp169 = icmp eq i32 %and168, 32
  br i1 %cmp169, label %if.then177, label %lor.lhs.false171

lor.lhs.false171:                                 ; preds = %land.lhs.true
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code172 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %62, i32 0, i32 0
  %63 = load i8, i8* %code172, align 4
  %conv173 = zext i8 %63 to i32
  %and174 = and i32 %conv173, 224
  %cmp175 = icmp eq i32 %and174, 64
  br i1 %cmp175, label %if.then177, label %if.end204

if.then177:                                       ; preds = %lor.lhs.false171, %land.lhs.true
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops178 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 3
  %65 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops178, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %65, i32 0, i32 3
  %66 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %67 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay179 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call180 = call i32 %66(%struct.bpf_insn* noundef %67, %struct.bpf_insn* noundef %arraydecay179) #8
  store i32 %call180, i32* %cnt, align 4
  %68 = load i32, i32* %cnt, align 4
  %cmp181 = icmp eq i32 %68, 0
  br i1 %cmp181, label %if.then187, label %lor.lhs.false183

lor.lhs.false183:                                 ; preds = %if.then177
  %69 = load i32, i32* %cnt, align 4
  %conv184 = sext i32 %69 to i64
  %cmp185 = icmp uge i64 %conv184, 16
  br i1 %cmp185, label %if.then187, label %if.end188

if.then187:                                       ; preds = %lor.lhs.false183, %if.then177
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end188:                                        ; preds = %lor.lhs.false183
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load i32, i32* %i, align 4
  %74 = load i32, i32* %delta, align 4
  %add189 = add i32 %73, %74
  %arraydecay190 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %75 = load i32, i32* %cnt, align 4
  %call191 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %72, i32 noundef %add189, %struct.bpf_insn* noundef %arraydecay190, i32 noundef %75) #8
  store %struct.bpf_prog* %call191, %struct.bpf_prog** %new_prog, align 8
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool192 = icmp ne %struct.bpf_prog* %76, null
  br i1 %tobool192, label %if.end194, label %if.then193

if.then193:                                       ; preds = %if.end188
  store i32 -12, i32* %retval, align 4
  br label %return

if.end194:                                        ; preds = %if.end188
  %77 = load i32, i32* %cnt, align 4
  %sub195 = sub i32 %77, 1
  %78 = load i32, i32* %delta, align 4
  %add196 = add i32 %78, %sub195
  store i32 %add196, i32* %delta, align 4
  %79 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %79, %struct.bpf_prog** %prog, align 8
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog197 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %80, i32 0, i32 2
  store %struct.bpf_prog* %79, %struct.bpf_prog** %prog197, align 8
  %81 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %82 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %81, i32 0, i32 10
  %insnsi198 = bitcast %union.anon.146* %82 to [0 x %struct.bpf_insn]*
  %arraydecay199 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi198, i64 0, i64 0
  %83 = load i32, i32* %i, align 4
  %idx.ext200 = sext i32 %83 to i64
  %add.ptr201 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay199, i64 %idx.ext200
  %84 = load i32, i32* %delta, align 4
  %idx.ext202 = sext i32 %84 to i64
  %add.ptr203 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr201, i64 %idx.ext202
  store %struct.bpf_insn* %add.ptr203, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end204:                                        ; preds = %lor.lhs.false171, %if.end160
  %85 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code205 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %85, i32 0, i32 0
  %86 = load i8, i8* %code205, align 4
  %conv206 = zext i8 %86 to i32
  %cmp207 = icmp eq i32 %conv206, 15
  br i1 %cmp207, label %if.then214, label %lor.lhs.false209

lor.lhs.false209:                                 ; preds = %if.end204
  %87 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code210 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %87, i32 0, i32 0
  %88 = load i8, i8* %code210, align 4
  %conv211 = zext i8 %88 to i32
  %cmp212 = icmp eq i32 %conv211, 31
  br i1 %cmp212, label %if.then214, label %if.end425

if.then214:                                       ; preds = %lor.lhs.false209, %if.end204
  store i8 15, i8* %code_add, align 1
  store i8 31, i8* %code_sub, align 1
  %arrayidx = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf215, i64 0, i64 0
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %patch, align 8
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %89, i32 0, i32 16
  %90 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %91 = load i32, i32* %i, align 4
  %92 = load i32, i32* %delta, align 4
  %add216 = add i32 %91, %92
  %idxprom = sext i32 %add216 to i64
  %arrayidx217 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %90, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx217, %struct.bpf_insn_aux_data** %aux, align 8
  %93 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %93, i32 0, i32 5
  %94 = load i8, i8* %alu_state, align 2
  %tobool218 = icmp ne i8 %94, 0
  br i1 %tobool218, label %lor.lhs.false219, label %if.then224

lor.lhs.false219:                                 ; preds = %if.then214
  %95 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state220 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %95, i32 0, i32 5
  %96 = load i8, i8* %alu_state220, align 2
  %conv221 = zext i8 %96 to i32
  %cmp222 = icmp eq i32 %conv221, 8
  br i1 %cmp222, label %if.then224, label %if.end225

if.then224:                                       ; preds = %lor.lhs.false219, %if.then214
  br label %for.inc

if.end225:                                        ; preds = %lor.lhs.false219
  %97 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state226 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %97, i32 0, i32 5
  %98 = load i8, i8* %alu_state226, align 2
  %conv227 = zext i8 %98 to i32
  %and228 = and i32 %conv227, 4
  %tobool229 = icmp ne i32 %and228, 0
  %frombool230 = zext i1 %tobool229 to i8
  store i8 %frombool230, i8* %isneg, align 1
  %99 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state231 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %99, i32 0, i32 5
  %100 = load i8, i8* %alu_state231, align 2
  %conv232 = zext i8 %100 to i32
  %and233 = and i32 %conv232, 3
  %cmp234 = icmp eq i32 %and233, 1
  %frombool236 = zext i1 %cmp234 to i8
  store i8 %frombool236, i8* %issrc, align 1
  %101 = load i8, i8* %issrc, align 1
  %tobool237 = trunc i8 %101 to i1
  br i1 %tobool237, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end225
  %102 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg239 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %102, i32 0, i32 1
  %bf.load240 = load i8, i8* %src_reg239, align 1
  %bf.lshr241 = lshr i8 %bf.load240, 4
  %conv242 = zext i8 %bf.lshr241 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end225
  %103 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg243 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %103, i32 0, i32 1
  %bf.load244 = load i8, i8* %dst_reg243, align 1
  %bf.clear245 = and i8 %bf.load244, 15
  %conv246 = zext i8 %bf.clear245 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond247 = phi i32 [ %conv242, %cond.true ], [ %conv246, %cond.false ]
  store i32 %cond247, i32* %off_reg, align 4
  %104 = load i8, i8* %isneg, align 1
  %tobool248 = trunc i8 %104 to i1
  br i1 %tobool248, label %if.then249, label %if.end263

if.then249:                                       ; preds = %cond.end
  %105 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %105, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %patch, align 8
  %code250 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 39, i8* %code250, align 4
  %dst_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %106 = load i32, i32* %off_reg, align 4
  %conv252 = trunc i32 %106 to i8
  %bf.load253 = load i8, i8* %dst_reg251, align 1
  %bf.value254 = and i8 %conv252, 15
  %bf.clear255 = and i8 %bf.load253, -16
  %bf.set256 = or i8 %bf.clear255, %bf.value254
  store i8 %bf.set256, i8* %dst_reg251, align 1
  %src_reg257 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load258 = load i8, i8* %src_reg257, align 1
  %bf.clear259 = and i8 %bf.load258, 15
  %bf.set260 = or i8 %bf.clear259, 0
  store i8 %bf.set260, i8* %src_reg257, align 1
  %off261 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off261, align 2
  %imm262 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 -1, i32* %imm262, align 4
  %107 = bitcast %struct.bpf_insn* %105 to i8*
  %108 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %107, i8* align 4 %108, i64 8, i1 false)
  br label %if.end263

if.end263:                                        ; preds = %if.then249, %cond.end
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr264 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %109, i32 1
  store %struct.bpf_insn* %incdec.ptr264, %struct.bpf_insn** %patch, align 8
  %code266 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral265, i32 0, i32 0
  store i8 -76, i8* %code266, align 4
  %dst_reg267 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral265, i32 0, i32 1
  %bf.load268 = load i8, i8* %dst_reg267, align 1
  %bf.clear269 = and i8 %bf.load268, -16
  %bf.set270 = or i8 %bf.clear269, 11
  store i8 %bf.set270, i8* %dst_reg267, align 1
  %src_reg271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral265, i32 0, i32 1
  %bf.load272 = load i8, i8* %src_reg271, align 1
  %bf.clear273 = and i8 %bf.load272, 15
  %bf.set274 = or i8 %bf.clear273, 0
  store i8 %bf.set274, i8* %src_reg271, align 1
  %off275 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral265, i32 0, i32 2
  store i16 0, i16* %off275, align 2
  %imm276 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral265, i32 0, i32 3
  %110 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %111 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %110, i32 0, i32 0
  %alu_limit = bitcast %union.anon.13* %111 to i32*
  %112 = load i32, i32* %alu_limit, align 8
  %sub277 = sub i32 %112, 1
  store i32 %sub277, i32* %imm276, align 4
  %113 = bitcast %struct.bpf_insn* %109 to i8*
  %114 = bitcast %struct.bpf_insn* %.compoundliteral265 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %113, i8* align 4 %114, i64 8, i1 false)
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr278 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %115, i32 1
  store %struct.bpf_insn* %incdec.ptr278, %struct.bpf_insn** %patch, align 8
  %code280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral279, i32 0, i32 0
  store i8 31, i8* %code280, align 4
  %dst_reg281 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral279, i32 0, i32 1
  %bf.load282 = load i8, i8* %dst_reg281, align 1
  %bf.clear283 = and i8 %bf.load282, -16
  %bf.set284 = or i8 %bf.clear283, 11
  store i8 %bf.set284, i8* %dst_reg281, align 1
  %src_reg285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral279, i32 0, i32 1
  %116 = load i32, i32* %off_reg, align 4
  %conv286 = trunc i32 %116 to i8
  %bf.load287 = load i8, i8* %src_reg285, align 1
  %bf.value288 = and i8 %conv286, 15
  %bf.shl289 = shl i8 %bf.value288, 4
  %bf.clear290 = and i8 %bf.load287, 15
  %bf.set291 = or i8 %bf.clear290, %bf.shl289
  store i8 %bf.set291, i8* %src_reg285, align 1
  %off292 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral279, i32 0, i32 2
  store i16 0, i16* %off292, align 2
  %imm293 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral279, i32 0, i32 3
  store i32 0, i32* %imm293, align 4
  %117 = bitcast %struct.bpf_insn* %115 to i8*
  %118 = bitcast %struct.bpf_insn* %.compoundliteral279 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %117, i8* align 4 %118, i64 8, i1 false)
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr294 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %119, i32 1
  store %struct.bpf_insn* %incdec.ptr294, %struct.bpf_insn** %patch, align 8
  %code296 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral295, i32 0, i32 0
  store i8 79, i8* %code296, align 4
  %dst_reg297 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral295, i32 0, i32 1
  %bf.load298 = load i8, i8* %dst_reg297, align 1
  %bf.clear299 = and i8 %bf.load298, -16
  %bf.set300 = or i8 %bf.clear299, 11
  store i8 %bf.set300, i8* %dst_reg297, align 1
  %src_reg301 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral295, i32 0, i32 1
  %120 = load i32, i32* %off_reg, align 4
  %conv302 = trunc i32 %120 to i8
  %bf.load303 = load i8, i8* %src_reg301, align 1
  %bf.value304 = and i8 %conv302, 15
  %bf.shl305 = shl i8 %bf.value304, 4
  %bf.clear306 = and i8 %bf.load303, 15
  %bf.set307 = or i8 %bf.clear306, %bf.shl305
  store i8 %bf.set307, i8* %src_reg301, align 1
  %off308 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral295, i32 0, i32 2
  store i16 0, i16* %off308, align 2
  %imm309 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral295, i32 0, i32 3
  store i32 0, i32* %imm309, align 4
  %121 = bitcast %struct.bpf_insn* %119 to i8*
  %122 = bitcast %struct.bpf_insn* %.compoundliteral295 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %121, i8* align 4 %122, i64 8, i1 false)
  %123 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr310 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %123, i32 1
  store %struct.bpf_insn* %incdec.ptr310, %struct.bpf_insn** %patch, align 8
  %code312 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 0
  store i8 -121, i8* %code312, align 4
  %dst_reg313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 1
  %bf.load314 = load i8, i8* %dst_reg313, align 1
  %bf.clear315 = and i8 %bf.load314, -16
  %bf.set316 = or i8 %bf.clear315, 11
  store i8 %bf.set316, i8* %dst_reg313, align 1
  %src_reg317 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 1
  %bf.load318 = load i8, i8* %src_reg317, align 1
  %bf.clear319 = and i8 %bf.load318, 15
  %bf.set320 = or i8 %bf.clear319, 0
  store i8 %bf.set320, i8* %src_reg317, align 1
  %off321 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 2
  store i16 0, i16* %off321, align 2
  %imm322 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 3
  store i32 0, i32* %imm322, align 4
  %124 = bitcast %struct.bpf_insn* %123 to i8*
  %125 = bitcast %struct.bpf_insn* %.compoundliteral311 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %124, i8* align 4 %125, i64 8, i1 false)
  %126 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr323 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %126, i32 1
  store %struct.bpf_insn* %incdec.ptr323, %struct.bpf_insn** %patch, align 8
  %code325 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral324, i32 0, i32 0
  store i8 -57, i8* %code325, align 4
  %dst_reg326 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral324, i32 0, i32 1
  %bf.load327 = load i8, i8* %dst_reg326, align 1
  %bf.clear328 = and i8 %bf.load327, -16
  %bf.set329 = or i8 %bf.clear328, 11
  store i8 %bf.set329, i8* %dst_reg326, align 1
  %src_reg330 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral324, i32 0, i32 1
  %bf.load331 = load i8, i8* %src_reg330, align 1
  %bf.clear332 = and i8 %bf.load331, 15
  %bf.set333 = or i8 %bf.clear332, 0
  store i8 %bf.set333, i8* %src_reg330, align 1
  %off334 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral324, i32 0, i32 2
  store i16 0, i16* %off334, align 2
  %imm335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral324, i32 0, i32 3
  store i32 63, i32* %imm335, align 4
  %127 = bitcast %struct.bpf_insn* %126 to i8*
  %128 = bitcast %struct.bpf_insn* %.compoundliteral324 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %127, i8* align 4 %128, i64 8, i1 false)
  %129 = load i8, i8* %issrc, align 1
  %tobool336 = trunc i8 %129 to i1
  br i1 %tobool336, label %if.then337, label %if.else358

if.then337:                                       ; preds = %if.end263
  %130 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr338 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %130, i32 1
  store %struct.bpf_insn* %incdec.ptr338, %struct.bpf_insn** %patch, align 8
  %code340 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral339, i32 0, i32 0
  store i8 95, i8* %code340, align 4
  %dst_reg341 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral339, i32 0, i32 1
  %bf.load342 = load i8, i8* %dst_reg341, align 1
  %bf.clear343 = and i8 %bf.load342, -16
  %bf.set344 = or i8 %bf.clear343, 11
  store i8 %bf.set344, i8* %dst_reg341, align 1
  %src_reg345 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral339, i32 0, i32 1
  %131 = load i32, i32* %off_reg, align 4
  %conv346 = trunc i32 %131 to i8
  %bf.load347 = load i8, i8* %src_reg345, align 1
  %bf.value348 = and i8 %conv346, 15
  %bf.shl349 = shl i8 %bf.value348, 4
  %bf.clear350 = and i8 %bf.load347, 15
  %bf.set351 = or i8 %bf.clear350, %bf.shl349
  store i8 %bf.set351, i8* %src_reg345, align 1
  %off352 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral339, i32 0, i32 2
  store i16 0, i16* %off352, align 2
  %imm353 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral339, i32 0, i32 3
  store i32 0, i32* %imm353, align 4
  %132 = bitcast %struct.bpf_insn* %130 to i8*
  %133 = bitcast %struct.bpf_insn* %.compoundliteral339 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %132, i8* align 4 %133, i64 8, i1 false)
  %134 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg354 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %134, i32 0, i32 1
  %bf.load355 = load i8, i8* %src_reg354, align 1
  %bf.clear356 = and i8 %bf.load355, 15
  %bf.set357 = or i8 %bf.clear356, -80
  store i8 %bf.set357, i8* %src_reg354, align 1
  br label %if.end374

if.else358:                                       ; preds = %if.end263
  %135 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr359 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %135, i32 1
  store %struct.bpf_insn* %incdec.ptr359, %struct.bpf_insn** %patch, align 8
  %code361 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral360, i32 0, i32 0
  store i8 95, i8* %code361, align 4
  %dst_reg362 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral360, i32 0, i32 1
  %136 = load i32, i32* %off_reg, align 4
  %conv363 = trunc i32 %136 to i8
  %bf.load364 = load i8, i8* %dst_reg362, align 1
  %bf.value365 = and i8 %conv363, 15
  %bf.clear366 = and i8 %bf.load364, -16
  %bf.set367 = or i8 %bf.clear366, %bf.value365
  store i8 %bf.set367, i8* %dst_reg362, align 1
  %src_reg368 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral360, i32 0, i32 1
  %bf.load369 = load i8, i8* %src_reg368, align 1
  %bf.clear370 = and i8 %bf.load369, 15
  %bf.set371 = or i8 %bf.clear370, -80
  store i8 %bf.set371, i8* %src_reg368, align 1
  %off372 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral360, i32 0, i32 2
  store i16 0, i16* %off372, align 2
  %imm373 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral360, i32 0, i32 3
  store i32 0, i32* %imm373, align 4
  %137 = bitcast %struct.bpf_insn* %135 to i8*
  %138 = bitcast %struct.bpf_insn* %.compoundliteral360 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %137, i8* align 4 %138, i64 8, i1 false)
  br label %if.end374

if.end374:                                        ; preds = %if.else358, %if.then337
  %139 = load i8, i8* %isneg, align 1
  %tobool375 = trunc i8 %139 to i1
  br i1 %tobool375, label %if.then376, label %if.end384

if.then376:                                       ; preds = %if.end374
  %140 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code377 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %140, i32 0, i32 0
  %141 = load i8, i8* %code377, align 4
  %conv378 = zext i8 %141 to i32
  %cmp379 = icmp eq i32 %conv378, 15
  %142 = zext i1 %cmp379 to i64
  %cond381 = select i1 %cmp379, i32 31, i32 15
  %conv382 = trunc i32 %cond381 to i8
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code383 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %143, i32 0, i32 0
  store i8 %conv382, i8* %code383, align 4
  br label %if.end384

if.end384:                                        ; preds = %if.then376, %if.end374
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr385 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %144, i32 1
  store %struct.bpf_insn* %incdec.ptr385, %struct.bpf_insn** %patch, align 8
  %145 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %146 = bitcast %struct.bpf_insn* %144 to i8*
  %147 = bitcast %struct.bpf_insn* %145 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %146, i8* align 4 %147, i64 8, i1 false)
  %148 = load i8, i8* %issrc, align 1
  %tobool386 = trunc i8 %148 to i1
  br i1 %tobool386, label %land.lhs.true388, label %if.end407

land.lhs.true388:                                 ; preds = %if.end384
  %149 = load i8, i8* %isneg, align 1
  %tobool389 = trunc i8 %149 to i1
  br i1 %tobool389, label %if.then391, label %if.end407

if.then391:                                       ; preds = %land.lhs.true388
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr392 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %150, i32 1
  store %struct.bpf_insn* %incdec.ptr392, %struct.bpf_insn** %patch, align 8
  %code394 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral393, i32 0, i32 0
  store i8 39, i8* %code394, align 4
  %dst_reg395 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral393, i32 0, i32 1
  %151 = load i32, i32* %off_reg, align 4
  %conv396 = trunc i32 %151 to i8
  %bf.load397 = load i8, i8* %dst_reg395, align 1
  %bf.value398 = and i8 %conv396, 15
  %bf.clear399 = and i8 %bf.load397, -16
  %bf.set400 = or i8 %bf.clear399, %bf.value398
  store i8 %bf.set400, i8* %dst_reg395, align 1
  %src_reg401 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral393, i32 0, i32 1
  %bf.load402 = load i8, i8* %src_reg401, align 1
  %bf.clear403 = and i8 %bf.load402, 15
  %bf.set404 = or i8 %bf.clear403, 0
  store i8 %bf.set404, i8* %src_reg401, align 1
  %off405 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral393, i32 0, i32 2
  store i16 0, i16* %off405, align 2
  %imm406 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral393, i32 0, i32 3
  store i32 -1, i32* %imm406, align 4
  %152 = bitcast %struct.bpf_insn* %150 to i8*
  %153 = bitcast %struct.bpf_insn* %.compoundliteral393 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %152, i8* align 4 %153, i64 8, i1 false)
  br label %if.end407

if.end407:                                        ; preds = %if.then391, %land.lhs.true388, %if.end384
  %154 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %arraydecay408 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf215, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_insn* %154 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_insn* %arraydecay408 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv409 = trunc i64 %sub.ptr.div to i32
  store i32 %conv409, i32* %cnt, align 4
  %155 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %156 = load i32, i32* %i, align 4
  %157 = load i32, i32* %delta, align 4
  %add410 = add i32 %156, %157
  %arraydecay411 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf215, i64 0, i64 0
  %158 = load i32, i32* %cnt, align 4
  %call412 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %155, i32 noundef %add410, %struct.bpf_insn* noundef %arraydecay411, i32 noundef %158) #8
  store %struct.bpf_prog* %call412, %struct.bpf_prog** %new_prog, align 8
  %159 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool413 = icmp ne %struct.bpf_prog* %159, null
  br i1 %tobool413, label %if.end415, label %if.then414

if.then414:                                       ; preds = %if.end407
  store i32 -12, i32* %retval, align 4
  br label %return

if.end415:                                        ; preds = %if.end407
  %160 = load i32, i32* %cnt, align 4
  %sub416 = sub i32 %160, 1
  %161 = load i32, i32* %delta, align 4
  %add417 = add i32 %161, %sub416
  store i32 %add417, i32* %delta, align 4
  %162 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %162, %struct.bpf_prog** %prog, align 8
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog418 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %163, i32 0, i32 2
  store %struct.bpf_prog* %162, %struct.bpf_prog** %prog418, align 8
  %164 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %165 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %164, i32 0, i32 10
  %insnsi419 = bitcast %union.anon.146* %165 to [0 x %struct.bpf_insn]*
  %arraydecay420 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi419, i64 0, i64 0
  %166 = load i32, i32* %i, align 4
  %idx.ext421 = sext i32 %166 to i64
  %add.ptr422 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay420, i64 %idx.ext421
  %167 = load i32, i32* %delta, align 4
  %idx.ext423 = sext i32 %167 to i64
  %add.ptr424 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr422, i64 %idx.ext423
  store %struct.bpf_insn* %add.ptr424, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end425:                                        ; preds = %lor.lhs.false209
  %168 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code426 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %168, i32 0, i32 0
  %169 = load i8, i8* %code426, align 4
  %conv427 = zext i8 %169 to i32
  %cmp428 = icmp ne i32 %conv427, 133
  br i1 %cmp428, label %if.then430, label %if.end431

if.then430:                                       ; preds = %if.end425
  br label %for.inc

if.end431:                                        ; preds = %if.end425
  %170 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg432 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %170, i32 0, i32 1
  %bf.load433 = load i8, i8* %src_reg432, align 1
  %bf.lshr434 = lshr i8 %bf.load433, 4
  %conv435 = zext i8 %bf.lshr434 to i32
  %cmp436 = icmp eq i32 %conv435, 1
  br i1 %cmp436, label %if.then438, label %if.end439

if.then438:                                       ; preds = %if.end431
  br label %for.inc

if.end439:                                        ; preds = %if.end431
  %171 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm440 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %171, i32 0, i32 3
  %172 = load i32, i32* %imm440, align 4
  %cmp441 = icmp eq i32 %172, 24
  br i1 %cmp441, label %if.then443, label %if.end447

if.then443:                                       ; preds = %if.end439
  %173 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %dst_needed = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %173, i32 0, i32 1
  %bf.load444 = load i16, i16* %dst_needed, align 2
  %bf.clear445 = and i16 %bf.load444, -17
  %bf.set446 = or i16 %bf.clear445, 16
  store i16 %bf.set446, i16* %dst_needed, align 2
  br label %if.end447

if.end447:                                        ; preds = %if.then443, %if.end439
  %174 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm448 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %174, i32 0, i32 3
  %175 = load i32, i32* %imm448, align 4
  %cmp449 = icmp eq i32 %175, 7
  br i1 %cmp449, label %if.then451, label %if.end452

if.then451:                                       ; preds = %if.end447
  call void @bpf_user_rnd_init_once() #8
  br label %if.end452

if.end452:                                        ; preds = %if.then451, %if.end447
  %176 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm453 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %176, i32 0, i32 3
  %177 = load i32, i32* %imm453, align 4
  %cmp454 = icmp eq i32 %177, 58
  br i1 %cmp454, label %if.then456, label %if.end460

if.then456:                                       ; preds = %if.end452
  %178 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %kprobe_override = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %178, i32 0, i32 1
  %bf.load457 = load i16, i16* %kprobe_override, align 2
  %bf.clear458 = and i16 %bf.load457, -129
  %bf.set459 = or i16 %bf.clear458, 128
  store i16 %bf.set459, i16* %kprobe_override, align 2
  br label %if.end460

if.end460:                                        ; preds = %if.then456, %if.end452
  %179 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm461 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %179, i32 0, i32 3
  %180 = load i32, i32* %imm461, align 4
  %cmp462 = icmp eq i32 %180, 12
  br i1 %cmp462, label %if.then464, label %if.end528

if.then464:                                       ; preds = %if.end460
  %181 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %cb_access = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %181, i32 0, i32 1
  %bf.load465 = load i16, i16* %cb_access, align 2
  %bf.clear466 = and i16 %bf.load465, -9
  %bf.set467 = or i16 %bf.clear466, 8
  store i16 %bf.set467, i16* %cb_access, align 2
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog468 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %182, i32 0, i32 2
  %183 = load %struct.bpf_prog*, %struct.bpf_prog** %prog468, align 8
  %aux469 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %183, i32 0, i32 7
  %184 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux469, align 8
  %stack_depth = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %184, i32 0, i32 5
  store i32 512, i32* %stack_depth, align 4
  %185 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog470 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %185, i32 0, i32 2
  %186 = load %struct.bpf_prog*, %struct.bpf_prog** %prog470, align 8
  %aux471 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %186, i32 0, i32 7
  %187 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux471, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %187, i32 0, i32 3
  store i32 65535, i32* %max_pkt_offset, align 4
  %188 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm472 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %188, i32 0, i32 3
  store i32 0, i32* %imm472, align 4
  %189 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code473 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %189, i32 0, i32 0
  store i8 -11, i8* %code473, align 4
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data474 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %190, i32 0, i32 16
  %191 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data474, align 8
  %192 = load i32, i32* %i, align 4
  %193 = load i32, i32* %delta, align 4
  %add475 = add i32 %192, %193
  %idxprom476 = sext i32 %add475 to i64
  %arrayidx477 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %191, i64 %idxprom476
  store %struct.bpf_insn_aux_data* %arrayidx477, %struct.bpf_insn_aux_data** %aux, align 8
  %194 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call478 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %194) #8
  br i1 %call478, label %if.end480, label %if.then479

if.then479:                                       ; preds = %if.then464
  br label %for.inc

if.end480:                                        ; preds = %if.then464
  %195 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call481 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %195) #8
  br i1 %call481, label %if.then482, label %if.end483

if.then482:                                       ; preds = %if.end480
  %196 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %197 = bitcast %struct.bpf_verifier_env* %196 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %197, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.286, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end483:                                        ; preds = %if.end480
  %198 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %199 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %198, i32 0, i32 0
  %map_state = bitcast %union.anon.13* %199 to i64*
  %200 = load i64, i64* %map_state, align 8
  %and484 = and i64 %200, -2
  %201 = inttoptr i64 %and484 to %struct.bpf_map*
  store %struct.bpf_map* %201, %struct.bpf_map** %map_ptr, align 8
  %arrayidx485 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code487 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral486, i32 0, i32 0
  store i8 53, i8* %code487, align 4
  %dst_reg488 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral486, i32 0, i32 1
  %bf.load489 = load i8, i8* %dst_reg488, align 1
  %bf.clear490 = and i8 %bf.load489, -16
  %bf.set491 = or i8 %bf.clear490, 3
  store i8 %bf.set491, i8* %dst_reg488, align 1
  %src_reg492 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral486, i32 0, i32 1
  %bf.load493 = load i8, i8* %src_reg492, align 1
  %bf.clear494 = and i8 %bf.load493, 15
  %bf.set495 = or i8 %bf.clear494, 0
  store i8 %bf.set495, i8* %src_reg492, align 1
  %off496 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral486, i32 0, i32 2
  store i16 2, i16* %off496, align 2
  %imm497 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral486, i32 0, i32 3
  %202 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %202, i32 0, i32 6
  %203 = load i32, i32* %max_entries, align 4
  store i32 %203, i32* %imm497, align 4
  %204 = bitcast %struct.bpf_insn* %arrayidx485 to i8*
  %205 = bitcast %struct.bpf_insn* %.compoundliteral486 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %204, i8* align 4 %205, i64 8, i1 false)
  %arrayidx498 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %code500 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral499, i32 0, i32 0
  store i8 84, i8* %code500, align 4
  %dst_reg501 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral499, i32 0, i32 1
  %bf.load502 = load i8, i8* %dst_reg501, align 1
  %bf.clear503 = and i8 %bf.load502, -16
  %bf.set504 = or i8 %bf.clear503, 3
  store i8 %bf.set504, i8* %dst_reg501, align 1
  %src_reg505 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral499, i32 0, i32 1
  %bf.load506 = load i8, i8* %src_reg505, align 1
  %bf.clear507 = and i8 %bf.load506, 15
  %bf.set508 = or i8 %bf.clear507, 0
  store i8 %bf.set508, i8* %src_reg505, align 1
  %off509 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral499, i32 0, i32 2
  store i16 0, i16* %off509, align 2
  %imm510 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral499, i32 0, i32 3
  %206 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %207 = bitcast %struct.bpf_map* %206 to i8*
  store i8* %207, i8** %__mptr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end483
  br label %do.end

do.end:                                           ; preds = %do.body
  %208 = load i8*, i8** %__mptr, align 8
  %add.ptr511 = getelementptr i8, i8* %208, i64 0
  %209 = bitcast i8* %add.ptr511 to %struct.bpf_array*
  store %struct.bpf_array* %209, %struct.bpf_array** %tmp, align 8
  %210 = load %struct.bpf_array*, %struct.bpf_array** %tmp, align 8
  %index_mask = getelementptr inbounds %struct.bpf_array, %struct.bpf_array* %210, i32 0, i32 2
  %211 = load i32, i32* %index_mask, align 4
  store i32 %211, i32* %imm510, align 4
  %212 = bitcast %struct.bpf_insn* %arrayidx498 to i8*
  %213 = bitcast %struct.bpf_insn* %.compoundliteral499 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %212, i8* align 4 %213, i64 8, i1 false)
  %arrayidx512 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %214 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %215 = bitcast %struct.bpf_insn* %arrayidx512 to i8*
  %216 = bitcast %struct.bpf_insn* %214 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %215, i8* align 4 %216, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %218 = load i32, i32* %i, align 4
  %219 = load i32, i32* %delta, align 4
  %add513 = add i32 %218, %219
  %arraydecay514 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %220 = load i32, i32* %cnt, align 4
  %call515 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %217, i32 noundef %add513, %struct.bpf_insn* noundef %arraydecay514, i32 noundef %220) #8
  store %struct.bpf_prog* %call515, %struct.bpf_prog** %new_prog, align 8
  %221 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool516 = icmp ne %struct.bpf_prog* %221, null
  br i1 %tobool516, label %if.end518, label %if.then517

if.then517:                                       ; preds = %do.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end518:                                        ; preds = %do.end
  %222 = load i32, i32* %cnt, align 4
  %sub519 = sub i32 %222, 1
  %223 = load i32, i32* %delta, align 4
  %add520 = add i32 %223, %sub519
  store i32 %add520, i32* %delta, align 4
  %224 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %224, %struct.bpf_prog** %prog, align 8
  %225 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog521 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %225, i32 0, i32 2
  store %struct.bpf_prog* %224, %struct.bpf_prog** %prog521, align 8
  %226 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %227 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %226, i32 0, i32 10
  %insnsi522 = bitcast %union.anon.146* %227 to [0 x %struct.bpf_insn]*
  %arraydecay523 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi522, i64 0, i64 0
  %228 = load i32, i32* %i, align 4
  %idx.ext524 = sext i32 %228 to i64
  %add.ptr525 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay523, i64 %idx.ext524
  %229 = load i32, i32* %delta, align 4
  %idx.ext526 = sext i32 %229 to i64
  %add.ptr527 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr525, i64 %idx.ext526
  store %struct.bpf_insn* %add.ptr527, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end528:                                        ; preds = %if.end460
  %230 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %230, i32 0, i32 1
  %bf.load529 = load i16, i16* %jit_requested, align 2
  %bf.lshr530 = lshr i16 %bf.load529, 1
  %bf.clear531 = and i16 %bf.lshr530, 1
  %conv532 = zext i16 %bf.clear531 to i32
  %tobool533 = icmp ne i32 %conv532, 0
  br i1 %tobool533, label %land.lhs.true534, label %if.end644

land.lhs.true534:                                 ; preds = %if.end528
  %231 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm535 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %231, i32 0, i32 3
  %232 = load i32, i32* %imm535, align 4
  %cmp536 = icmp eq i32 %232, 1
  br i1 %cmp536, label %if.then558, label %lor.lhs.false538

lor.lhs.false538:                                 ; preds = %land.lhs.true534
  %233 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm539 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %233, i32 0, i32 3
  %234 = load i32, i32* %imm539, align 4
  %cmp540 = icmp eq i32 %234, 2
  br i1 %cmp540, label %if.then558, label %lor.lhs.false542

lor.lhs.false542:                                 ; preds = %lor.lhs.false538
  %235 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm543 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %235, i32 0, i32 3
  %236 = load i32, i32* %imm543, align 4
  %cmp544 = icmp eq i32 %236, 3
  br i1 %cmp544, label %if.then558, label %lor.lhs.false546

lor.lhs.false546:                                 ; preds = %lor.lhs.false542
  %237 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm547 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %237, i32 0, i32 3
  %238 = load i32, i32* %imm547, align 4
  %cmp548 = icmp eq i32 %238, 87
  br i1 %cmp548, label %if.then558, label %lor.lhs.false550

lor.lhs.false550:                                 ; preds = %lor.lhs.false546
  %239 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm551 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %239, i32 0, i32 3
  %240 = load i32, i32* %imm551, align 4
  %cmp552 = icmp eq i32 %240, 88
  br i1 %cmp552, label %if.then558, label %lor.lhs.false554

lor.lhs.false554:                                 ; preds = %lor.lhs.false550
  %241 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm555 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %241, i32 0, i32 3
  %242 = load i32, i32* %imm555, align 4
  %cmp556 = icmp eq i32 %242, 89
  br i1 %cmp556, label %if.then558, label %if.end644

if.then558:                                       ; preds = %lor.lhs.false554, %lor.lhs.false550, %lor.lhs.false546, %lor.lhs.false542, %lor.lhs.false538, %land.lhs.true534
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data559 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %243, i32 0, i32 16
  %244 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data559, align 8
  %245 = load i32, i32* %i, align 4
  %246 = load i32, i32* %delta, align 4
  %add560 = add i32 %245, %246
  %idxprom561 = sext i32 %add560 to i64
  %arrayidx562 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %244, i64 %idxprom561
  store %struct.bpf_insn_aux_data* %arrayidx562, %struct.bpf_insn_aux_data** %aux, align 8
  %247 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call563 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %247) #8
  br i1 %call563, label %if.then564, label %if.end565

if.then564:                                       ; preds = %if.then558
  br label %patch_call_imm

if.end565:                                        ; preds = %if.then558
  %248 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %249 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %248, i32 0, i32 0
  %map_state566 = bitcast %union.anon.13* %249 to i64*
  %250 = load i64, i64* %map_state566, align 8
  %and567 = and i64 %250, -2
  %251 = inttoptr i64 %and567 to %struct.bpf_map*
  store %struct.bpf_map* %251, %struct.bpf_map** %map_ptr, align 8
  %252 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops568 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %252, i32 0, i32 0
  %253 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops568, align 64
  store %struct.bpf_map_ops* %253, %struct.bpf_map_ops** %ops, align 8
  %254 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm569 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %254, i32 0, i32 3
  %255 = load i32, i32* %imm569, align 4
  %cmp570 = icmp eq i32 %255, 1
  br i1 %cmp570, label %land.lhs.true572, label %if.end601

land.lhs.true572:                                 ; preds = %if.end565
  %256 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %256, i32 0, i32 15
  %257 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup, align 8
  %tobool573 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_insn*)* %257, null
  br i1 %tobool573, label %if.then574, label %if.end601

if.then574:                                       ; preds = %land.lhs.true572
  %258 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup575 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %258, i32 0, i32 15
  %259 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup575, align 8
  %260 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %arraydecay576 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call577 = call i32 %259(%struct.bpf_map* noundef %260, %struct.bpf_insn* noundef %arraydecay576) #8
  store i32 %call577, i32* %cnt, align 4
  %261 = load i32, i32* %cnt, align 4
  %cmp578 = icmp eq i32 %261, 0
  br i1 %cmp578, label %if.then584, label %lor.lhs.false580

lor.lhs.false580:                                 ; preds = %if.then574
  %262 = load i32, i32* %cnt, align 4
  %conv581 = sext i32 %262 to i64
  %cmp582 = icmp uge i64 %conv581, 16
  br i1 %cmp582, label %if.then584, label %if.end585

if.then584:                                       ; preds = %lor.lhs.false580, %if.then574
  %263 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %264 = bitcast %struct.bpf_verifier_env* %263 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %264, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end585:                                        ; preds = %lor.lhs.false580
  %265 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %266 = load i32, i32* %i, align 4
  %267 = load i32, i32* %delta, align 4
  %add586 = add i32 %266, %267
  %arraydecay587 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %268 = load i32, i32* %cnt, align 4
  %call588 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %265, i32 noundef %add586, %struct.bpf_insn* noundef %arraydecay587, i32 noundef %268) #8
  store %struct.bpf_prog* %call588, %struct.bpf_prog** %new_prog, align 8
  %269 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool589 = icmp ne %struct.bpf_prog* %269, null
  br i1 %tobool589, label %if.end591, label %if.then590

if.then590:                                       ; preds = %if.end585
  store i32 -12, i32* %retval, align 4
  br label %return

if.end591:                                        ; preds = %if.end585
  %270 = load i32, i32* %cnt, align 4
  %sub592 = sub i32 %270, 1
  %271 = load i32, i32* %delta, align 4
  %add593 = add i32 %271, %sub592
  store i32 %add593, i32* %delta, align 4
  %272 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %272, %struct.bpf_prog** %prog, align 8
  %273 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog594 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %273, i32 0, i32 2
  store %struct.bpf_prog* %272, %struct.bpf_prog** %prog594, align 8
  %274 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %275 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %274, i32 0, i32 10
  %insnsi595 = bitcast %union.anon.146* %275 to [0 x %struct.bpf_insn]*
  %arraydecay596 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi595, i64 0, i64 0
  %276 = load i32, i32* %i, align 4
  %idx.ext597 = sext i32 %276 to i64
  %add.ptr598 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay596, i64 %idx.ext597
  %277 = load i32, i32* %delta, align 4
  %idx.ext599 = sext i32 %277 to i64
  %add.ptr600 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr598, i64 %idx.ext599
  store %struct.bpf_insn* %add.ptr600, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end601:                                        ; preds = %land.lhs.true572, %if.end565
  br label %do.body602

do.body602:                                       ; preds = %if.end601
  br label %do.end603

do.end603:                                        ; preds = %do.body602
  br label %do.body604

do.body604:                                       ; preds = %do.end603
  br label %do.end605

do.end605:                                        ; preds = %do.body604
  br label %do.body606

do.body606:                                       ; preds = %do.end605
  br label %do.end607

do.end607:                                        ; preds = %do.body606
  br label %do.body608

do.body608:                                       ; preds = %do.end607
  br label %do.end609

do.end609:                                        ; preds = %do.body608
  br label %do.body610

do.body610:                                       ; preds = %do.end609
  br label %do.end611

do.end611:                                        ; preds = %do.body610
  br label %do.body612

do.body612:                                       ; preds = %do.end611
  br label %do.end613

do.end613:                                        ; preds = %do.body612
  %278 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm614 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %278, i32 0, i32 3
  %279 = load i32, i32* %imm614, align 4
  switch i32 %279, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb619
    i32 3, label %sw.bb624
    i32 87, label %sw.bb629
    i32 88, label %sw.bb634
    i32 89, label %sw.bb639
  ]

sw.bb:                                            ; preds = %do.end613
  %280 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_lookup_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %280, i32 0, i32 7
  %281 = load i8* (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, i8*)** %map_lookup_elem, align 8
  %282 = bitcast i8* (%struct.bpf_map*, i8*)* %281 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast615 = ptrtoint i64 (i64, i64, i64, i64, i64)* %282 to i64
  %sub.ptr.sub616 = sub i64 %sub.ptr.lhs.cast615, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv617 = trunc i64 %sub.ptr.sub616 to i32
  %283 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm618 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %283, i32 0, i32 3
  store i32 %conv617, i32* %imm618, align 4
  br label %for.inc

sw.bb619:                                         ; preds = %do.end613
  %284 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_update_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %284, i32 0, i32 8
  %285 = load i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i8*, i64)** %map_update_elem, align 8
  %286 = bitcast i32 (%struct.bpf_map*, i8*, i8*, i64)* %285 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast620 = ptrtoint i64 (i64, i64, i64, i64, i64)* %286 to i64
  %sub.ptr.sub621 = sub i64 %sub.ptr.lhs.cast620, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv622 = trunc i64 %sub.ptr.sub621 to i32
  %287 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm623 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %287, i32 0, i32 3
  store i32 %conv622, i32* %imm623, align 4
  br label %for.inc

sw.bb624:                                         ; preds = %do.end613
  %288 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_delete_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %288, i32 0, i32 9
  %289 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_delete_elem, align 8
  %290 = bitcast i32 (%struct.bpf_map*, i8*)* %289 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast625 = ptrtoint i64 (i64, i64, i64, i64, i64)* %290 to i64
  %sub.ptr.sub626 = sub i64 %sub.ptr.lhs.cast625, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv627 = trunc i64 %sub.ptr.sub626 to i32
  %291 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm628 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %291, i32 0, i32 3
  store i32 %conv627, i32* %imm628, align 4
  br label %for.inc

sw.bb629:                                         ; preds = %do.end613
  %292 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_push_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %292, i32 0, i32 10
  %293 = load i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i64)** %map_push_elem, align 8
  %294 = bitcast i32 (%struct.bpf_map*, i8*, i64)* %293 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast630 = ptrtoint i64 (i64, i64, i64, i64, i64)* %294 to i64
  %sub.ptr.sub631 = sub i64 %sub.ptr.lhs.cast630, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv632 = trunc i64 %sub.ptr.sub631 to i32
  %295 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm633 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %295, i32 0, i32 3
  store i32 %conv632, i32* %imm633, align 4
  br label %for.inc

sw.bb634:                                         ; preds = %do.end613
  %296 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_pop_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %296, i32 0, i32 11
  %297 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_pop_elem, align 8
  %298 = bitcast i32 (%struct.bpf_map*, i8*)* %297 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast635 = ptrtoint i64 (i64, i64, i64, i64, i64)* %298 to i64
  %sub.ptr.sub636 = sub i64 %sub.ptr.lhs.cast635, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv637 = trunc i64 %sub.ptr.sub636 to i32
  %299 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm638 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %299, i32 0, i32 3
  store i32 %conv637, i32* %imm638, align 4
  br label %for.inc

sw.bb639:                                         ; preds = %do.end613
  %300 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_peek_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %300, i32 0, i32 12
  %301 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_peek_elem, align 8
  %302 = bitcast i32 (%struct.bpf_map*, i8*)* %301 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast640 = ptrtoint i64 (i64, i64, i64, i64, i64)* %302 to i64
  %sub.ptr.sub641 = sub i64 %sub.ptr.lhs.cast640, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv642 = trunc i64 %sub.ptr.sub641 to i32
  %303 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm643 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %303, i32 0, i32 3
  store i32 %conv642, i32* %imm643, align 4
  br label %for.inc

sw.epilog:                                        ; preds = %do.end613
  br label %patch_call_imm

if.end644:                                        ; preds = %lor.lhs.false554, %if.end528
  br label %patch_call_imm

patch_call_imm:                                   ; preds = %if.end644, %sw.epilog, %if.then564
  %304 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops645 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %304, i32 0, i32 3
  %305 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops645, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %305, i32 0, i32 0
  %306 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %307 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm646 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %307, i32 0, i32 3
  %308 = load i32, i32* %imm646, align 4
  %309 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog647 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %309, i32 0, i32 2
  %310 = load %struct.bpf_prog*, %struct.bpf_prog** %prog647, align 8
  %call648 = call %struct.bpf_func_proto* %306(i32 noundef %308, %struct.bpf_prog* noundef %310) #8
  store %struct.bpf_func_proto* %call648, %struct.bpf_func_proto** %fn, align 8
  %311 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %311, i32 0, i32 0
  %312 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %tobool649 = icmp ne i64 (i64, i64, i64, i64, i64)* %312, null
  br i1 %tobool649, label %if.end654, label %if.then650

if.then650:                                       ; preds = %patch_call_imm
  %313 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %314 = bitcast %struct.bpf_verifier_env* %313 to i8*
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm651 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %315, i32 0, i32 3
  %316 = load i32, i32* %imm651, align 4
  %call652 = call i8* @func_id_name(i32 noundef %316) #8
  %317 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm653 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %317, i32 0, i32 3
  %318 = load i32, i32* %imm653, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %314, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.222, i64 0, i64 0), i8* noundef %call652, i32 noundef %318) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end654:                                        ; preds = %patch_call_imm
  %319 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func655 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %319, i32 0, i32 0
  %320 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func655, align 8
  %sub.ptr.lhs.cast656 = ptrtoint i64 (i64, i64, i64, i64, i64)* %320 to i64
  %sub.ptr.sub657 = sub i64 %sub.ptr.lhs.cast656, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv658 = trunc i64 %sub.ptr.sub657 to i32
  %321 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm659 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %321, i32 0, i32 3
  store i32 %conv658, i32* %imm659, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end654, %sw.bb639, %sw.bb634, %sw.bb629, %sw.bb624, %sw.bb619, %sw.bb, %if.end591, %if.end518, %if.then479, %if.then438, %if.then430, %if.end415, %if.then224, %if.end194, %if.end150
  %322 = load i32, i32* %i, align 4
  %inc = add i32 %322, 1
  store i32 %inc, i32* %i, align 4
  %323 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr660 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %323, i32 1
  store %struct.bpf_insn* %incdec.ptr660, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then650, %if.then590, %if.then584, %if.then517, %if.then482, %if.then414, %if.then193, %if.then187, %if.then149
  %324 = load i32, i32* %retval, align 4
  ret i32 %324
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %patch = alloca %struct.bpf_insn*, align 8
  %zext_patch = alloca [2 x %struct.bpf_insn], align 16
  %rnd_hi32_patch = alloca [4 x %struct.bpf_insn], align 16
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %i = alloca i32, align 4
  %patch_len = alloca i32, align 4
  %delta = alloca i32, align 4
  %len = alloca i32, align 4
  %insns = alloca %struct.bpf_insn*, align 8
  %new_prog = alloca %struct.bpf_prog*, align 8
  %rnd_hi32 = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral7 = alloca %struct.bpf_insn, align 4
  %.compoundliteral20 = alloca %struct.bpf_insn, align 4
  %.compoundliteral33 = alloca %struct.bpf_insn, align 4
  %adj_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn, align 4
  %code49 = alloca i8, align 1
  %class = alloca i8, align 1
  %imm_rnd = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len1, align 4
  store i32 %4, i32* %len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %7 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %7 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %8 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %9 = bitcast %union.bpf_attr* %8 to %struct.anon.1*
  %prog_flags = getelementptr inbounds %struct.anon.1, %struct.anon.1* %9, i32 0, i32 8
  %10 = load i32, i32* %prog_flags, align 4
  %and = and i32 %10, 4
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %rnd_hi32, align 1
  %arrayidx = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -68, i8* %code, align 4
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 0
  store i8 %bf.set5, i8* %src_reg, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 1, i32* %imm, align 4
  %11 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %12 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 4 %12, i64 8, i1 false)
  %arrayidx6 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %code8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 0
  store i8 -73, i8* %code8, align 4
  %dst_reg9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load10 = load i8, i8* %dst_reg9, align 1
  %bf.clear11 = and i8 %bf.load10, -16
  %bf.set12 = or i8 %bf.clear11, 11
  store i8 %bf.set12, i8* %dst_reg9, align 1
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %bf.set16 = or i8 %bf.clear15, 0
  store i8 %bf.set16, i8* %src_reg13, align 1
  %off17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 2
  store i16 0, i16* %off17, align 2
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 3
  store i32 0, i32* %imm18, align 4
  %13 = bitcast %struct.bpf_insn* %arrayidx6 to i8*
  %14 = bitcast %struct.bpf_insn* %.compoundliteral7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 4 %14, i64 8, i1 false)
  %arrayidx19 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 2
  %code21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 0
  store i8 103, i8* %code21, align 4
  %dst_reg22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load23 = load i8, i8* %dst_reg22, align 1
  %bf.clear24 = and i8 %bf.load23, -16
  %bf.set25 = or i8 %bf.clear24, 11
  store i8 %bf.set25, i8* %dst_reg22, align 1
  %src_reg26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load27 = load i8, i8* %src_reg26, align 1
  %bf.clear28 = and i8 %bf.load27, 15
  %bf.set29 = or i8 %bf.clear28, 0
  store i8 %bf.set29, i8* %src_reg26, align 1
  %off30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 2
  store i16 0, i16* %off30, align 2
  %imm31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 3
  store i32 32, i32* %imm31, align 4
  %15 = bitcast %struct.bpf_insn* %arrayidx19 to i8*
  %16 = bitcast %struct.bpf_insn* %.compoundliteral20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %15, i8* align 4 %16, i64 8, i1 false)
  %arrayidx32 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %code34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 0
  store i8 79, i8* %code34, align 4
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, -16
  %bf.set38 = or i8 %bf.clear37, 0
  store i8 %bf.set38, i8* %dst_reg35, align 1
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.clear41 = and i8 %bf.load40, 15
  %bf.set42 = or i8 %bf.clear41, -80
  store i8 %bf.set42, i8* %src_reg39, align 1
  %off43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 2
  store i16 0, i16* %off43, align 2
  %imm44 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 3
  store i32 0, i32* %imm44, align 4
  %17 = bitcast %struct.bpf_insn* %arrayidx32 to i8*
  %18 = bitcast %struct.bpf_insn* %.compoundliteral33 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 4 %18, i64 8, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %19 = load i32, i32* %i, align 4
  %20 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %19, %20
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load i32, i32* %i, align 4
  %22 = load i32, i32* %delta, align 4
  %add = add i32 %21, %22
  store i32 %add, i32* %adj_idx, align 4
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %24 = load i32, i32* %adj_idx, align 4
  %idxprom = sext i32 %24 to i64
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %23, i64 %idxprom
  %25 = bitcast %struct.bpf_insn* %insn to i8*
  %26 = bitcast %struct.bpf_insn* %arrayidx45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %25, i8* align 4 %26, i64 8, i1 false)
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %28 = load i32, i32* %adj_idx, align 4
  %idxprom46 = sext i32 %28 to i64
  %arrayidx47 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idxprom46
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx47, i32 0, i32 4
  %29 = load i8, i8* %zext_dst, align 1
  %tobool48 = trunc i8 %29 to i1
  br i1 %tobool48, label %if.end96, label %if.then

if.then:                                          ; preds = %for.body
  %30 = load i8, i8* %rnd_hi32, align 1
  %tobool50 = trunc i8 %30 to i1
  br i1 %tobool50, label %if.end, label %if.then51

if.then51:                                        ; preds = %if.then
  br label %for.inc

if.end:                                           ; preds = %if.then
  %code52 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %31 = load i8, i8* %code52, align 4
  store i8 %31, i8* %code49, align 1
  %32 = load i8, i8* %code49, align 1
  %conv = zext i8 %32 to i32
  %and53 = and i32 %conv, 7
  %conv54 = trunc i32 %and53 to i8
  store i8 %conv54, i8* %class, align 1
  %call = call zeroext i1 @insn_no_def(%struct.bpf_insn* noundef %insn) #8
  br i1 %call, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end
  br label %for.inc

if.end56:                                         ; preds = %if.end
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %dst_reg57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load58 = load i8, i8* %dst_reg57, align 1
  %bf.clear59 = and i8 %bf.load58, 15
  %conv60 = zext i8 %bf.clear59 to i32
  %call61 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %33, %struct.bpf_insn* noundef %insn, i32 noundef %conv60, %struct.bpf_reg_state* noundef null, i32 noundef 1) #8
  br i1 %call61, label %if.then62, label %if.end72

if.then62:                                        ; preds = %if.end56
  %34 = load i8, i8* %class, align 1
  %conv63 = zext i8 %34 to i32
  %cmp64 = icmp eq i32 %conv63, 0
  br i1 %cmp64, label %land.lhs.true, label %if.end71

land.lhs.true:                                    ; preds = %if.then62
  %35 = load i8, i8* %code49, align 1
  %conv66 = zext i8 %35 to i32
  %and67 = and i32 %conv66, 224
  %cmp68 = icmp eq i32 %and67, 0
  br i1 %cmp68, label %if.then70, label %if.end71

if.then70:                                        ; preds = %land.lhs.true
  %36 = load i32, i32* %i, align 4
  %inc = add i32 %36, 1
  store i32 %inc, i32* %i, align 4
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %land.lhs.true, %if.then62
  br label %for.inc

if.end72:                                         ; preds = %if.end56
  %37 = load i8, i8* %class, align 1
  %conv73 = zext i8 %37 to i32
  %cmp74 = icmp eq i32 %conv73, 1
  br i1 %cmp74, label %land.lhs.true76, label %if.end82

land.lhs.true76:                                  ; preds = %if.end72
  %38 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %39 = load i32, i32* %adj_idx, align 4
  %idxprom77 = sext i32 %39 to i64
  %arrayidx78 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %38, i64 %idxprom77
  %40 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx78, i32 0, i32 0
  %ptr_type = bitcast %union.anon.13* %40 to i32*
  %41 = load i32, i32* %ptr_type, align 8
  %cmp79 = icmp eq i32 %41, 2
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true76
  br label %for.inc

if.end82:                                         ; preds = %land.lhs.true76, %if.end72
  %call83 = call i32 @get_random_int() #8
  store i32 %call83, i32* %imm_rnd, align 4
  %arrayidx84 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  %42 = bitcast %struct.bpf_insn* %arrayidx84 to i8*
  %43 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %42, i8* align 4 %43, i64 8, i1 false)
  %44 = load i32, i32* %imm_rnd, align 4
  %arrayidx85 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %imm86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx85, i32 0, i32 3
  store i32 %44, i32* %imm86, align 4
  %dst_reg87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load88 = load i8, i8* %dst_reg87, align 1
  %bf.clear89 = and i8 %bf.load88, 15
  %arrayidx90 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %dst_reg91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx90, i32 0, i32 1
  %bf.load92 = load i8, i8* %dst_reg91, align 1
  %bf.value = and i8 %bf.clear89, 15
  %bf.clear93 = and i8 %bf.load92, -16
  %bf.set94 = or i8 %bf.clear93, %bf.value
  store i8 %bf.set94, i8* %dst_reg91, align 1
  %arraydecay95 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay95, %struct.bpf_insn** %patch, align 8
  store i32 4, i32* %patch_len, align 4
  br label %apply_patch_buffer

if.end96:                                         ; preds = %for.body
  %call97 = call zeroext i1 @bpf_jit_needs_zext() #8
  br i1 %call97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %if.end96
  br label %for.inc

if.end99:                                         ; preds = %if.end96
  %arrayidx100 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  %45 = bitcast %struct.bpf_insn* %arrayidx100 to i8*
  %46 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %45, i8* align 4 %46, i64 8, i1 false)
  %dst_reg101 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load102 = load i8, i8* %dst_reg101, align 1
  %bf.clear103 = and i8 %bf.load102, 15
  %arrayidx104 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %dst_reg105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx104, i32 0, i32 1
  %bf.load106 = load i8, i8* %dst_reg105, align 1
  %bf.value107 = and i8 %bf.clear103, 15
  %bf.clear108 = and i8 %bf.load106, -16
  %bf.set109 = or i8 %bf.clear108, %bf.value107
  store i8 %bf.set109, i8* %dst_reg105, align 1
  %dst_reg110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load111 = load i8, i8* %dst_reg110, align 1
  %bf.clear112 = and i8 %bf.load111, 15
  %arrayidx113 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %src_reg114 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx113, i32 0, i32 1
  %bf.load115 = load i8, i8* %src_reg114, align 1
  %bf.value116 = and i8 %bf.clear112, 15
  %bf.shl = shl i8 %bf.value116, 4
  %bf.clear117 = and i8 %bf.load115, 15
  %bf.set118 = or i8 %bf.clear117, %bf.shl
  store i8 %bf.set118, i8* %src_reg114, align 1
  %arraydecay119 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay119, %struct.bpf_insn** %patch, align 8
  store i32 2, i32* %patch_len, align 4
  br label %apply_patch_buffer

apply_patch_buffer:                               ; preds = %if.end99, %if.end82
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load i32, i32* %adj_idx, align 4
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %50 = load i32, i32* %patch_len, align 4
  %call120 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %47, i32 noundef %48, %struct.bpf_insn* noundef %49, i32 noundef %50) #8
  store %struct.bpf_prog* %call120, %struct.bpf_prog** %new_prog, align 8
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool121 = icmp ne %struct.bpf_prog* %51, null
  br i1 %tobool121, label %if.end123, label %if.then122

if.then122:                                       ; preds = %apply_patch_buffer
  store i32 -12, i32* %retval, align 4
  br label %return

if.end123:                                        ; preds = %apply_patch_buffer
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog124 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 2
  store %struct.bpf_prog* %52, %struct.bpf_prog** %prog124, align 8
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %55 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 10
  %insnsi125 = bitcast %union.anon.146* %55 to [0 x %struct.bpf_insn]*
  %arraydecay126 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi125, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay126, %struct.bpf_insn** %insns, align 8
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data127 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %56, i32 0, i32 16
  %57 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data127, align 8
  store %struct.bpf_insn_aux_data* %57, %struct.bpf_insn_aux_data** %aux, align 8
  %58 = load i32, i32* %patch_len, align 4
  %sub = sub i32 %58, 1
  %59 = load i32, i32* %delta, align 4
  %add128 = add i32 %59, %sub
  store i32 %add128, i32* %delta, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end123, %if.then98, %if.then81, %if.end71, %if.then55, %if.then51
  %60 = load i32, i32* %i, align 4
  %inc129 = add i32 %60, 1
  store i32 %inc129, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then122
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_needs_zext() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %3 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %err, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 7
  %8 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %8) #8
  br i1 %call, label %if.end11, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call4 = call i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %9) #8
  store i32 %call4, i32* %err, align 4
  %10 = load i32, i32* %err, align 4
  %cmp = icmp eq i32 %10, 0
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %11 = load i32, i32* %err, align 4
  %cmp7 = icmp eq i32 %11, -14
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %12 = load i32, i32* %err, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %14, i32 0, i32 4
  %15 = load i32, i32* %len, align 4
  %cmp12 = icmp ult i32 %13, %15
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code, align 4
  %conv14 = zext i8 %17 to i32
  %cmp15 = icmp ne i32 %conv14, 133
  br i1 %cmp15, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load17 = load i8, i8* %src_reg, align 1
  %bf.lshr18 = lshr i8 %bf.load17, 4
  %conv19 = zext i8 %bf.lshr18 to i32
  %cmp20 = icmp ne i32 %conv19, 1
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end23:                                         ; preds = %lor.lhs.false
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %21 = load i32, i32* %i, align 4
  %call24 = call i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %19, %struct.bpf_insn* noundef %20, i32 noundef %21) #8
  store i32 %call24, i32* %depth, align 4
  %22 = load i32, i32* %depth, align 4
  %cmp25 = icmp slt i32 %22, 0
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  %23 = load i32, i32* %depth, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end23
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %25 = load i32, i32* %depth, align 4
  call void @bpf_patch_call_args(%struct.bpf_insn* noundef %24, i32 noundef %25) #8
  br label %for.inc

for.inc:                                          ; preds = %if.end28, %if.then22
  %26 = load i32, i32* %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, i32* %i, align 4
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %27, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %err, align 4
  %28 = load i32, i32* %err, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then27, %if.then9, %if.then6
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verification_stats(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 26
  %5 = load i64, i64* %verification_time, align 8
  %call = call i64 @div_u64(i64 noundef %5, i32 noundef 1000) #8
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.288, i64 0, i64 0), i64 noundef %call) #8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.289, i64 0, i64 0)) #8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 21
  %10 = load i32, i32* %subprog_cnt, align 8
  %cmp = icmp ult i32 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 19
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %13 = load i16, i16* %stack_depth, align 4
  %conv = zext i16 %13 to i32
  store i32 %conv, i32* %depth, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.290, i64 0, i64 0), i32 noundef %16) #8
  %17 = load i32, i32* %i, align 4
  %add = add i32 %17, 1
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 21
  %19 = load i32, i32* %subprog_cnt1, align 8
  %cmp2 = icmp ult i32 %add, %19
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %for.body
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.291, i64 0, i64 0)) #8
  br label %if.end

if.end:                                           ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i32, i32* %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.109, i64 0, i64 0)) #8
  br label %if.end5

if.end5:                                          ; preds = %for.end, %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 23
  %28 = load i32, i32* %insn_processed, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 27
  %30 = load i32, i32* %max_states_per_insn, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 28
  %32 = load i32, i32* %total_states, align 4
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 29
  %34 = load i32, i32* %peak_states, align 8
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 30
  %36 = load i32, i32* %longest_mark_read_walk, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([98 x i8], [98 x i8]* @.str.292, i64 0, i64 0), i32 noundef %28, i32 noundef 1000000, i32 noundef %30, i32 noundef %32, i32 noundef %34, i32 noundef %36) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval.i19 = alloca i32, align 4
  %flags.addr.i20 = alloca i32, align 4
  %retval.i12 = alloca i32, align 4
  %size.addr.i13 = alloca i64, align 8
  %size.addr.i9 = alloca i64, align 8
  %flags.addr.i10 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %n.addr, align 8
  %11 = call i1 @llvm.is.constant.i64(i64 %10)
  br i1 %11, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %12 = load i64, i64* %size.addr, align 8
  %13 = call i1 @llvm.is.constant.i64(i64 %12)
  br i1 %13, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  %14 = load i64, i64* %bytes, align 8
  %15 = load i32, i32* %flags.addr, align 4
  store i64 %14, i64* %size.addr.i, align 8
  store i32 %15, i32* %flags.addr.i, align 4
  %16 = load i64, i64* %size.addr.i, align 8
  %17 = call i1 @llvm.is.constant.i64(i64 %16) #9
  br i1 %17, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %if.then6
  %18 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %18, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %19 = load i64, i64* %size.addr.i, align 8
  %20 = load i32, i32* %flags.addr.i, align 4
  store i64 %19, i64* %size.addr.i9, align 8
  store i32 %20, i32* %flags.addr.i10, align 4
  %21 = load i64, i64* %size.addr.i9, align 8
  %call.i11 = call i32 @get_order(i64 noundef %21) #11
  store i32 %call.i11, i32* %order.i, align 4
  %22 = load i64, i64* %size.addr.i9, align 8
  %23 = load i32, i32* %flags.addr.i10, align 4
  %24 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %22, i32 noundef %23, i32 noundef %24) #10
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %25 = load i64, i64* %size.addr.i, align 8
  store i64 %25, i64* %size.addr.i13, align 8
  %26 = load i64, i64* %size.addr.i13, align 8
  %tobool.i14 = icmp ne i64 %26, 0
  br i1 %tobool.i14, label %if.end.i17, label %if.then.i15

if.then.i15:                                      ; preds = %if.end.i
  store i32 0, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end.i17:                                       ; preds = %if.end.i
  %27 = load i64, i64* %size.addr.i13, align 8
  %cmp.i16 = icmp ule i64 %27, 8
  br i1 %cmp.i16, label %if.then1.i18, label %if.end2.i

if.then1.i18:                                     ; preds = %if.end.i17
  store i32 3, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i17
  %28 = load i64, i64* %size.addr.i13, align 8
  %cmp3.i = icmp ugt i64 %28, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %29 = load i64, i64* %size.addr.i13, align 8
  %cmp4.i = icmp ule i64 %29, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %30 = load i64, i64* %size.addr.i13, align 8
  %cmp7.i = icmp ugt i64 %30, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %31 = load i64, i64* %size.addr.i13, align 8
  %cmp9.i = icmp ule i64 %31, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %32 = load i64, i64* %size.addr.i13, align 8
  %cmp12.i = icmp ule i64 %32, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %33 = load i64, i64* %size.addr.i13, align 8
  %cmp15.i = icmp ule i64 %33, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %34 = load i64, i64* %size.addr.i13, align 8
  %cmp18.i = icmp ule i64 %34, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %35 = load i64, i64* %size.addr.i13, align 8
  %cmp21.i = icmp ule i64 %35, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %36 = load i64, i64* %size.addr.i13, align 8
  %cmp24.i = icmp ule i64 %36, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %37 = load i64, i64* %size.addr.i13, align 8
  %cmp27.i = icmp ule i64 %37, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %38 = load i64, i64* %size.addr.i13, align 8
  %cmp30.i = icmp ule i64 %38, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %39 = load i64, i64* %size.addr.i13, align 8
  %cmp33.i = icmp ule i64 %39, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %40 = load i64, i64* %size.addr.i13, align 8
  %cmp36.i = icmp ule i64 %40, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %41 = load i64, i64* %size.addr.i13, align 8
  %cmp39.i = icmp ule i64 %41, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %42 = load i64, i64* %size.addr.i13, align 8
  %cmp42.i = icmp ule i64 %42, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %43 = load i64, i64* %size.addr.i13, align 8
  %cmp45.i = icmp ule i64 %43, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %44 = load i64, i64* %size.addr.i13, align 8
  %cmp48.i = icmp ule i64 %44, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %45 = load i64, i64* %size.addr.i13, align 8
  %cmp51.i = icmp ule i64 %45, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %46 = load i64, i64* %size.addr.i13, align 8
  %cmp54.i = icmp ule i64 %46, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %47 = load i64, i64* %size.addr.i13, align 8
  %cmp57.i = icmp ule i64 %47, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %48 = load i64, i64* %size.addr.i13, align 8
  %cmp60.i = icmp ule i64 %48, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %49 = load i64, i64* %size.addr.i13, align 8
  %cmp63.i = icmp ule i64 %49, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %50 = load i64, i64* %size.addr.i13, align 8
  %cmp66.i = icmp ule i64 %50, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %51 = load i64, i64* %size.addr.i13, align 8
  %cmp69.i = icmp ule i64 %51, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %52 = load i64, i64* %size.addr.i13, align 8
  %cmp72.i = icmp ule i64 %52, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %53 = load i64, i64* %size.addr.i13, align 8
  %cmp75.i = icmp ule i64 %53, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %54 = load i64, i64* %size.addr.i13, align 8
  %cmp78.i = icmp ule i64 %54, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %55 = load i64, i64* %size.addr.i13, align 8
  %cmp81.i = icmp ule i64 %55, 67108864
  br i1 %cmp81.i, label %if.then82.i, label %if.end83.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 26, i32* %retval.i12, align 4
  br label %kmalloc_index.exit

if.end83.i:                                       ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i64 0, i64 0), i32 386, i32 0, i64 12) #9, !srcloc !9
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.unreachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 15) #9, !srcloc !10
  unreachable

kmalloc_index.exit:                               ; preds = %if.then82.i, %if.then79.i, %if.then76.i, %if.then73.i, %if.then70.i, %if.then67.i, %if.then64.i, %if.then61.i, %if.then58.i, %if.then55.i, %if.then52.i, %if.then49.i, %if.then46.i, %if.then43.i, %if.then40.i, %if.then37.i, %if.then34.i, %if.then31.i, %if.then28.i, %if.then25.i, %if.then22.i, %if.then19.i, %if.then16.i, %if.then13.i, %if.then10.i, %if.then5.i, %if.then1.i18, %if.then.i15
  %56 = load i32, i32* %retval.i12, align 4
  store i32 %56, i32* %index.i, align 4
  %57 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %57, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %kmalloc_index.exit
  %58 = load i32, i32* %flags.addr.i, align 4
  store i32 %58, i32* %flags.addr.i20, align 4
  %59 = load i32, i32* %flags.addr.i20, align 4
  %and.i = and i32 %59, 17
  %cmp.i21 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i21, true
  %lnot.ext.i = zext i1 %cmp.i21 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i21, label %if.then.i22, label %if.end.i23

if.then.i22:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i19, align 4
  br label %kmalloc_type.exit

if.end.i23:                                       ; preds = %if.end4.i
  %60 = load i32, i32* %flags.addr.i20, align 4
  %and2.i = and i32 %60, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  %61 = zext i1 %tobool3.i to i64
  %cond.i = select i1 %tobool3.i, i32 2, i32 1
  store i32 %cond.i, i32* %retval.i19, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.end.i23, %if.then.i22
  %62 = load i32, i32* %retval.i19, align 4
  %idxprom.i = zext i32 %62 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %63 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %63 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %64 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %65 = load i32, i32* %flags.addr.i, align 4
  %66 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %64, i32 noundef %65, i64 noundef %66) #10
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %if.then6
  %67 = load i64, i64* %size.addr.i, align 8
  %68 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %67, i32 noundef %68) #10
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.end9.i, %kmalloc_type.exit, %if.then3.i, %if.then1.i
  %69 = load i8*, i8** %retval.i, align 8
  store i8* %69, i8** %retval, align 8
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end
  %70 = load i64, i64* %bytes, align 8
  %71 = load i32, i32* %flags.addr, align 4
  %call8 = call noalias align 8 i8* @__kmalloc(i64 noundef %70, i32 noundef %71) #8
  store i8* %call8, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %kmalloc.exit, %if.then
  %72 = load i8*, i8** %retval, align 8
  ret i8* %72
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %2 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %cmp2 = icmp eq i32 %conv, 24
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %src_reg, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %12, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_btf_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 7
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %2, i32 0, i32 25
  %3 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %tobool = icmp ne %struct.util_est* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 21
  %6 = load i32, i32* %subprog_cnt, align 8
  %cmp = icmp ult i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 19
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %9 = load i32, i32* %start, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 2
  %11 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %aux2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %11, i32 0, i32 7
  %12 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux2, align 8
  %func_info3 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %12, i32 0, i32 25
  %13 = load %struct.util_est*, %struct.util_est** %func_info3, align 8
  %14 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %14 to i64
  %arrayidx5 = getelementptr %struct.util_est, %struct.util_est* %13, i64 %idxprom4
  %insn_off = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx5, i32 0, i32 0
  store i32 %9, i32* %insn_off, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_maps(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %stype = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end, %if.then, %entry
  br i1 false, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 7
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %cgroup_storage = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %2, i32 0, i32 20
  %3 = load i32, i32* %stype, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [2 x %struct.bpf_map*], [2 x %struct.bpf_map*]* %cgroup_storage, i64 0, i64 %idxprom
  %4 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx, align 8
  %tobool = icmp ne %struct.bpf_map* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.cond

if.end:                                           ; preds = %for.body
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 2
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %8, i32 0, i32 7
  %9 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %cgroup_storage4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %9, i32 0, i32 20
  %10 = load i32, i32* %stype, align 4
  %idxprom5 = zext i32 %10 to i64
  %arrayidx6 = getelementptr [2 x %struct.bpf_map*], [2 x %struct.bpf_map*]* %cgroup_storage4, i64 0, i64 %idxprom5
  %11 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx6, align 8
  call void @bpf_cgroup_storage_release(%struct.bpf_prog* noundef %6, %struct.bpf_map* noundef %11) #8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc, %for.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 12
  %14 = load i32, i32* %used_map_cnt, align 8
  %cmp = icmp ult i32 %12, %14
  br i1 %cmp, label %for.body8, label %for.end11

for.body8:                                        ; preds = %for.cond7
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 11
  %16 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom9
  %17 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx10, align 8
  call void @bpf_map_put(%struct.bpf_map* noundef %17) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body8
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond7

for.end11:                                        ; preds = %for.cond7
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_unlock(%struct.mutex* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @vfree(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kfree(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_cgroup_storage_release(%struct.bpf_prog* noundef %prog, %struct.bpf_map* noundef %map) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_map_put(%struct.bpf_map* noundef) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #6

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal i32 @get_order(i64 noundef %size) #5 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %size.addr = alloca i64, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %1 = call i1 @llvm.is.constant.i64(i64 %0)
  br i1 %1, label %if.then, label %if.end447

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %size.addr, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  store i32 52, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %3 = load i64, i64* %size.addr, align 8
  %cmp = icmp ult i64 %3, 4096
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i64, i64* %size.addr, align 8
  %sub = sub i64 %4, 1
  %5 = call i1 @llvm.is.constant.i64(i64 %sub)
  br i1 %5, label %cond.true, label %cond.false442

cond.true:                                        ; preds = %if.end3
  %6 = load i64, i64* %size.addr, align 8
  %sub4 = sub i64 %6, 1
  %7 = call i1 @llvm.is.constant.i64(i64 %sub4)
  br i1 %7, label %cond.true5, label %cond.false439

cond.true5:                                       ; preds = %cond.true
  %8 = load i64, i64* %size.addr, align 8
  %sub6 = sub i64 %8, 1
  %cmp7 = icmp ult i64 %sub6, 2
  br i1 %cmp7, label %cond.true8, label %cond.false

cond.true8:                                       ; preds = %cond.true5
  br label %cond.end437

cond.false:                                       ; preds = %cond.true5
  %9 = load i64, i64* %size.addr, align 8
  %sub9 = sub i64 %9, 1
  %and = and i64 %sub9, -9223372036854775808
  %tobool10 = icmp ne i64 %and, 0
  br i1 %tobool10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false
  br label %cond.end435

cond.false12:                                     ; preds = %cond.false
  %10 = load i64, i64* %size.addr, align 8
  %sub13 = sub i64 %10, 1
  %and14 = and i64 %sub13, 4611686018427387904
  %tobool15 = icmp ne i64 %and14, 0
  br i1 %tobool15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end433

cond.false17:                                     ; preds = %cond.false12
  %11 = load i64, i64* %size.addr, align 8
  %sub18 = sub i64 %11, 1
  %and19 = and i64 %sub18, 2305843009213693952
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end431

cond.false22:                                     ; preds = %cond.false17
  %12 = load i64, i64* %size.addr, align 8
  %sub23 = sub i64 %12, 1
  %and24 = and i64 %sub23, 1152921504606846976
  %tobool25 = icmp ne i64 %and24, 0
  br i1 %tobool25, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end429

cond.false27:                                     ; preds = %cond.false22
  %13 = load i64, i64* %size.addr, align 8
  %sub28 = sub i64 %13, 1
  %and29 = and i64 %sub28, 576460752303423488
  %tobool30 = icmp ne i64 %and29, 0
  br i1 %tobool30, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end427

cond.false32:                                     ; preds = %cond.false27
  %14 = load i64, i64* %size.addr, align 8
  %sub33 = sub i64 %14, 1
  %and34 = and i64 %sub33, 288230376151711744
  %tobool35 = icmp ne i64 %and34, 0
  br i1 %tobool35, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end425

cond.false37:                                     ; preds = %cond.false32
  %15 = load i64, i64* %size.addr, align 8
  %sub38 = sub i64 %15, 1
  %and39 = and i64 %sub38, 144115188075855872
  %tobool40 = icmp ne i64 %and39, 0
  br i1 %tobool40, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end423

cond.false42:                                     ; preds = %cond.false37
  %16 = load i64, i64* %size.addr, align 8
  %sub43 = sub i64 %16, 1
  %and44 = and i64 %sub43, 72057594037927936
  %tobool45 = icmp ne i64 %and44, 0
  br i1 %tobool45, label %cond.true46, label %cond.false47

cond.true46:                                      ; preds = %cond.false42
  br label %cond.end421

cond.false47:                                     ; preds = %cond.false42
  %17 = load i64, i64* %size.addr, align 8
  %sub48 = sub i64 %17, 1
  %and49 = and i64 %sub48, 36028797018963968
  %tobool50 = icmp ne i64 %and49, 0
  br i1 %tobool50, label %cond.true51, label %cond.false52

cond.true51:                                      ; preds = %cond.false47
  br label %cond.end419

cond.false52:                                     ; preds = %cond.false47
  %18 = load i64, i64* %size.addr, align 8
  %sub53 = sub i64 %18, 1
  %and54 = and i64 %sub53, 18014398509481984
  %tobool55 = icmp ne i64 %and54, 0
  br i1 %tobool55, label %cond.true56, label %cond.false57

cond.true56:                                      ; preds = %cond.false52
  br label %cond.end417

cond.false57:                                     ; preds = %cond.false52
  %19 = load i64, i64* %size.addr, align 8
  %sub58 = sub i64 %19, 1
  %and59 = and i64 %sub58, 9007199254740992
  %tobool60 = icmp ne i64 %and59, 0
  br i1 %tobool60, label %cond.true61, label %cond.false62

cond.true61:                                      ; preds = %cond.false57
  br label %cond.end415

cond.false62:                                     ; preds = %cond.false57
  %20 = load i64, i64* %size.addr, align 8
  %sub63 = sub i64 %20, 1
  %and64 = and i64 %sub63, 4503599627370496
  %tobool65 = icmp ne i64 %and64, 0
  br i1 %tobool65, label %cond.true66, label %cond.false67

cond.true66:                                      ; preds = %cond.false62
  br label %cond.end413

cond.false67:                                     ; preds = %cond.false62
  %21 = load i64, i64* %size.addr, align 8
  %sub68 = sub i64 %21, 1
  %and69 = and i64 %sub68, 2251799813685248
  %tobool70 = icmp ne i64 %and69, 0
  br i1 %tobool70, label %cond.true71, label %cond.false72

cond.true71:                                      ; preds = %cond.false67
  br label %cond.end411

cond.false72:                                     ; preds = %cond.false67
  %22 = load i64, i64* %size.addr, align 8
  %sub73 = sub i64 %22, 1
  %and74 = and i64 %sub73, 1125899906842624
  %tobool75 = icmp ne i64 %and74, 0
  br i1 %tobool75, label %cond.true76, label %cond.false77

cond.true76:                                      ; preds = %cond.false72
  br label %cond.end409

cond.false77:                                     ; preds = %cond.false72
  %23 = load i64, i64* %size.addr, align 8
  %sub78 = sub i64 %23, 1
  %and79 = and i64 %sub78, 562949953421312
  %tobool80 = icmp ne i64 %and79, 0
  br i1 %tobool80, label %cond.true81, label %cond.false82

cond.true81:                                      ; preds = %cond.false77
  br label %cond.end407

cond.false82:                                     ; preds = %cond.false77
  %24 = load i64, i64* %size.addr, align 8
  %sub83 = sub i64 %24, 1
  %and84 = and i64 %sub83, 281474976710656
  %tobool85 = icmp ne i64 %and84, 0
  br i1 %tobool85, label %cond.true86, label %cond.false87

cond.true86:                                      ; preds = %cond.false82
  br label %cond.end405

cond.false87:                                     ; preds = %cond.false82
  %25 = load i64, i64* %size.addr, align 8
  %sub88 = sub i64 %25, 1
  %and89 = and i64 %sub88, 140737488355328
  %tobool90 = icmp ne i64 %and89, 0
  br i1 %tobool90, label %cond.true91, label %cond.false92

cond.true91:                                      ; preds = %cond.false87
  br label %cond.end403

cond.false92:                                     ; preds = %cond.false87
  %26 = load i64, i64* %size.addr, align 8
  %sub93 = sub i64 %26, 1
  %and94 = and i64 %sub93, 70368744177664
  %tobool95 = icmp ne i64 %and94, 0
  br i1 %tobool95, label %cond.true96, label %cond.false97

cond.true96:                                      ; preds = %cond.false92
  br label %cond.end401

cond.false97:                                     ; preds = %cond.false92
  %27 = load i64, i64* %size.addr, align 8
  %sub98 = sub i64 %27, 1
  %and99 = and i64 %sub98, 35184372088832
  %tobool100 = icmp ne i64 %and99, 0
  br i1 %tobool100, label %cond.true101, label %cond.false102

cond.true101:                                     ; preds = %cond.false97
  br label %cond.end399

cond.false102:                                    ; preds = %cond.false97
  %28 = load i64, i64* %size.addr, align 8
  %sub103 = sub i64 %28, 1
  %and104 = and i64 %sub103, 17592186044416
  %tobool105 = icmp ne i64 %and104, 0
  br i1 %tobool105, label %cond.true106, label %cond.false107

cond.true106:                                     ; preds = %cond.false102
  br label %cond.end397

cond.false107:                                    ; preds = %cond.false102
  %29 = load i64, i64* %size.addr, align 8
  %sub108 = sub i64 %29, 1
  %and109 = and i64 %sub108, 8796093022208
  %tobool110 = icmp ne i64 %and109, 0
  br i1 %tobool110, label %cond.true111, label %cond.false112

cond.true111:                                     ; preds = %cond.false107
  br label %cond.end395

cond.false112:                                    ; preds = %cond.false107
  %30 = load i64, i64* %size.addr, align 8
  %sub113 = sub i64 %30, 1
  %and114 = and i64 %sub113, 4398046511104
  %tobool115 = icmp ne i64 %and114, 0
  br i1 %tobool115, label %cond.true116, label %cond.false117

cond.true116:                                     ; preds = %cond.false112
  br label %cond.end393

cond.false117:                                    ; preds = %cond.false112
  %31 = load i64, i64* %size.addr, align 8
  %sub118 = sub i64 %31, 1
  %and119 = and i64 %sub118, 2199023255552
  %tobool120 = icmp ne i64 %and119, 0
  br i1 %tobool120, label %cond.true121, label %cond.false122

cond.true121:                                     ; preds = %cond.false117
  br label %cond.end391

cond.false122:                                    ; preds = %cond.false117
  %32 = load i64, i64* %size.addr, align 8
  %sub123 = sub i64 %32, 1
  %and124 = and i64 %sub123, 1099511627776
  %tobool125 = icmp ne i64 %and124, 0
  br i1 %tobool125, label %cond.true126, label %cond.false127

cond.true126:                                     ; preds = %cond.false122
  br label %cond.end389

cond.false127:                                    ; preds = %cond.false122
  %33 = load i64, i64* %size.addr, align 8
  %sub128 = sub i64 %33, 1
  %and129 = and i64 %sub128, 549755813888
  %tobool130 = icmp ne i64 %and129, 0
  br i1 %tobool130, label %cond.true131, label %cond.false132

cond.true131:                                     ; preds = %cond.false127
  br label %cond.end387

cond.false132:                                    ; preds = %cond.false127
  %34 = load i64, i64* %size.addr, align 8
  %sub133 = sub i64 %34, 1
  %and134 = and i64 %sub133, 274877906944
  %tobool135 = icmp ne i64 %and134, 0
  br i1 %tobool135, label %cond.true136, label %cond.false137

cond.true136:                                     ; preds = %cond.false132
  br label %cond.end385

cond.false137:                                    ; preds = %cond.false132
  %35 = load i64, i64* %size.addr, align 8
  %sub138 = sub i64 %35, 1
  %and139 = and i64 %sub138, 137438953472
  %tobool140 = icmp ne i64 %and139, 0
  br i1 %tobool140, label %cond.true141, label %cond.false142

cond.true141:                                     ; preds = %cond.false137
  br label %cond.end383

cond.false142:                                    ; preds = %cond.false137
  %36 = load i64, i64* %size.addr, align 8
  %sub143 = sub i64 %36, 1
  %and144 = and i64 %sub143, 68719476736
  %tobool145 = icmp ne i64 %and144, 0
  br i1 %tobool145, label %cond.true146, label %cond.false147

cond.true146:                                     ; preds = %cond.false142
  br label %cond.end381

cond.false147:                                    ; preds = %cond.false142
  %37 = load i64, i64* %size.addr, align 8
  %sub148 = sub i64 %37, 1
  %and149 = and i64 %sub148, 34359738368
  %tobool150 = icmp ne i64 %and149, 0
  br i1 %tobool150, label %cond.true151, label %cond.false152

cond.true151:                                     ; preds = %cond.false147
  br label %cond.end379

cond.false152:                                    ; preds = %cond.false147
  %38 = load i64, i64* %size.addr, align 8
  %sub153 = sub i64 %38, 1
  %and154 = and i64 %sub153, 17179869184
  %tobool155 = icmp ne i64 %and154, 0
  br i1 %tobool155, label %cond.true156, label %cond.false157

cond.true156:                                     ; preds = %cond.false152
  br label %cond.end377

cond.false157:                                    ; preds = %cond.false152
  %39 = load i64, i64* %size.addr, align 8
  %sub158 = sub i64 %39, 1
  %and159 = and i64 %sub158, 8589934592
  %tobool160 = icmp ne i64 %and159, 0
  br i1 %tobool160, label %cond.true161, label %cond.false162

cond.true161:                                     ; preds = %cond.false157
  br label %cond.end375

cond.false162:                                    ; preds = %cond.false157
  %40 = load i64, i64* %size.addr, align 8
  %sub163 = sub i64 %40, 1
  %and164 = and i64 %sub163, 4294967296
  %tobool165 = icmp ne i64 %and164, 0
  br i1 %tobool165, label %cond.true166, label %cond.false167

cond.true166:                                     ; preds = %cond.false162
  br label %cond.end373

cond.false167:                                    ; preds = %cond.false162
  %41 = load i64, i64* %size.addr, align 8
  %sub168 = sub i64 %41, 1
  %and169 = and i64 %sub168, 2147483648
  %tobool170 = icmp ne i64 %and169, 0
  br i1 %tobool170, label %cond.true171, label %cond.false172

cond.true171:                                     ; preds = %cond.false167
  br label %cond.end371

cond.false172:                                    ; preds = %cond.false167
  %42 = load i64, i64* %size.addr, align 8
  %sub173 = sub i64 %42, 1
  %and174 = and i64 %sub173, 1073741824
  %tobool175 = icmp ne i64 %and174, 0
  br i1 %tobool175, label %cond.true176, label %cond.false177

cond.true176:                                     ; preds = %cond.false172
  br label %cond.end369

cond.false177:                                    ; preds = %cond.false172
  %43 = load i64, i64* %size.addr, align 8
  %sub178 = sub i64 %43, 1
  %and179 = and i64 %sub178, 536870912
  %tobool180 = icmp ne i64 %and179, 0
  br i1 %tobool180, label %cond.true181, label %cond.false182

cond.true181:                                     ; preds = %cond.false177
  br label %cond.end367

cond.false182:                                    ; preds = %cond.false177
  %44 = load i64, i64* %size.addr, align 8
  %sub183 = sub i64 %44, 1
  %and184 = and i64 %sub183, 268435456
  %tobool185 = icmp ne i64 %and184, 0
  br i1 %tobool185, label %cond.true186, label %cond.false187

cond.true186:                                     ; preds = %cond.false182
  br label %cond.end365

cond.false187:                                    ; preds = %cond.false182
  %45 = load i64, i64* %size.addr, align 8
  %sub188 = sub i64 %45, 1
  %and189 = and i64 %sub188, 134217728
  %tobool190 = icmp ne i64 %and189, 0
  br i1 %tobool190, label %cond.true191, label %cond.false192

cond.true191:                                     ; preds = %cond.false187
  br label %cond.end363

cond.false192:                                    ; preds = %cond.false187
  %46 = load i64, i64* %size.addr, align 8
  %sub193 = sub i64 %46, 1
  %and194 = and i64 %sub193, 67108864
  %tobool195 = icmp ne i64 %and194, 0
  br i1 %tobool195, label %cond.true196, label %cond.false197

cond.true196:                                     ; preds = %cond.false192
  br label %cond.end361

cond.false197:                                    ; preds = %cond.false192
  %47 = load i64, i64* %size.addr, align 8
  %sub198 = sub i64 %47, 1
  %and199 = and i64 %sub198, 33554432
  %tobool200 = icmp ne i64 %and199, 0
  br i1 %tobool200, label %cond.true201, label %cond.false202

cond.true201:                                     ; preds = %cond.false197
  br label %cond.end359

cond.false202:                                    ; preds = %cond.false197
  %48 = load i64, i64* %size.addr, align 8
  %sub203 = sub i64 %48, 1
  %and204 = and i64 %sub203, 16777216
  %tobool205 = icmp ne i64 %and204, 0
  br i1 %tobool205, label %cond.true206, label %cond.false207

cond.true206:                                     ; preds = %cond.false202
  br label %cond.end357

cond.false207:                                    ; preds = %cond.false202
  %49 = load i64, i64* %size.addr, align 8
  %sub208 = sub i64 %49, 1
  %and209 = and i64 %sub208, 8388608
  %tobool210 = icmp ne i64 %and209, 0
  br i1 %tobool210, label %cond.true211, label %cond.false212

cond.true211:                                     ; preds = %cond.false207
  br label %cond.end355

cond.false212:                                    ; preds = %cond.false207
  %50 = load i64, i64* %size.addr, align 8
  %sub213 = sub i64 %50, 1
  %and214 = and i64 %sub213, 4194304
  %tobool215 = icmp ne i64 %and214, 0
  br i1 %tobool215, label %cond.true216, label %cond.false217

cond.true216:                                     ; preds = %cond.false212
  br label %cond.end353

cond.false217:                                    ; preds = %cond.false212
  %51 = load i64, i64* %size.addr, align 8
  %sub218 = sub i64 %51, 1
  %and219 = and i64 %sub218, 2097152
  %tobool220 = icmp ne i64 %and219, 0
  br i1 %tobool220, label %cond.true221, label %cond.false222

cond.true221:                                     ; preds = %cond.false217
  br label %cond.end351

cond.false222:                                    ; preds = %cond.false217
  %52 = load i64, i64* %size.addr, align 8
  %sub223 = sub i64 %52, 1
  %and224 = and i64 %sub223, 1048576
  %tobool225 = icmp ne i64 %and224, 0
  br i1 %tobool225, label %cond.true226, label %cond.false227

cond.true226:                                     ; preds = %cond.false222
  br label %cond.end349

cond.false227:                                    ; preds = %cond.false222
  %53 = load i64, i64* %size.addr, align 8
  %sub228 = sub i64 %53, 1
  %and229 = and i64 %sub228, 524288
  %tobool230 = icmp ne i64 %and229, 0
  br i1 %tobool230, label %cond.true231, label %cond.false232

cond.true231:                                     ; preds = %cond.false227
  br label %cond.end347

cond.false232:                                    ; preds = %cond.false227
  %54 = load i64, i64* %size.addr, align 8
  %sub233 = sub i64 %54, 1
  %and234 = and i64 %sub233, 262144
  %tobool235 = icmp ne i64 %and234, 0
  br i1 %tobool235, label %cond.true236, label %cond.false237

cond.true236:                                     ; preds = %cond.false232
  br label %cond.end345

cond.false237:                                    ; preds = %cond.false232
  %55 = load i64, i64* %size.addr, align 8
  %sub238 = sub i64 %55, 1
  %and239 = and i64 %sub238, 131072
  %tobool240 = icmp ne i64 %and239, 0
  br i1 %tobool240, label %cond.true241, label %cond.false242

cond.true241:                                     ; preds = %cond.false237
  br label %cond.end343

cond.false242:                                    ; preds = %cond.false237
  %56 = load i64, i64* %size.addr, align 8
  %sub243 = sub i64 %56, 1
  %and244 = and i64 %sub243, 65536
  %tobool245 = icmp ne i64 %and244, 0
  br i1 %tobool245, label %cond.true246, label %cond.false247

cond.true246:                                     ; preds = %cond.false242
  br label %cond.end341

cond.false247:                                    ; preds = %cond.false242
  %57 = load i64, i64* %size.addr, align 8
  %sub248 = sub i64 %57, 1
  %and249 = and i64 %sub248, 32768
  %tobool250 = icmp ne i64 %and249, 0
  br i1 %tobool250, label %cond.true251, label %cond.false252

cond.true251:                                     ; preds = %cond.false247
  br label %cond.end339

cond.false252:                                    ; preds = %cond.false247
  %58 = load i64, i64* %size.addr, align 8
  %sub253 = sub i64 %58, 1
  %and254 = and i64 %sub253, 16384
  %tobool255 = icmp ne i64 %and254, 0
  br i1 %tobool255, label %cond.true256, label %cond.false257

cond.true256:                                     ; preds = %cond.false252
  br label %cond.end337

cond.false257:                                    ; preds = %cond.false252
  %59 = load i64, i64* %size.addr, align 8
  %sub258 = sub i64 %59, 1
  %and259 = and i64 %sub258, 8192
  %tobool260 = icmp ne i64 %and259, 0
  br i1 %tobool260, label %cond.true261, label %cond.false262

cond.true261:                                     ; preds = %cond.false257
  br label %cond.end335

cond.false262:                                    ; preds = %cond.false257
  %60 = load i64, i64* %size.addr, align 8
  %sub263 = sub i64 %60, 1
  %and264 = and i64 %sub263, 4096
  %tobool265 = icmp ne i64 %and264, 0
  br i1 %tobool265, label %cond.true266, label %cond.false267

cond.true266:                                     ; preds = %cond.false262
  br label %cond.end333

cond.false267:                                    ; preds = %cond.false262
  %61 = load i64, i64* %size.addr, align 8
  %sub268 = sub i64 %61, 1
  %and269 = and i64 %sub268, 2048
  %tobool270 = icmp ne i64 %and269, 0
  br i1 %tobool270, label %cond.true271, label %cond.false272

cond.true271:                                     ; preds = %cond.false267
  br label %cond.end331

cond.false272:                                    ; preds = %cond.false267
  %62 = load i64, i64* %size.addr, align 8
  %sub273 = sub i64 %62, 1
  %and274 = and i64 %sub273, 1024
  %tobool275 = icmp ne i64 %and274, 0
  br i1 %tobool275, label %cond.true276, label %cond.false277

cond.true276:                                     ; preds = %cond.false272
  br label %cond.end329

cond.false277:                                    ; preds = %cond.false272
  %63 = load i64, i64* %size.addr, align 8
  %sub278 = sub i64 %63, 1
  %and279 = and i64 %sub278, 512
  %tobool280 = icmp ne i64 %and279, 0
  br i1 %tobool280, label %cond.true281, label %cond.false282

cond.true281:                                     ; preds = %cond.false277
  br label %cond.end327

cond.false282:                                    ; preds = %cond.false277
  %64 = load i64, i64* %size.addr, align 8
  %sub283 = sub i64 %64, 1
  %and284 = and i64 %sub283, 256
  %tobool285 = icmp ne i64 %and284, 0
  br i1 %tobool285, label %cond.true286, label %cond.false287

cond.true286:                                     ; preds = %cond.false282
  br label %cond.end325

cond.false287:                                    ; preds = %cond.false282
  %65 = load i64, i64* %size.addr, align 8
  %sub288 = sub i64 %65, 1
  %and289 = and i64 %sub288, 128
  %tobool290 = icmp ne i64 %and289, 0
  br i1 %tobool290, label %cond.true291, label %cond.false292

cond.true291:                                     ; preds = %cond.false287
  br label %cond.end323

cond.false292:                                    ; preds = %cond.false287
  %66 = load i64, i64* %size.addr, align 8
  %sub293 = sub i64 %66, 1
  %and294 = and i64 %sub293, 64
  %tobool295 = icmp ne i64 %and294, 0
  br i1 %tobool295, label %cond.true296, label %cond.false297

cond.true296:                                     ; preds = %cond.false292
  br label %cond.end321

cond.false297:                                    ; preds = %cond.false292
  %67 = load i64, i64* %size.addr, align 8
  %sub298 = sub i64 %67, 1
  %and299 = and i64 %sub298, 32
  %tobool300 = icmp ne i64 %and299, 0
  br i1 %tobool300, label %cond.true301, label %cond.false302

cond.true301:                                     ; preds = %cond.false297
  br label %cond.end319

cond.false302:                                    ; preds = %cond.false297
  %68 = load i64, i64* %size.addr, align 8
  %sub303 = sub i64 %68, 1
  %and304 = and i64 %sub303, 16
  %tobool305 = icmp ne i64 %and304, 0
  br i1 %tobool305, label %cond.true306, label %cond.false307

cond.true306:                                     ; preds = %cond.false302
  br label %cond.end317

cond.false307:                                    ; preds = %cond.false302
  %69 = load i64, i64* %size.addr, align 8
  %sub308 = sub i64 %69, 1
  %and309 = and i64 %sub308, 8
  %tobool310 = icmp ne i64 %and309, 0
  br i1 %tobool310, label %cond.true311, label %cond.false312

cond.true311:                                     ; preds = %cond.false307
  br label %cond.end

cond.false312:                                    ; preds = %cond.false307
  %70 = load i64, i64* %size.addr, align 8
  %sub313 = sub i64 %70, 1
  %and314 = and i64 %sub313, 4
  %tobool315 = icmp ne i64 %and314, 0
  %71 = zext i1 %tobool315 to i64
  %cond = select i1 %tobool315, i32 2, i32 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false312, %cond.true311
  %cond316 = phi i32 [ 3, %cond.true311 ], [ %cond, %cond.false312 ]
  br label %cond.end317

cond.end317:                                      ; preds = %cond.end, %cond.true306
  %cond318 = phi i32 [ 4, %cond.true306 ], [ %cond316, %cond.end ]
  br label %cond.end319

cond.end319:                                      ; preds = %cond.end317, %cond.true301
  %cond320 = phi i32 [ 5, %cond.true301 ], [ %cond318, %cond.end317 ]
  br label %cond.end321

cond.end321:                                      ; preds = %cond.end319, %cond.true296
  %cond322 = phi i32 [ 6, %cond.true296 ], [ %cond320, %cond.end319 ]
  br label %cond.end323

cond.end323:                                      ; preds = %cond.end321, %cond.true291
  %cond324 = phi i32 [ 7, %cond.true291 ], [ %cond322, %cond.end321 ]
  br label %cond.end325

cond.end325:                                      ; preds = %cond.end323, %cond.true286
  %cond326 = phi i32 [ 8, %cond.true286 ], [ %cond324, %cond.end323 ]
  br label %cond.end327

cond.end327:                                      ; preds = %cond.end325, %cond.true281
  %cond328 = phi i32 [ 9, %cond.true281 ], [ %cond326, %cond.end325 ]
  br label %cond.end329

cond.end329:                                      ; preds = %cond.end327, %cond.true276
  %cond330 = phi i32 [ 10, %cond.true276 ], [ %cond328, %cond.end327 ]
  br label %cond.end331

cond.end331:                                      ; preds = %cond.end329, %cond.true271
  %cond332 = phi i32 [ 11, %cond.true271 ], [ %cond330, %cond.end329 ]
  br label %cond.end333

cond.end333:                                      ; preds = %cond.end331, %cond.true266
  %cond334 = phi i32 [ 12, %cond.true266 ], [ %cond332, %cond.end331 ]
  br label %cond.end335

cond.end335:                                      ; preds = %cond.end333, %cond.true261
  %cond336 = phi i32 [ 13, %cond.true261 ], [ %cond334, %cond.end333 ]
  br label %cond.end337

cond.end337:                                      ; preds = %cond.end335, %cond.true256
  %cond338 = phi i32 [ 14, %cond.true256 ], [ %cond336, %cond.end335 ]
  br label %cond.end339

cond.end339:                                      ; preds = %cond.end337, %cond.true251
  %cond340 = phi i32 [ 15, %cond.true251 ], [ %cond338, %cond.end337 ]
  br label %cond.end341

cond.end341:                                      ; preds = %cond.end339, %cond.true246
  %cond342 = phi i32 [ 16, %cond.true246 ], [ %cond340, %cond.end339 ]
  br label %cond.end343

cond.end343:                                      ; preds = %cond.end341, %cond.true241
  %cond344 = phi i32 [ 17, %cond.true241 ], [ %cond342, %cond.end341 ]
  br label %cond.end345

cond.end345:                                      ; preds = %cond.end343, %cond.true236
  %cond346 = phi i32 [ 18, %cond.true236 ], [ %cond344, %cond.end343 ]
  br label %cond.end347

cond.end347:                                      ; preds = %cond.end345, %cond.true231
  %cond348 = phi i32 [ 19, %cond.true231 ], [ %cond346, %cond.end345 ]
  br label %cond.end349

cond.end349:                                      ; preds = %cond.end347, %cond.true226
  %cond350 = phi i32 [ 20, %cond.true226 ], [ %cond348, %cond.end347 ]
  br label %cond.end351

cond.end351:                                      ; preds = %cond.end349, %cond.true221
  %cond352 = phi i32 [ 21, %cond.true221 ], [ %cond350, %cond.end349 ]
  br label %cond.end353

cond.end353:                                      ; preds = %cond.end351, %cond.true216
  %cond354 = phi i32 [ 22, %cond.true216 ], [ %cond352, %cond.end351 ]
  br label %cond.end355

cond.end355:                                      ; preds = %cond.end353, %cond.true211
  %cond356 = phi i32 [ 23, %cond.true211 ], [ %cond354, %cond.end353 ]
  br label %cond.end357

cond.end357:                                      ; preds = %cond.end355, %cond.true206
  %cond358 = phi i32 [ 24, %cond.true206 ], [ %cond356, %cond.end355 ]
  br label %cond.end359

cond.end359:                                      ; preds = %cond.end357, %cond.true201
  %cond360 = phi i32 [ 25, %cond.true201 ], [ %cond358, %cond.end357 ]
  br label %cond.end361

cond.end361:                                      ; preds = %cond.end359, %cond.true196
  %cond362 = phi i32 [ 26, %cond.true196 ], [ %cond360, %cond.end359 ]
  br label %cond.end363

cond.end363:                                      ; preds = %cond.end361, %cond.true191
  %cond364 = phi i32 [ 27, %cond.true191 ], [ %cond362, %cond.end361 ]
  br label %cond.end365

cond.end365:                                      ; preds = %cond.end363, %cond.true186
  %cond366 = phi i32 [ 28, %cond.true186 ], [ %cond364, %cond.end363 ]
  br label %cond.end367

cond.end367:                                      ; preds = %cond.end365, %cond.true181
  %cond368 = phi i32 [ 29, %cond.true181 ], [ %cond366, %cond.end365 ]
  br label %cond.end369

cond.end369:                                      ; preds = %cond.end367, %cond.true176
  %cond370 = phi i32 [ 30, %cond.true176 ], [ %cond368, %cond.end367 ]
  br label %cond.end371

cond.end371:                                      ; preds = %cond.end369, %cond.true171
  %cond372 = phi i32 [ 31, %cond.true171 ], [ %cond370, %cond.end369 ]
  br label %cond.end373

cond.end373:                                      ; preds = %cond.end371, %cond.true166
  %cond374 = phi i32 [ 32, %cond.true166 ], [ %cond372, %cond.end371 ]
  br label %cond.end375

cond.end375:                                      ; preds = %cond.end373, %cond.true161
  %cond376 = phi i32 [ 33, %cond.true161 ], [ %cond374, %cond.end373 ]
  br label %cond.end377

cond.end377:                                      ; preds = %cond.end375, %cond.true156
  %cond378 = phi i32 [ 34, %cond.true156 ], [ %cond376, %cond.end375 ]
  br label %cond.end379

cond.end379:                                      ; preds = %cond.end377, %cond.true151
  %cond380 = phi i32 [ 35, %cond.true151 ], [ %cond378, %cond.end377 ]
  br label %cond.end381

cond.end381:                                      ; preds = %cond.end379, %cond.true146
  %cond382 = phi i32 [ 36, %cond.true146 ], [ %cond380, %cond.end379 ]
  br label %cond.end383

cond.end383:                                      ; preds = %cond.end381, %cond.true141
  %cond384 = phi i32 [ 37, %cond.true141 ], [ %cond382, %cond.end381 ]
  br label %cond.end385

cond.end385:                                      ; preds = %cond.end383, %cond.true136
  %cond386 = phi i32 [ 38, %cond.true136 ], [ %cond384, %cond.end383 ]
  br label %cond.end387

cond.end387:                                      ; preds = %cond.end385, %cond.true131
  %cond388 = phi i32 [ 39, %cond.true131 ], [ %cond386, %cond.end385 ]
  br label %cond.end389

cond.end389:                                      ; preds = %cond.end387, %cond.true126
  %cond390 = phi i32 [ 40, %cond.true126 ], [ %cond388, %cond.end387 ]
  br label %cond.end391

cond.end391:                                      ; preds = %cond.end389, %cond.true121
  %cond392 = phi i32 [ 41, %cond.true121 ], [ %cond390, %cond.end389 ]
  br label %cond.end393

cond.end393:                                      ; preds = %cond.end391, %cond.true116
  %cond394 = phi i32 [ 42, %cond.true116 ], [ %cond392, %cond.end391 ]
  br label %cond.end395

cond.end395:                                      ; preds = %cond.end393, %cond.true111
  %cond396 = phi i32 [ 43, %cond.true111 ], [ %cond394, %cond.end393 ]
  br label %cond.end397

cond.end397:                                      ; preds = %cond.end395, %cond.true106
  %cond398 = phi i32 [ 44, %cond.true106 ], [ %cond396, %cond.end395 ]
  br label %cond.end399

cond.end399:                                      ; preds = %cond.end397, %cond.true101
  %cond400 = phi i32 [ 45, %cond.true101 ], [ %cond398, %cond.end397 ]
  br label %cond.end401

cond.end401:                                      ; preds = %cond.end399, %cond.true96
  %cond402 = phi i32 [ 46, %cond.true96 ], [ %cond400, %cond.end399 ]
  br label %cond.end403

cond.end403:                                      ; preds = %cond.end401, %cond.true91
  %cond404 = phi i32 [ 47, %cond.true91 ], [ %cond402, %cond.end401 ]
  br label %cond.end405

cond.end405:                                      ; preds = %cond.end403, %cond.true86
  %cond406 = phi i32 [ 48, %cond.true86 ], [ %cond404, %cond.end403 ]
  br label %cond.end407

cond.end407:                                      ; preds = %cond.end405, %cond.true81
  %cond408 = phi i32 [ 49, %cond.true81 ], [ %cond406, %cond.end405 ]
  br label %cond.end409

cond.end409:                                      ; preds = %cond.end407, %cond.true76
  %cond410 = phi i32 [ 50, %cond.true76 ], [ %cond408, %cond.end407 ]
  br label %cond.end411

cond.end411:                                      ; preds = %cond.end409, %cond.true71
  %cond412 = phi i32 [ 51, %cond.true71 ], [ %cond410, %cond.end409 ]
  br label %cond.end413

cond.end413:                                      ; preds = %cond.end411, %cond.true66
  %cond414 = phi i32 [ 52, %cond.true66 ], [ %cond412, %cond.end411 ]
  br label %cond.end415

cond.end415:                                      ; preds = %cond.end413, %cond.true61
  %cond416 = phi i32 [ 53, %cond.true61 ], [ %cond414, %cond.end413 ]
  br label %cond.end417

cond.end417:                                      ; preds = %cond.end415, %cond.true56
  %cond418 = phi i32 [ 54, %cond.true56 ], [ %cond416, %cond.end415 ]
  br label %cond.end419

cond.end419:                                      ; preds = %cond.end417, %cond.true51
  %cond420 = phi i32 [ 55, %cond.true51 ], [ %cond418, %cond.end417 ]
  br label %cond.end421

cond.end421:                                      ; preds = %cond.end419, %cond.true46
  %cond422 = phi i32 [ 56, %cond.true46 ], [ %cond420, %cond.end419 ]
  br label %cond.end423

cond.end423:                                      ; preds = %cond.end421, %cond.true41
  %cond424 = phi i32 [ 57, %cond.true41 ], [ %cond422, %cond.end421 ]
  br label %cond.end425

cond.end425:                                      ; preds = %cond.end423, %cond.true36
  %cond426 = phi i32 [ 58, %cond.true36 ], [ %cond424, %cond.end423 ]
  br label %cond.end427

cond.end427:                                      ; preds = %cond.end425, %cond.true31
  %cond428 = phi i32 [ 59, %cond.true31 ], [ %cond426, %cond.end425 ]
  br label %cond.end429

cond.end429:                                      ; preds = %cond.end427, %cond.true26
  %cond430 = phi i32 [ 60, %cond.true26 ], [ %cond428, %cond.end427 ]
  br label %cond.end431

cond.end431:                                      ; preds = %cond.end429, %cond.true21
  %cond432 = phi i32 [ 61, %cond.true21 ], [ %cond430, %cond.end429 ]
  br label %cond.end433

cond.end433:                                      ; preds = %cond.end431, %cond.true16
  %cond434 = phi i32 [ 62, %cond.true16 ], [ %cond432, %cond.end431 ]
  br label %cond.end435

cond.end435:                                      ; preds = %cond.end433, %cond.true11
  %cond436 = phi i32 [ 63, %cond.true11 ], [ %cond434, %cond.end433 ]
  br label %cond.end437

cond.end437:                                      ; preds = %cond.end435, %cond.true8
  %cond438 = phi i32 [ 0, %cond.true8 ], [ %cond436, %cond.end435 ]
  br label %cond.end440

cond.false439:                                    ; preds = %cond.true
  br label %cond.end440

cond.end440:                                      ; preds = %cond.false439, %cond.end437
  %cond441 = phi i32 [ %cond438, %cond.end437 ], [ -1, %cond.false439 ]
  br label %cond.end444

cond.false442:                                    ; preds = %if.end3
  %72 = load i64, i64* %size.addr, align 8
  %sub443 = sub i64 %72, 1
  %call = call i32 @__ilog2_u64(i64 noundef %sub443) #11
  br label %cond.end444

cond.end444:                                      ; preds = %cond.false442, %cond.end440
  %cond445 = phi i32 [ %cond441, %cond.end440 ], [ %call, %cond.false442 ]
  %sub446 = sub i32 %cond445, 12
  %add = add i32 %sub446, 1
  store i32 %add, i32* %retval, align 4
  br label %return

if.end447:                                        ; preds = %entry
  %73 = load i64, i64* %size.addr, align 8
  %dec = add i64 %73, -1
  store i64 %dec, i64* %size.addr, align 8
  %74 = load i64, i64* %size.addr, align 8
  %shr = lshr i64 %74, 12
  store i64 %shr, i64* %size.addr, align 8
  %75 = load i64, i64* %size.addr, align 8
  store i64 %75, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %76 = load i32, i32* %bitpos.i, align 4
  %77 = load i64, i64* %x.addr.i, align 8
  %78 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %77, i32 %76) #13, !srcloc !16
  store i32 %78, i32* %bitpos.i, align 4
  %79 = load i32, i32* %bitpos.i, align 4
  %add.i = add i32 %79, 1
  store i32 %add.i, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end447, %cond.end444, %if.then2, %if.then1
  %80 = load i32, i32* %retval, align 4
  ret i32 %80
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @kmalloc_order_trace(i64 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef, i32 noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @__kmalloc(i64 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal i32 @__ilog2_u64(i64 noundef %n) #5 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %1 = load i32, i32* %bitpos.i, align 4
  %2 = load i64, i64* %x.addr.i, align 8
  %3 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %2, i32 %1) #13, !srcloc !16
  store i32 %3, i32* %bitpos.i, align 4
  %4 = load i32, i32* %bitpos.i, align 4
  %add.i = add i32 %4, 1
  %sub = sub i32 %add.i, 1
  ret i32 %sub
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64(i64 noundef %dividend, i32 noundef %divisor) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder = alloca i32, align 4
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %call = call i64 @div_u64_rem(i64 noundef %0, i32 noundef %1, i32* noundef %remainder) #8
  ret i64 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64_rem(i64 noundef %dividend, i32 noundef %divisor, i32* noundef %remainder) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder.addr = alloca i32*, align 8
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  store i32* %remainder, i32** %remainder.addr, align 8
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %conv = zext i32 %1 to i64
  %rem = urem i64 %0, %conv
  %conv1 = trunc i64 %rem to i32
  %2 = load i32*, i32** %remainder.addr, align 8
  store i32 %conv1, i32* %2, align 4
  %3 = load i64, i64* %dividend.addr, align 8
  %4 = load i32, i32* %divisor.addr, align 4
  %conv2 = zext i32 %4 to i64
  %div = udiv i64 %3, %conv2
  ret i64 %div
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %func = alloca %struct.bpf_prog**, align 8
  %tmp = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %len = alloca i32, align 4
  %subprog = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %old_bpf_func = alloca i8*, align 8
  %err = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp37 = alloca i64, align 8
  %tmp45 = alloca i64, align 8
  %tmp169 = alloca i32, align 4
  %tmp247 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  store i32 0, i32* %subprog_end, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 21
  %3 = load i32, i32* %subprog_cnt, align 8
  %cmp = icmp ule i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %5 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len2, align 4
  %cmp3 = icmp ult i32 %6, %8
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code, align 4
  %conv = zext i8 %10 to i32
  %cmp4 = icmp ne i32 %conv, 133
  br i1 %cmp4, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv6 = zext i8 %bf.lshr to i32
  %cmp7 = icmp ne i32 %conv6, 1
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end10:                                         ; preds = %lor.lhs.false
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 3
  %15 = load i32, i32* %imm, align 4
  %add = add i32 %13, %15
  %add11 = add i32 %add, 1
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %12, i32 noundef %add11) #8
  store i32 %call, i32* %subprog, align 4
  %16 = load i32, i32* %subprog, align 4
  %cmp12 = icmp slt i32 %16, 0
  br i1 %cmp12, label %if.then14, label %if.end52

if.then14:                                        ; preds = %if.end10
  store i32 1, i32* %__ret_warn_once, align 4
  %17 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then14
  %18 = load i8, i8* @jit_subprogs.__warned, align 1
  %tobool15 = trunc i8 %18 to i1
  %lnot = xor i1 %tobool15, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then14
  %19 = phi i1 [ false, %if.then14 ], [ %lnot, %land.rhs ]
  %lnot16 = xor i1 %19, true
  %lnot17 = xor i1 %lnot16, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv18 = sext i32 %lnot.ext to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %if.then20, label %if.end44

if.then20:                                        ; preds = %land.end
  store i8 1, i8* @jit_subprogs.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %20 = load i32, i32* %__ret_warn_on, align 4
  %tobool21 = icmp ne i32 %20, 0
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  %tobool27 = icmp ne i64 %conv26, 0
  br i1 %tobool27, label %if.then28, label %if.end36

if.then28:                                        ; preds = %if.then20
  br label %do.body

do.body:                                          ; preds = %if.then28
  %21 = load i32, i32* %i, align 4
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 3
  %23 = load i32, i32* %imm29, align 4
  %add30 = add i32 %21, %23
  %add31 = add i32 %add30, 1
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.214, i64 0, i64 0), i32 noundef %add31) #8
  br label %do.body32

do.body32:                                        ; preds = %do.body
  br label %do.body33

do.body33:                                        ; preds = %do.body32
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10622, i32 2313, i64 12) #9, !srcloc !17
  br label %do.end

do.end:                                           ; preds = %do.body33
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 221) #9, !srcloc !18
  br label %do.end34

do.end34:                                         ; preds = %do.end
  br label %do.end35

do.end35:                                         ; preds = %do.end34
  br label %if.end36

if.end36:                                         ; preds = %do.end35, %if.then20
  %24 = load i32, i32* %__ret_warn_on, align 4
  %tobool38 = icmp ne i32 %24, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  store i64 %conv43, i64* %tmp37, align 8
  %25 = load i64, i64* %tmp37, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.end36, %land.end
  %26 = load i32, i32* %__ret_warn_once, align 4
  %tobool46 = icmp ne i32 %26, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  store i64 %conv51, i64* %tmp45, align 8
  %27 = load i64, i64* %tmp45, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end10
  %28 = load i32, i32* %subprog, align 4
  %conv53 = trunc i32 %28 to i16
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 2
  store i16 %conv53, i16* %off, align 2
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 3
  %31 = load i32, i32* %imm54, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 16
  %33 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %34 = load i32, i32* %i, align 4
  %idxprom = sext i32 %34 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %33, i64 %idxprom
  %35 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 0
  %call_imm = bitcast %union.anon.13* %35 to i32*
  store i32 %31, i32* %call_imm, align 8
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 3
  store i32 1, i32* %imm55, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end52, %if.then9
  %37 = load i32, i32* %i, align 4
  %inc = add i32 %37, 1
  store i32 %inc, i32* %i, align 4
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %38, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %39 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call56 = call i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef %39) #8
  store i32 %call56, i32* %err, align 4
  %40 = load i32, i32* %err, align 4
  %tobool57 = icmp ne i32 %40, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %for.end
  br label %out_undo_insn

if.end59:                                         ; preds = %for.end
  store i32 -12, i32* %err, align 4
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt60 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 21
  %42 = load i32, i32* %subprog_cnt60, align 8
  %conv61 = zext i32 %42 to i64
  %call62 = call i8* @kcalloc(i64 noundef %conv61, i64 noundef 8, i32 noundef 3264) #8
  %43 = bitcast i8* %call62 to %struct.bpf_prog**
  store %struct.bpf_prog** %43, %struct.bpf_prog*** %func, align 8
  %44 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %tobool63 = icmp ne %struct.bpf_prog** %44, null
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %if.end59
  br label %out_undo_insn

if.end65:                                         ; preds = %if.end59
  store i32 0, i32* %i, align 4
  br label %for.cond66

for.cond66:                                       ; preds = %for.inc171, %if.end65
  %45 = load i32, i32* %i, align 4
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt67 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %46, i32 0, i32 21
  %47 = load i32, i32* %subprog_cnt67, align 8
  %cmp68 = icmp ult i32 %45, %47
  br i1 %cmp68, label %for.body70, label %for.end173

for.body70:                                       ; preds = %for.cond66
  %48 = load i32, i32* %subprog_end, align 4
  store i32 %48, i32* %subprog_start, align 4
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 19
  %50 = load i32, i32* %i, align 4
  %add71 = add i32 %50, 1
  %idxprom72 = sext i32 %add71 to i64
  %arrayidx73 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom72
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx73, i32 0, i32 0
  %51 = load i32, i32* %start, align 4
  store i32 %51, i32* %subprog_end, align 4
  %52 = load i32, i32* %subprog_end, align 4
  %53 = load i32, i32* %subprog_start, align 4
  %sub = sub i32 %52, %53
  store i32 %sub, i32* %len, align 4
  %54 = load i32, i32* %len, align 4
  %call74 = call i32 @bpf_prog_size(i32 noundef %54) #8
  %call75 = call %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef %call74, i32 noundef 1051840) #8
  %55 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %56 = load i32, i32* %i, align 4
  %idxprom76 = sext i32 %56 to i64
  %arrayidx77 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %55, i64 %idxprom76
  store %struct.bpf_prog* %call75, %struct.bpf_prog** %arrayidx77, align 8
  %57 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %58 = load i32, i32* %i, align 4
  %idxprom78 = sext i32 %58 to i64
  %arrayidx79 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %57, i64 %idxprom78
  %59 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx79, align 8
  %tobool80 = icmp ne %struct.bpf_prog* %59, null
  br i1 %tobool80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %for.body70
  br label %out_free

if.end82:                                         ; preds = %for.body70
  %60 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %61 = load i32, i32* %i, align 4
  %idxprom83 = sext i32 %61 to i64
  %arrayidx84 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %60, i64 %idxprom83
  %62 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx84, align 8
  %63 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %62, i32 0, i32 10
  %insnsi85 = bitcast %union.anon.146* %63 to [0 x %struct.bpf_insn]*
  %arraydecay86 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi85, i64 0, i64 0
  %64 = bitcast %struct.bpf_insn* %arraydecay86 to i8*
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %66 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %65, i32 0, i32 10
  %insnsi87 = bitcast %union.anon.146* %66 to [0 x %struct.bpf_insn]*
  %67 = load i32, i32* %subprog_start, align 4
  %idxprom88 = sext i32 %67 to i64
  %arrayidx89 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi87, i64 0, i64 %idxprom88
  %68 = bitcast %struct.bpf_insn* %arrayidx89 to i8*
  %69 = load i32, i32* %len, align 4
  %conv90 = sext i32 %69 to i64
  %mul = mul i64 %conv90, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %64, i8* align 8 %68, i64 %mul, i1 false)
  %70 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %70, i32 0, i32 2
  %71 = load i32, i32* %type, align 4
  %72 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %73 = load i32, i32* %i, align 4
  %idxprom91 = sext i32 %73 to i64
  %arrayidx92 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %72, i64 %idxprom91
  %74 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx92, align 8
  %type93 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %74, i32 0, i32 2
  store i32 %71, i32* %type93, align 4
  %75 = load i32, i32* %len, align 4
  %76 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %77 = load i32, i32* %i, align 4
  %idxprom94 = sext i32 %77 to i64
  %arrayidx95 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %76, i64 %idxprom94
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx95, align 8
  %len96 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %78, i32 0, i32 4
  store i32 %75, i32* %len96, align 4
  %79 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %80 = load i32, i32* %i, align 4
  %idxprom97 = sext i32 %80 to i64
  %arrayidx98 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %79, i64 %idxprom97
  %81 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx98, align 8
  %call99 = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %81) #8
  %tobool100 = icmp ne i32 %call99, 0
  br i1 %tobool100, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.end82
  br label %out_free

if.end102:                                        ; preds = %if.end82
  %82 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %83 = load i32, i32* %i, align 4
  %idxprom103 = sext i32 %83 to i64
  %arrayidx104 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %82, i64 %idxprom103
  %84 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx104, align 8
  %is_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %84, i32 0, i32 1
  %bf.load105 = load i16, i16* %is_func, align 2
  %bf.clear = and i16 %bf.load105, -65
  %bf.set = or i16 %bf.clear, 64
  store i16 %bf.set, i16* %is_func, align 2
  %85 = load i32, i32* %i, align 4
  %86 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %87 = load i32, i32* %i, align 4
  %idxprom106 = sext i32 %87 to i64
  %arrayidx107 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %86, i64 %idxprom106
  %88 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx107, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %88, i32 0, i32 7
  %89 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_idx = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %89, i32 0, i32 8
  store i32 %85, i32* %func_idx, align 8
  %90 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux108 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %90, i32 0, i32 7
  %91 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux108, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %91, i32 0, i32 24
  %92 = load %struct.btf*, %struct.btf** %btf, align 8
  %93 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %94 = load i32, i32* %i, align 4
  %idxprom109 = sext i32 %94 to i64
  %arrayidx110 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %93, i64 %idxprom109
  %95 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx110, align 8
  %aux111 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %95, i32 0, i32 7
  %96 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux111, align 8
  %btf112 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %96, i32 0, i32 24
  store %struct.btf* %92, %struct.btf** %btf112, align 8
  %97 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux113 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %97, i32 0, i32 7
  %98 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux113, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %98, i32 0, i32 25
  %99 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %100 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %101 = load i32, i32* %i, align 4
  %idxprom114 = sext i32 %101 to i64
  %arrayidx115 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %100, i64 %idxprom114
  %102 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx115, align 8
  %aux116 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %102, i32 0, i32 7
  %103 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux116, align 8
  %func_info117 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %103, i32 0, i32 25
  store %struct.util_est* %99, %struct.util_est** %func_info117, align 8
  %104 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %105 = load i32, i32* %i, align 4
  %idxprom118 = sext i32 %105 to i64
  %arrayidx119 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %104, i64 %idxprom118
  %106 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx119, align 8
  %aux120 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %106, i32 0, i32 7
  %107 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux120, align 8
  %name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %107, i32 0, i32 21
  %arrayidx121 = getelementptr [16 x i8], [16 x i8]* %name, i64 0, i64 0
  store i8 70, i8* %arrayidx121, align 8
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info122 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %108, i32 0, i32 19
  %109 = load i32, i32* %i, align 4
  %idxprom123 = sext i32 %109 to i64
  %arrayidx124 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info122, i64 0, i64 %idxprom123
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx124, i32 0, i32 2
  %110 = load i16, i16* %stack_depth, align 4
  %conv125 = zext i16 %110 to i32
  %111 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %112 = load i32, i32* %i, align 4
  %idxprom126 = sext i32 %112 to i64
  %arrayidx127 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %111, i64 %idxprom126
  %113 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx127, align 8
  %aux128 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %113, i32 0, i32 7
  %114 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux128, align 8
  %stack_depth129 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %114, i32 0, i32 5
  store i32 %conv125, i32* %stack_depth129, align 4
  %115 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %116 = load i32, i32* %i, align 4
  %idxprom130 = sext i32 %116 to i64
  %arrayidx131 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %115, i64 %idxprom130
  %117 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx131, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %117, i32 0, i32 1
  %bf.load132 = load i16, i16* %jit_requested, align 2
  %bf.clear133 = and i16 %bf.load132, -3
  %bf.set134 = or i16 %bf.clear133, 2
  store i16 %bf.set134, i16* %jit_requested, align 2
  %118 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux135 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %118, i32 0, i32 7
  %119 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux135, align 8
  %linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %119, i32 0, i32 26
  %120 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %121 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %122 = load i32, i32* %i, align 4
  %idxprom136 = sext i32 %122 to i64
  %arrayidx137 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %121, i64 %idxprom136
  %123 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx137, align 8
  %aux138 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %123, i32 0, i32 7
  %124 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux138, align 8
  %linfo139 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %124, i32 0, i32 26
  store %struct.ethtool_pauseparam* %120, %struct.ethtool_pauseparam** %linfo139, align 8
  %125 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux140 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %125, i32 0, i32 7
  %126 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux140, align 8
  %nr_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %126, i32 0, i32 29
  %127 = load i32, i32* %nr_linfo, align 4
  %128 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %129 = load i32, i32* %i, align 4
  %idxprom141 = sext i32 %129 to i64
  %arrayidx142 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %128, i64 %idxprom141
  %130 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx142, align 8
  %aux143 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %130, i32 0, i32 7
  %131 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux143, align 8
  %nr_linfo144 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %131, i32 0, i32 29
  store i32 %127, i32* %nr_linfo144, align 4
  %132 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux145 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %132, i32 0, i32 7
  %133 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux145, align 8
  %jited_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %133, i32 0, i32 27
  %134 = load i8**, i8*** %jited_linfo, align 8
  %135 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %136 = load i32, i32* %i, align 4
  %idxprom146 = sext i32 %136 to i64
  %arrayidx147 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %135, i64 %idxprom146
  %137 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx147, align 8
  %aux148 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %137, i32 0, i32 7
  %138 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux148, align 8
  %jited_linfo149 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %138, i32 0, i32 27
  store i8** %134, i8*** %jited_linfo149, align 8
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info150 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %139, i32 0, i32 19
  %140 = load i32, i32* %i, align 4
  %idxprom151 = sext i32 %140 to i64
  %arrayidx152 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info150, i64 0, i64 %idxprom151
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx152, i32 0, i32 1
  %141 = load i32, i32* %linfo_idx, align 4
  %142 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %143 = load i32, i32* %i, align 4
  %idxprom153 = sext i32 %143 to i64
  %arrayidx154 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %142, i64 %idxprom153
  %144 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx154, align 8
  %aux155 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %144, i32 0, i32 7
  %145 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux155, align 8
  %linfo_idx156 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %145, i32 0, i32 30
  store i32 %141, i32* %linfo_idx156, align 8
  %146 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %147 = load i32, i32* %i, align 4
  %idxprom157 = sext i32 %147 to i64
  %arrayidx158 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %146, i64 %idxprom157
  %148 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx158, align 8
  %call159 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %148) #8
  %149 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %150 = load i32, i32* %i, align 4
  %idxprom160 = sext i32 %150 to i64
  %arrayidx161 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %149, i64 %idxprom160
  store %struct.bpf_prog* %call159, %struct.bpf_prog** %arrayidx161, align 8
  %151 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %152 = load i32, i32* %i, align 4
  %idxprom162 = sext i32 %152 to i64
  %arrayidx163 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %151, i64 %idxprom162
  %153 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx163, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %153, i32 0, i32 1
  %bf.load164 = load i16, i16* %jited, align 2
  %bf.clear165 = and i16 %bf.load164, 1
  %tobool166 = icmp ne i16 %bf.clear165, 0
  br i1 %tobool166, label %if.end168, label %if.then167

if.then167:                                       ; preds = %if.end102
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end168:                                        ; preds = %if.end102
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 10686, i32 noundef 0) #8
  %call170 = call i32 @_cond_resched() #8
  store i32 %call170, i32* %tmp169, align 4
  %154 = load i32, i32* %tmp169, align 4
  br label %for.inc171

for.inc171:                                       ; preds = %if.end168
  %155 = load i32, i32* %i, align 4
  %inc172 = add i32 %155, 1
  store i32 %inc172, i32* %i, align 4
  br label %for.cond66

for.end173:                                       ; preds = %for.cond66
  store i32 0, i32* %i, align 4
  br label %for.cond174

for.cond174:                                      ; preds = %for.inc221, %for.end173
  %156 = load i32, i32* %i, align 4
  %157 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt175 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %157, i32 0, i32 21
  %158 = load i32, i32* %subprog_cnt175, align 8
  %cmp176 = icmp ult i32 %156, %158
  br i1 %cmp176, label %for.body178, label %for.end223

for.body178:                                      ; preds = %for.cond174
  %159 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %160 = load i32, i32* %i, align 4
  %idxprom179 = sext i32 %160 to i64
  %arrayidx180 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %159, i64 %idxprom179
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx180, align 8
  %162 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 10
  %insnsi181 = bitcast %union.anon.146* %162 to [0 x %struct.bpf_insn]*
  %arraydecay182 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi181, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay182, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond183

for.cond183:                                      ; preds = %for.inc209, %for.body178
  %163 = load i32, i32* %j, align 4
  %164 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %165 = load i32, i32* %i, align 4
  %idxprom184 = sext i32 %165 to i64
  %arrayidx185 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %164, i64 %idxprom184
  %166 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx185, align 8
  %len186 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %166, i32 0, i32 4
  %167 = load i32, i32* %len186, align 4
  %cmp187 = icmp ult i32 %163, %167
  br i1 %cmp187, label %for.body189, label %for.end212

for.body189:                                      ; preds = %for.cond183
  %168 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code190 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %168, i32 0, i32 0
  %169 = load i8, i8* %code190, align 4
  %conv191 = zext i8 %169 to i32
  %cmp192 = icmp ne i32 %conv191, 133
  br i1 %cmp192, label %if.then201, label %lor.lhs.false194

lor.lhs.false194:                                 ; preds = %for.body189
  %170 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg195 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %170, i32 0, i32 1
  %bf.load196 = load i8, i8* %src_reg195, align 1
  %bf.lshr197 = lshr i8 %bf.load196, 4
  %conv198 = zext i8 %bf.lshr197 to i32
  %cmp199 = icmp ne i32 %conv198, 1
  br i1 %cmp199, label %if.then201, label %if.end202

if.then201:                                       ; preds = %lor.lhs.false194, %for.body189
  br label %for.inc209

if.end202:                                        ; preds = %lor.lhs.false194
  %171 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %171, i32 0, i32 2
  %172 = load i16, i16* %off203, align 2
  %conv204 = sext i16 %172 to i32
  store i32 %conv204, i32* %subprog, align 4
  %173 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %174 = load i32, i32* %subprog, align 4
  %idxprom205 = sext i32 %174 to i64
  %arrayidx206 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %173, i64 %idxprom205
  %175 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx206, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %175, i32 0, i32 9
  %176 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %177 = bitcast i32 (i8*, %struct.bpf_insn*)* %176 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast = ptrtoint i64 (i64, i64, i64, i64, i64)* %177 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv207 = trunc i64 %sub.ptr.sub to i32
  %178 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm208 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %178, i32 0, i32 3
  store i32 %conv207, i32* %imm208, align 4
  br label %for.inc209

for.inc209:                                       ; preds = %if.end202, %if.then201
  %179 = load i32, i32* %j, align 4
  %inc210 = add i32 %179, 1
  store i32 %inc210, i32* %j, align 4
  %180 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr211 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %180, i32 1
  store %struct.bpf_insn* %incdec.ptr211, %struct.bpf_insn** %insn, align 8
  br label %for.cond183

for.end212:                                       ; preds = %for.cond183
  %181 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %182 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %183 = load i32, i32* %i, align 4
  %idxprom213 = sext i32 %183 to i64
  %arrayidx214 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %182, i64 %idxprom213
  %184 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx214, align 8
  %aux215 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %184, i32 0, i32 7
  %185 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux215, align 8
  %func216 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %185, i32 0, i32 11
  store %struct.bpf_prog** %181, %struct.bpf_prog*** %func216, align 8
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt217 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %186, i32 0, i32 21
  %187 = load i32, i32* %subprog_cnt217, align 8
  %188 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %189 = load i32, i32* %i, align 4
  %idxprom218 = sext i32 %189 to i64
  %arrayidx219 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %188, i64 %idxprom218
  %190 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx219, align 8
  %aux220 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %190, i32 0, i32 7
  %191 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux220, align 8
  %func_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %191, i32 0, i32 7
  store i32 %187, i32* %func_cnt, align 4
  br label %for.inc221

for.inc221:                                       ; preds = %for.end212
  %192 = load i32, i32* %i, align 4
  %inc222 = add i32 %192, 1
  store i32 %inc222, i32* %i, align 4
  br label %for.cond174

for.end223:                                       ; preds = %for.cond174
  store i32 0, i32* %i, align 4
  br label %for.cond224

for.cond224:                                      ; preds = %for.inc249, %for.end223
  %193 = load i32, i32* %i, align 4
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt225 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %194, i32 0, i32 21
  %195 = load i32, i32* %subprog_cnt225, align 8
  %cmp226 = icmp ult i32 %193, %195
  br i1 %cmp226, label %for.body228, label %for.end251

for.body228:                                      ; preds = %for.cond224
  %196 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %197 = load i32, i32* %i, align 4
  %idxprom229 = sext i32 %197 to i64
  %arrayidx230 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %196, i64 %idxprom229
  %198 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx230, align 8
  %bpf_func231 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %198, i32 0, i32 9
  %199 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func231, align 8
  %200 = bitcast i32 (i8*, %struct.bpf_insn*)* %199 to i8*
  store i8* %200, i8** %old_bpf_func, align 8
  %201 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %202 = load i32, i32* %i, align 4
  %idxprom232 = sext i32 %202 to i64
  %arrayidx233 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %201, i64 %idxprom232
  %203 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx233, align 8
  %call234 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %203) #8
  store %struct.bpf_prog* %call234, %struct.bpf_prog** %tmp, align 8
  %204 = load %struct.bpf_prog*, %struct.bpf_prog** %tmp, align 8
  %205 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %206 = load i32, i32* %i, align 4
  %idxprom235 = sext i32 %206 to i64
  %arrayidx236 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %205, i64 %idxprom235
  %207 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx236, align 8
  %cmp237 = icmp ne %struct.bpf_prog* %204, %207
  br i1 %cmp237, label %if.then245, label %lor.lhs.false239

lor.lhs.false239:                                 ; preds = %for.body228
  %208 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %209 = load i32, i32* %i, align 4
  %idxprom240 = sext i32 %209 to i64
  %arrayidx241 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %208, i64 %idxprom240
  %210 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx241, align 8
  %bpf_func242 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %210, i32 0, i32 9
  %211 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func242, align 8
  %212 = load i8*, i8** %old_bpf_func, align 8
  %213 = bitcast i8* %212 to i32 (i8*, %struct.bpf_insn*)*
  %cmp243 = icmp ne i32 (i8*, %struct.bpf_insn*)* %211, %213
  br i1 %cmp243, label %if.then245, label %if.end246

if.then245:                                       ; preds = %lor.lhs.false239, %for.body228
  %214 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %215 = bitcast %struct.bpf_verifier_env* %214 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %215, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.287, i64 0, i64 0)) #8
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end246:                                        ; preds = %lor.lhs.false239
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 10725, i32 noundef 0) #8
  %call248 = call i32 @_cond_resched() #8
  store i32 %call248, i32* %tmp247, align 4
  %216 = load i32, i32* %tmp247, align 4
  br label %for.inc249

for.inc249:                                       ; preds = %if.end246
  %217 = load i32, i32* %i, align 4
  %inc250 = add i32 %217, 1
  store i32 %inc250, i32* %i, align 4
  br label %for.cond224

for.end251:                                       ; preds = %for.cond224
  store i32 0, i32* %i, align 4
  br label %for.cond252

for.cond252:                                      ; preds = %for.inc261, %for.end251
  %218 = load i32, i32* %i, align 4
  %219 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt253 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %219, i32 0, i32 21
  %220 = load i32, i32* %subprog_cnt253, align 8
  %cmp254 = icmp ult i32 %218, %220
  br i1 %cmp254, label %for.body256, label %for.end263

for.body256:                                      ; preds = %for.cond252
  %221 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %222 = load i32, i32* %i, align 4
  %idxprom257 = sext i32 %222 to i64
  %arrayidx258 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %221, i64 %idxprom257
  %223 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx258, align 8
  call void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %223) #8
  %224 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %225 = load i32, i32* %i, align 4
  %idxprom259 = sext i32 %225 to i64
  %arrayidx260 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %224, i64 %idxprom259
  %226 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx260, align 8
  call void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %226) #8
  br label %for.inc261

for.inc261:                                       ; preds = %for.body256
  %227 = load i32, i32* %i, align 4
  %inc262 = add i32 %227, 1
  store i32 %inc262, i32* %i, align 4
  br label %for.cond252

for.end263:                                       ; preds = %for.cond252
  store i32 0, i32* %i, align 4
  %228 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %229 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %228, i32 0, i32 10
  %insnsi264 = bitcast %union.anon.146* %229 to [0 x %struct.bpf_insn]*
  %arraydecay265 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi264, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay265, %struct.bpf_insn** %insn, align 8
  br label %for.cond266

for.cond266:                                      ; preds = %for.inc296, %for.end263
  %230 = load i32, i32* %i, align 4
  %231 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len267 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %231, i32 0, i32 4
  %232 = load i32, i32* %len267, align 4
  %cmp268 = icmp ult i32 %230, %232
  br i1 %cmp268, label %for.body270, label %for.end299

for.body270:                                      ; preds = %for.cond266
  %233 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %233, i32 0, i32 0
  %234 = load i8, i8* %code271, align 4
  %conv272 = zext i8 %234 to i32
  %cmp273 = icmp ne i32 %conv272, 133
  br i1 %cmp273, label %if.then282, label %lor.lhs.false275

lor.lhs.false275:                                 ; preds = %for.body270
  %235 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg276 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %235, i32 0, i32 1
  %bf.load277 = load i8, i8* %src_reg276, align 1
  %bf.lshr278 = lshr i8 %bf.load277, 4
  %conv279 = zext i8 %bf.lshr278 to i32
  %cmp280 = icmp ne i32 %conv279, 1
  br i1 %cmp280, label %if.then282, label %if.end283

if.then282:                                       ; preds = %lor.lhs.false275, %for.body270
  br label %for.inc296

if.end283:                                        ; preds = %lor.lhs.false275
  %236 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data284 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %236, i32 0, i32 16
  %237 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data284, align 8
  %238 = load i32, i32* %i, align 4
  %idxprom285 = sext i32 %238 to i64
  %arrayidx286 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %237, i64 %idxprom285
  %239 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx286, i32 0, i32 0
  %call_imm287 = bitcast %union.anon.13* %239 to i32*
  %240 = load i32, i32* %call_imm287, align 8
  %conv288 = trunc i32 %240 to i16
  %241 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off289 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %241, i32 0, i32 2
  store i16 %conv288, i16* %off289, align 2
  %242 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %243 = load i32, i32* %i, align 4
  %244 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off290 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %244, i32 0, i32 2
  %245 = load i16, i16* %off290, align 2
  %conv291 = sext i16 %245 to i32
  %add292 = add i32 %243, %conv291
  %add293 = add i32 %add292, 1
  %call294 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %242, i32 noundef %add293) #8
  store i32 %call294, i32* %subprog, align 4
  %246 = load i32, i32* %subprog, align 4
  %247 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm295 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %247, i32 0, i32 3
  store i32 %246, i32* %imm295, align 4
  br label %for.inc296

for.inc296:                                       ; preds = %if.end283, %if.then282
  %248 = load i32, i32* %i, align 4
  %inc297 = add i32 %248, 1
  store i32 %inc297, i32* %i, align 4
  %249 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr298 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %249, i32 1
  store %struct.bpf_insn* %incdec.ptr298, %struct.bpf_insn** %insn, align 8
  br label %for.cond266

for.end299:                                       ; preds = %for.cond266
  %250 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jited300 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %250, i32 0, i32 1
  %bf.load301 = load i16, i16* %jited300, align 2
  %bf.clear302 = and i16 %bf.load301, -2
  %bf.set303 = or i16 %bf.clear302, 1
  store i16 %bf.set303, i16* %jited300, align 2
  %251 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %arrayidx304 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %251, i64 0
  %252 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx304, align 8
  %bpf_func305 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %252, i32 0, i32 9
  %253 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func305, align 8
  %254 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %bpf_func306 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %254, i32 0, i32 9
  store i32 (i8*, %struct.bpf_insn*)* %253, i32 (i8*, %struct.bpf_insn*)** %bpf_func306, align 8
  %255 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %256 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux307 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %256, i32 0, i32 7
  %257 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux307, align 8
  %func308 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %257, i32 0, i32 11
  store %struct.bpf_prog** %255, %struct.bpf_prog*** %func308, align 8
  %258 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt309 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %258, i32 0, i32 21
  %259 = load i32, i32* %subprog_cnt309, align 8
  %260 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux310 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %260, i32 0, i32 7
  %261 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux310, align 8
  %func_cnt311 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %261, i32 0, i32 7
  store i32 %259, i32* %func_cnt311, align 4
  %262 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_free_unused_jited_linfo(%struct.bpf_prog* noundef %262) #8
  store i32 0, i32* %retval, align 4
  br label %return

out_free:                                         ; preds = %if.then245, %if.then167, %if.then101, %if.then81
  store i32 0, i32* %i, align 4
  br label %for.cond312

for.cond312:                                      ; preds = %for.inc324, %out_free
  %263 = load i32, i32* %i, align 4
  %264 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt313 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %264, i32 0, i32 21
  %265 = load i32, i32* %subprog_cnt313, align 8
  %cmp314 = icmp ult i32 %263, %265
  br i1 %cmp314, label %for.body316, label %for.end326

for.body316:                                      ; preds = %for.cond312
  %266 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %267 = load i32, i32* %i, align 4
  %idxprom317 = sext i32 %267 to i64
  %arrayidx318 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %266, i64 %idxprom317
  %268 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx318, align 8
  %tobool319 = icmp ne %struct.bpf_prog* %268, null
  br i1 %tobool319, label %if.then320, label %if.end323

if.then320:                                       ; preds = %for.body316
  %269 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %270 = load i32, i32* %i, align 4
  %idxprom321 = sext i32 %270 to i64
  %arrayidx322 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %269, i64 %idxprom321
  %271 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx322, align 8
  call void @bpf_jit_free(%struct.bpf_prog* noundef %271) #8
  br label %if.end323

if.end323:                                        ; preds = %if.then320, %for.body316
  br label %for.inc324

for.inc324:                                       ; preds = %if.end323
  %272 = load i32, i32* %i, align 4
  %inc325 = add i32 %272, 1
  store i32 %inc325, i32* %i, align 4
  br label %for.cond312

for.end326:                                       ; preds = %for.cond312
  %273 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %274 = bitcast %struct.bpf_prog** %273 to i8*
  call void @kfree(i8* noundef %274) #8
  br label %out_undo_insn

out_undo_insn:                                    ; preds = %for.end326, %if.then64, %if.then58
  %275 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested327 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %275, i32 0, i32 1
  %bf.load328 = load i16, i16* %jit_requested327, align 2
  %bf.clear329 = and i16 %bf.load328, -3
  %bf.set330 = or i16 %bf.clear329, 0
  store i16 %bf.set330, i16* %jit_requested327, align 2
  store i32 0, i32* %i, align 4
  %276 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %277 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %276, i32 0, i32 10
  %insnsi331 = bitcast %union.anon.146* %277 to [0 x %struct.bpf_insn]*
  %arraydecay332 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi331, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay332, %struct.bpf_insn** %insn, align 8
  br label %for.cond333

for.cond333:                                      ; preds = %for.inc357, %out_undo_insn
  %278 = load i32, i32* %i, align 4
  %279 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len334 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %279, i32 0, i32 4
  %280 = load i32, i32* %len334, align 4
  %cmp335 = icmp ult i32 %278, %280
  br i1 %cmp335, label %for.body337, label %for.end360

for.body337:                                      ; preds = %for.cond333
  %281 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code338 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %281, i32 0, i32 0
  %282 = load i8, i8* %code338, align 4
  %conv339 = zext i8 %282 to i32
  %cmp340 = icmp ne i32 %conv339, 133
  br i1 %cmp340, label %if.then349, label %lor.lhs.false342

lor.lhs.false342:                                 ; preds = %for.body337
  %283 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg343 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %283, i32 0, i32 1
  %bf.load344 = load i8, i8* %src_reg343, align 1
  %bf.lshr345 = lshr i8 %bf.load344, 4
  %conv346 = zext i8 %bf.lshr345 to i32
  %cmp347 = icmp ne i32 %conv346, 1
  br i1 %cmp347, label %if.then349, label %if.end350

if.then349:                                       ; preds = %lor.lhs.false342, %for.body337
  br label %for.inc357

if.end350:                                        ; preds = %lor.lhs.false342
  %284 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off351 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %284, i32 0, i32 2
  store i16 0, i16* %off351, align 2
  %285 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data352 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %285, i32 0, i32 16
  %286 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data352, align 8
  %287 = load i32, i32* %i, align 4
  %idxprom353 = sext i32 %287 to i64
  %arrayidx354 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %286, i64 %idxprom353
  %288 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx354, i32 0, i32 0
  %call_imm355 = bitcast %union.anon.13* %288 to i32*
  %289 = load i32, i32* %call_imm355, align 8
  %290 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm356 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %290, i32 0, i32 3
  store i32 %289, i32* %imm356, align 4
  br label %for.inc357

for.inc357:                                       ; preds = %if.end350, %if.then349
  %291 = load i32, i32* %i, align 4
  %inc358 = add i32 %291, 1
  store i32 %inc358, i32* %i, align 4
  %292 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr359 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %292, i32 1
  store %struct.bpf_insn* %incdec.ptr359, %struct.bpf_insn** %insn, align 8
  br label %for.cond333

for.end360:                                       ; preds = %for.cond333
  %293 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_free_jited_linfo(%struct.bpf_prog* noundef %293) #8
  %294 = load i32, i32* %err, align 4
  store i32 %294, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end360, %for.end299, %if.end44, %if.then
  %295 = load i32, i32* %retval, align 4
  ret i32 %295
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %idx.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %subprog = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp26 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load i32, i32* %idx.addr, align 4
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm, align 4
  %add = add i32 %0, %2
  %add1 = add i32 %add, 1
  store i32 %add1, i32* %start, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load i32, i32* %start, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %3, i32 noundef %4) #8
  store i32 %call, i32* %subprog, align 4
  %5 = load i32, i32* %subprog, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_once, align 4
  %6 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %7 = load i8, i8* @get_callee_stack_depth.__warned, align 1
  %tobool2 = trunc i8 %7 to i1
  %lnot = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %8 = phi i1 [ false, %if.then ], [ %lnot, %land.rhs ]
  %lnot3 = xor i1 %8, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then6, label %if.end25

if.then6:                                         ; preds = %land.end
  store i8 1, i8* @get_callee_stack_depth.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %9, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then6
  br label %do.body

do.body:                                          ; preds = %if.then14
  %10 = load i32, i32* %start, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.214, i64 0, i64 0), i32 noundef %10) #8
  br label %do.body15

do.body15:                                        ; preds = %do.body
  br label %do.body16

do.body16:                                        ; preds = %do.body15
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2754, i32 2313, i64 12) #9, !srcloc !19
  br label %do.end

do.end:                                           ; preds = %do.body16
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 158) #9, !srcloc !20
  br label %do.end17

do.end17:                                         ; preds = %do.end
  br label %do.end18

do.end18:                                         ; preds = %do.end17
  br label %if.end

if.end:                                           ; preds = %do.end18, %if.then6
  %11 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %11, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  store i64 %conv24, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.end, %land.end
  %13 = load i32, i32* %__ret_warn_once, align 4
  %tobool27 = icmp ne i32 %13, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp26, align 8
  %14 = load i64, i64* %tmp26, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 19
  %16 = load i32, i32* %subprog, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %17 = load i16, i16* %stack_depth, align 4
  %conv34 = zext i16 %17 to i32
  store i32 %conv34, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %if.end25
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_patch_call_args(%struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @find_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %p = alloca %struct.bpf_subprog_info*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = bitcast i32* %off.addr to i8*
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 19
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %2 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 21
  %4 = load i32, i32* %subprog_cnt, align 8
  %conv = zext i32 %4 to i64
  %call = call i8* @bsearch(i8* noundef %0, i8* noundef %2, i64 noundef %conv, i64 noundef 12, i32 (i8*, i8*)* noundef @cmp_subprogs) #8
  %5 = bitcast i8* %call to %struct.bpf_subprog_info*
  store %struct.bpf_subprog_info* %5, %struct.bpf_subprog_info** %p, align 8
  %6 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %tobool = icmp ne %struct.bpf_subprog_info* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 19
  %arraydecay2 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_subprog_info* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_subprog_info* %arraydecay2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 12
  %conv3 = trunc i64 %sub.ptr.div to i32
  store i32 %conv3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @cmp_subprogs(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_subprog_info*
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %1, i32 0, i32 0
  %2 = load i32, i32* %start, align 4
  %3 = load i8*, i8** %b.addr, align 8
  %4 = bitcast i8* %3 to %struct.bpf_subprog_info*
  %start1 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i32 0, i32 0
  %5 = load i32, i32* %start1, align 4
  %sub = sub i32 %2, %5
  ret i32 %sub
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @bsearch(i8* noundef, i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call i8* @kmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #8
  ret i8* %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_prog_size(i32 noundef %proglen) #0 {
entry:
  %proglen.addr = alloca i32, align 4
  %__UNIQUE_ID___x116 = alloca i64, align 8
  %__UNIQUE_ID___y117 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i32 %proglen, i32* %proglen.addr, align 4
  store i64 56, i64* %__UNIQUE_ID___x116, align 8
  %0 = load i32, i32* %proglen.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = mul i64 %conv, 8
  %2 = add i64 56, %1
  store i64 %2, i64* %__UNIQUE_ID___y117, align 8
  %3 = load i64, i64* %__UNIQUE_ID___x116, align 8
  %4 = load i64, i64* %__UNIQUE_ID___y117, align 8
  %cmp = icmp ugt i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, i64* %__UNIQUE_ID___x116, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___y117, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %conv2 = trunc i64 %7 to i32
  ret i32 %conv2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @___might_sleep(i8* noundef %file, i32 noundef %line, i32 noundef %preempt_offset) #0 {
entry:
  %file.addr = alloca i8*, align 8
  %line.addr = alloca i32, align 4
  %preempt_offset.addr = alloca i32, align 4
  store i8* %file, i8** %file.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  store i32 %preempt_offset, i32* %preempt_offset.addr, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @_cond_resched() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__bpf_call_base(i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %1 = bitcast %struct.bpf_prog* %0 to i8*
  call void @set_vm_flush_reset_perms(i8* noundef %1) #8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %3 = ptrtoint %struct.bpf_prog* %2 to i64
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %pages = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 0
  %5 = load i16, i16* %pages, align 8
  %conv = zext i16 %5 to i32
  %call = call i32 @set_memory_ro(i64 noundef %3, i32 noundef %conv) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_free_unused_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_jit_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %0) #8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_free_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @__bpf_prog_free(%struct.bpf_prog* noundef %0) #8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_prog_free(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @set_vm_flush_reset_perms(i8* noundef %addr) #0 {
entry:
  %addr.addr = alloca i8*, align 8
  %vm = alloca %struct.vm_struct*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8*, i8** %addr.addr, align 8
  %call = call %struct.vm_struct* @find_vm_area(i8* noundef %0) #8
  store %struct.vm_struct* %call, %struct.vm_struct** %vm, align 8
  %1 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %tobool = icmp ne %struct.vm_struct* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %flags = getelementptr inbounds %struct.vm_struct, %struct.vm_struct* %2, i32 0, i32 3
  %3 = load i64, i64* %flags, align 8
  %or = or i64 %3, 256
  store i64 %or, i64* %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @set_memory_ro(i64 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.vm_struct* @find_vm_area(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_no_def(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %class, align 1
  %2 = load i8, i8* %class, align 1
  %conv2 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv2, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8, i8* %class, align 1
  %conv4 = zext i8 %3 to i32
  %cmp5 = icmp eq i32 %conv4, 6
  br i1 %cmp5, label %lor.end, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %4 = load i8, i8* %class, align 1
  %conv8 = zext i8 %4 to i32
  %cmp9 = icmp eq i32 %conv8, 3
  br i1 %cmp9, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false7
  %5 = load i8, i8* %class, align 1
  %conv11 = zext i8 %5 to i32
  %cmp12 = icmp eq i32 %conv11, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false7, %lor.lhs.false, %entry
  %6 = phi i1 [ true, %lor.lhs.false7 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp12, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %regno, %struct.bpf_reg_state* noundef %reg, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regno.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %t.addr = alloca i32, align 4
  %code = alloca i8, align 1
  %class = alloca i8, align 1
  %op = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code1, align 4
  store i8 %1, i8* %code, align 1
  %2 = load i8, i8* %code, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %class, align 1
  %3 = load i8, i8* %code, align 1
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %op, align 1
  %4 = load i8, i8* %class, align 1
  %conv6 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv6, 5
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  %5 = load i8, i8* %op, align 1
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 144
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load i8, i8* %op, align 1
  %conv12 = zext i8 %6 to i32
  %cmp13 = icmp eq i32 %conv12, 128
  br i1 %cmp13, label %if.then15, label %if.end25

if.then15:                                        ; preds = %if.end
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv16 = zext i8 %bf.lshr to i32
  %cmp17 = icmp eq i32 %conv16, 1
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then15
  store i1 false, i1* %retval, align 1
  br label %return

if.end20:                                         ; preds = %if.then15
  %8 = load i32, i32* %t.addr, align 4
  %cmp21 = icmp eq i32 %8, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store i1 true, i1* %retval, align 1
  br label %return

if.end24:                                         ; preds = %if.end20
  store i1 false, i1* %retval, align 1
  br label %return

if.end25:                                         ; preds = %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %9 = load i8, i8* %class, align 1
  %conv27 = zext i8 %9 to i32
  %cmp28 = icmp eq i32 %conv27, 7
  br i1 %cmp28, label %if.then43, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end26
  %10 = load i8, i8* %class, align 1
  %conv30 = zext i8 %10 to i32
  %cmp31 = icmp eq i32 %conv30, 5
  br i1 %cmp31, label %if.then43, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %11 = load i8, i8* %class, align 1
  %conv34 = zext i8 %11 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  br i1 %cmp35, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %lor.lhs.false33
  %12 = load i8, i8* %op, align 1
  %conv37 = zext i8 %12 to i32
  %cmp38 = icmp eq i32 %conv37, 208
  br i1 %cmp38, label %land.lhs.true40, label %if.end44

land.lhs.true40:                                  ; preds = %land.lhs.true
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm, align 4
  %cmp41 = icmp eq i32 %14, 64
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true40, %lor.lhs.false, %if.end26
  store i1 true, i1* %retval, align 1
  br label %return

if.end44:                                         ; preds = %land.lhs.true40, %land.lhs.true, %lor.lhs.false33
  %15 = load i8, i8* %class, align 1
  %conv45 = zext i8 %15 to i32
  %cmp46 = icmp eq i32 %conv45, 4
  br i1 %cmp46, label %if.then52, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.end44
  %16 = load i8, i8* %class, align 1
  %conv49 = zext i8 %16 to i32
  %cmp50 = icmp eq i32 %conv49, 6
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %lor.lhs.false48, %if.end44
  store i1 false, i1* %retval, align 1
  br label %return

if.end53:                                         ; preds = %lor.lhs.false48
  %17 = load i8, i8* %class, align 1
  %conv54 = zext i8 %17 to i32
  %cmp55 = icmp eq i32 %conv54, 1
  br i1 %cmp55, label %if.then57, label %if.end66

if.then57:                                        ; preds = %if.end53
  %18 = load i32, i32* %t.addr, align 4
  %cmp58 = icmp ne i32 %18, 0
  br i1 %cmp58, label %if.then60, label %if.end65

if.then60:                                        ; preds = %if.then57
  %19 = load i8, i8* %code, align 1
  %conv61 = zext i8 %19 to i32
  %and62 = and i32 %conv61, 24
  %cmp63 = icmp eq i32 %and62, 24
  store i1 %cmp63, i1* %retval, align 1
  br label %return

if.end65:                                         ; preds = %if.then57
  store i1 true, i1* %retval, align 1
  br label %return

if.end66:                                         ; preds = %if.end53
  %20 = load i8, i8* %class, align 1
  %conv67 = zext i8 %20 to i32
  %cmp68 = icmp eq i32 %conv67, 3
  br i1 %cmp68, label %if.then70, label %if.end79

if.then70:                                        ; preds = %if.end66
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type, align 8
  %cmp71 = icmp ne i32 %22, 1
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.then70
  store i1 true, i1* %retval, align 1
  br label %return

if.end74:                                         ; preds = %if.then70
  %23 = load i8, i8* %code, align 1
  %conv75 = zext i8 %23 to i32
  %and76 = and i32 %conv75, 24
  %cmp77 = icmp eq i32 %and76, 24
  store i1 %cmp77, i1* %retval, align 1
  br label %return

if.end79:                                         ; preds = %if.end66
  %24 = load i8, i8* %class, align 1
  %conv80 = zext i8 %24 to i32
  %cmp81 = icmp eq i32 %conv80, 0
  br i1 %cmp81, label %if.then83, label %if.end100

if.then83:                                        ; preds = %if.end79
  %25 = load i8, i8* %code, align 1
  %conv84 = zext i8 %25 to i32
  %and85 = and i32 %conv84, 224
  %conv86 = trunc i32 %and85 to i8
  store i8 %conv86, i8* %mode, align 1
  %26 = load i8, i8* %mode, align 1
  %conv87 = zext i8 %26 to i32
  %cmp88 = icmp eq i32 %conv87, 0
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.then83
  store i1 true, i1* %retval, align 1
  br label %return

if.end91:                                         ; preds = %if.then83
  %27 = load i32, i32* %t.addr, align 4
  %cmp92 = icmp ne i32 %27, 0
  br i1 %cmp92, label %if.then94, label %if.end95

if.then94:                                        ; preds = %if.end91
  store i1 false, i1* %retval, align 1
  br label %return

if.end95:                                         ; preds = %if.end91
  %28 = load i32, i32* %regno.addr, align 4
  %cmp96 = icmp eq i32 %28, 6
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end95
  store i1 true, i1* %retval, align 1
  br label %return

if.end99:                                         ; preds = %if.end95
  store i1 true, i1* %retval, align 1
  br label %return

if.end100:                                        ; preds = %if.end79
  %29 = load i8, i8* %class, align 1
  %conv101 = zext i8 %29 to i32
  %cmp102 = icmp eq i32 %conv101, 2
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end100
  store i1 true, i1* %retval, align 1
  br label %return

if.end105:                                        ; preds = %if.end100
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end105, %if.then104, %if.end99, %if.then98, %if.then94, %if.then90, %if.end74, %if.then73, %if.end65, %if.then60, %if.then52, %if.then43, %if.end24, %if.then23, %if.then19, %if.then11
  %30 = load i1, i1* %retval, align 1
  ret i1 %30
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_random_int() #0 {
entry:
  %call = call i32 @get_random_u32() #8
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, %struct.bpf_insn* noundef %patch, i32 noundef %len) #0 {
entry:
  %retval = alloca %struct.bpf_prog*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %patch.addr = alloca %struct.bpf_insn*, align 8
  %len.addr = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store %struct.bpf_insn* %patch, %struct.bpf_insn** %patch.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = load i32, i32* %off.addr, align 4
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %patch.addr, align 8
  %4 = load i32, i32* %len.addr, align 4
  %call = call %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef %1, i32 noundef %2, %struct.bpf_insn* noundef %3, i32 noundef %4) #8
  store %struct.bpf_prog* %call, %struct.bpf_prog** %new_prog, align 8
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %6 = bitcast %struct.bpf_prog* %5 to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* noundef %6) #8
  br i1 %call1, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %8 = bitcast %struct.bpf_prog* %7 to i8*
  %call2 = call i64 @PTR_ERR(i8* noundef %8) #8
  %cmp = icmp eq i64 %call2, -34
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 16
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %13 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  %14 = load i32, i32* %orig_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.285, i64 0, i64 0), i32 noundef %14) #8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %len.addr, align 4
  %call5 = call i32 @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %15, %struct.bpf_prog* noundef %16, i32 noundef %17, i32 noundef %18) #8
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %len.addr, align 4
  call void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %19, i32 noundef %20, i32 noundef %21) #8
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %22, %struct.bpf_prog** %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.end
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %retval, align 8
  ret %struct.bpf_prog* %23
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef, i32 noundef, %struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @IS_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %2 = inttoptr i64 %1 to i8*
  %3 = ptrtoint i8* %2 to i64
  %cmp = icmp uge i64 %3, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @PTR_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  ret i64 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_prog* noundef %new_prog, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %new_prog.addr = alloca %struct.bpf_prog*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %new_data = alloca %struct.bpf_insn_aux_data*, align 8
  %old_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %prog_len = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_prog* %new_prog, %struct.bpf_prog** %new_prog.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %old_data, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %3 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %6 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %6 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %5, i64 %idx.ext
  %7 = load i32, i32* %cnt.addr, align 4
  %idx.ext1 = zext i32 %7 to i64
  %add.ptr2 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext1
  %add.ptr3 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr2, i64 -1
  %call = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %4, %struct.bpf_insn* noundef %add.ptr3) #8
  %8 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %9 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %8, i64 %idxprom
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %zext_dst, align 1
  %10 = load i32, i32* %cnt.addr, align 4
  %cmp = icmp eq i32 %10, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %11, i32 0, i32 4
  %12 = load i32, i32* %len, align 4
  store i32 %12, i32* %prog_len, align 4
  %13 = load i32, i32* %prog_len, align 4
  %conv = zext i32 %13 to i64
  %call4 = call i64 @array_size(i64 noundef %conv, i64 noundef 24) #8
  %call5 = call i8* @vzalloc(i64 noundef %call4) #8
  %14 = bitcast i8* %call5 to %struct.bpf_insn_aux_data*
  store %struct.bpf_insn_aux_data* %14, %struct.bpf_insn_aux_data** %new_data, align 8
  %15 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %tobool = icmp ne %struct.bpf_insn_aux_data* %15, null
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %16 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %17 = bitcast %struct.bpf_insn_aux_data* %16 to i8*
  %18 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %19 = bitcast %struct.bpf_insn_aux_data* %18 to i8*
  %20 = load i32, i32* %off.addr, align 4
  %conv8 = zext i32 %20 to i64
  %mul = mul i64 24, %conv8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %19, i64 %mul, i1 false)
  %21 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %22 = load i32, i32* %off.addr, align 4
  %idx.ext9 = zext i32 %22 to i64
  %add.ptr10 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %21, i64 %idx.ext9
  %23 = load i32, i32* %cnt.addr, align 4
  %idx.ext11 = zext i32 %23 to i64
  %add.ptr12 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr10, i64 %idx.ext11
  %add.ptr13 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr12, i64 -1
  %24 = bitcast %struct.bpf_insn_aux_data* %add.ptr13 to i8*
  %25 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %26 = load i32, i32* %off.addr, align 4
  %idx.ext14 = zext i32 %26 to i64
  %add.ptr15 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %25, i64 %idx.ext14
  %27 = bitcast %struct.bpf_insn_aux_data* %add.ptr15 to i8*
  %28 = load i32, i32* %prog_len, align 4
  %29 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %28, %29
  %30 = load i32, i32* %cnt.addr, align 4
  %sub16 = sub i32 %sub, %30
  %add = add i32 %sub16, 1
  %conv17 = zext i32 %add to i64
  %mul18 = mul i64 24, %conv17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %27, i64 %mul18, i1 false)
  %31 = load i32, i32* %off.addr, align 4
  store i32 %31, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %32 = load i32, i32* %i, align 4
  %33 = load i32, i32* %off.addr, align 4
  %34 = load i32, i32* %cnt.addr, align 4
  %add19 = add i32 %33, %34
  %sub20 = sub i32 %add19, 1
  %cmp21 = icmp ult i32 %32, %sub20
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %36 to i64
  %arrayidx24 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %35, i64 %idxprom23
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx24, i32 0, i32 3
  store i8 1, i8* %seen, align 8
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %39 = load i32, i32* %i, align 4
  %idx.ext25 = sext i32 %39 to i64
  %add.ptr26 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %38, i64 %idx.ext25
  %call27 = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %37, %struct.bpf_insn* noundef %add.ptr26) #8
  %40 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %41 = load i32, i32* %i, align 4
  %idxprom28 = sext i32 %41 to i64
  %arrayidx29 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %40, i64 %idxprom28
  %zext_dst30 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx29, i32 0, i32 4
  %frombool31 = zext i1 %call27 to i8
  store i8 %frombool31, i8* %zext_dst30, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %42 = load i32, i32* %i, align 4
  %inc = add i32 %42, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %43 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data32 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 16
  store %struct.bpf_insn_aux_data* %43, %struct.bpf_insn_aux_data** %insn_aux_data32, align 8
  %45 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %46 = bitcast %struct.bpf_insn_aux_data* %45 to i8*
  call void @vfree(i8* noundef %46) #8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then6, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %len) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 21
  %3 = load i32, i32* %subprog_cnt, align 8
  %cmp1 = icmp ule i32 %1, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 19
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %6 = load i32, i32* %start, align 4
  %7 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp ule i32 %6, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %8 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %8, 1
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 19
  %10 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info5, i64 0, i64 %idxprom6
  %start8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %11 = load i32, i32* %start8, align 4
  %add = add i32 %11, %sub
  store i32 %add, i32* %start8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end4, %if.then3
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call = call zeroext i1 @insn_no_def(%struct.bpf_insn* noundef %0) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  %call1 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %1, %struct.bpf_insn* noundef %2, i32 noundef %conv, %struct.bpf_reg_state* noundef null, i32 noundef 1) #8
  %lnot = xor i1 %call1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i1, i1* %retval, align 1
  ret i1 %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_random_u32() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_user_rnd_init_once() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_state = bitcast %union.anon.13* %1 to i64*
  %2 = load i64, i64* %map_state, align 8
  %and = and i64 %2, 1
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_state = bitcast %union.anon.13* %1 to i64*
  %2 = load i64, i64* %map_state, align 8
  %and = and i64 %2, -2
  %3 = inttoptr i64 %and to %struct.bpf_map*
  %cmp = icmp eq %struct.bpf_map* %3, inttoptr (i64 -2401263026318485698 to %struct.bpf_map*)
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @func_id_name(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_tcp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_xdp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_ctx_off_adjust_machine(i32 noundef %size) #0 {
entry:
  %size.addr = alloca i32, align 4
  %size_machine = alloca i32, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 8, i32* %size_machine, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp ugt i32 %0, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %rem = urem i32 %1, 8
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 8, i32* %size.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, i32* %size.addr, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %off, i32 noundef %size, i32 noundef %size_default) #0 {
entry:
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %size_default.addr = alloca i32, align 4
  %access_off = alloca i8, align 1
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %size_default, i32* %size_default.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %1 = load i32, i32* %size_default.addr, align 4
  %sub = sub i32 %1, 1
  %and = and i32 %0, %sub
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %access_off, align 1
  %2 = load i8, i8* %access_off, align 1
  ret i8 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @memcmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %orig_prog_len = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %orig_prog_len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %7) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %10 = load i32, i32* %cnt.addr, align 4
  call void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef %8, i32 noundef %9, i32 noundef %10) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 2
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %cnt.addr, align 4
  %call3 = call i32 @bpf_remove_insns(%struct.bpf_prog* noundef %12, i32 noundef %13, i32 noundef %14) #8
  store i32 %call3, i32* %err, align 4
  %15 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %16 = load i32, i32* %err, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %off.addr, align 4
  %19 = load i32, i32* %cnt.addr, align 4
  %call6 = call i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #8
  store i32 %call6, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool7 = icmp ne i32 %20, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load i32, i32* %off.addr, align 4
  %24 = load i32, i32* %cnt.addr, align 4
  %call10 = call i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %22, i32 noundef %23, i32 noundef %24) #8
  store i32 %call10, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %25, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  %26 = load i32, i32* %err, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %28 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idx.ext
  %29 = bitcast %struct.bpf_insn_aux_data* %add.ptr to i8*
  %30 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %31 = load i32, i32* %off.addr, align 4
  %idx.ext14 = zext i32 %31 to i64
  %add.ptr15 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %30, i64 %idx.ext14
  %32 = load i32, i32* %cnt.addr, align 4
  %idx.ext16 = zext i32 %32 to i64
  %add.ptr17 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr15, i64 %idx.ext16
  %33 = bitcast %struct.bpf_insn_aux_data* %add.ptr17 to i8*
  %34 = load i32, i32* %orig_prog_len, align 4
  %35 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %34, %35
  %36 = load i32, i32* %cnt.addr, align 4
  %sub18 = sub i32 %sub, %36
  %conv = zext i32 %sub18 to i64
  %mul = mul i64 24, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %33, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then8, %if.then4
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_remove_insns(%struct.bpf_prog* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %move = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 21
  %2 = load i32, i32* %subprog_cnt, align 8
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 19
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %5 = load i32, i32* %start, align 4
  %6 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp uge i32 %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %8 = load i32, i32* %i, align 4
  store i32 %8, i32* %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc13, %for.end
  %9 = load i32, i32* %j, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 21
  %11 = load i32, i32* %subprog_cnt3, align 8
  %cmp4 = icmp ult i32 %9, %11
  br i1 %cmp4, label %for.body5, label %for.end15

for.body5:                                        ; preds = %for.cond2
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 19
  %13 = load i32, i32* %j, align 4
  %idxprom7 = sext i32 %13 to i64
  %arrayidx8 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info6, i64 0, i64 %idxprom7
  %start9 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx8, i32 0, i32 0
  %14 = load i32, i32* %start9, align 4
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %15, %16
  %cmp10 = icmp uge i32 %14, %add
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body5
  br label %for.end15

if.end12:                                         ; preds = %for.body5
  br label %for.inc13

for.inc13:                                        ; preds = %if.end12
  %17 = load i32, i32* %j, align 4
  %inc14 = add i32 %17, 1
  store i32 %inc14, i32* %j, align 4
  br label %for.cond2

for.end15:                                        ; preds = %if.then11, %for.cond2
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 19
  %19 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %19 to i64
  %arrayidx18 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info16, i64 0, i64 %idxprom17
  %start19 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx18, i32 0, i32 0
  %20 = load i32, i32* %start19, align 4
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %cnt.addr, align 4
  %add20 = add i32 %21, %22
  %cmp21 = icmp ne i32 %20, %add20
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.end15
  %23 = load i32, i32* %j, align 4
  %dec = add i32 %23, -1
  store i32 %dec, i32* %j, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %for.end15
  %24 = load i32, i32* %j, align 4
  %25 = load i32, i32* %i, align 4
  %cmp24 = icmp sgt i32 %24, %25
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end23
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 2
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 7
  %28 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux26, align 8
  store %struct.bpf_prog_aux* %28, %struct.bpf_prog_aux** %aux, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 21
  %30 = load i32, i32* %subprog_cnt27, align 8
  %add28 = add i32 %30, 1
  %31 = load i32, i32* %j, align 4
  %sub = sub i32 %add28, %31
  store i32 %sub, i32* %move, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 19
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info29, i64 0, i64 0
  %33 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %33 to i64
  %add.ptr = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay, i64 %idx.ext
  %34 = bitcast %struct.bpf_subprog_info* %add.ptr to i8*
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 19
  %arraydecay31 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info30, i64 0, i64 0
  %36 = load i32, i32* %j, align 4
  %idx.ext32 = sext i32 %36 to i64
  %add.ptr33 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay31, i64 %idx.ext32
  %37 = bitcast %struct.bpf_subprog_info* %add.ptr33 to i8*
  %38 = load i32, i32* %move, align 4
  %conv = sext i32 %38 to i64
  %mul = mul i64 12, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %34, i8* align 4 %37, i64 %mul, i1 false)
  %39 = load i32, i32* %j, align 4
  %40 = load i32, i32* %i, align 4
  %sub34 = sub i32 %39, %40
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt35 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 21
  %42 = load i32, i32* %subprog_cnt35, align 8
  %sub36 = sub i32 %42, %sub34
  store i32 %sub36, i32* %subprog_cnt35, align 8
  %43 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %43, i32 0, i32 25
  %44 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %tobool = icmp ne %struct.util_est* %44, null
  br i1 %tobool, label %if.then37, label %if.end50

if.then37:                                        ; preds = %if.then25
  %45 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %45, i32 0, i32 28
  %46 = load i32, i32* %func_info_cnt, align 8
  %47 = load i32, i32* %j, align 4
  %sub38 = sub i32 %46, %47
  store i32 %sub38, i32* %move, align 4
  %48 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info39 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %48, i32 0, i32 25
  %49 = load %struct.util_est*, %struct.util_est** %func_info39, align 8
  %50 = load i32, i32* %i, align 4
  %idx.ext40 = sext i32 %50 to i64
  %add.ptr41 = getelementptr %struct.util_est, %struct.util_est* %49, i64 %idx.ext40
  %51 = bitcast %struct.util_est* %add.ptr41 to i8*
  %52 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %52, i32 0, i32 25
  %53 = load %struct.util_est*, %struct.util_est** %func_info42, align 8
  %54 = load i32, i32* %j, align 4
  %idx.ext43 = sext i32 %54 to i64
  %add.ptr44 = getelementptr %struct.util_est, %struct.util_est* %53, i64 %idx.ext43
  %55 = bitcast %struct.util_est* %add.ptr44 to i8*
  %56 = load i32, i32* %move, align 4
  %conv45 = sext i32 %56 to i64
  %mul46 = mul i64 8, %conv45
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %51, i8* align 4 %55, i64 %mul46, i1 false)
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* %i, align 4
  %sub47 = sub i32 %57, %58
  %59 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt48 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %59, i32 0, i32 28
  %60 = load i32, i32* %func_info_cnt48, align 8
  %sub49 = sub i32 %60, %sub47
  store i32 %sub49, i32* %func_info_cnt48, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then37, %if.then25
  br label %if.end60

if.else:                                          ; preds = %if.end23
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 19
  %62 = load i32, i32* %i, align 4
  %idxprom52 = sext i32 %62 to i64
  %arrayidx53 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info51, i64 0, i64 %idxprom52
  %start54 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx53, i32 0, i32 0
  %63 = load i32, i32* %start54, align 4
  %64 = load i32, i32* %off.addr, align 4
  %cmp55 = icmp eq i32 %63, %64
  br i1 %cmp55, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.else
  %65 = load i32, i32* %i, align 4
  %inc58 = add i32 %65, 1
  store i32 %inc58, i32* %i, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.else
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end50
  br label %for.cond61

for.cond61:                                       ; preds = %for.inc71, %if.end60
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 21
  %68 = load i32, i32* %subprog_cnt62, align 8
  %cmp63 = icmp ule i32 %66, %68
  br i1 %cmp63, label %for.body65, label %for.end73

for.body65:                                       ; preds = %for.cond61
  %69 = load i32, i32* %cnt.addr, align 4
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info66 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 19
  %71 = load i32, i32* %i, align 4
  %idxprom67 = sext i32 %71 to i64
  %arrayidx68 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info66, i64 0, i64 %idxprom67
  %start69 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx68, i32 0, i32 0
  %72 = load i32, i32* %start69, align 4
  %sub70 = sub i32 %72, %69
  store i32 %sub70, i32* %start69, align 4
  br label %for.inc71

for.inc71:                                        ; preds = %for.body65
  %73 = load i32, i32* %i, align 4
  %inc72 = add i32 %73, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond61

for.end73:                                        ; preds = %for.cond61
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %l_off = alloca i32, align 4
  %l_cnt = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 7
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 29
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 26
  %8 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo4, align 8
  store %struct.ethtool_pauseparam* %8, %struct.ethtool_pauseparam** %linfo, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %nr_linfo, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %11, i64 %idxprom
  %insn_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx, i32 0, i32 0
  %13 = load i32, i32* %insn_off, align 4
  %14 = load i32, i32* %off.addr, align 4
  %cmp5 = icmp uge i32 %13, %14
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.end

if.end7:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then6, %for.cond
  %16 = load i32, i32* %i, align 4
  store i32 %16, i32* %l_off, align 4
  store i32 0, i32* %l_cnt, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc18, %for.end
  %17 = load i32, i32* %i, align 4
  %18 = load i32, i32* %nr_linfo, align 4
  %cmp9 = icmp ult i32 %17, %18
  br i1 %cmp9, label %for.body10, label %for.end20

for.body10:                                       ; preds = %for.cond8
  %19 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %20 to i64
  %arrayidx12 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %19, i64 %idxprom11
  %insn_off13 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx12, i32 0, i32 0
  %21 = load i32, i32* %insn_off13, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %22, %23
  %cmp14 = icmp ult i32 %21, %add
  br i1 %cmp14, label %if.then15, label %if.else

if.then15:                                        ; preds = %for.body10
  %24 = load i32, i32* %l_cnt, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, i32* %l_cnt, align 4
  br label %if.end17

if.else:                                          ; preds = %for.body10
  br label %for.end20

if.end17:                                         ; preds = %if.then15
  br label %for.inc18

for.inc18:                                        ; preds = %if.end17
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  br label %for.cond8

for.end20:                                        ; preds = %if.else, %for.cond8
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %26, i32 0, i32 4
  %27 = load i32, i32* %len, align 4
  %28 = load i32, i32* %off.addr, align 4
  %cmp21 = icmp ne i32 %27, %28
  br i1 %cmp21, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %for.end20
  %29 = load i32, i32* %l_cnt, align 4
  %tobool22 = icmp ne i32 %29, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end36

land.lhs.true23:                                  ; preds = %land.lhs.true
  %30 = load i32, i32* %i, align 4
  %31 = load i32, i32* %nr_linfo, align 4
  %cmp24 = icmp eq i32 %30, %31
  br i1 %cmp24, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %32 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom25 = zext i32 %33 to i64
  %arrayidx26 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %32, i64 %idxprom25
  %insn_off27 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx26, i32 0, i32 0
  %34 = load i32, i32* %insn_off27, align 4
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %cnt.addr, align 4
  %add28 = add i32 %35, %36
  %cmp29 = icmp ne i32 %34, %add28
  br i1 %cmp29, label %if.then30, label %if.end36

if.then30:                                        ; preds = %lor.lhs.false, %land.lhs.true23
  %37 = load i32, i32* %l_cnt, align 4
  %dec = add i32 %37, -1
  store i32 %dec, i32* %l_cnt, align 4
  %38 = load i32, i32* %off.addr, align 4
  %39 = load i32, i32* %cnt.addr, align 4
  %add31 = add i32 %38, %39
  %40 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %41 = load i32, i32* %i, align 4
  %dec32 = add i32 %41, -1
  store i32 %dec32, i32* %i, align 4
  %idxprom33 = zext i32 %dec32 to i64
  %arrayidx34 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %40, i64 %idxprom33
  %insn_off35 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx34, i32 0, i32 0
  store i32 %add31, i32* %insn_off35, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then30, %lor.lhs.false, %land.lhs.true, %for.end20
  %42 = load i32, i32* %l_cnt, align 4
  %tobool37 = icmp ne i32 %42, 0
  br i1 %tobool37, label %if.then38, label %if.end46

if.then38:                                        ; preds = %if.end36
  %43 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %44 = load i32, i32* %l_off, align 4
  %idx.ext = zext i32 %44 to i64
  %add.ptr = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %43, i64 %idx.ext
  %45 = bitcast %struct.ethtool_pauseparam* %add.ptr to i8*
  %46 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %47 = load i32, i32* %i, align 4
  %idx.ext39 = zext i32 %47 to i64
  %add.ptr40 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %46, i64 %idx.ext39
  %48 = bitcast %struct.ethtool_pauseparam* %add.ptr40 to i8*
  %49 = load i32, i32* %nr_linfo, align 4
  %50 = load i32, i32* %i, align 4
  %sub = sub i32 %49, %50
  %conv = zext i32 %sub to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %45, i8* align 4 %48, i64 %mul, i1 false)
  %51 = load i32, i32* %l_cnt, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux41 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 7
  %53 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux41, align 8
  %nr_linfo42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %53, i32 0, i32 29
  %54 = load i32, i32* %nr_linfo42, align 4
  %sub43 = sub i32 %54, %51
  store i32 %sub43, i32* %nr_linfo42, align 4
  %55 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %55, i32 0, i32 7
  %56 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux44, align 8
  %nr_linfo45 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %56, i32 0, i32 29
  %57 = load i32, i32* %nr_linfo45, align 4
  store i32 %57, i32* %nr_linfo, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then38, %if.end36
  %58 = load i32, i32* %l_off, align 4
  store i32 %58, i32* %i, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc55, %if.end46
  %59 = load i32, i32* %i, align 4
  %60 = load i32, i32* %nr_linfo, align 4
  %cmp48 = icmp ult i32 %59, %60
  br i1 %cmp48, label %for.body50, label %for.end57

for.body50:                                       ; preds = %for.cond47
  %61 = load i32, i32* %cnt.addr, align 4
  %62 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %63 = load i32, i32* %i, align 4
  %idxprom51 = zext i32 %63 to i64
  %arrayidx52 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %62, i64 %idxprom51
  %insn_off53 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx52, i32 0, i32 0
  %64 = load i32, i32* %insn_off53, align 4
  %sub54 = sub i32 %64, %61
  store i32 %sub54, i32* %insn_off53, align 4
  br label %for.inc55

for.inc55:                                        ; preds = %for.body50
  %65 = load i32, i32* %i, align 4
  %inc56 = add i32 %65, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond47

for.end57:                                        ; preds = %for.cond47
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc87, %for.end57
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 21
  %68 = load i32, i32* %subprog_cnt, align 8
  %cmp59 = icmp ule i32 %66, %68
  br i1 %cmp59, label %for.body61, label %for.end89

for.body61:                                       ; preds = %for.cond58
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 19
  %70 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %70 to i64
  %arrayidx63 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom62
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx63, i32 0, i32 1
  %71 = load i32, i32* %linfo_idx, align 4
  %72 = load i32, i32* %l_off, align 4
  %cmp64 = icmp ugt i32 %71, %72
  br i1 %cmp64, label %if.then66, label %if.end86

if.then66:                                        ; preds = %for.body61
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info67 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 19
  %74 = load i32, i32* %i, align 4
  %idxprom68 = zext i32 %74 to i64
  %arrayidx69 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info67, i64 0, i64 %idxprom68
  %linfo_idx70 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx69, i32 0, i32 1
  %75 = load i32, i32* %linfo_idx70, align 4
  %76 = load i32, i32* %l_off, align 4
  %77 = load i32, i32* %l_cnt, align 4
  %add71 = add i32 %76, %77
  %cmp72 = icmp uge i32 %75, %add71
  br i1 %cmp72, label %if.then74, label %if.else80

if.then74:                                        ; preds = %if.then66
  %78 = load i32, i32* %l_cnt, align 4
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 19
  %80 = load i32, i32* %i, align 4
  %idxprom76 = zext i32 %80 to i64
  %arrayidx77 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info75, i64 0, i64 %idxprom76
  %linfo_idx78 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx77, i32 0, i32 1
  %81 = load i32, i32* %linfo_idx78, align 4
  %sub79 = sub i32 %81, %78
  store i32 %sub79, i32* %linfo_idx78, align 4
  br label %if.end85

if.else80:                                        ; preds = %if.then66
  %82 = load i32, i32* %l_off, align 4
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 19
  %84 = load i32, i32* %i, align 4
  %idxprom82 = zext i32 %84 to i64
  %arrayidx83 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info81, i64 0, i64 %idxprom82
  %linfo_idx84 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx83, i32 0, i32 1
  store i32 %82, i32* %linfo_idx84, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.else80, %if.then74
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %for.body61
  br label %for.inc87

for.inc87:                                        ; preds = %if.end86
  %85 = load i32, i32* %i, align 4
  %inc88 = add i32 %85, 1
  store i32 %inc88, i32* %i, align 4
  br label %for.cond58

for.end89:                                        ; preds = %for.cond58
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end89, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #2

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %code) #0 {
entry:
  %retval = alloca i1, align 1
  %code.addr = alloca i8, align 1
  %op = alloca i8, align 1
  store i8 %code, i8* %code.addr, align 1
  %0 = load i8, i8* %code.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  %cmp = icmp eq i32 %and, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %code.addr, align 1
  %conv2 = zext i8 %1 to i32
  %and3 = and i32 %conv2, 7
  %cmp4 = icmp ne i32 %and3, 5
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  %2 = load i8, i8* %code.addr, align 1
  %conv8 = zext i8 %2 to i32
  %and9 = and i32 %conv8, 240
  %conv10 = trunc i32 %and9 to i8
  store i8 %conv10, i8* %op, align 1
  %3 = load i8, i8* %op, align 1
  %conv11 = zext i8 %3 to i32
  %cmp12 = icmp ne i32 %conv11, 0
  br i1 %cmp12, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end7
  %4 = load i8, i8* %op, align 1
  %conv14 = zext i8 %4 to i32
  %cmp15 = icmp ne i32 %conv14, 144
  br i1 %cmp15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load i8, i8* %op, align 1
  %conv17 = zext i8 %5 to i32
  %cmp18 = icmp ne i32 %conv17, 128
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.end7
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %if.end7 ], [ %cmp18, %land.rhs ]
  store i1 %6, i1* %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then6, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_insn* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kvfree(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %dst_state, %struct.bpf_verifier_state* noundef %src) #0 {
entry:
  %retval.i68 = alloca i32, align 4
  %flags.addr.i69 = alloca i32, align 4
  %retval.i61 = alloca i32, align 4
  %size.addr.i62 = alloca i64, align 8
  %size.addr.i58 = alloca i64, align 8
  %flags.addr.i59 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %dst_state.addr = alloca %struct.bpf_verifier_state*, align 8
  %src.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst = alloca %struct.bpf_func_state*, align 8
  %jmp_sz = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_state* %dst_state, %struct.bpf_verifier_state** %dst_state.addr, align 8
  store %struct.bpf_verifier_state* %src, %struct.bpf_verifier_state** %src.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 10
  %1 = load i32, i32* %jmp_history_cnt, align 8
  %conv = zext i32 %1 to i64
  %mul = mul i64 8, %conv
  %conv1 = trunc i64 %mul to i32
  store i32 %conv1, i32* %jmp_sz, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history_cnt2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 10
  %3 = load i32, i32* %jmp_history_cnt2, align 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 10
  %5 = load i32, i32* %jmp_history_cnt3, align 8
  %cmp = icmp ult i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 9
  %7 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %8 = bitcast %struct.util_est* %7 to i8*
  call void @kfree(i8* noundef %8) #8
  %9 = load i32, i32* %jmp_sz, align 4
  %conv5 = zext i32 %9 to i64
  store i64 %conv5, i64* %size.addr.i, align 8
  store i32 1051840, i32* %flags.addr.i, align 4
  %10 = load i64, i64* %size.addr.i, align 8
  %11 = call i1 @llvm.is.constant.i64(i64 %10) #9
  br i1 %11, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %if.then
  %12 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %12, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %13 = load i64, i64* %size.addr.i, align 8
  %14 = load i32, i32* %flags.addr.i, align 4
  store i64 %13, i64* %size.addr.i58, align 8
  store i32 %14, i32* %flags.addr.i59, align 4
  %15 = load i64, i64* %size.addr.i58, align 8
  %call.i60 = call i32 @get_order(i64 noundef %15) #11
  store i32 %call.i60, i32* %order.i, align 4
  %16 = load i64, i64* %size.addr.i58, align 8
  %17 = load i32, i32* %flags.addr.i59, align 4
  %18 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %16, i32 noundef %17, i32 noundef %18) #10
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %19 = load i64, i64* %size.addr.i, align 8
  store i64 %19, i64* %size.addr.i62, align 8
  %20 = load i64, i64* %size.addr.i62, align 8
  %tobool.i63 = icmp ne i64 %20, 0
  br i1 %tobool.i63, label %if.end.i66, label %if.then.i64

if.then.i64:                                      ; preds = %if.end.i
  store i32 0, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end.i66:                                       ; preds = %if.end.i
  %21 = load i64, i64* %size.addr.i62, align 8
  %cmp.i65 = icmp ule i64 %21, 8
  br i1 %cmp.i65, label %if.then1.i67, label %if.end2.i

if.then1.i67:                                     ; preds = %if.end.i66
  store i32 3, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i66
  %22 = load i64, i64* %size.addr.i62, align 8
  %cmp3.i = icmp ugt i64 %22, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %23 = load i64, i64* %size.addr.i62, align 8
  %cmp4.i = icmp ule i64 %23, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %24 = load i64, i64* %size.addr.i62, align 8
  %cmp7.i = icmp ugt i64 %24, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %25 = load i64, i64* %size.addr.i62, align 8
  %cmp9.i = icmp ule i64 %25, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %26 = load i64, i64* %size.addr.i62, align 8
  %cmp12.i = icmp ule i64 %26, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %27 = load i64, i64* %size.addr.i62, align 8
  %cmp15.i = icmp ule i64 %27, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %28 = load i64, i64* %size.addr.i62, align 8
  %cmp18.i = icmp ule i64 %28, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %29 = load i64, i64* %size.addr.i62, align 8
  %cmp21.i = icmp ule i64 %29, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %30 = load i64, i64* %size.addr.i62, align 8
  %cmp24.i = icmp ule i64 %30, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %31 = load i64, i64* %size.addr.i62, align 8
  %cmp27.i = icmp ule i64 %31, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %32 = load i64, i64* %size.addr.i62, align 8
  %cmp30.i = icmp ule i64 %32, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %33 = load i64, i64* %size.addr.i62, align 8
  %cmp33.i = icmp ule i64 %33, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %34 = load i64, i64* %size.addr.i62, align 8
  %cmp36.i = icmp ule i64 %34, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %35 = load i64, i64* %size.addr.i62, align 8
  %cmp39.i = icmp ule i64 %35, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %36 = load i64, i64* %size.addr.i62, align 8
  %cmp42.i = icmp ule i64 %36, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %37 = load i64, i64* %size.addr.i62, align 8
  %cmp45.i = icmp ule i64 %37, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %38 = load i64, i64* %size.addr.i62, align 8
  %cmp48.i = icmp ule i64 %38, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %39 = load i64, i64* %size.addr.i62, align 8
  %cmp51.i = icmp ule i64 %39, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %40 = load i64, i64* %size.addr.i62, align 8
  %cmp54.i = icmp ule i64 %40, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %41 = load i64, i64* %size.addr.i62, align 8
  %cmp57.i = icmp ule i64 %41, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %42 = load i64, i64* %size.addr.i62, align 8
  %cmp60.i = icmp ule i64 %42, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %43 = load i64, i64* %size.addr.i62, align 8
  %cmp63.i = icmp ule i64 %43, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %44 = load i64, i64* %size.addr.i62, align 8
  %cmp66.i = icmp ule i64 %44, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %45 = load i64, i64* %size.addr.i62, align 8
  %cmp69.i = icmp ule i64 %45, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %46 = load i64, i64* %size.addr.i62, align 8
  %cmp72.i = icmp ule i64 %46, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %47 = load i64, i64* %size.addr.i62, align 8
  %cmp75.i = icmp ule i64 %47, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %48 = load i64, i64* %size.addr.i62, align 8
  %cmp78.i = icmp ule i64 %48, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %49 = load i64, i64* %size.addr.i62, align 8
  %cmp81.i = icmp ule i64 %49, 67108864
  br i1 %cmp81.i, label %if.then82.i, label %if.end83.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 26, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end83.i:                                       ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i64 0, i64 0), i32 386, i32 0, i64 12) #9, !srcloc !9
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.unreachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 15) #9, !srcloc !10
  unreachable

kmalloc_index.exit:                               ; preds = %if.then82.i, %if.then79.i, %if.then76.i, %if.then73.i, %if.then70.i, %if.then67.i, %if.then64.i, %if.then61.i, %if.then58.i, %if.then55.i, %if.then52.i, %if.then49.i, %if.then46.i, %if.then43.i, %if.then40.i, %if.then37.i, %if.then34.i, %if.then31.i, %if.then28.i, %if.then25.i, %if.then22.i, %if.then19.i, %if.then16.i, %if.then13.i, %if.then10.i, %if.then5.i, %if.then1.i67, %if.then.i64
  %50 = load i32, i32* %retval.i61, align 4
  store i32 %50, i32* %index.i, align 4
  %51 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %51, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %kmalloc_index.exit
  %52 = load i32, i32* %flags.addr.i, align 4
  store i32 %52, i32* %flags.addr.i69, align 4
  %53 = load i32, i32* %flags.addr.i69, align 4
  %and.i = and i32 %53, 17
  %cmp.i70 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i70, true
  %lnot.ext.i = zext i1 %cmp.i70 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i70, label %if.then.i71, label %if.end.i72

if.then.i71:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i68, align 4
  br label %kmalloc_type.exit

if.end.i72:                                       ; preds = %if.end4.i
  %54 = load i32, i32* %flags.addr.i69, align 4
  %and2.i = and i32 %54, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  %55 = zext i1 %tobool3.i to i64
  %cond.i = select i1 %tobool3.i, i32 2, i32 1
  store i32 %cond.i, i32* %retval.i68, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.end.i72, %if.then.i71
  %56 = load i32, i32* %retval.i68, align 4
  %idxprom.i = zext i32 %56 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %57 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %57 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %58 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %59 = load i32, i32* %flags.addr.i, align 4
  %60 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %58, i32 noundef %59, i64 noundef %60) #10
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %if.then
  %61 = load i64, i64* %size.addr.i, align 8
  %62 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %61, i32 noundef %62) #10
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.end9.i, %kmalloc_type.exit, %if.then3.i, %if.then1.i
  %63 = load i8*, i8** %retval.i, align 8
  %64 = bitcast i8* %63 to %struct.util_est*
  %65 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %65, i32 0, i32 9
  store %struct.util_est* %64, %struct.util_est** %jmp_history6, align 8
  %66 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history7 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %66, i32 0, i32 9
  %67 = load %struct.util_est*, %struct.util_est** %jmp_history7, align 8
  %tobool = icmp ne %struct.util_est* %67, null
  br i1 %tobool, label %if.end, label %if.then8

if.then8:                                         ; preds = %kmalloc.exit
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %kmalloc.exit
  br label %if.end9

if.end9:                                          ; preds = %if.end, %entry
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %68, i32 0, i32 9
  %69 = load %struct.util_est*, %struct.util_est** %jmp_history10, align 8
  %70 = bitcast %struct.util_est* %69 to i8*
  %71 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %71, i32 0, i32 9
  %72 = load %struct.util_est*, %struct.util_est** %jmp_history11, align 8
  %73 = bitcast %struct.util_est* %72 to i8*
  %74 = load i32, i32* %jmp_sz, align 4
  %conv12 = zext i32 %74 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %70, i8* align 4 %73, i64 %conv12, i1 false)
  %75 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt13 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %75, i32 0, i32 10
  %76 = load i32, i32* %jmp_history_cnt13, align 8
  %77 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history_cnt14 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %77, i32 0, i32 10
  store i32 %76, i32* %jmp_history_cnt14, align 8
  %78 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %78, i32 0, i32 4
  %79 = load i32, i32* %curframe, align 8
  %add = add i32 %79, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %80 = load i32, i32* %i, align 4
  %81 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe15 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %81, i32 0, i32 4
  %82 = load i32, i32* %curframe15, align 8
  %cmp16 = icmp ule i32 %80, %82
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %83 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %83, i32 0, i32 0
  %84 = load i32, i32* %i, align 4
  %idxprom = sext i32 %84 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %85 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %85) #8
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame18 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 0
  %87 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %87 to i64
  %arrayidx20 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame18, i64 0, i64 %idxprom19
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx20, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %88 = load i32, i32* %i, align 4
  %inc = add i32 %88, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %89 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %89, i32 0, i32 6
  %90 = load i8, i8* %speculative, align 8
  %tobool21 = trunc i8 %90 to i1
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %speculative22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %91, i32 0, i32 6
  %frombool = zext i1 %tobool21 to i8
  store i8 %frombool, i8* %speculative22, align 8
  %92 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe23 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %92, i32 0, i32 4
  %93 = load i32, i32* %curframe23, align 8
  %94 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %94, i32 0, i32 4
  store i32 %93, i32* %curframe24, align 8
  %95 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %95, i32 0, i32 5
  %96 = load i32, i32* %active_spin_lock, align 4
  %97 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %active_spin_lock25 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %97, i32 0, i32 5
  store i32 %96, i32* %active_spin_lock25, align 4
  %98 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %98, i32 0, i32 2
  %99 = load i32, i32* %branches, align 8
  %100 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %branches26 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %100, i32 0, i32 2
  store i32 %99, i32* %branches26, align 8
  %101 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %101, i32 0, i32 1
  %102 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %103 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %parent27 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %103, i32 0, i32 1
  store %struct.bpf_verifier_state* %102, %struct.bpf_verifier_state** %parent27, align 8
  %104 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %104, i32 0, i32 7
  %105 = load i32, i32* %first_insn_idx, align 4
  %106 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %first_insn_idx28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %106, i32 0, i32 7
  store i32 %105, i32* %first_insn_idx28, align 4
  %107 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %107, i32 0, i32 8
  %108 = load i32, i32* %last_insn_idx, align 8
  %109 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %last_insn_idx29 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %109, i32 0, i32 8
  store i32 %108, i32* %last_insn_idx29, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond30

for.cond30:                                       ; preds = %for.inc55, %for.end
  %110 = load i32, i32* %i, align 4
  %111 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe31 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %111, i32 0, i32 4
  %112 = load i32, i32* %curframe31, align 8
  %cmp32 = icmp ule i32 %110, %112
  br i1 %cmp32, label %for.body34, label %for.end57

for.body34:                                       ; preds = %for.cond30
  %113 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame35 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %113, i32 0, i32 0
  %114 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %114 to i64
  %arrayidx37 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame35, i64 0, i64 %idxprom36
  %115 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx37, align 8
  store %struct.bpf_func_state* %115, %struct.bpf_func_state** %dst, align 8
  %116 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool38 = icmp ne %struct.bpf_func_state* %116, null
  br i1 %tobool38, label %if.end47, label %if.then39

if.then39:                                        ; preds = %for.body34
  %call40 = call i8* @kzalloc(i64 noundef 1184, i32 noundef 3264) #8
  %117 = bitcast i8* %call40 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %117, %struct.bpf_func_state** %dst, align 8
  %118 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool41 = icmp ne %struct.bpf_func_state* %118, null
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.then39
  store i32 -12, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.then39
  %119 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %120 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame44 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %120, i32 0, i32 0
  %121 = load i32, i32* %i, align 4
  %idxprom45 = sext i32 %121 to i64
  %arrayidx46 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame44, i64 0, i64 %idxprom45
  store %struct.bpf_func_state* %119, %struct.bpf_func_state** %arrayidx46, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.end43, %for.body34
  %122 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %123 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %frame48 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %123, i32 0, i32 0
  %124 = load i32, i32* %i, align 4
  %idxprom49 = sext i32 %124 to i64
  %arrayidx50 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame48, i64 0, i64 %idxprom49
  %125 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx50, align 8
  %call51 = call i32 @copy_func_state(%struct.bpf_func_state* noundef %122, %struct.bpf_func_state* noundef %125) #8
  store i32 %call51, i32* %err, align 4
  %126 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %126, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end47
  %127 = load i32, i32* %err, align 4
  store i32 %127, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end47
  br label %for.inc55

for.inc55:                                        ; preds = %if.end54
  %128 = load i32, i32* %i, align 4
  %inc56 = add i32 %128, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond30

for.end57:                                        ; preds = %for.cond30
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end57, %if.then53, %if.then42, %if.then8
  %129 = load i32, i32* %retval, align 4
  ret i32 %129
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_func_state(%struct.bpf_func_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %tobool = icmp ne %struct.bpf_func_state* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 5
  %2 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %3 = bitcast %struct.util_est* %2 to i8*
  call void @kfree(i8* noundef %3) #8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 7
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = bitcast %struct.bpf_stack_state* %5 to i8*
  call void @kfree(i8* noundef %6) #8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %8 = bitcast %struct.bpf_func_state* %7 to i8*
  call void @kfree(i8* noundef %8) #8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_func_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 6
  %2 = load i32, i32* %allocated_stack, align 8
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 4
  %4 = load i32, i32* %acquired_refs, align 4
  %call = call i32 @realloc_func_state(%struct.bpf_func_state* noundef %0, i32 noundef %2, i32 noundef %4, i1 noundef zeroext false) #8
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %8 = bitcast %struct.bpf_func_state* %7 to i8*
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %10 = bitcast %struct.bpf_func_state* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %10, i64 1156, i1 false)
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call1 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %11, %struct.bpf_func_state* noundef %12) #8
  store i32 %call1, i32* %err, align 4
  %13 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %13, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %14 = load i32, i32* %err, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call5 = call i32 @copy_stack_state(%struct.bpf_func_state* noundef %15, %struct.bpf_func_state* noundef %16) #8
  store i32 %call5, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @realloc_func_state(%struct.bpf_func_state* noundef %state, i32 noundef %stack_size, i32 noundef %refs_size, i1 noundef zeroext %copy_old) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %stack_size.addr = alloca i32, align 4
  %refs_size.addr = alloca i32, align 4
  %copy_old.addr = alloca i8, align 1
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %stack_size, i32* %stack_size.addr, align 4
  store i32 %refs_size, i32* %refs_size.addr, align 4
  %frombool = zext i1 %copy_old to i8
  store i8 %frombool, i8* %copy_old.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %1 = load i32, i32* %refs_size.addr, align 4
  %2 = load i8, i8* %copy_old.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call = call i32 @realloc_reference_state(%struct.bpf_func_state* noundef %0, i32 noundef %1, i1 noundef zeroext %tobool) #8
  store i32 %call, i32* %err, align 4
  %3 = load i32, i32* %err, align 4
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %err, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %6 = load i32, i32* %stack_size.addr, align 4
  %7 = load i8, i8* %copy_old.addr, align 1
  %tobool2 = trunc i8 %7 to i1
  %call3 = call i32 @realloc_stack_state(%struct.bpf_func_state* noundef %5, i32 noundef %6, i1 noundef zeroext %tobool2) #8
  store i32 %call3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_reference_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 5
  %1 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %tobool = icmp ne %struct.util_est* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 4
  %3 = load i32, i32* %acquired_refs, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 4
  %5 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp slt i32 %3, %5
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %6 = load i32, i32* %__ret_warn_on, align 4
  %tobool3 = icmp ne i32 %6, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then9
  br label %do.body10

do.body10:                                        ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 640, i32 2307, i64 12) #9, !srcloc !21
  br label %do.end

do.end:                                           ; preds = %do.body10
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 124) #9, !srcloc !22
  br label %do.end11

do.end11:                                         ; preds = %do.end
  br label %if.end12

if.end12:                                         ; preds = %do.end11, %if.end
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %7, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %8, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end12
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %10 = bitcast %struct.bpf_func_state* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %10, i8 0, i64 1184, i1 false)
  store i32 -14, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end12
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  %12 = load %struct.util_est*, %struct.util_est** %refs22, align 8
  %13 = bitcast %struct.util_est* %12 to i8*
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %refs23 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 5
  %15 = load %struct.util_est*, %struct.util_est** %refs23, align 8
  %16 = bitcast %struct.util_est* %15 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 4
  %18 = load i32, i32* %acquired_refs24, align 4
  %div = sdiv i32 %18, 1
  %conv25 = sext i32 %div to i64
  %mul = mul i64 8, %conv25
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %16, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_stack_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 7
  %1 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %tobool = icmp ne %struct.bpf_stack_state* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 6
  %3 = load i32, i32* %allocated_stack, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 6
  %5 = load i32, i32* %allocated_stack1, align 8
  %cmp = icmp slt i32 %3, %5
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %6 = load i32, i32* %__ret_warn_on, align 4
  %tobool3 = icmp ne i32 %6, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then9
  br label %do.body10

do.body10:                                        ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 642, i32 2307, i64 12) #9, !srcloc !23
  br label %do.end

do.end:                                           ; preds = %do.body10
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 125) #9, !srcloc !24
  br label %do.end11

do.end11:                                         ; preds = %do.end
  br label %if.end12

if.end12:                                         ; preds = %do.end11, %if.end
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %7, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %8, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end12
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %10 = bitcast %struct.bpf_func_state* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %10, i8 0, i64 1184, i1 false)
  store i32 -14, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end12
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack22, align 8
  %13 = bitcast %struct.bpf_stack_state* %12 to i8*
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %stack23 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack23, align 8
  %16 = bitcast %struct.bpf_stack_state* %15 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 6
  %18 = load i32, i32* %allocated_stack24, align 8
  %div = sdiv i32 %18, 8
  %conv25 = sext i32 %div to i64
  %mul = mul i64 112, %conv25
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %16, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #7

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @realloc_reference_state(%struct.bpf_func_state* noundef %state, i32 noundef %size, i1 noundef zeroext %copy_old) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %size.addr = alloca i32, align 4
  %copy_old.addr = alloca i8, align 1
  %old_size = alloca i32, align 4
  %new_refs = alloca %struct.util_est*, align 8
  %slot = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %copy_old to i8
  store i8 %frombool, i8* %copy_old.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 4
  %1 = load i32, i32* %acquired_refs, align 4
  store i32 %1, i32* %old_size, align 4
  %2 = load i32, i32* %size.addr, align 4
  %div = sdiv i32 %2, 1
  store i32 %div, i32* %slot, align 4
  %3 = load i32, i32* %size.addr, align 4
  %4 = load i32, i32* %old_size, align 4
  %cmp = icmp ule i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %size.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i8, i8* %copy_old.addr, align 1
  %tobool1 = trunc i8 %6 to i1
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i32, i32* %slot, align 4
  %mul = mul i32 %7, 1
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 4
  store i32 %mul, i32* %acquired_refs3, align 4
  %9 = load i32, i32* %size.addr, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %10 = load i32, i32* %old_size, align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  %12 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %13 = bitcast %struct.util_est* %12 to i8*
  call void @kfree(i8* noundef %13) #8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 5
  store %struct.util_est* null, %struct.util_est** %refs7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %land.lhs.true, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %lor.lhs.false
  %15 = load i32, i32* %slot, align 4
  %conv = sext i32 %15 to i64
  %call = call i8* @kmalloc_array(i64 noundef %conv, i64 noundef 8, i32 noundef 3264) #8
  %16 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %16, %struct.util_est** %new_refs, align 8
  %17 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %tobool10 = icmp ne %struct.util_est* %17, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  store i32 -12, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %18 = load i8, i8* %copy_old.addr, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.then14, label %if.end27

if.then14:                                        ; preds = %if.end12
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 5
  %20 = load %struct.util_est*, %struct.util_est** %refs15, align 8
  %tobool16 = icmp ne %struct.util_est* %20, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.then14
  %21 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %22 = bitcast %struct.util_est* %21 to i8*
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 5
  %24 = load %struct.util_est*, %struct.util_est** %refs18, align 8
  %25 = bitcast %struct.util_est* %24 to i8*
  %26 = load i32, i32* %old_size, align 4
  %div19 = udiv i32 %26, 1
  %conv20 = zext i32 %div19 to i64
  %mul21 = mul i64 8, %conv20
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %22, i8* align 4 %25, i64 %mul21, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.then14
  %27 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %28 = load i32, i32* %old_size, align 4
  %div23 = udiv i32 %28, 1
  %idx.ext = zext i32 %div23 to i64
  %add.ptr = getelementptr %struct.util_est, %struct.util_est* %27, i64 %idx.ext
  %29 = bitcast %struct.util_est* %add.ptr to i8*
  %30 = load i32, i32* %size.addr, align 4
  %31 = load i32, i32* %old_size, align 4
  %sub = sub i32 %30, %31
  %conv24 = zext i32 %sub to i64
  %mul25 = mul i64 8, %conv24
  %div26 = udiv i64 %mul25, 1
  call void @llvm.memset.p0i8.i64(i8* align 4 %29, i8 0, i64 %div26, i1 false)
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.end12
  %32 = load i32, i32* %slot, align 4
  %mul28 = mul i32 %32, 1
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 4
  store i32 %mul28, i32* %acquired_refs29, align 4
  %34 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs30 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %34, i32 0, i32 5
  %35 = load %struct.util_est*, %struct.util_est** %refs30, align 8
  %36 = bitcast %struct.util_est* %35 to i8*
  call void @kfree(i8* noundef %36) #8
  %37 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 5
  store %struct.util_est* %37, %struct.util_est** %refs31, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then11, %if.end8, %if.then2
  %39 = load i32, i32* %retval, align 4
  ret i32 %39
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @realloc_stack_state(%struct.bpf_func_state* noundef %state, i32 noundef %size, i1 noundef zeroext %copy_old) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %size.addr = alloca i32, align 4
  %copy_old.addr = alloca i8, align 1
  %old_size = alloca i32, align 4
  %new_stack = alloca %struct.bpf_stack_state*, align 8
  %slot = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %copy_old to i8
  store i8 %frombool, i8* %copy_old.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 6
  %1 = load i32, i32* %allocated_stack, align 8
  store i32 %1, i32* %old_size, align 4
  %2 = load i32, i32* %size.addr, align 4
  %div = sdiv i32 %2, 8
  store i32 %div, i32* %slot, align 4
  %3 = load i32, i32* %size.addr, align 4
  %4 = load i32, i32* %old_size, align 4
  %cmp = icmp ule i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %size.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i8, i8* %copy_old.addr, align 1
  %tobool1 = trunc i8 %6 to i1
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i32, i32* %slot, align 4
  %mul = mul i32 %7, 8
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 6
  store i32 %mul, i32* %allocated_stack3, align 8
  %9 = load i32, i32* %size.addr, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %10 = load i32, i32* %old_size, align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = bitcast %struct.bpf_stack_state* %12 to i8*
  call void @kfree(i8* noundef %13) #8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  store %struct.bpf_stack_state* null, %struct.bpf_stack_state** %stack7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %land.lhs.true, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %lor.lhs.false
  %15 = load i32, i32* %slot, align 4
  %conv = sext i32 %15 to i64
  %call = call i8* @kmalloc_array(i64 noundef %conv, i64 noundef 112, i32 noundef 3264) #8
  %16 = bitcast i8* %call to %struct.bpf_stack_state*
  store %struct.bpf_stack_state* %16, %struct.bpf_stack_state** %new_stack, align 8
  %17 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %tobool10 = icmp ne %struct.bpf_stack_state* %17, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  store i32 -12, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %18 = load i8, i8* %copy_old.addr, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.then14, label %if.end27

if.then14:                                        ; preds = %if.end12
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 7
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %tobool16 = icmp ne %struct.bpf_stack_state* %20, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.then14
  %21 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %22 = bitcast %struct.bpf_stack_state* %21 to i8*
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 7
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack18, align 8
  %25 = bitcast %struct.bpf_stack_state* %24 to i8*
  %26 = load i32, i32* %old_size, align 4
  %div19 = udiv i32 %26, 8
  %conv20 = zext i32 %div19 to i64
  %mul21 = mul i64 112, %conv20
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %25, i64 %mul21, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.then14
  %27 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %28 = load i32, i32* %old_size, align 4
  %div23 = udiv i32 %28, 8
  %idx.ext = zext i32 %div23 to i64
  %add.ptr = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %27, i64 %idx.ext
  %29 = bitcast %struct.bpf_stack_state* %add.ptr to i8*
  %30 = load i32, i32* %size.addr, align 4
  %31 = load i32, i32* %old_size, align 4
  %sub = sub i32 %30, %31
  %conv24 = zext i32 %sub to i64
  %mul25 = mul i64 112, %conv24
  %div26 = udiv i64 %mul25, 8
  call void @llvm.memset.p0i8.i64(i8* align 8 %29, i8 0, i64 %div26, i1 false)
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.end12
  %32 = load i32, i32* %slot, align 4
  %mul28 = mul i32 %32, 8
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 6
  store i32 %mul28, i32* %allocated_stack29, align 8
  %34 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack30 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %34, i32 0, i32 7
  %35 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack30, align 8
  %36 = bitcast %struct.bpf_stack_state* %35 to i8*
  call void @kfree(i8* noundef %36) #8
  %37 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 7
  store %struct.bpf_stack_state* %37, %struct.bpf_stack_state** %stack31, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then11, %if.end8, %if.then2
  %39 = load i32, i32* %retval, align 4
  ret i32 %39
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_jmp_history(%struct.bpf_verifier_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 9
  %1 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %2 = bitcast %struct.util_est* %1 to i8*
  call void @kfree(i8* noundef %2) #8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  store %struct.util_est* null, %struct.util_est** %jmp_history1, align 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 10
  store i32 0, i32* %jmp_history_cnt, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %callsite, i32 noundef %frameno, i32 noundef %subprogno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %callsite.addr = alloca i32, align 4
  %frameno.addr = alloca i32, align 4
  %subprogno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %callsite, i32* %callsite.addr, align 4
  store i32 %frameno, i32* %frameno.addr, align 4
  store i32 %subprogno, i32* %subprogno.addr, align 4
  %0 = load i32, i32* %callsite.addr, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %callsite1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 1
  store i32 %0, i32* %callsite1, align 8
  %2 = load i32, i32* %frameno.addr, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 2
  store i32 %2, i32* %frameno2, align 4
  %4 = load i32, i32* %subprogno.addr, align 4
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %subprogno3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 3
  store i32 %4, i32* %subprogno3, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  call void @init_reg_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %7) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_state_visited(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %new_sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %pprev = alloca %struct.bpf_verifier_state_list**, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %new = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %states_cnt = alloca i32, align 4
  %add_new_state = alloca i8, align 1
  %br = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp101 = alloca i64, align 8
  %__ret_warn_once148 = alloca i32, align 4
  %__ret_warn_on169 = alloca i32, align 4
  %tmp186 = alloca i64, align 8
  %tmp194 = alloca i64, align 8
  %frame250 = alloca %struct.bpf_func_state*, align 8
  %newframe = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  store i32 0, i32* %states_cnt, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 7
  %3 = load i8, i8* %test_state_freq, align 1
  %tobool = trunc i8 %3 to i1
  %4 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %tobool1 = icmp ne i32 %cond, 0
  %frombool = zext i1 %tobool1 to i8
  store i8 %frombool, i8* %add_new_state, align 1
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 1
  %6 = load i32, i32* %prev_insn_idx, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 8
  store i32 %6, i32* %last_insn_idx, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 16
  %9 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %10 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %9, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 6
  %11 = load i8, i8* %prune_point, align 1
  %tobool2 = trunc i8 %11 to i1
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 25
  %13 = load i32, i32* %jmps_processed, align 8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 24
  %15 = load i32, i32* %prev_jmps_processed, align 4
  %sub = sub i32 %13, %15
  %cmp = icmp uge i32 %sub, 2
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 23
  %17 = load i32, i32* %insn_processed, align 8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 22
  %19 = load i32, i32* %prev_insn_processed, align 4
  %sub3 = sub i32 %17, %19
  %cmp4 = icmp uge i32 %sub3, 8
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  store i8 1, i8* %add_new_state, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load i32, i32* %insn_idx.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %20, i32 noundef %21) #8
  store %struct.bpf_verifier_state_list** %call, %struct.bpf_verifier_state_list*** %pprev, align 8
  %22 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %23 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %22, align 8
  store %struct.bpf_verifier_state_list* %23, %struct.bpf_verifier_state_list** %sl, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %insn_idx.addr, align 4
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clean_live_states(%struct.bpf_verifier_env* noundef %24, i32 noundef %25, %struct.bpf_verifier_state* noundef %26) #8
  br label %while.cond

while.cond:                                       ; preds = %next113, %if.end111, %if.end6
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool7 = icmp ne %struct.bpf_verifier_state_list* %27, null
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %28 = load i32, i32* %states_cnt, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %states_cnt, align 4
  %29 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %29, i32 0, i32 0
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 3
  %30 = load i32, i32* %insn_idx8, align 4
  %31 = load i32, i32* %insn_idx.addr, align 4
  %cmp9 = icmp ne i32 %30, %31
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  br label %next113

if.end11:                                         ; preds = %while.body
  %32 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state12 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %32, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state12, i32 0, i32 2
  %33 = load i32, i32* %branches, align 8
  %tobool13 = icmp ne i32 %33, 0
  br i1 %tobool13, label %if.then14, label %if.end33

if.then14:                                        ; preds = %if.end11
  %34 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state15 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %34, i32 0, i32 0
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call16 = call zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %state15, %struct.bpf_verifier_state* noundef %35) #8
  br i1 %call16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.then14
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state18 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %37, i32 0, i32 0
  %38 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call19 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %36, %struct.bpf_verifier_state* noundef %state18, %struct.bpf_verifier_state* noundef %38) #8
  br i1 %call19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %39, i32 noundef %40, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.54, i64 0, i64 0)) #8
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.68, i64 0, i64 0), i32 noundef %43) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %land.lhs.true17, %if.then14
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed22 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 25
  %45 = load i32, i32* %jmps_processed22, align 8
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %46, i32 0, i32 24
  %47 = load i32, i32* %prev_jmps_processed23, align 4
  %sub24 = sub i32 %45, %47
  %cmp25 = icmp ult i32 %sub24, 20
  br i1 %cmp25, label %land.lhs.true26, label %if.end32

land.lhs.true26:                                  ; preds = %if.end21
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 23
  %49 = load i32, i32* %insn_processed27, align 8
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 22
  %51 = load i32, i32* %prev_insn_processed28, align 4
  %sub29 = sub i32 %49, %51
  %cmp30 = icmp ult i32 %sub29, 100
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true26
  store i8 0, i8* %add_new_state, align 1
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %land.lhs.true26, %if.end21
  br label %miss

if.end33:                                         ; preds = %if.end11
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state34 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %53, i32 0, i32 0
  %54 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call35 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %52, %struct.bpf_verifier_state* noundef %state34, %struct.bpf_verifier_state* noundef %54) #8
  br i1 %call35, label %if.then36, label %if.end53

if.then36:                                        ; preds = %if.end33
  %55 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %55, i32 0, i32 3
  %56 = load i32, i32* %hit_cnt, align 4
  %inc37 = add i32 %56, 1
  store i32 %inc37, i32* %hit_cnt, align 4
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state38 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %58, i32 0, i32 0
  %59 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call39 = call i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %57, %struct.bpf_verifier_state* noundef %state38, %struct.bpf_verifier_state* noundef %59) #8
  store i32 %call39, i32* %err, align 4
  %60 = load i32, i32* %err, align 4
  %tobool40 = icmp ne i32 %60, 0
  br i1 %tobool40, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then36
  br label %cond.end

cond.false:                                       ; preds = %if.then36
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call41 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %61, %struct.bpf_verifier_state* noundef %62) #8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond42 = phi i32 [ %60, %cond.true ], [ %call41, %cond.false ]
  store i32 %cond42, i32* %err, align 4
  %63 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %63, 0
  br i1 %tobool43, label %cond.true44, label %cond.false45

cond.true44:                                      ; preds = %cond.end
  br label %cond.end48

cond.false45:                                     ; preds = %cond.end
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state46 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %65, i32 0, i32 0
  %call47 = call i32 @propagate_precision(%struct.bpf_verifier_env* noundef %64, %struct.bpf_verifier_state* noundef %state46) #8
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false45, %cond.true44
  %cond49 = phi i32 [ %63, %cond.true44 ], [ %call47, %cond.false45 ]
  store i32 %cond49, i32* %err, align 4
  %66 = load i32, i32* %err, align 4
  %tobool50 = icmp ne i32 %66, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %cond.end48
  %67 = load i32, i32* %err, align 4
  store i32 %67, i32* %retval, align 4
  br label %return

if.end52:                                         ; preds = %cond.end48
  store i32 1, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.end33
  br label %miss

miss:                                             ; preds = %if.end53, %if.end32
  %68 = load i8, i8* %add_new_state, align 1
  %tobool54 = trunc i8 %68 to i1
  br i1 %tobool54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %miss
  %69 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %69, i32 0, i32 2
  %70 = load i32, i32* %miss_cnt, align 8
  %inc56 = add i32 %70, 1
  store i32 %inc56, i32* %miss_cnt, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %miss
  %71 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt58 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %71, i32 0, i32 2
  %72 = load i32, i32* %miss_cnt58, align 8
  %73 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt59 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %73, i32 0, i32 3
  %74 = load i32, i32* %hit_cnt59, align 4
  %mul = mul i32 %74, 3
  %add = add i32 %mul, 3
  %cmp60 = icmp sgt i32 %72, %add
  br i1 %cmp60, label %if.then61, label %if.end112

if.then61:                                        ; preds = %if.end57
  %75 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %75, i32 0, i32 1
  %76 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  %77 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  store %struct.bpf_verifier_state_list* %76, %struct.bpf_verifier_state_list** %77, align 8
  %78 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state62 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %78, i32 0, i32 0
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state62, i32 0, i32 0
  %arrayidx63 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %79 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx63, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %79, i32 0, i32 0
  %arrayidx64 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx64, i32 0, i32 13
  %80 = load i32, i32* %live, align 8
  %and = and i32 %80, 8
  %tobool65 = icmp ne i32 %and, 0
  br i1 %tobool65, label %if.then66, label %if.else

if.then66:                                        ; preds = %if.then61
  %81 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state67 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %81, i32 0, i32 0
  %branches68 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state67, i32 0, i32 2
  %82 = load i32, i32* %branches68, align 8
  store i32 %82, i32* %br, align 4
  %83 = load i32, i32* %br, align 4
  %tobool69 = icmp ne i32 %83, 0
  %lnot = xor i1 %tobool69, true
  %lnot70 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot70 to i32
  store i32 %lnot.ext, i32* %__ret_warn_once, align 4
  %84 = load i32, i32* %__ret_warn_once, align 4
  %tobool71 = icmp ne i32 %84, 0
  br i1 %tobool71, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then66
  %85 = load i8, i8* @is_state_visited.__warned, align 1
  %tobool72 = trunc i8 %85 to i1
  %lnot73 = xor i1 %tobool72, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then66
  %86 = phi i1 [ false, %if.then66 ], [ %lnot73, %land.rhs ]
  %lnot75 = xor i1 %86, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv = sext i32 %lnot.ext78 to i64
  %tobool79 = icmp ne i64 %conv, 0
  br i1 %tobool79, label %if.then80, label %if.end100

if.then80:                                        ; preds = %land.end
  store i8 1, i8* @is_state_visited.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %87 = load i32, i32* %__ret_warn_on, align 4
  %tobool81 = icmp ne i32 %87, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  %tobool87 = icmp ne i64 %conv86, 0
  br i1 %tobool87, label %if.then88, label %if.end93

if.then88:                                        ; preds = %if.then80
  br label %do.body

do.body:                                          ; preds = %if.then88
  %88 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.69, i64 0, i64 0), i32 noundef %88) #8
  br label %do.body89

do.body89:                                        ; preds = %do.body
  br label %do.body90

do.body90:                                        ; preds = %do.body89
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9274, i32 2313, i64 12) #9, !srcloc !25
  br label %do.end

do.end:                                           ; preds = %do.body90
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 218) #9, !srcloc !26
  br label %do.end91

do.end91:                                         ; preds = %do.end
  br label %do.end92

do.end92:                                         ; preds = %do.end91
  br label %if.end93

if.end93:                                         ; preds = %do.end92, %if.then80
  %89 = load i32, i32* %__ret_warn_on, align 4
  %tobool94 = icmp ne i32 %89, 0
  %lnot95 = xor i1 %tobool94, true
  %lnot97 = xor i1 %lnot95, true
  %lnot.ext98 = zext i1 %lnot97 to i32
  %conv99 = sext i32 %lnot.ext98 to i64
  store i64 %conv99, i64* %tmp, align 8
  %90 = load i64, i64* %tmp, align 8
  br label %if.end100

if.end100:                                        ; preds = %if.end93, %land.end
  %91 = load i32, i32* %__ret_warn_once, align 4
  %tobool102 = icmp ne i32 %91, 0
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  %conv107 = sext i32 %lnot.ext106 to i64
  store i64 %conv107, i64* %tmp101, align 8
  %92 = load i64, i64* %tmp101, align 8
  %93 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state108 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %93, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state108, i1 noundef zeroext false) #8
  %94 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %95 = bitcast %struct.bpf_verifier_state_list* %94 to i8*
  call void @kfree(i8* noundef %95) #8
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %96, i32 0, i32 29
  %97 = load i32, i32* %peak_states, align 8
  %dec = add i32 %97, -1
  store i32 %dec, i32* %peak_states, align 8
  br label %if.end111

if.else:                                          ; preds = %if.then61
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 10
  %99 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  %100 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next109 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %100, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %99, %struct.bpf_verifier_state_list** %next109, align 8
  %101 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list110 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %102, i32 0, i32 10
  store %struct.bpf_verifier_state_list* %101, %struct.bpf_verifier_state_list** %free_list110, align 8
  br label %if.end111

if.end111:                                        ; preds = %if.else, %if.end100
  %103 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %104 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %103, align 8
  store %struct.bpf_verifier_state_list* %104, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

if.end112:                                        ; preds = %if.end57
  br label %next113

next113:                                          ; preds = %if.end112, %if.then10
  %105 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next114 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %105, i32 0, i32 1
  store %struct.bpf_verifier_state_list** %next114, %struct.bpf_verifier_state_list*** %pprev, align 8
  %106 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %107 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %106, align 8
  store %struct.bpf_verifier_state_list* %107, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %108, i32 0, i32 27
  %109 = load i32, i32* %max_states_per_insn, align 8
  %110 = load i32, i32* %states_cnt, align 4
  %cmp115 = icmp ult i32 %109, %110
  br i1 %cmp115, label %if.then117, label %if.end119

if.then117:                                       ; preds = %while.end
  %111 = load i32, i32* %states_cnt, align 4
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn118 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %112, i32 0, i32 27
  store i32 %111, i32* %max_states_per_insn118, align 8
  br label %if.end119

if.end119:                                        ; preds = %if.then117, %while.end
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 14
  %114 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool120 = trunc i8 %114 to i1
  br i1 %tobool120, label %if.end126, label %land.lhs.true121

land.lhs.true121:                                 ; preds = %if.end119
  %115 = load i32, i32* %states_cnt, align 4
  %cmp122 = icmp sgt i32 %115, 64
  br i1 %cmp122, label %if.then124, label %if.end126

if.then124:                                       ; preds = %land.lhs.true121
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call125 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %116, %struct.bpf_verifier_state* noundef %117) #8
  store i32 %call125, i32* %retval, align 4
  br label %return

if.end126:                                        ; preds = %land.lhs.true121, %if.end119
  %118 = load i8, i8* %add_new_state, align 1
  %tobool127 = trunc i8 %118 to i1
  br i1 %tobool127, label %if.end130, label %if.then128

if.then128:                                       ; preds = %if.end126
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call129 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %119, %struct.bpf_verifier_state* noundef %120) #8
  store i32 %call129, i32* %retval, align 4
  br label %return

if.end130:                                        ; preds = %if.end126
  %call131 = call i8* @kzalloc(i64 noundef 136, i32 noundef 3264) #8
  %121 = bitcast i8* %call131 to %struct.bpf_verifier_state_list*
  store %struct.bpf_verifier_state_list* %121, %struct.bpf_verifier_state_list** %new_sl, align 8
  %122 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %tobool132 = icmp ne %struct.bpf_verifier_state_list* %122, null
  br i1 %tobool132, label %if.end134, label %if.then133

if.then133:                                       ; preds = %if.end130
  store i32 -12, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end130
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %123, i32 0, i32 28
  %124 = load i32, i32* %total_states, align 4
  %inc135 = add i32 %124, 1
  store i32 %inc135, i32* %total_states, align 4
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states136 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %125, i32 0, i32 29
  %126 = load i32, i32* %peak_states136, align 8
  %inc137 = add i32 %126, 1
  store i32 %inc137, i32* %peak_states136, align 8
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed138 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %127, i32 0, i32 25
  %128 = load i32, i32* %jmps_processed138, align 8
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed139 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %129, i32 0, i32 24
  store i32 %128, i32* %prev_jmps_processed139, align 4
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed140 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %130, i32 0, i32 23
  %131 = load i32, i32* %insn_processed140, align 8
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed141 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %132, i32 0, i32 22
  store i32 %131, i32* %prev_insn_processed141, align 4
  %133 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %state142 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %133, i32 0, i32 0
  store %struct.bpf_verifier_state* %state142, %struct.bpf_verifier_state** %new, align 8
  %134 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %135 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call143 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %134, %struct.bpf_verifier_state* noundef %135) #8
  store i32 %call143, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool144 = icmp ne i32 %136, 0
  br i1 %tobool144, label %if.then145, label %if.end146

if.then145:                                       ; preds = %if.end134
  %137 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %137, i1 noundef zeroext false) #8
  %138 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %139 = bitcast %struct.bpf_verifier_state_list* %138 to i8*
  call void @kfree(i8* noundef %139) #8
  %140 = load i32, i32* %err, align 4
  store i32 %140, i32* %retval, align 4
  br label %return

if.end146:                                        ; preds = %if.end134
  %141 = load i32, i32* %insn_idx.addr, align 4
  %142 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %insn_idx147 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %142, i32 0, i32 3
  store i32 %141, i32* %insn_idx147, align 4
  %143 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches149 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %143, i32 0, i32 2
  %144 = load i32, i32* %branches149, align 8
  %cmp150 = icmp ne i32 %144, 1
  %lnot152 = xor i1 %cmp150, true
  %lnot154 = xor i1 %lnot152, true
  %lnot.ext155 = zext i1 %lnot154 to i32
  store i32 %lnot.ext155, i32* %__ret_warn_once148, align 4
  %145 = load i32, i32* %__ret_warn_once148, align 4
  %tobool156 = icmp ne i32 %145, 0
  br i1 %tobool156, label %land.rhs157, label %land.end161

land.rhs157:                                      ; preds = %if.end146
  %146 = load i8, i8* @is_state_visited.__warned.70, align 1
  %tobool158 = trunc i8 %146 to i1
  %lnot159 = xor i1 %tobool158, true
  br label %land.end161

land.end161:                                      ; preds = %land.rhs157, %if.end146
  %147 = phi i1 [ false, %if.end146 ], [ %lnot159, %land.rhs157 ]
  %lnot162 = xor i1 %147, true
  %lnot164 = xor i1 %lnot162, true
  %lnot.ext165 = zext i1 %lnot164 to i32
  %conv166 = sext i32 %lnot.ext165 to i64
  %tobool167 = icmp ne i64 %conv166, 0
  br i1 %tobool167, label %if.then168, label %if.end193

if.then168:                                       ; preds = %land.end161
  store i8 1, i8* @is_state_visited.__warned.70, align 1
  store i32 1, i32* %__ret_warn_on169, align 4
  %148 = load i32, i32* %__ret_warn_on169, align 4
  %tobool170 = icmp ne i32 %148, 0
  %lnot171 = xor i1 %tobool170, true
  %lnot173 = xor i1 %lnot171, true
  %lnot.ext174 = zext i1 %lnot173 to i32
  %conv175 = sext i32 %lnot.ext174 to i64
  %tobool176 = icmp ne i64 %conv175, 0
  br i1 %tobool176, label %if.then177, label %if.end185

if.then177:                                       ; preds = %if.then168
  br label %do.body178

do.body178:                                       ; preds = %if.then177
  %149 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches179 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %149, i32 0, i32 2
  %150 = load i32, i32* %branches179, align 8
  %151 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.71, i64 0, i64 0), i32 noundef %150, i32 noundef %151) #8
  br label %do.body180

do.body180:                                       ; preds = %do.body178
  br label %do.body181

do.body181:                                       ; preds = %do.body180
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9330, i32 2313, i64 12) #9, !srcloc !27
  br label %do.end182

do.end182:                                        ; preds = %do.body181
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 219) #9, !srcloc !28
  br label %do.end183

do.end183:                                        ; preds = %do.end182
  br label %do.end184

do.end184:                                        ; preds = %do.end183
  br label %if.end185

if.end185:                                        ; preds = %do.end184, %if.then168
  %152 = load i32, i32* %__ret_warn_on169, align 4
  %tobool187 = icmp ne i32 %152, 0
  %lnot188 = xor i1 %tobool187, true
  %lnot190 = xor i1 %lnot188, true
  %lnot.ext191 = zext i1 %lnot190 to i32
  %conv192 = sext i32 %lnot.ext191 to i64
  store i64 %conv192, i64* %tmp186, align 8
  %153 = load i64, i64* %tmp186, align 8
  br label %if.end193

if.end193:                                        ; preds = %if.end185, %land.end161
  %154 = load i32, i32* %__ret_warn_once148, align 4
  %tobool195 = icmp ne i32 %154, 0
  %lnot196 = xor i1 %tobool195, true
  %lnot198 = xor i1 %lnot196, true
  %lnot.ext199 = zext i1 %lnot198 to i32
  %conv200 = sext i32 %lnot.ext199 to i64
  store i64 %conv200, i64* %tmp194, align 8
  %155 = load i64, i64* %tmp194, align 8
  %156 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %157 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %157, i32 0, i32 1
  store %struct.bpf_verifier_state* %156, %struct.bpf_verifier_state** %parent, align 8
  %158 = load i32, i32* %insn_idx.addr, align 4
  %159 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %159, i32 0, i32 7
  store i32 %158, i32* %first_insn_idx, align 4
  %160 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %160) #8
  %161 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %162 = load i32, i32* %insn_idx.addr, align 4
  %call201 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %161, i32 noundef %162) #8
  %163 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call201, align 8
  %164 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %next202 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %164, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %163, %struct.bpf_verifier_state_list** %next202, align 8
  %165 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %166 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %167 = load i32, i32* %insn_idx.addr, align 4
  %call203 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %166, i32 noundef %167) #8
  store %struct.bpf_verifier_state_list* %165, %struct.bpf_verifier_state_list** %call203, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc242, %if.end193
  %168 = load i32, i32* %j, align 4
  %169 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %169, i32 0, i32 4
  %170 = load i32, i32* %curframe, align 8
  %cmp204 = icmp ule i32 %168, %170
  br i1 %cmp204, label %for.body, label %for.end244

for.body:                                         ; preds = %for.cond
  %171 = load i32, i32* %j, align 4
  %172 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe206 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %172, i32 0, i32 4
  %173 = load i32, i32* %curframe206, align 8
  %cmp207 = icmp ult i32 %171, %173
  %174 = zext i1 %cmp207 to i64
  %cond209 = select i1 %cmp207, i32 6, i32 0
  store i32 %cond209, i32* %i, align 4
  br label %for.cond210

for.cond210:                                      ; preds = %for.inc, %for.body
  %175 = load i32, i32* %i, align 4
  %cmp211 = icmp slt i32 %175, 10
  br i1 %cmp211, label %for.body213, label %for.end

for.body213:                                      ; preds = %for.cond210
  %176 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame214 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %176, i32 0, i32 0
  %177 = load i32, i32* %j, align 4
  %idxprom215 = sext i32 %177 to i64
  %arrayidx216 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame214, i64 0, i64 %idxprom215
  %178 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx216, align 8
  %regs217 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %178, i32 0, i32 0
  %179 = load i32, i32* %i, align 4
  %idxprom218 = sext i32 %179 to i64
  %arrayidx219 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs217, i64 0, i64 %idxprom218
  %180 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame220 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %180, i32 0, i32 0
  %181 = load i32, i32* %j, align 4
  %idxprom221 = sext i32 %181 to i64
  %arrayidx222 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame220, i64 0, i64 %idxprom221
  %182 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx222, align 8
  %regs223 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %182, i32 0, i32 0
  %183 = load i32, i32* %i, align 4
  %idxprom224 = sext i32 %183 to i64
  %arrayidx225 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs223, i64 0, i64 %idxprom224
  %parent226 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx225, i32 0, i32 10
  store %struct.bpf_reg_state* %arrayidx219, %struct.bpf_reg_state** %parent226, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body213
  %184 = load i32, i32* %i, align 4
  %inc227 = add i32 %184, 1
  store i32 %inc227, i32* %i, align 4
  br label %for.cond210

for.end:                                          ; preds = %for.cond210
  store i32 0, i32* %i, align 4
  br label %for.cond228

for.cond228:                                      ; preds = %for.inc239, %for.end
  %185 = load i32, i32* %i, align 4
  %cmp229 = icmp slt i32 %185, 10
  br i1 %cmp229, label %for.body231, label %for.end241

for.body231:                                      ; preds = %for.cond228
  %186 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame232 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %186, i32 0, i32 0
  %187 = load i32, i32* %j, align 4
  %idxprom233 = sext i32 %187 to i64
  %arrayidx234 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame232, i64 0, i64 %idxprom233
  %188 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx234, align 8
  %regs235 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %188, i32 0, i32 0
  %189 = load i32, i32* %i, align 4
  %idxprom236 = sext i32 %189 to i64
  %arrayidx237 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs235, i64 0, i64 %idxprom236
  %live238 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx237, i32 0, i32 13
  store i32 0, i32* %live238, align 8
  br label %for.inc239

for.inc239:                                       ; preds = %for.body231
  %190 = load i32, i32* %i, align 4
  %inc240 = add i32 %190, 1
  store i32 %inc240, i32* %i, align 4
  br label %for.cond228

for.end241:                                       ; preds = %for.cond228
  br label %for.inc242

for.inc242:                                       ; preds = %for.end241
  %191 = load i32, i32* %j, align 4
  %inc243 = add i32 %191, 1
  store i32 %inc243, i32* %j, align 4
  br label %for.cond

for.end244:                                       ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc276, %for.end244
  %192 = load i32, i32* %j, align 4
  %193 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe246 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %193, i32 0, i32 4
  %194 = load i32, i32* %curframe246, align 8
  %cmp247 = icmp ule i32 %192, %194
  br i1 %cmp247, label %for.body249, label %for.end278

for.body249:                                      ; preds = %for.cond245
  %195 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame251 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %195, i32 0, i32 0
  %196 = load i32, i32* %j, align 4
  %idxprom252 = sext i32 %196 to i64
  %arrayidx253 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame251, i64 0, i64 %idxprom252
  %197 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx253, align 8
  store %struct.bpf_func_state* %197, %struct.bpf_func_state** %frame250, align 8
  %198 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame254 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %198, i32 0, i32 0
  %199 = load i32, i32* %j, align 4
  %idxprom255 = sext i32 %199 to i64
  %arrayidx256 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame254, i64 0, i64 %idxprom255
  %200 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx256, align 8
  store %struct.bpf_func_state* %200, %struct.bpf_func_state** %newframe, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond257

for.cond257:                                      ; preds = %for.inc273, %for.body249
  %201 = load i32, i32* %i, align 4
  %202 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame250, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %202, i32 0, i32 6
  %203 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %203, 8
  %cmp258 = icmp slt i32 %201, %div
  br i1 %cmp258, label %for.body260, label %for.end275

for.body260:                                      ; preds = %for.cond257
  %204 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame250, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %204, i32 0, i32 7
  %205 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %206 = load i32, i32* %i, align 4
  %idxprom261 = sext i32 %206 to i64
  %arrayidx262 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %205, i64 %idxprom261
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx262, i32 0, i32 0
  %live263 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 13
  store i32 0, i32* %live263, align 8
  %207 = load %struct.bpf_func_state*, %struct.bpf_func_state** %newframe, align 8
  %stack264 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %207, i32 0, i32 7
  %208 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack264, align 8
  %209 = load i32, i32* %i, align 4
  %idxprom265 = sext i32 %209 to i64
  %arrayidx266 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %208, i64 %idxprom265
  %spilled_ptr267 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx266, i32 0, i32 0
  %210 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame250, align 8
  %stack268 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %210, i32 0, i32 7
  %211 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack268, align 8
  %212 = load i32, i32* %i, align 4
  %idxprom269 = sext i32 %212 to i64
  %arrayidx270 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %211, i64 %idxprom269
  %spilled_ptr271 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx270, i32 0, i32 0
  %parent272 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr271, i32 0, i32 10
  store %struct.bpf_reg_state* %spilled_ptr267, %struct.bpf_reg_state** %parent272, align 8
  br label %for.inc273

for.inc273:                                       ; preds = %for.body260
  %213 = load i32, i32* %i, align 4
  %inc274 = add i32 %213, 1
  store i32 %inc274, i32* %i, align 4
  br label %for.cond257

for.end275:                                       ; preds = %for.cond257
  br label %for.inc276

for.inc276:                                       ; preds = %for.end275
  %214 = load i32, i32* %j, align 4
  %inc277 = add i32 %214, 1
  store i32 %inc277, i32* %j, align 4
  br label %for.cond245

for.end278:                                       ; preds = %for.cond245
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end278, %if.then145, %if.then133, %if.then128, %if.then124, %if.end52, %if.then51, %if.then20, %if.then
  %215 = load i32, i32* %retval, align 4
  ret i32 %215
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @signal_pending(%struct.task_struct* noundef %p) #0 {
entry:
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* noundef %0, i32 noundef 2) #8
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %conv2 = trunc i64 %conv to i32
  ret i32 %conv2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_ti_thread_flag(%struct.thread_info* noundef %ti, i32 noundef %flag) #0 {
entry:
  %ti.addr = alloca %struct.thread_info*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.thread_info* %ti, %struct.thread_info** %ti.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %flag.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %1, i32 0, i32 0
  %call = call zeroext i1 @test_bit(i64 noundef %conv, i64* noundef %flags) #8
  %conv1 = zext i1 %call to i32
  ret i32 %conv1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca i32, align 4
  %i = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  %types_buf = alloca [9 x i8], align 1
  %valid = alloca i8, align 1
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 2
  %1 = load i32, i32* %frameno, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 2
  %5 = load i32, i32* %frameno1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.89, i64 0, i64 0), i32 noundef %5) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  store i32 %10, i32* %t, align 4
  %11 = load i32, i32* %t, align 4
  %cmp2 = icmp eq i32 %11, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.90, i64 0, i64 0), i32 noundef %14) #8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 13
  %17 = load i32, i32* %live, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %15, i32 noundef %17) #8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %t, align 4
  %idxprom5 = zext i32 %20 to i64
  %arrayidx6 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom5
  %21 = load i8*, i8** %arrayidx6, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.91, i64 0, i64 0), i8* noundef %21) #8
  %22 = load i32, i32* %t, align 4
  %cmp7 = icmp eq i32 %22, 1
  br i1 %cmp7, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 14
  %24 = load i8, i8* %precise, align 4
  %tobool8 = trunc i8 %24 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.92, i64 0, i64 0)) #8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true, %if.end4
  %27 = load i32, i32* %t, align 4
  %cmp11 = icmp eq i32 %27, 1
  br i1 %cmp11, label %land.lhs.true13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %28 = load i32, i32* %t, align 4
  %cmp12 = icmp eq i32 %28, 6
  br i1 %cmp12, label %land.lhs.true13, label %if.else

land.lhs.true13:                                  ; preds = %lor.lhs.false, %if.end10
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 5
  %30 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %32, i64 %34) #8
  br i1 %call, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true13
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %38 = load i64, i64* %value, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 2
  %40 = load i32, i32* %off, align 8
  %conv = sext i32 %40 to i64
  %add = add i64 %38, %conv
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.93, i64 0, i64 0), i64 noundef %add) #8
  br label %if.end84

if.else:                                          ; preds = %land.lhs.true13, %lor.lhs.false
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 3
  %44 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.94, i64 0, i64 0), i32 noundef %44) #8
  %45 = load i32, i32* %t, align 4
  %call16 = call zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %45) #8
  br i1 %call16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.else
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = bitcast %struct.bpf_verifier_env* %46 to i8*
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 4
  %49 = load i32, i32* %ref_obj_id, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %47, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str.95, i64 0, i64 0), i32 noundef %49) #8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.else
  %50 = load i32, i32* %t, align 4
  %cmp19 = icmp ne i32 %50, 1
  br i1 %cmp19, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end18
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 2
  %54 = load i32, i32* %off22, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.96, i64 0, i64 0), i32 noundef %54) #8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end18
  %55 = load i32, i32* %t, align 4
  %call24 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %55) #8
  br i1 %call24, label %if.then25, label %if.else27

if.then25:                                        ; preds = %if.end23
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 1
  %range = bitcast %union.anon.147* %59 to i16*
  %60 = load i16, i16* %range, align 8
  %conv26 = zext i16 %60 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i64 0, i64 0), i32 noundef %conv26) #8
  br label %if.end39

if.else27:                                        ; preds = %if.end23
  %61 = load i32, i32* %t, align 4
  %cmp28 = icmp eq i32 %61, 3
  br i1 %cmp28, label %if.then36, label %lor.lhs.false30

lor.lhs.false30:                                  ; preds = %if.else27
  %62 = load i32, i32* %t, align 4
  %cmp31 = icmp eq i32 %62, 4
  br i1 %cmp31, label %if.then36, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false30
  %63 = load i32, i32* %t, align 4
  %cmp34 = icmp eq i32 %63, 5
  br i1 %cmp34, label %if.then36, label %if.end38

if.then36:                                        ; preds = %lor.lhs.false33, %lor.lhs.false30, %if.else27
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %67 to %struct.bpf_map**
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %68, i32 0, i32 4
  %69 = load i32, i32* %key_size, align 4
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 1
  %map_ptr37 = bitcast %union.anon.147* %71 to %struct.bpf_map**
  %72 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr37, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %72, i32 0, i32 5
  %73 = load i32, i32* %value_size, align 32
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.98, i64 0, i64 0), i32 noundef %69, i32 noundef %73) #8
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %lor.lhs.false33
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then25
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 5
  %75 = bitcast %struct.tnum* %var_off40 to { i64, i64 }*
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %75, i32 0, i32 0
  %77 = load i64, i64* %76, align 8
  %78 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %75, i32 0, i32 1
  %79 = load i64, i64* %78, align 8
  %call41 = call zeroext i1 @tnum_is_const(i64 %77, i64 %79) #8
  br i1 %call41, label %if.then42, label %if.else45

if.then42:                                        ; preds = %if.end39
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = bitcast %struct.bpf_verifier_env* %80 to i8*
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 5
  %value44 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off43, i32 0, i32 0
  %83 = load i64, i64* %value44, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %81, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.99, i64 0, i64 0), i64 noundef %83) #8
  br label %if.end83

if.else45:                                        ; preds = %if.end39
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 6
  %85 = load i64, i64* %smin_value, align 8
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 8
  %87 = load i64, i64* %umin_value, align 8
  %cmp46 = icmp ne i64 %85, %87
  br i1 %cmp46, label %land.lhs.true48, label %if.end54

land.lhs.true48:                                  ; preds = %if.else45
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 6
  %89 = load i64, i64* %smin_value49, align 8
  %cmp50 = icmp ne i64 %89, -9223372036854775808
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %land.lhs.true48
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = bitcast %struct.bpf_verifier_env* %90 to i8*
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 6
  %93 = load i64, i64* %smin_value53, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %91, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.100, i64 0, i64 0), i64 noundef %93) #8
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %land.lhs.true48, %if.else45
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 7
  %95 = load i64, i64* %smax_value, align 8
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 9
  %97 = load i64, i64* %umax_value, align 8
  %cmp55 = icmp ne i64 %95, %97
  br i1 %cmp55, label %land.lhs.true57, label %if.end63

land.lhs.true57:                                  ; preds = %if.end54
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %98, i32 0, i32 7
  %99 = load i64, i64* %smax_value58, align 8
  %cmp59 = icmp ne i64 %99, 9223372036854775807
  br i1 %cmp59, label %if.then61, label %if.end63

if.then61:                                        ; preds = %land.lhs.true57
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = bitcast %struct.bpf_verifier_env* %100 to i8*
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value62 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 7
  %103 = load i64, i64* %smax_value62, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %101, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.101, i64 0, i64 0), i64 noundef %103) #8
  br label %if.end63

if.end63:                                         ; preds = %if.then61, %land.lhs.true57, %if.end54
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 8
  %105 = load i64, i64* %umin_value64, align 8
  %cmp65 = icmp ne i64 %105, 0
  br i1 %cmp65, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.end63
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %108, i32 0, i32 8
  %109 = load i64, i64* %umin_value68, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.102, i64 0, i64 0), i64 noundef %109) #8
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %if.end63
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %110, i32 0, i32 9
  %111 = load i64, i64* %umax_value70, align 8
  %cmp71 = icmp ne i64 %111, -1
  br i1 %cmp71, label %if.then73, label %if.end75

if.then73:                                        ; preds = %if.end69
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = bitcast %struct.bpf_verifier_env* %112 to i8*
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i32 0, i32 9
  %115 = load i64, i64* %umax_value74, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %113, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.103, i64 0, i64 0), i64 noundef %115) #8
  br label %if.end75

if.end75:                                         ; preds = %if.then73, %if.end69
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i32 0, i32 5
  %117 = bitcast %struct.tnum* %var_off76 to { i64, i64 }*
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 0
  %119 = load i64, i64* %118, align 8
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 1
  %121 = load i64, i64* %120, align 8
  %call77 = call zeroext i1 @tnum_is_unknown(i64 %119, i64 %121) #8
  br i1 %call77, label %if.end82, label %if.then78

if.then78:                                        ; preds = %if.end75
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 5
  %123 = bitcast %struct.tnum* %var_off79 to { i64, i64 }*
  %124 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 0
  %125 = load i64, i64* %124, align 8
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 1
  %127 = load i64, i64* %126, align 8
  %call80 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %125, i64 %127) #8
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %129 = bitcast %struct.bpf_verifier_env* %128 to i8*
  %arraydecay81 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %129, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i64 0, i64 0), i8* noundef %arraydecay81) #8
  br label %if.end82

if.end82:                                         ; preds = %if.then78, %if.end75
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.then42
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = bitcast %struct.bpf_verifier_env* %130 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %131, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.105, i64 0, i64 0)) #8
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.then14
  br label %for.inc

for.inc:                                          ; preds = %if.end84, %if.then3
  %132 = load i32, i32* %i, align 4
  %inc = add i32 %132, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond85

for.cond85:                                       ; preds = %for.inc164, %for.end
  %133 = load i32, i32* %i, align 4
  %134 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %134, i32 0, i32 6
  %135 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %135, 8
  %cmp86 = icmp slt i32 %133, %div
  br i1 %cmp86, label %for.body88, label %for.end166

for.body88:                                       ; preds = %for.cond85
  store i8 0, i8* %valid, align 1
  store i32 0, i32* %j, align 4
  br label %for.cond89

for.cond89:                                       ; preds = %for.inc112, %for.body88
  %136 = load i32, i32* %j, align 4
  %cmp90 = icmp slt i32 %136, 8
  br i1 %cmp90, label %for.body92, label %for.end114

for.body92:                                       ; preds = %for.cond89
  %137 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %137, i32 0, i32 7
  %138 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %139 = load i32, i32* %i, align 4
  %idxprom93 = sext i32 %139 to i64
  %arrayidx94 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %138, i64 %idxprom93
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx94, i32 0, i32 1
  %140 = load i32, i32* %j, align 4
  %idxprom95 = sext i32 %140 to i64
  %arrayidx96 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom95
  %141 = load i8, i8* %arrayidx96, align 1
  %conv97 = zext i8 %141 to i32
  %cmp98 = icmp ne i32 %conv97, 0
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %for.body92
  store i8 1, i8* %valid, align 1
  br label %if.end101

if.end101:                                        ; preds = %if.then100, %for.body92
  %142 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack102 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %142, i32 0, i32 7
  %143 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack102, align 8
  %144 = load i32, i32* %i, align 4
  %idxprom103 = sext i32 %144 to i64
  %arrayidx104 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %143, i64 %idxprom103
  %slot_type105 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx104, i32 0, i32 1
  %145 = load i32, i32* %j, align 4
  %idxprom106 = sext i32 %145 to i64
  %arrayidx107 = getelementptr [8 x i8], [8 x i8]* %slot_type105, i64 0, i64 %idxprom106
  %146 = load i8, i8* %arrayidx107, align 1
  %idxprom108 = zext i8 %146 to i64
  %arrayidx109 = getelementptr [4 x i8], [4 x i8]* @slot_type_char, i64 0, i64 %idxprom108
  %147 = load i8, i8* %arrayidx109, align 1
  %148 = load i32, i32* %j, align 4
  %idxprom110 = sext i32 %148 to i64
  %arrayidx111 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 %idxprom110
  store i8 %147, i8* %arrayidx111, align 1
  br label %for.inc112

for.inc112:                                       ; preds = %if.end101
  %149 = load i32, i32* %j, align 4
  %inc113 = add i32 %149, 1
  store i32 %inc113, i32* %j, align 4
  br label %for.cond89

for.end114:                                       ; preds = %for.cond89
  %arrayidx115 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 8
  store i8 0, i8* %arrayidx115, align 1
  %150 = load i8, i8* %valid, align 1
  %tobool116 = trunc i8 %150 to i1
  br i1 %tobool116, label %if.end118, label %if.then117

if.then117:                                       ; preds = %for.end114
  br label %for.inc164

if.end118:                                        ; preds = %for.end114
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %152 = bitcast %struct.bpf_verifier_env* %151 to i8*
  %153 = load i32, i32* %i, align 4
  %sub = sub i32 0, %153
  %sub119 = sub i32 %sub, 1
  %mul = mul i32 %sub119, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %152, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i32 noundef %mul) #8
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %155 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack120 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %155, i32 0, i32 7
  %156 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack120, align 8
  %157 = load i32, i32* %i, align 4
  %idxprom121 = sext i32 %157 to i64
  %arrayidx122 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %156, i64 %idxprom121
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx122, i32 0, i32 0
  %live123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 13
  %158 = load i32, i32* %live123, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %154, i32 noundef %158) #8
  %159 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack124 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %159, i32 0, i32 7
  %160 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack124, align 8
  %161 = load i32, i32* %i, align 4
  %idxprom125 = sext i32 %161 to i64
  %arrayidx126 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %160, i64 %idxprom125
  %slot_type127 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx126, i32 0, i32 1
  %arrayidx128 = getelementptr [8 x i8], [8 x i8]* %slot_type127, i64 0, i64 0
  %162 = load i8, i8* %arrayidx128, align 8
  %conv129 = zext i8 %162 to i32
  %cmp130 = icmp eq i32 %conv129, 1
  br i1 %cmp130, label %if.then132, label %if.else161

if.then132:                                       ; preds = %if.end118
  %163 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack133 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %163, i32 0, i32 7
  %164 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack133, align 8
  %165 = load i32, i32* %i, align 4
  %idxprom134 = sext i32 %165 to i64
  %arrayidx135 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %164, i64 %idxprom134
  %spilled_ptr136 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx135, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr136, %struct.bpf_reg_state** %reg, align 8
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type137 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 0
  %167 = load i32, i32* %type137, align 8
  store i32 %167, i32* %t, align 4
  %168 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %169 = bitcast %struct.bpf_verifier_env* %168 to i8*
  %170 = load i32, i32* %t, align 4
  %idxprom138 = zext i32 %170 to i64
  %arrayidx139 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom138
  %171 = load i8*, i8** %arrayidx139, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %169, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.91, i64 0, i64 0), i8* noundef %171) #8
  %172 = load i32, i32* %t, align 4
  %cmp140 = icmp eq i32 %172, 1
  br i1 %cmp140, label %land.lhs.true142, label %if.end147

land.lhs.true142:                                 ; preds = %if.then132
  %173 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise143 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %173, i32 0, i32 14
  %174 = load i8, i8* %precise143, align 4
  %tobool144 = trunc i8 %174 to i1
  br i1 %tobool144, label %if.then146, label %if.end147

if.then146:                                       ; preds = %land.lhs.true142
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %176 = bitcast %struct.bpf_verifier_env* %175 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %176, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.92, i64 0, i64 0)) #8
  br label %if.end147

if.end147:                                        ; preds = %if.then146, %land.lhs.true142, %if.then132
  %177 = load i32, i32* %t, align 4
  %cmp148 = icmp eq i32 %177, 1
  br i1 %cmp148, label %land.lhs.true150, label %if.end160

land.lhs.true150:                                 ; preds = %if.end147
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 5
  %179 = bitcast %struct.tnum* %var_off151 to { i64, i64 }*
  %180 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %179, i32 0, i32 0
  %181 = load i64, i64* %180, align 8
  %182 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %179, i32 0, i32 1
  %183 = load i64, i64* %182, align 8
  %call152 = call zeroext i1 @tnum_is_const(i64 %181, i64 %183) #8
  br i1 %call152, label %if.then154, label %if.end160

if.then154:                                       ; preds = %land.lhs.true150
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %185 = bitcast %struct.bpf_verifier_env* %184 to i8*
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off155 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i32 0, i32 5
  %value156 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off155, i32 0, i32 0
  %187 = load i64, i64* %value156, align 8
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off157 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i32 0, i32 2
  %189 = load i32, i32* %off157, align 8
  %conv158 = sext i32 %189 to i64
  %add159 = add i64 %187, %conv158
  call void (i8*, i8*, ...) @verbose(i8* noundef %185, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.93, i64 0, i64 0), i64 noundef %add159) #8
  br label %if.end160

if.end160:                                        ; preds = %if.then154, %land.lhs.true150, %if.end147
  br label %if.end163

if.else161:                                       ; preds = %if.end118
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %191 = bitcast %struct.bpf_verifier_env* %190 to i8*
  %arraydecay162 = getelementptr inbounds [9 x i8], [9 x i8]* %types_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %191, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.91, i64 0, i64 0), i8* noundef %arraydecay162) #8
  br label %if.end163

if.end163:                                        ; preds = %if.else161, %if.end160
  br label %for.inc164

for.inc164:                                       ; preds = %if.end163, %if.then117
  %192 = load i32, i32* %i, align 4
  %inc165 = add i32 %192, 1
  store i32 %inc165, i32* %i, align 4
  br label %for.cond85

for.end166:                                       ; preds = %for.cond85
  %193 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %193, i32 0, i32 4
  %194 = load i32, i32* %acquired_refs, align 4
  %tobool167 = icmp ne i32 %194, 0
  br i1 %tobool167, label %land.lhs.true168, label %if.end195

land.lhs.true168:                                 ; preds = %for.end166
  %195 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %195, i32 0, i32 5
  %196 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %arrayidx169 = getelementptr %struct.util_est, %struct.util_est* %196, i64 0
  %id170 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx169, i32 0, i32 0
  %197 = load i32, i32* %id170, align 4
  %tobool171 = icmp ne i32 %197, 0
  br i1 %tobool171, label %if.then172, label %if.end195

if.then172:                                       ; preds = %land.lhs.true168
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %199 = bitcast %struct.bpf_verifier_env* %198 to i8*
  %200 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs173 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %200, i32 0, i32 5
  %201 = load %struct.util_est*, %struct.util_est** %refs173, align 8
  %arrayidx174 = getelementptr %struct.util_est, %struct.util_est* %201, i64 0
  %id175 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx174, i32 0, i32 0
  %202 = load i32, i32* %id175, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %199, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.107, i64 0, i64 0), i32 noundef %202) #8
  store i32 1, i32* %i, align 4
  br label %for.cond176

for.cond176:                                      ; preds = %for.inc192, %if.then172
  %203 = load i32, i32* %i, align 4
  %204 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs177 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %204, i32 0, i32 4
  %205 = load i32, i32* %acquired_refs177, align 4
  %cmp178 = icmp slt i32 %203, %205
  br i1 %cmp178, label %for.body180, label %for.end194

for.body180:                                      ; preds = %for.cond176
  %206 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs181 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %206, i32 0, i32 5
  %207 = load %struct.util_est*, %struct.util_est** %refs181, align 8
  %208 = load i32, i32* %i, align 4
  %idxprom182 = sext i32 %208 to i64
  %arrayidx183 = getelementptr %struct.util_est, %struct.util_est* %207, i64 %idxprom182
  %id184 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx183, i32 0, i32 0
  %209 = load i32, i32* %id184, align 4
  %tobool185 = icmp ne i32 %209, 0
  br i1 %tobool185, label %if.then186, label %if.end191

if.then186:                                       ; preds = %for.body180
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %211 = bitcast %struct.bpf_verifier_env* %210 to i8*
  %212 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs187 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %212, i32 0, i32 5
  %213 = load %struct.util_est*, %struct.util_est** %refs187, align 8
  %214 = load i32, i32* %i, align 4
  %idxprom188 = sext i32 %214 to i64
  %arrayidx189 = getelementptr %struct.util_est, %struct.util_est* %213, i64 %idxprom188
  %id190 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx189, i32 0, i32 0
  %215 = load i32, i32* %id190, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %211, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.108, i64 0, i64 0), i32 noundef %215) #8
  br label %if.end191

if.end191:                                        ; preds = %if.then186, %for.body180
  br label %for.inc192

for.inc192:                                       ; preds = %if.end191
  %216 = load i32, i32* %i, align 4
  %inc193 = add i32 %216, 1
  store i32 %inc193, i32* %i, align 4
  br label %for.cond176

for.end194:                                       ; preds = %for.cond176
  br label %if.end195

if.end195:                                        ; preds = %for.end194, %land.lhs.true168, %for.end166
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %218 = bitcast %struct.bpf_verifier_env* %217 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %218, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.109, i64 0, i64 0)) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off, i8* noundef %prefix_fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %prefix_fmt.addr = alloca i8*, align 8
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  store i8* %prefix_fmt, i8** %prefix_fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 18
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #8
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load i32, i32* %insn_off.addr, align 4
  %call1 = call %struct.ethtool_pauseparam* @find_linfo(%struct.bpf_verifier_env* noundef %1, i32 noundef %2) #8
  store %struct.ethtool_pauseparam* %call1, %struct.ethtool_pauseparam** %linfo, align 8
  %3 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %tobool = icmp ne %struct.ethtool_pauseparam* %3, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %4 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 17
  %6 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %prev_linfo, align 8
  %cmp = icmp eq %struct.ethtool_pauseparam* %4, %6
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %7 = load i8*, i8** %prefix_fmt.addr, align 8
  %tobool4 = icmp ne i8* %7, null
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end3
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay6 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay6)
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 18
  %9 = load i8*, i8** %prefix_fmt.addr, align 8
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log7, i8* noundef %9, %struct.__va_list_tag* noundef %arraydecay8) #8
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay910 = bitcast %struct.__va_list_tag* %arraydecay9 to i8*
  call void @llvm.va_end(i8* %arraydecay910)
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end3
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 2
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 7
  %14 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %14, i32 0, i32 24
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %line_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %16, i32 0, i32 2
  %17 = load i32, i32* %line_off, align 4
  %call12 = call i8* @btf_name_by_offset(%struct.btf* noundef %15, i32 noundef %17) #8
  %call13 = call i8* @ltrim(i8* noundef %call12) #8
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.45, i64 0, i64 0), i8* noundef %call13) #8
  %18 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 17
  store %struct.ethtool_pauseparam* %18, %struct.ethtool_pauseparam** %prev_linfo14, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then2, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @print_bpf_insn(%struct.bpf_insn_cbs* noundef, %struct.bpf_insn* noundef, i1 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_alu_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %src_reg141 = alloca %struct.bpf_reg_state*, align 8
  %dst_reg146 = alloca %struct.bpf_reg_state*, align 8
  %size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load i8, i8* %opcode, align 1
  %conv2 = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv2, 208
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i8, i8* %opcode, align 1
  %conv4 = zext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, 128
  br i1 %cmp5, label %if.then, label %if.else83

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i8, i8* %opcode, align 1
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 128
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code11 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code11, align 4
  %conv12 = zext i8 %7 to i32
  %and13 = and i32 %conv12, 8
  %cmp14 = icmp ne i32 %and13, 0
  br i1 %cmp14, label %if.then27, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.then10
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp ne i32 %conv17, 0
  br i1 %cmp18, label %if.then27, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false16
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 2
  %10 = load i16, i16* %off, align 2
  %conv21 = sext i16 %10 to i32
  %cmp22 = icmp ne i32 %conv21, 0
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %lor.lhs.false20
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 3
  %12 = load i32, i32* %imm, align 4
  %cmp25 = icmp ne i32 %12, 0
  br i1 %cmp25, label %if.then27, label %if.end

if.then27:                                        ; preds = %lor.lhs.false24, %lor.lhs.false20, %lor.lhs.false16, %if.then10
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.114, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false24
  br label %if.end58

if.else:                                          ; preds = %if.then
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load29 = load i8, i8* %src_reg28, align 1
  %bf.lshr30 = lshr i8 %bf.load29, 4
  %conv31 = zext i8 %bf.lshr30 to i32
  %cmp32 = icmp ne i32 %conv31, 0
  br i1 %cmp32, label %if.then56, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %if.else
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 2
  %17 = load i16, i16* %off35, align 2
  %conv36 = sext i16 %17 to i32
  %cmp37 = icmp ne i32 %conv36, 0
  br i1 %cmp37, label %if.then56, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 3
  %19 = load i32, i32* %imm40, align 4
  %cmp41 = icmp ne i32 %19, 16
  br i1 %cmp41, label %land.lhs.true, label %lor.lhs.false50

land.lhs.true:                                    ; preds = %lor.lhs.false39
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 3
  %21 = load i32, i32* %imm43, align 4
  %cmp44 = icmp ne i32 %21, 32
  br i1 %cmp44, label %land.lhs.true46, label %lor.lhs.false50

land.lhs.true46:                                  ; preds = %land.lhs.true
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 3
  %23 = load i32, i32* %imm47, align 4
  %cmp48 = icmp ne i32 %23, 64
  br i1 %cmp48, label %if.then56, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true46, %land.lhs.true, %lor.lhs.false39
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 0
  %25 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %25 to i32
  %and53 = and i32 %conv52, 7
  %cmp54 = icmp eq i32 %and53, 7
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %lor.lhs.false50, %land.lhs.true46, %lor.lhs.false34, %if.else
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.115, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %lor.lhs.false50
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load59 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load59, 15
  %conv60 = zext i8 %bf.clear to i32
  %call61 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %28, i32 noundef %conv60, i32 noundef 0) #8
  store i32 %call61, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end58
  %31 = load i32, i32* %err, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.end58
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load65 = load i8, i8* %dst_reg64, align 1
  %bf.clear66 = and i8 %bf.load65, 15
  %conv67 = zext i8 %bf.clear66 to i32
  %call68 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv67) #8
  br i1 %call68, label %if.then69, label %if.end74

if.then69:                                        ; preds = %if.end63
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load71 = load i8, i8* %dst_reg70, align 1
  %bf.clear72 = and i8 %bf.load71, 15
  %conv73 = zext i8 %bf.clear72 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.116, i64 0, i64 0), i32 noundef %conv73) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end63
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load76 = load i8, i8* %dst_reg75, align 1
  %bf.clear77 = and i8 %bf.load76, 15
  %conv78 = zext i8 %bf.clear77 to i32
  %call79 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %37, i32 noundef %conv78, i32 noundef 1) #8
  store i32 %call79, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool80 = icmp ne i32 %39, 0
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end74
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.end74
  br label %if.end336

if.else83:                                        ; preds = %lor.lhs.false
  %41 = load i8, i8* %opcode, align 1
  %conv84 = zext i8 %41 to i32
  %cmp85 = icmp eq i32 %conv84, 176
  br i1 %cmp85, label %if.then87, label %if.else219

if.then87:                                        ; preds = %if.else83
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code88 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code88, align 4
  %conv89 = zext i8 %43 to i32
  %and90 = and i32 %conv89, 8
  %cmp91 = icmp eq i32 %and90, 8
  br i1 %cmp91, label %if.then93, label %if.else112

if.then93:                                        ; preds = %if.then87
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm94, align 4
  %cmp95 = icmp ne i32 %45, 0
  br i1 %cmp95, label %if.then102, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.then93
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 2
  %47 = load i16, i16* %off98, align 2
  %conv99 = sext i16 %47 to i32
  %cmp100 = icmp ne i32 %conv99, 0
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %lor.lhs.false97, %if.then93
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.117, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %lor.lhs.false97
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg104, align 1
  %bf.lshr106 = lshr i8 %bf.load105, 4
  %conv107 = zext i8 %bf.lshr106 to i32
  %call108 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %50, i32 noundef %conv107, i32 noundef 0) #8
  store i32 %call108, i32* %err, align 4
  %52 = load i32, i32* %err, align 4
  %tobool109 = icmp ne i32 %52, 0
  br i1 %tobool109, label %if.then110, label %if.end111

if.then110:                                       ; preds = %if.end103
  %53 = load i32, i32* %err, align 4
  store i32 %53, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %if.end103
  br label %if.end126

if.else112:                                       ; preds = %if.then87
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %54, i32 0, i32 1
  %bf.load114 = load i8, i8* %src_reg113, align 1
  %bf.lshr115 = lshr i8 %bf.load114, 4
  %conv116 = zext i8 %bf.lshr115 to i32
  %cmp117 = icmp ne i32 %conv116, 0
  br i1 %cmp117, label %if.then124, label %lor.lhs.false119

lor.lhs.false119:                                 ; preds = %if.else112
  %55 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off120 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %55, i32 0, i32 2
  %56 = load i16, i16* %off120, align 2
  %conv121 = sext i16 %56 to i32
  %cmp122 = icmp ne i32 %conv121, 0
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %lor.lhs.false119, %if.else112
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.117, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end125:                                        ; preds = %lor.lhs.false119
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.end111
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg127 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 1
  %bf.load128 = load i8, i8* %dst_reg127, align 1
  %bf.clear129 = and i8 %bf.load128, 15
  %conv130 = zext i8 %bf.clear129 to i32
  %call131 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %59, i32 noundef %conv130, i32 noundef 2) #8
  store i32 %call131, i32* %err, align 4
  %61 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %61, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end126
  %62 = load i32, i32* %err, align 4
  store i32 %62, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end126
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %63, i32 0, i32 0
  %64 = load i8, i8* %code135, align 4
  %conv136 = zext i8 %64 to i32
  %and137 = and i32 %conv136, 8
  %cmp138 = icmp eq i32 %and137, 8
  br i1 %cmp138, label %if.then140, label %if.else185

if.then140:                                       ; preds = %if.end134
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg142 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %66, i32 0, i32 1
  %bf.load143 = load i8, i8* %src_reg142, align 1
  %bf.lshr144 = lshr i8 %bf.load143, 4
  %conv145 = zext i8 %bf.lshr144 to i32
  %idx.ext = sext i32 %conv145 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %src_reg141, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg147 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %68, i32 0, i32 1
  %bf.load148 = load i8, i8* %dst_reg147, align 1
  %bf.clear149 = and i8 %bf.load148, 15
  %conv150 = zext i8 %bf.clear149 to i32
  %idx.ext151 = sext i32 %conv150 to i64
  %add.ptr152 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i64 %idx.ext151
  store %struct.bpf_reg_state* %add.ptr152, %struct.bpf_reg_state** %dst_reg146, align 8
  %69 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %69, i32 0, i32 0
  %70 = load i8, i8* %code153, align 4
  %conv154 = zext i8 %70 to i32
  %and155 = and i32 %conv154, 7
  %cmp156 = icmp eq i32 %and155, 7
  br i1 %cmp156, label %if.then158, label %if.else159

if.then158:                                       ; preds = %if.then140
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %73 = bitcast %struct.bpf_reg_state* %71 to i8*
  %74 = bitcast %struct.bpf_reg_state* %72 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %73, i8* align 8 %74, i64 104, i1 false)
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 13
  %76 = load i32, i32* %live, align 8
  %or = or i32 %76, 4
  store i32 %or, i32* %live, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 12
  store i32 0, i32* %subreg_def, align 4
  br label %if.end184

if.else159:                                       ; preds = %if.then140
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg160 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %79, i32 0, i32 1
  %bf.load161 = load i8, i8* %src_reg160, align 1
  %bf.lshr162 = lshr i8 %bf.load161, 4
  %conv163 = zext i8 %bf.lshr162 to i32
  %call164 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %78, i32 noundef %conv163) #8
  br i1 %call164, label %if.then165, label %if.else170

if.then165:                                       ; preds = %if.else159
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = bitcast %struct.bpf_verifier_env* %80 to i8*
  %82 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg166 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %82, i32 0, i32 1
  %bf.load167 = load i8, i8* %src_reg166, align 1
  %bf.lshr168 = lshr i8 %bf.load167, 4
  %conv169 = zext i8 %bf.lshr168 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %81, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.118, i64 0, i64 0), i32 noundef %conv169) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.else170:                                       ; preds = %if.else159
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 0
  %84 = load i32, i32* %type, align 8
  %cmp171 = icmp eq i32 %84, 1
  br i1 %cmp171, label %if.then173, label %if.else177

if.then173:                                       ; preds = %if.else170
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %87 = bitcast %struct.bpf_reg_state* %85 to i8*
  %88 = bitcast %struct.bpf_reg_state* %86 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %87, i8* align 8 %88, i64 104, i1 false)
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 13
  %90 = load i32, i32* %live174, align 8
  %or175 = or i32 %90, 4
  store i32 %or175, i32* %live174, align 8
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 0
  %92 = load i32, i32* %insn_idx, align 8
  %add = add i32 %92, 1
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %93, i32 0, i32 12
  store i32 %add, i32* %subreg_def176, align 4
  br label %if.end182

if.else177:                                       ; preds = %if.else170
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %96 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg178 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %96, i32 0, i32 1
  %bf.load179 = load i8, i8* %dst_reg178, align 1
  %bf.clear180 = and i8 %bf.load179, 15
  %conv181 = zext i8 %bf.clear180 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %94, %struct.bpf_reg_state* noundef %95, i32 noundef %conv181) #8
  br label %if.end182

if.end182:                                        ; preds = %if.else177, %if.then173
  br label %if.end183

if.end183:                                        ; preds = %if.end182
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %97, i32 noundef 4) #8
  br label %if.end184

if.end184:                                        ; preds = %if.end183, %if.then158
  br label %if.end218

if.else185:                                       ; preds = %if.end134
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %100 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg186 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %100, i32 0, i32 1
  %bf.load187 = load i8, i8* %dst_reg186, align 1
  %bf.clear188 = and i8 %bf.load187, 15
  %conv189 = zext i8 %bf.clear188 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %98, %struct.bpf_reg_state* noundef %99, i32 noundef %conv189) #8
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %102 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg190 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %102, i32 0, i32 1
  %bf.load191 = load i8, i8* %dst_reg190, align 1
  %bf.clear192 = and i8 %bf.load191, 15
  %idxprom = zext i8 %bf.clear192 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i64 %idxprom
  %type193 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type193, align 8
  %103 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code194 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %103, i32 0, i32 0
  %104 = load i8, i8* %code194, align 4
  %conv195 = zext i8 %104 to i32
  %and196 = and i32 %conv195, 7
  %cmp197 = icmp eq i32 %and196, 7
  br i1 %cmp197, label %if.then199, label %if.else208

if.then199:                                       ; preds = %if.else185
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %106 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg200 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %106, i32 0, i32 1
  %bf.load201 = load i8, i8* %dst_reg200, align 1
  %bf.clear202 = and i8 %bf.load201, 15
  %conv203 = zext i8 %bf.clear202 to i32
  %idx.ext204 = sext i32 %conv203 to i64
  %add.ptr205 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i64 %idx.ext204
  %107 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm206 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %107, i32 0, i32 3
  %108 = load i32, i32* %imm206, align 4
  %conv207 = sext i32 %108 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr205, i64 noundef %conv207) #8
  br label %if.end217

if.else208:                                       ; preds = %if.else185
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %110 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %110, i32 0, i32 1
  %bf.load210 = load i8, i8* %dst_reg209, align 1
  %bf.clear211 = and i8 %bf.load210, 15
  %conv212 = zext i8 %bf.clear211 to i32
  %idx.ext213 = sext i32 %conv212 to i64
  %add.ptr214 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i64 %idx.ext213
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm215 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 3
  %112 = load i32, i32* %imm215, align 4
  %conv216 = zext i32 %112 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr214, i64 noundef %conv216) #8
  br label %if.end217

if.end217:                                        ; preds = %if.else208, %if.then199
  br label %if.end218

if.end218:                                        ; preds = %if.end217, %if.end184
  br label %if.end335

if.else219:                                       ; preds = %if.else83
  %113 = load i8, i8* %opcode, align 1
  %conv220 = zext i8 %113 to i32
  %cmp221 = icmp sgt i32 %conv220, 208
  br i1 %cmp221, label %if.then223, label %if.else225

if.then223:                                       ; preds = %if.else219
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = bitcast %struct.bpf_verifier_env* %114 to i8*
  %116 = load i8, i8* %opcode, align 1
  %conv224 = zext i8 %116 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %115, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.119, i64 0, i64 0), i32 noundef %conv224) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.else225:                                       ; preds = %if.else219
  %117 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code226 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %117, i32 0, i32 0
  %118 = load i8, i8* %code226, align 4
  %conv227 = zext i8 %118 to i32
  %and228 = and i32 %conv227, 8
  %cmp229 = icmp eq i32 %and228, 8
  br i1 %cmp229, label %if.then231, label %if.else250

if.then231:                                       ; preds = %if.else225
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm232 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 3
  %120 = load i32, i32* %imm232, align 4
  %cmp233 = icmp ne i32 %120, 0
  br i1 %cmp233, label %if.then240, label %lor.lhs.false235

lor.lhs.false235:                                 ; preds = %if.then231
  %121 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off236 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %121, i32 0, i32 2
  %122 = load i16, i16* %off236, align 2
  %conv237 = sext i16 %122 to i32
  %cmp238 = icmp ne i32 %conv237, 0
  br i1 %cmp238, label %if.then240, label %if.end241

if.then240:                                       ; preds = %lor.lhs.false235, %if.then231
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %124 = bitcast %struct.bpf_verifier_env* %123 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %124, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.120, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end241:                                        ; preds = %lor.lhs.false235
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %126 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg242 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %126, i32 0, i32 1
  %bf.load243 = load i8, i8* %src_reg242, align 1
  %bf.lshr244 = lshr i8 %bf.load243, 4
  %conv245 = zext i8 %bf.lshr244 to i32
  %call246 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %125, i32 noundef %conv245, i32 noundef 0) #8
  store i32 %call246, i32* %err, align 4
  %127 = load i32, i32* %err, align 4
  %tobool247 = icmp ne i32 %127, 0
  br i1 %tobool247, label %if.then248, label %if.end249

if.then248:                                       ; preds = %if.end241
  %128 = load i32, i32* %err, align 4
  store i32 %128, i32* %retval, align 4
  br label %return

if.end249:                                        ; preds = %if.end241
  br label %if.end264

if.else250:                                       ; preds = %if.else225
  %129 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %129, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %conv254 = zext i8 %bf.lshr253 to i32
  %cmp255 = icmp ne i32 %conv254, 0
  br i1 %cmp255, label %if.then262, label %lor.lhs.false257

lor.lhs.false257:                                 ; preds = %if.else250
  %130 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off258 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %130, i32 0, i32 2
  %131 = load i16, i16* %off258, align 2
  %conv259 = sext i16 %131 to i32
  %cmp260 = icmp ne i32 %conv259, 0
  br i1 %cmp260, label %if.then262, label %if.end263

if.then262:                                       ; preds = %lor.lhs.false257, %if.else250
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %133 = bitcast %struct.bpf_verifier_env* %132 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %133, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.120, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end263:                                        ; preds = %lor.lhs.false257
  br label %if.end264

if.end264:                                        ; preds = %if.end263, %if.end249
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %135 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg265 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %135, i32 0, i32 1
  %bf.load266 = load i8, i8* %dst_reg265, align 1
  %bf.clear267 = and i8 %bf.load266, 15
  %conv268 = zext i8 %bf.clear267 to i32
  %call269 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %134, i32 noundef %conv268, i32 noundef 0) #8
  store i32 %call269, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool270 = icmp ne i32 %136, 0
  br i1 %tobool270, label %if.then271, label %if.end272

if.then271:                                       ; preds = %if.end264
  %137 = load i32, i32* %err, align 4
  store i32 %137, i32* %retval, align 4
  br label %return

if.end272:                                        ; preds = %if.end264
  %138 = load i8, i8* %opcode, align 1
  %conv273 = zext i8 %138 to i32
  %cmp274 = icmp eq i32 %conv273, 144
  br i1 %cmp274, label %land.lhs.true280, label %lor.lhs.false276

lor.lhs.false276:                                 ; preds = %if.end272
  %139 = load i8, i8* %opcode, align 1
  %conv277 = zext i8 %139 to i32
  %cmp278 = icmp eq i32 %conv277, 48
  br i1 %cmp278, label %land.lhs.true280, label %if.end291

land.lhs.true280:                                 ; preds = %lor.lhs.false276, %if.end272
  %140 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code281 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %140, i32 0, i32 0
  %141 = load i8, i8* %code281, align 4
  %conv282 = zext i8 %141 to i32
  %and283 = and i32 %conv282, 8
  %cmp284 = icmp eq i32 %and283, 0
  br i1 %cmp284, label %land.lhs.true286, label %if.end291

land.lhs.true286:                                 ; preds = %land.lhs.true280
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm287 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %142, i32 0, i32 3
  %143 = load i32, i32* %imm287, align 4
  %cmp288 = icmp eq i32 %143, 0
  br i1 %cmp288, label %if.then290, label %if.end291

if.then290:                                       ; preds = %land.lhs.true286
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %145 = bitcast %struct.bpf_verifier_env* %144 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %145, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.121, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end291:                                        ; preds = %land.lhs.true286, %land.lhs.true280, %lor.lhs.false276
  %146 = load i8, i8* %opcode, align 1
  %conv292 = zext i8 %146 to i32
  %cmp293 = icmp eq i32 %conv292, 96
  br i1 %cmp293, label %land.lhs.true303, label %lor.lhs.false295

lor.lhs.false295:                                 ; preds = %if.end291
  %147 = load i8, i8* %opcode, align 1
  %conv296 = zext i8 %147 to i32
  %cmp297 = icmp eq i32 %conv296, 112
  br i1 %cmp297, label %land.lhs.true303, label %lor.lhs.false299

lor.lhs.false299:                                 ; preds = %lor.lhs.false295
  %148 = load i8, i8* %opcode, align 1
  %conv300 = zext i8 %148 to i32
  %cmp301 = icmp eq i32 %conv300, 192
  br i1 %cmp301, label %land.lhs.true303, label %if.end325

land.lhs.true303:                                 ; preds = %lor.lhs.false299, %lor.lhs.false295, %if.end291
  %149 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code304 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %149, i32 0, i32 0
  %150 = load i8, i8* %code304, align 4
  %conv305 = zext i8 %150 to i32
  %and306 = and i32 %conv305, 8
  %cmp307 = icmp eq i32 %and306, 0
  br i1 %cmp307, label %if.then309, label %if.end325

if.then309:                                       ; preds = %land.lhs.true303
  %151 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code310 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %151, i32 0, i32 0
  %152 = load i8, i8* %code310, align 4
  %conv311 = zext i8 %152 to i32
  %and312 = and i32 %conv311, 7
  %cmp313 = icmp eq i32 %and312, 7
  %153 = zext i1 %cmp313 to i64
  %cond = select i1 %cmp313, i32 64, i32 32
  store i32 %cond, i32* %size, align 4
  %154 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm315 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %154, i32 0, i32 3
  %155 = load i32, i32* %imm315, align 4
  %cmp316 = icmp slt i32 %155, 0
  br i1 %cmp316, label %if.then322, label %lor.lhs.false318

lor.lhs.false318:                                 ; preds = %if.then309
  %156 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %156, i32 0, i32 3
  %157 = load i32, i32* %imm319, align 4
  %158 = load i32, i32* %size, align 4
  %cmp320 = icmp sge i32 %157, %158
  br i1 %cmp320, label %if.then322, label %if.end324

if.then322:                                       ; preds = %lor.lhs.false318, %if.then309
  %159 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %160 = bitcast %struct.bpf_verifier_env* %159 to i8*
  %161 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm323 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %161, i32 0, i32 3
  %162 = load i32, i32* %imm323, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %160, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.122, i64 0, i64 0), i32 noundef %162) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end324:                                        ; preds = %lor.lhs.false318
  br label %if.end325

if.end325:                                        ; preds = %if.end324, %land.lhs.true303, %lor.lhs.false299
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %164 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg326 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %164, i32 0, i32 1
  %bf.load327 = load i8, i8* %dst_reg326, align 1
  %bf.clear328 = and i8 %bf.load327, 15
  %conv329 = zext i8 %bf.clear328 to i32
  %call330 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %163, i32 noundef %conv329, i32 noundef 2) #8
  store i32 %call330, i32* %err, align 4
  %165 = load i32, i32* %err, align 4
  %tobool331 = icmp ne i32 %165, 0
  br i1 %tobool331, label %if.then332, label %if.end333

if.then332:                                       ; preds = %if.end325
  %166 = load i32, i32* %err, align 4
  store i32 %166, i32* %retval, align 4
  br label %return

if.end333:                                        ; preds = %if.end325
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %168 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call334 = call i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %167, %struct.bpf_insn* noundef %168) #8
  store i32 %call334, i32* %retval, align 4
  br label %return

if.end335:                                        ; preds = %if.end218
  br label %if.end336

if.end336:                                        ; preds = %if.end335, %if.end82
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end336, %if.end333, %if.then332, %if.then322, %if.then290, %if.then271, %if.then262, %if.then248, %if.then240, %if.then223, %if.then165, %if.then133, %if.then124, %if.then110, %if.then102, %if.then81, %if.then69, %if.then62, %if.then56, %if.then27
  %169 = load i32, i32* %retval, align 4
  ret i32 %169
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %rw64 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %8 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 0
  %10 = load i32, i32* %insn_idx, align 8
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay2, %struct.bpf_reg_state** %regs, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %12, 11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.152, i64 0, i64 0), i32 noundef %15) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %17 = load i32, i32* %regno.addr, align 4
  %idxprom3 = zext i32 %17 to i64
  %arrayidx4 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i64 %idxprom3
  store %struct.bpf_reg_state* %arrayidx4, %struct.bpf_reg_state** %reg, align 8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %20 = load i32, i32* %regno.addr, align 4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %22 = load i32, i32* %t.addr, align 4
  %call = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %18, %struct.bpf_insn* noundef %19, i32 noundef %20, %struct.bpf_reg_state* noundef %21, i32 noundef %22) #8
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %rw64, align 1
  %23 = load i32, i32* %t.addr, align 4
  %cmp5 = icmp eq i32 %23, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type, align 8
  %cmp7 = icmp eq i32 %25, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.153, i64 0, i64 0), i32 noundef %28) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then6
  %29 = load i32, i32* %regno.addr, align 4
  %cmp10 = icmp eq i32 %29, 10
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  store i32 0, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %30 = load i8, i8* %rw64, align 1
  %tobool = trunc i8 %30 to i1
  br i1 %tobool, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %31, %struct.bpf_reg_state* noundef %32) #8
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end12
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 10
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %37 = load i8, i8* %rw64, align 1
  %tobool15 = trunc i8 %37 to i1
  %38 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 2, i32 1
  %conv = trunc i32 %cond to i8
  %call16 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %33, %struct.bpf_reg_state* noundef %34, %struct.bpf_reg_state* noundef %36, i8 noundef zeroext %conv) #8
  store i32 %call16, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %39 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp eq i32 %39, 10
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.else
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.154, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.else
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 13
  %43 = load i32, i32* %live, align 8
  %or = or i32 %43, 4
  store i32 %or, i32* %live, align 8
  %44 = load i8, i8* %rw64, align 1
  %tobool21 = trunc i8 %44 to i1
  br i1 %tobool21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end20
  br label %cond.end

cond.false:                                       ; preds = %if.end20
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 0
  %46 = load i32, i32* %insn_idx23, align 8
  %add = add i32 %46, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond24 = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 12
  store i32 %cond24, i32* %subreg_def, align 4
  %48 = load i32, i32* %t.addr, align 4
  %cmp25 = icmp eq i32 %48, 1
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %cond.end
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %51 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %49, %struct.bpf_reg_state* noundef %50, i32 noundef %51) #8
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %cond.end
  br label %if.end29

if.end29:                                         ; preds = %if.end28
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then19, %if.end14, %if.then11, %if.then8, %if.then
  %52 = load i32, i32* %retval, align 4
  ret i32 %52
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %bpf_size, i32 noundef %t, i32 noundef %value_regno, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %bpf_size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %size = alloca i32, align 4
  %err = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %reg_type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %bpf_size, i32* %bpf_size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  store i32 0, i32* %err, align 4
  store i32 -22, i32* %bytes, align 4
  %3 = load i32, i32* %bpf_size.addr, align 4
  %cmp = icmp eq i32 %3, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %bytes, align 4
  br label %if.end11

if.else:                                          ; preds = %entry
  %4 = load i32, i32* %bpf_size.addr, align 4
  %cmp1 = icmp eq i32 %4, 8
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i32 2, i32* %bytes, align 4
  br label %if.end10

if.else3:                                         ; preds = %if.else
  %5 = load i32, i32* %bpf_size.addr, align 4
  %cmp4 = icmp eq i32 %5, 0
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else3
  store i32 4, i32* %bytes, align 4
  br label %if.end9

if.else6:                                         ; preds = %if.else3
  %6 = load i32, i32* %bpf_size.addr, align 4
  %cmp7 = icmp eq i32 %6, 24
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else6
  store i32 8, i32* %bytes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.else6
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then2
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  %7 = load i32, i32* %bytes, align 4
  store i32 %7, i32* %tmp, align 4
  %8 = load i32, i32* %tmp, align 4
  store i32 %8, i32* %size, align 4
  %9 = load i32, i32* %size, align 4
  %cmp12 = icmp slt i32 %9, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %10 = load i32, i32* %size, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size, align 4
  %15 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool = trunc i8 %15 to i1
  %call15 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i32 noundef %13, i32 noundef %14, i1 noundef zeroext %tobool) #8
  store i32 %call15, i32* %err, align 4
  %16 = load i32, i32* %err, align 4
  %tobool16 = icmp ne i32 %16, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %17 = load i32, i32* %err, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end14
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %19 = load i32, i32* %off19, align 8
  %20 = load i32, i32* %off.addr, align 4
  %add = add i32 %20, %19
  store i32 %add, i32* %off.addr, align 4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type, align 8
  %cmp20 = icmp eq i32 %22, 4
  br i1 %cmp20, label %if.then21, label %if.else40

if.then21:                                        ; preds = %if.end18
  %23 = load i32, i32* %t.addr, align 4
  %cmp22 = icmp eq i32 %23, 2
  br i1 %cmp22, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.then21
  %24 = load i32, i32* %value_regno.addr, align 4
  %cmp23 = icmp sge i32 %24, 0
  br i1 %cmp23, label %land.lhs.true24, label %if.end27

land.lhs.true24:                                  ; preds = %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %value_regno.addr, align 4
  %call25 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #8
  br i1 %call25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true24
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.155, i64 0, i64 0), i32 noundef %29) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %land.lhs.true24, %land.lhs.true, %if.then21
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load i32, i32* %off.addr, align 4
  %33 = load i32, i32* %size, align 4
  %34 = load i32, i32* %t.addr, align 4
  %call28 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %30, i32 noundef %31, i32 noundef %32, i32 noundef %33, i32 noundef %34) #8
  store i32 %call28, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool29 = icmp ne i32 %35, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end27
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load i32, i32* %off.addr, align 4
  %40 = load i32, i32* %size, align 4
  %call32 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %37, i32 noundef %38, i32 noundef %39, i32 noundef %40, i1 noundef zeroext false) #8
  store i32 %call32, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool33 = icmp ne i32 %41, 0
  br i1 %tobool33, label %if.end39, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %if.end31
  %42 = load i32, i32* %t.addr, align 4
  %cmp35 = icmp eq i32 %42, 1
  br i1 %cmp35, label %land.lhs.true36, label %if.end39

land.lhs.true36:                                  ; preds = %land.lhs.true34
  %43 = load i32, i32* %value_regno.addr, align 4
  %cmp37 = icmp sge i32 %43, 0
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %land.lhs.true36
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %46 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45, i32 noundef %46) #8
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %land.lhs.true36, %land.lhs.true34, %if.end31
  br label %if.end194

if.else40:                                        ; preds = %if.end18
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 0
  %48 = load i32, i32* %type41, align 8
  %cmp42 = icmp eq i32 %48, 2
  br i1 %cmp42, label %if.then43, label %if.else75

if.then43:                                        ; preds = %if.else40
  store i32 1, i32* %reg_type, align 4
  %49 = load i32, i32* %t.addr, align 4
  %cmp44 = icmp eq i32 %49, 2
  br i1 %cmp44, label %land.lhs.true45, label %if.end50

land.lhs.true45:                                  ; preds = %if.then43
  %50 = load i32, i32* %value_regno.addr, align 4
  %cmp46 = icmp sge i32 %50, 0
  br i1 %cmp46, label %land.lhs.true47, label %if.end50

land.lhs.true47:                                  ; preds = %land.lhs.true45
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load i32, i32* %value_regno.addr, align 4
  %call48 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %51, i32 noundef %52) #8
  br i1 %call48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true47
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.156, i64 0, i64 0), i32 noundef %55) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end50:                                         ; preds = %land.lhs.true47, %land.lhs.true45, %if.then43
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %58 = load i32, i32* %regno.addr, align 4
  %call51 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %57, i32 noundef %58) #8
  store i32 %call51, i32* %err, align 4
  %59 = load i32, i32* %err, align 4
  %cmp52 = icmp slt i32 %59, 0
  br i1 %cmp52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end50
  %60 = load i32, i32* %err, align 4
  store i32 %60, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end50
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load i32, i32* %insn_idx.addr, align 4
  %63 = load i32, i32* %off.addr, align 4
  %64 = load i32, i32* %size, align 4
  %65 = load i32, i32* %t.addr, align 4
  %call55 = call i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %61, i32 noundef %62, i32 noundef %63, i32 noundef %64, i32 noundef %65, i32* noundef %reg_type) #8
  store i32 %call55, i32* %err, align 4
  %66 = load i32, i32* %err, align 4
  %tobool56 = icmp ne i32 %66, 0
  br i1 %tobool56, label %if.end74, label %land.lhs.true57

land.lhs.true57:                                  ; preds = %if.end54
  %67 = load i32, i32* %t.addr, align 4
  %cmp58 = icmp eq i32 %67, 1
  br i1 %cmp58, label %land.lhs.true59, label %if.end74

land.lhs.true59:                                  ; preds = %land.lhs.true57
  %68 = load i32, i32* %value_regno.addr, align 4
  %cmp60 = icmp sge i32 %68, 0
  br i1 %cmp60, label %if.then61, label %if.end74

if.then61:                                        ; preds = %land.lhs.true59
  %69 = load i32, i32* %reg_type, align 4
  %cmp62 = icmp eq i32 %69, 1
  br i1 %cmp62, label %if.then63, label %if.else64

if.then63:                                        ; preds = %if.then61
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %72 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %70, %struct.bpf_reg_state* noundef %71, i32 noundef %72) #8
  br label %if.end70

if.else64:                                        ; preds = %if.then61
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %75 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %73, %struct.bpf_reg_state* noundef %74, i32 noundef %75) #8
  %76 = load i32, i32* %reg_type, align 4
  %call65 = call zeroext i1 @reg_type_may_be_null(i32 noundef %76) #8
  br i1 %call65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.else64
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %77, i32 0, i32 13
  %78 = load i32, i32* %id_gen, align 4
  %inc = add i32 %78, 1
  store i32 %inc, i32* %id_gen, align 4
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %80 = load i32, i32* %value_regno.addr, align 4
  %idxprom = sext i32 %80 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %79, i64 %idxprom
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 3
  store i32 %inc, i32* %id, align 4
  br label %if.end67

if.end67:                                         ; preds = %if.then66, %if.else64
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %82 = load i32, i32* %value_regno.addr, align 4
  %idxprom68 = sext i32 %82 to i64
  %arrayidx69 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i64 %idxprom68
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx69, i32 0, i32 12
  store i32 0, i32* %subreg_def, align 4
  br label %if.end70

if.end70:                                         ; preds = %if.end67, %if.then63
  %83 = load i32, i32* %reg_type, align 4
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %85 = load i32, i32* %value_regno.addr, align 4
  %idxprom71 = sext i32 %85 to i64
  %arrayidx72 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i64 %idxprom71
  %type73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx72, i32 0, i32 0
  store i32 %83, i32* %type73, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.end70, %land.lhs.true59, %land.lhs.true57, %if.end54
  br label %if.end193

if.else75:                                        ; preds = %if.else40
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 0
  %87 = load i32, i32* %type76, align 8
  %cmp77 = icmp eq i32 %87, 6
  br i1 %cmp77, label %if.then78, label %if.else97

if.then78:                                        ; preds = %if.else75
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %89 = load i64, i64* %value, align 8
  %90 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %90 to i64
  %add79 = add i64 %conv, %89
  %conv80 = trunc i64 %add79 to i32
  store i32 %conv80, i32* %off.addr, align 4
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %93 = load i32, i32* %off.addr, align 4
  %94 = load i32, i32* %size, align 4
  %call81 = call i32 @check_stack_access(%struct.bpf_verifier_env* noundef %91, %struct.bpf_reg_state* noundef %92, i32 noundef %93, i32 noundef %94) #8
  store i32 %call81, i32* %err, align 4
  %95 = load i32, i32* %err, align 4
  %tobool82 = icmp ne i32 %95, 0
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.then78
  %96 = load i32, i32* %err, align 4
  store i32 %96, i32* %retval, align 4
  br label %return

if.end84:                                         ; preds = %if.then78
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call85 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %97, %struct.bpf_reg_state* noundef %98) #8
  store %struct.bpf_func_state* %call85, %struct.bpf_func_state** %state, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %101 = load i32, i32* %off.addr, align 4
  %call86 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %99, %struct.bpf_func_state* noundef %100, i32 noundef %101) #8
  store i32 %call86, i32* %err, align 4
  %102 = load i32, i32* %err, align 4
  %tobool87 = icmp ne i32 %102, 0
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.end84
  %103 = load i32, i32* %err, align 4
  store i32 %103, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.end84
  %104 = load i32, i32* %t.addr, align 4
  %cmp90 = icmp eq i32 %104, 2
  br i1 %cmp90, label %if.then92, label %if.else94

if.then92:                                        ; preds = %if.end89
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %107 = load i32, i32* %off.addr, align 4
  %108 = load i32, i32* %size, align 4
  %109 = load i32, i32* %value_regno.addr, align 4
  %110 = load i32, i32* %insn_idx.addr, align 4
  %call93 = call i32 @check_stack_write(%struct.bpf_verifier_env* noundef %105, %struct.bpf_func_state* noundef %106, i32 noundef %107, i32 noundef %108, i32 noundef %109, i32 noundef %110) #8
  store i32 %call93, i32* %err, align 4
  br label %if.end96

if.else94:                                        ; preds = %if.end89
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %112 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %113 = load i32, i32* %off.addr, align 4
  %114 = load i32, i32* %size, align 4
  %115 = load i32, i32* %value_regno.addr, align 4
  %call95 = call i32 @check_stack_read(%struct.bpf_verifier_env* noundef %111, %struct.bpf_func_state* noundef %112, i32 noundef %113, i32 noundef %114, i32 noundef %115) #8
  store i32 %call95, i32* %err, align 4
  br label %if.end96

if.end96:                                         ; preds = %if.else94, %if.then92
  br label %if.end192

if.else97:                                        ; preds = %if.else75
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call98 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %116) #8
  br i1 %call98, label %if.then99, label %if.else126

if.then99:                                        ; preds = %if.else97
  %117 = load i32, i32* %t.addr, align 4
  %cmp100 = icmp eq i32 %117, 2
  br i1 %cmp100, label %land.lhs.true102, label %if.end105

land.lhs.true102:                                 ; preds = %if.then99
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %119 = load i32, i32* %t.addr, align 4
  %call103 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %118, %struct.bpf_call_arg_meta* noundef null, i32 noundef %119) #8
  br i1 %call103, label %if.end105, label %if.then104

if.then104:                                       ; preds = %land.lhs.true102
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %121 = bitcast %struct.bpf_verifier_env* %120 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %121, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.157, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %land.lhs.true102, %if.then99
  %122 = load i32, i32* %t.addr, align 4
  %cmp106 = icmp eq i32 %122, 2
  br i1 %cmp106, label %land.lhs.true108, label %if.end115

land.lhs.true108:                                 ; preds = %if.end105
  %123 = load i32, i32* %value_regno.addr, align 4
  %cmp109 = icmp sge i32 %123, 0
  br i1 %cmp109, label %land.lhs.true111, label %if.end115

land.lhs.true111:                                 ; preds = %land.lhs.true108
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = load i32, i32* %value_regno.addr, align 4
  %call112 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %124, i32 noundef %125) #8
  br i1 %call112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %land.lhs.true111
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %127 = bitcast %struct.bpf_verifier_env* %126 to i8*
  %128 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %127, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.158, i64 0, i64 0), i32 noundef %128) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %land.lhs.true111, %land.lhs.true108, %if.end105
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %130 = load i32, i32* %regno.addr, align 4
  %131 = load i32, i32* %off.addr, align 4
  %132 = load i32, i32* %size, align 4
  %call116 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %129, i32 noundef %130, i32 noundef %131, i32 noundef %132, i1 noundef zeroext false) #8
  store i32 %call116, i32* %err, align 4
  %133 = load i32, i32* %err, align 4
  %tobool117 = icmp ne i32 %133, 0
  br i1 %tobool117, label %if.end125, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.end115
  %134 = load i32, i32* %t.addr, align 4
  %cmp119 = icmp eq i32 %134, 1
  br i1 %cmp119, label %land.lhs.true121, label %if.end125

land.lhs.true121:                                 ; preds = %land.lhs.true118
  %135 = load i32, i32* %value_regno.addr, align 4
  %cmp122 = icmp sge i32 %135, 0
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %land.lhs.true121
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %137 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %138 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %136, %struct.bpf_reg_state* noundef %137, i32 noundef %138) #8
  br label %if.end125

if.end125:                                        ; preds = %if.then124, %land.lhs.true121, %land.lhs.true118, %if.end115
  br label %if.end191

if.else126:                                       ; preds = %if.else97
  %139 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %139, i32 0, i32 0
  %140 = load i32, i32* %type127, align 8
  %cmp128 = icmp eq i32 %140, 10
  br i1 %cmp128, label %if.then130, label %if.else151

if.then130:                                       ; preds = %if.else126
  %141 = load i32, i32* %t.addr, align 4
  %cmp131 = icmp eq i32 %141, 2
  br i1 %cmp131, label %land.lhs.true133, label %if.end140

land.lhs.true133:                                 ; preds = %if.then130
  %142 = load i32, i32* %value_regno.addr, align 4
  %cmp134 = icmp sge i32 %142, 0
  br i1 %cmp134, label %land.lhs.true136, label %if.end140

land.lhs.true136:                                 ; preds = %land.lhs.true133
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %144 = load i32, i32* %value_regno.addr, align 4
  %call137 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %143, i32 noundef %144) #8
  br i1 %call137, label %if.then139, label %if.end140

if.then139:                                       ; preds = %land.lhs.true136
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %146 = bitcast %struct.bpf_verifier_env* %145 to i8*
  %147 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %146, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.159, i64 0, i64 0), i32 noundef %147) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end140:                                        ; preds = %land.lhs.true136, %land.lhs.true133, %if.then130
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %149 = load i32, i32* %off.addr, align 4
  %150 = load i32, i32* %size, align 4
  %call141 = call i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %148, i32 noundef %149, i32 noundef %150) #8
  store i32 %call141, i32* %err, align 4
  %151 = load i32, i32* %err, align 4
  %tobool142 = icmp ne i32 %151, 0
  br i1 %tobool142, label %if.end150, label %land.lhs.true143

land.lhs.true143:                                 ; preds = %if.end140
  %152 = load i32, i32* %t.addr, align 4
  %cmp144 = icmp eq i32 %152, 1
  br i1 %cmp144, label %land.lhs.true146, label %if.end150

land.lhs.true146:                                 ; preds = %land.lhs.true143
  %153 = load i32, i32* %value_regno.addr, align 4
  %cmp147 = icmp sge i32 %153, 0
  br i1 %cmp147, label %if.then149, label %if.end150

if.then149:                                       ; preds = %land.lhs.true146
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %156 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %154, %struct.bpf_reg_state* noundef %155, i32 noundef %156) #8
  br label %if.end150

if.end150:                                        ; preds = %if.then149, %land.lhs.true146, %land.lhs.true143, %if.end140
  br label %if.end190

if.else151:                                       ; preds = %if.else126
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type152 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %157, i32 0, i32 0
  %158 = load i32, i32* %type152, align 8
  %call153 = call zeroext i1 @type_is_sk_pointer(i32 noundef %158) #8
  br i1 %call153, label %if.then154, label %if.else169

if.then154:                                       ; preds = %if.else151
  %159 = load i32, i32* %t.addr, align 4
  %cmp155 = icmp eq i32 %159, 2
  br i1 %cmp155, label %if.then157, label %if.end161

if.then157:                                       ; preds = %if.then154
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %161 = bitcast %struct.bpf_verifier_env* %160 to i8*
  %162 = load i32, i32* %regno.addr, align 4
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %163, i32 0, i32 0
  %164 = load i32, i32* %type158, align 8
  %idxprom159 = zext i32 %164 to i64
  %arrayidx160 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom159
  %165 = load i8*, i8** %arrayidx160, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %161, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.160, i64 0, i64 0), i32 noundef %162, i8* noundef %165) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end161:                                        ; preds = %if.then154
  %166 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %167 = load i32, i32* %insn_idx.addr, align 4
  %168 = load i32, i32* %regno.addr, align 4
  %169 = load i32, i32* %off.addr, align 4
  %170 = load i32, i32* %size, align 4
  %171 = load i32, i32* %t.addr, align 4
  %call162 = call i32 @check_sock_access(%struct.bpf_verifier_env* noundef %166, i32 noundef %167, i32 noundef %168, i32 noundef %169, i32 noundef %170, i32 noundef %171) #8
  store i32 %call162, i32* %err, align 4
  %172 = load i32, i32* %err, align 4
  %tobool163 = icmp ne i32 %172, 0
  br i1 %tobool163, label %if.end168, label %land.lhs.true164

land.lhs.true164:                                 ; preds = %if.end161
  %173 = load i32, i32* %value_regno.addr, align 4
  %cmp165 = icmp sge i32 %173, 0
  br i1 %cmp165, label %if.then167, label %if.end168

if.then167:                                       ; preds = %land.lhs.true164
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %176 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %174, %struct.bpf_reg_state* noundef %175, i32 noundef %176) #8
  br label %if.end168

if.end168:                                        ; preds = %if.then167, %land.lhs.true164, %if.end161
  br label %if.end189

if.else169:                                       ; preds = %if.else151
  %177 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %177, i32 0, i32 0
  %178 = load i32, i32* %type170, align 8
  %cmp171 = icmp eq i32 %178, 17
  br i1 %cmp171, label %if.then173, label %if.else184

if.then173:                                       ; preds = %if.else169
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %181 = load i32, i32* %regno.addr, align 4
  %182 = load i32, i32* %off.addr, align 4
  %183 = load i32, i32* %size, align 4
  %call174 = call i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %179, %struct.bpf_reg_state* noundef %180, i32 noundef %181, i32 noundef %182, i32 noundef %183) #8
  store i32 %call174, i32* %err, align 4
  %184 = load i32, i32* %err, align 4
  %tobool175 = icmp ne i32 %184, 0
  br i1 %tobool175, label %if.end183, label %land.lhs.true176

land.lhs.true176:                                 ; preds = %if.then173
  %185 = load i32, i32* %t.addr, align 4
  %cmp177 = icmp eq i32 %185, 1
  br i1 %cmp177, label %land.lhs.true179, label %if.end183

land.lhs.true179:                                 ; preds = %land.lhs.true176
  %186 = load i32, i32* %value_regno.addr, align 4
  %cmp180 = icmp sge i32 %186, 0
  br i1 %cmp180, label %if.then182, label %if.end183

if.then182:                                       ; preds = %land.lhs.true179
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %189 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %187, %struct.bpf_reg_state* noundef %188, i32 noundef %189) #8
  br label %if.end183

if.end183:                                        ; preds = %if.then182, %land.lhs.true179, %land.lhs.true176, %if.then173
  br label %if.end188

if.else184:                                       ; preds = %if.else169
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %191 = bitcast %struct.bpf_verifier_env* %190 to i8*
  %192 = load i32, i32* %regno.addr, align 4
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type185 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %193, i32 0, i32 0
  %194 = load i32, i32* %type185, align 8
  %idxprom186 = zext i32 %194 to i64
  %arrayidx187 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom186
  %195 = load i8*, i8** %arrayidx187, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %191, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.161, i64 0, i64 0), i32 noundef %192, i8* noundef %195) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end188:                                        ; preds = %if.end183
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %if.end168
  br label %if.end190

if.end190:                                        ; preds = %if.end189, %if.end150
  br label %if.end191

if.end191:                                        ; preds = %if.end190, %if.end125
  br label %if.end192

if.end192:                                        ; preds = %if.end191, %if.end96
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.end74
  br label %if.end194

if.end194:                                        ; preds = %if.end193, %if.end39
  %196 = load i32, i32* %err, align 4
  %tobool195 = icmp ne i32 %196, 0
  br i1 %tobool195, label %if.end214, label %land.lhs.true196

land.lhs.true196:                                 ; preds = %if.end194
  %197 = load i32, i32* %size, align 4
  %cmp197 = icmp slt i32 %197, 8
  br i1 %cmp197, label %land.lhs.true199, label %if.end214

land.lhs.true199:                                 ; preds = %land.lhs.true196
  %198 = load i32, i32* %value_regno.addr, align 4
  %cmp200 = icmp sge i32 %198, 0
  br i1 %cmp200, label %land.lhs.true202, label %if.end214

land.lhs.true202:                                 ; preds = %land.lhs.true199
  %199 = load i32, i32* %t.addr, align 4
  %cmp203 = icmp eq i32 %199, 1
  br i1 %cmp203, label %land.lhs.true205, label %if.end214

land.lhs.true205:                                 ; preds = %land.lhs.true202
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %201 = load i32, i32* %value_regno.addr, align 4
  %idxprom206 = sext i32 %201 to i64
  %arrayidx207 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i64 %idxprom206
  %type208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx207, i32 0, i32 0
  %202 = load i32, i32* %type208, align 8
  %cmp209 = icmp eq i32 %202, 1
  br i1 %cmp209, label %if.then211, label %if.end214

if.then211:                                       ; preds = %land.lhs.true205
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %204 = load i32, i32* %value_regno.addr, align 4
  %idxprom212 = sext i32 %204 to i64
  %arrayidx213 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i64 %idxprom212
  %205 = load i32, i32* %size, align 4
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %arrayidx213, i32 noundef %205) #8
  br label %if.end214

if.end214:                                        ; preds = %if.then211, %land.lhs.true205, %land.lhs.true202, %land.lhs.true199, %land.lhs.true196, %if.end194
  %206 = load i32, i32* %err, align 4
  store i32 %206, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end214, %if.else184, %if.then157, %if.then139, %if.then114, %if.then104, %if.then88, %if.then83, %if.then53, %if.then49, %if.then30, %if.then26, %if.then17, %if.then13
  %207 = load i32, i32* %retval, align 4
  ret i32 %207
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch(i32 noundef %src, i32 noundef %prev) #0 {
entry:
  %src.addr = alloca i32, align 4
  %prev.addr = alloca i32, align 4
  store i32 %src, i32* %src.addr, align 4
  store i32 %prev, i32* %prev.addr, align 4
  %0 = load i32, i32* %src.addr, align 4
  %1 = load i32, i32* %prev.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i32, i32* %src.addr, align 4
  %call = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %2) #8
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %3 = load i32, i32* %prev.addr, align 4
  %call1 = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %3) #8
  %lnot = xor i1 %call1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %4 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %5 = phi i1 [ false, %entry ], [ %4, %lor.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_xadd(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 24
  %cmp5 = icmp ne i32 %and4, 24
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %cmp7 = icmp ne i32 %5, 0
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.191, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv9 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %8, i32 noundef %conv9, i32 noundef 0) #8
  store i32 %call, i32* %err, align 4
  %10 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %11 = load i32, i32* %err, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load12 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load12, 15
  %conv13 = zext i8 %bf.clear to i32
  %call14 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %12, i32 noundef %conv13, i32 noundef 0) #8
  store i32 %call14, i32* %err, align 4
  %14 = load i32, i32* %err, align 4
  %tobool15 = icmp ne i32 %14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end11
  %15 = load i32, i32* %err, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end11
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 1
  %bf.load19 = load i8, i8* %src_reg18, align 1
  %bf.lshr20 = lshr i8 %bf.load19, 4
  %conv21 = zext i8 %bf.lshr20 to i32
  %call22 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %16, i32 noundef %conv21) #8
  br i1 %call22, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end17
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load25 = load i8, i8* %src_reg24, align 1
  %bf.lshr26 = lshr i8 %bf.load25, 4
  %conv27 = zext i8 %bf.lshr26 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.192, i64 0, i64 0), i32 noundef %conv27) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 1
  %bf.load30 = load i8, i8* %dst_reg29, align 1
  %bf.clear31 = and i8 %bf.load30, 15
  %conv32 = zext i8 %bf.clear31 to i32
  %call33 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %21, i32 noundef %conv32) #8
  br i1 %call33, label %if.then56, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %if.end28
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load37 = load i8, i8* %dst_reg36, align 1
  %bf.clear38 = and i8 %bf.load37, 15
  %conv39 = zext i8 %bf.clear38 to i32
  %call40 = call zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %23, i32 noundef %conv39) #8
  br i1 %call40, label %if.then56, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %lor.lhs.false35
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, 15
  %conv46 = zext i8 %bf.clear45 to i32
  %call47 = call zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %25, i32 noundef %conv46) #8
  br i1 %call47, label %if.then56, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false42
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg50 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load51 = load i8, i8* %dst_reg50, align 1
  %bf.clear52 = and i8 %bf.load51, 15
  %conv53 = zext i8 %bf.clear52 to i32
  %call54 = call zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %27, i32 noundef %conv53) #8
  br i1 %call54, label %if.then56, label %if.end66

if.then56:                                        ; preds = %lor.lhs.false49, %lor.lhs.false42, %lor.lhs.false35, %if.end28
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load58 = load i8, i8* %dst_reg57, align 1
  %bf.clear59 = and i8 %bf.load58, 15
  %conv60 = zext i8 %bf.clear59 to i32
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load62 = load i8, i8* %dst_reg61, align 1
  %bf.clear63 = and i8 %bf.load62, 15
  %conv64 = zext i8 %bf.clear63 to i32
  %call65 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv64) #8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call65, i32 0, i32 0
  %34 = load i32, i32* %type, align 8
  %idxprom = zext i32 %34 to i64
  %arrayidx = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %35 = load i8*, i8** %arrayidx, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.193, i64 0, i64 0), i32 noundef %conv60, i8* noundef %35) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %lor.lhs.false49
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load i32, i32* %insn_idx.addr, align 4
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load68 = load i8, i8* %dst_reg67, align 1
  %bf.clear69 = and i8 %bf.load68, 15
  %conv70 = zext i8 %bf.clear69 to i32
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 2
  %40 = load i16, i16* %off, align 2
  %conv71 = sext i16 %40 to i32
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code72 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code72, align 4
  %conv73 = zext i8 %42 to i32
  %and74 = and i32 %conv73, 24
  %call75 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %36, i32 noundef %37, i32 noundef %conv70, i32 noundef %conv71, i32 noundef %and74, i32 noundef 1, i32 noundef -1, i1 noundef zeroext true) #8
  store i32 %call75, i32* %err, align 4
  %43 = load i32, i32* %err, align 4
  %tobool76 = icmp ne i32 %43, 0
  br i1 %tobool76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end66
  %44 = load i32, i32* %err, align 4
  store i32 %44, i32* %retval, align 4
  br label %return

if.end78:                                         ; preds = %if.end66
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load i32, i32* %insn_idx.addr, align 4
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %47, i32 0, i32 1
  %bf.load80 = load i8, i8* %dst_reg79, align 1
  %bf.clear81 = and i8 %bf.load80, 15
  %conv82 = zext i8 %bf.clear81 to i32
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off83 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 2
  %49 = load i16, i16* %off83, align 2
  %conv84 = sext i16 %49 to i32
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code85 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 0
  %51 = load i8, i8* %code85, align 4
  %conv86 = zext i8 %51 to i32
  %and87 = and i32 %conv86, 24
  %call88 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %45, i32 noundef %46, i32 noundef %conv82, i32 noundef %conv84, i32 noundef %and87, i32 noundef 2, i32 noundef -1, i1 noundef zeroext true) #8
  store i32 %call88, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end78, %if.then77, %if.then56, %if.then23, %if.then16, %if.then10, %if.then
  %52 = load i32, i32* %retval, align 4
  ret i32 %52
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idx.ext
  ret %struct.bpf_reg_state* %add.ptr
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %subprog = alloca i32, align 4
  %target_insn = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %add = add i32 %3, 1
  %cmp = icmp uge i32 %add, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 4
  %7 = load i32, i32* %curframe1, align 8
  %add2 = add i32 %7, 2
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.213, i64 0, i64 0), i32 noundef %add2) #8
  store i32 -7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32*, i32** %insn_idx.addr, align 8
  %9 = load i32, i32* %8, align 4
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 3
  %11 = load i32, i32* %imm, align 4
  %add3 = add i32 %9, %11
  store i32 %add3, i32* %target_insn, align 4
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %target_insn, align 4
  %add4 = add i32 %13, 1
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %12, i32 noundef %add4) #8
  store i32 %call, i32* %subprog, align 4
  %14 = load i32, i32* %subprog, align 4
  %cmp5 = icmp slt i32 %14, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load i32, i32* %target_insn, align 4
  %add7 = add i32 %17, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.214, i64 0, i64 0), i32 noundef %add7) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 0
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe9 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 4
  %20 = load i32, i32* %curframe9, align 8
  %idxprom = zext i32 %20 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %21, %struct.bpf_func_state** %caller, align 8
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %22, i32 0, i32 0
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe11, align 8
  %add12 = add i32 %24, 1
  %idxprom13 = zext i32 %add12 to i64
  %arrayidx14 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame10, i64 0, i64 %idxprom13
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx14, align 8
  %tobool = icmp ne %struct.bpf_func_state* %25, null
  br i1 %tobool, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe16 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %28, i32 0, i32 4
  %29 = load i32, i32* %curframe16, align 8
  %add17 = add i32 %29, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.215, i64 0, i64 0), i32 noundef %add17) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end8
  %call19 = call i8* @kzalloc(i64 noundef 1184, i32 noundef 3264) #8
  %30 = bitcast i8* %call19 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %30, %struct.bpf_func_state** %callee, align 8
  %31 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %tobool20 = icmp ne %struct.bpf_func_state* %31, null
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end18
  store i32 -12, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %33 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame23 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %33, i32 0, i32 0
  %34 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %34, i32 0, i32 4
  %35 = load i32, i32* %curframe24, align 8
  %add25 = add i32 %35, 1
  %idxprom26 = zext i32 %add25 to i64
  %arrayidx27 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame23, i64 0, i64 %idxprom26
  store %struct.bpf_func_state* %32, %struct.bpf_func_state** %arrayidx27, align 8
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %38 = load i32*, i32** %insn_idx.addr, align 8
  %39 = load i32, i32* %38, align 4
  %40 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %40, i32 0, i32 4
  %41 = load i32, i32* %curframe28, align 8
  %add29 = add i32 %41, 1
  %42 = load i32, i32* %subprog, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %36, %struct.bpf_func_state* noundef %37, i32 noundef %39, i32 noundef %add29, i32 noundef %42) #8
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %44 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %call30 = call i32 @transfer_reference_state(%struct.bpf_func_state* noundef %43, %struct.bpf_func_state* noundef %44) #8
  store i32 %call30, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %tobool31 = icmp ne i32 %45, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end22
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end22
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end33
  %47 = load i32, i32* %i, align 4
  %cmp34 = icmp sle i32 %47, 5
  br i1 %cmp34, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 0
  %49 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %49 to i64
  %arrayidx36 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom35
  %50 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %50, i32 0, i32 0
  %51 = load i32, i32* %i, align 4
  %idxprom38 = sext i32 %51 to i64
  %arrayidx39 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs37, i64 0, i64 %idxprom38
  %52 = bitcast %struct.bpf_reg_state* %arrayidx36 to i8*
  %53 = bitcast %struct.bpf_reg_state* %arrayidx39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %52, i8* align 8 %53, i64 104, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %54 = load i32, i32* %i, align 4
  %inc = add i32 %54, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc49, %for.end
  %55 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %55, 6
  br i1 %cmp41, label %for.body42, label %for.end51

for.body42:                                       ; preds = %for.cond40
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs43 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %57, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs43, i64 0, i64 0
  %58 = load i32, i32* %i, align 4
  %idxprom44 = sext i32 %58 to i64
  %arrayidx45 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom44
  %59 = load i32, i32* %arrayidx45, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %arraydecay, i32 noundef %59) #8
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = load i32, i32* %i, align 4
  %idxprom46 = sext i32 %61 to i64
  %arrayidx47 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom46
  %62 = load i32, i32* %arrayidx47, align 4
  %call48 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %60, i32 noundef %62, i32 noundef 2) #8
  br label %for.inc49

for.inc49:                                        ; preds = %for.body42
  %63 = load i32, i32* %i, align 4
  %inc50 = add i32 %63, 1
  store i32 %inc50, i32* %i, align 4
  br label %for.cond40

for.end51:                                        ; preds = %for.cond40
  %64 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe52 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %64, i32 0, i32 4
  %65 = load i32, i32* %curframe52, align 8
  %inc53 = add i32 %65, 1
  store i32 %inc53, i32* %curframe52, align 8
  %66 = load i32, i32* %target_insn, align 4
  %67 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %66, i32* %67, align 4
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %68, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %69 = load i32, i32* %level, align 8
  %and = and i32 %69, 3
  %tobool54 = icmp ne i32 %and, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %for.end51
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.216, i64 0, i64 0)) #8
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %72, %struct.bpf_func_state* noundef %73) #8
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.217, i64 0, i64 0)) #8
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %76, %struct.bpf_func_state* noundef %77) #8
  br label %if.end56

if.end56:                                         ; preds = %if.then55, %for.end51
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.then32, %if.then21, %if.then15, %if.then6, %if.then
  %78 = load i32, i32* %retval, align 4
  ret i32 %78
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_call(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %fn = alloca %struct.bpf_func_proto*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %meta = alloca %struct.bpf_call_arg_meta, align 8
  %changes_data = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %id180 = alloca i32, align 4
  %err_str = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_func_proto* null, %struct.bpf_func_proto** %fn, align 8
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp sge i32 %1, 111
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load i32, i32* %func_id.addr, align 4
  %call = call i8* @func_id_name(i32 noundef %4) #8
  %5 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.218, i64 0, i64 0), i8* noundef %call, i32 noundef %5) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 3
  %7 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %7, i32 0, i32 0
  %8 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %tobool = icmp ne %struct.bpf_func_proto* (i32, %struct.bpf_prog*)* %8, null
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 3
  %10 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops3, align 8
  %get_func_proto4 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %10, i32 0, i32 0
  %11 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto4, align 8
  %12 = load i32, i32* %func_id.addr, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 2
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call5 = call %struct.bpf_func_proto* %11(i32 noundef %12, %struct.bpf_prog* noundef %14) #8
  store %struct.bpf_func_proto* %call5, %struct.bpf_func_proto** %fn, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then2, %if.end
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %tobool7 = icmp ne %struct.bpf_func_proto* %15, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end6
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %func_id.addr, align 4
  %call9 = call i8* @func_id_name(i32 noundef %18) #8
  %19 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.219, i64 0, i64 0), i8* noundef %call9, i32 noundef %19) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog11, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 1
  %bf.load = load i16, i16* %gpl_compatible, align 2
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %tobool12 = icmp ne i16 %bf.clear, 0
  br i1 %tobool12, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %22 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %gpl_only = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %22, i32 0, i32 1
  %23 = load i8, i8* %gpl_only, align 8
  %tobool13 = trunc i8 %23 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.220, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true, %if.end10
  %26 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %26, i32 0, i32 0
  %27 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %28 = bitcast i64 (i64, i64, i64, i64, i64)* %27 to i8*
  %call16 = call zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef %28) #8
  %frombool = zext i1 %call16 to i8
  store i8 %frombool, i8* %changes_data, align 1
  %29 = load i8, i8* %changes_data, align 1
  %tobool17 = trunc i8 %29 to i1
  br i1 %tobool17, label %land.lhs.true18, label %if.end22

land.lhs.true18:                                  ; preds = %if.end15
  %30 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %arg1_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %30, i32 0, i32 4
  %31 = load i32, i32* %arg1_type, align 8
  %cmp19 = icmp ne i32 %31, 11
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %land.lhs.true18
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  %34 = load i32, i32* %func_id.addr, align 4
  %call21 = call i8* @func_id_name(i32 noundef %34) #8
  %35 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.221, i64 0, i64 0), i8* noundef %call21, i32 noundef %35) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %land.lhs.true18, %if.end15
  %36 = bitcast %struct.bpf_call_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %36, i8 0, i64 48, i1 false)
  %37 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %37, i32 0, i32 2
  %38 = load i8, i8* %pkt_access, align 1
  %tobool23 = trunc i8 %38 to i1
  %pkt_access24 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 2
  %frombool25 = zext i1 %tobool23 to i8
  store i8 %frombool25, i8* %pkt_access24, align 1
  %39 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %40 = load i32, i32* %func_id.addr, align 4
  %call26 = call i32 @check_func_proto(%struct.bpf_func_proto* noundef %39, i32 noundef %40) #8
  store i32 %call26, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool27 = icmp ne i32 %41, 0
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end22
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load i32, i32* %func_id.addr, align 4
  %call29 = call i8* @func_id_name(i32 noundef %44) #8
  %45 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.222, i64 0, i64 0), i8* noundef %call29, i32 noundef %45) #8
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end22
  %47 = load i32, i32* %func_id.addr, align 4
  %func_id31 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  store i32 %47, i32* %func_id31, align 4
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %arg1_type32 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %49, i32 0, i32 4
  %50 = load i32, i32* %arg1_type32, align 8
  %call33 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %48, i32 noundef 1, i32 noundef %50, %struct.bpf_call_arg_meta* noundef %meta) #8
  store i32 %call33, i32* %err, align 4
  %51 = load i32, i32* %err, align 4
  %tobool34 = icmp ne i32 %51, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end30
  %52 = load i32, i32* %err, align 4
  store i32 %52, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end30
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %arg2_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %54, i32 0, i32 5
  %55 = load i32, i32* %arg2_type, align 4
  %call37 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %53, i32 noundef 2, i32 noundef %55, %struct.bpf_call_arg_meta* noundef %meta) #8
  store i32 %call37, i32* %err, align 4
  %56 = load i32, i32* %err, align 4
  %tobool38 = icmp ne i32 %56, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end36
  %57 = load i32, i32* %err, align 4
  store i32 %57, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end36
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %arg3_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %59, i32 0, i32 6
  %60 = load i32, i32* %arg3_type, align 8
  %call41 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %58, i32 noundef 3, i32 noundef %60, %struct.bpf_call_arg_meta* noundef %meta) #8
  store i32 %call41, i32* %err, align 4
  %61 = load i32, i32* %err, align 4
  %tobool42 = icmp ne i32 %61, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end40
  %62 = load i32, i32* %err, align 4
  store i32 %62, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end40
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %arg4_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %64, i32 0, i32 7
  %65 = load i32, i32* %arg4_type, align 4
  %call45 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %63, i32 noundef 4, i32 noundef %65, %struct.bpf_call_arg_meta* noundef %meta) #8
  store i32 %call45, i32* %err, align 4
  %66 = load i32, i32* %err, align 4
  %tobool46 = icmp ne i32 %66, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end44
  %67 = load i32, i32* %err, align 4
  store i32 %67, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end44
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %arg5_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %69, i32 0, i32 8
  %70 = load i32, i32* %arg5_type, align 8
  %call49 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %68, i32 noundef 5, i32 noundef %70, %struct.bpf_call_arg_meta* noundef %meta) #8
  store i32 %call49, i32* %err, align 4
  %71 = load i32, i32* %err, align 4
  %tobool50 = icmp ne i32 %71, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end48
  %72 = load i32, i32* %err, align 4
  store i32 %72, i32* %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end48
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = load i32, i32* %func_id.addr, align 4
  %75 = load i32, i32* %insn_idx.addr, align 4
  %call53 = call i32 @record_func_map(%struct.bpf_verifier_env* noundef %73, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %74, i32 noundef %75) #8
  store i32 %call53, i32* %err, align 4
  %76 = load i32, i32* %err, align 4
  %tobool54 = icmp ne i32 %76, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end52
  %77 = load i32, i32* %err, align 4
  store i32 %77, i32* %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end52
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end56
  %78 = load i32, i32* %i, align 4
  %access_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 4
  %79 = load i32, i32* %access_size, align 8
  %cmp57 = icmp slt i32 %78, %79
  br i1 %cmp57, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = load i32, i32* %insn_idx.addr, align 4
  %regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %82 = load i32, i32* %regno, align 4
  %83 = load i32, i32* %i, align 4
  %call58 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %80, i32 noundef %81, i32 noundef %82, i32 noundef %83, i32 noundef 16, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #8
  store i32 %call58, i32* %err, align 4
  %84 = load i32, i32* %err, align 4
  %tobool59 = icmp ne i32 %84, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %for.body
  %85 = load i32, i32* %err, align 4
  store i32 %85, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end61
  %86 = load i32, i32* %i, align 4
  %inc = add i32 %86, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %87 = load i32, i32* %func_id.addr, align 4
  %cmp62 = icmp eq i32 %87, 12
  br i1 %cmp62, label %if.then63, label %if.else

if.then63:                                        ; preds = %for.end
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call64 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %88) #8
  store i32 %call64, i32* %err, align 4
  %89 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %89, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then63
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = bitcast %struct.bpf_verifier_env* %90 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %91, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.223, i64 0, i64 0)) #8
  %92 = load i32, i32* %err, align 4
  store i32 %92, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then63
  br label %if.end76

if.else:                                          ; preds = %for.end
  %93 = load i32, i32* %func_id.addr, align 4
  %call68 = call zeroext i1 @is_release_function(i32 noundef %93) #8
  br i1 %call68, label %if.then69, label %if.end75

if.then69:                                        ; preds = %if.else
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 7
  %95 = load i32, i32* %ref_obj_id, align 8
  %call70 = call i32 @release_reference(%struct.bpf_verifier_env* noundef %94, i32 noundef %95) #8
  store i32 %call70, i32* %err, align 4
  %96 = load i32, i32* %err, align 4
  %tobool71 = icmp ne i32 %96, 0
  br i1 %tobool71, label %if.then72, label %if.end74

if.then72:                                        ; preds = %if.then69
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = bitcast %struct.bpf_verifier_env* %97 to i8*
  %99 = load i32, i32* %func_id.addr, align 4
  %call73 = call i8* @func_id_name(i32 noundef %99) #8
  %100 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %98, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.224, i64 0, i64 0), i8* noundef %call73, i32 noundef %100) #8
  %101 = load i32, i32* %err, align 4
  store i32 %101, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.then69
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end67
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call77 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %102) #8
  store %struct.bpf_reg_state* %call77, %struct.bpf_reg_state** %regs, align 8
  %103 = load i32, i32* %func_id.addr, align 4
  %cmp78 = icmp eq i32 %103, 81
  br i1 %cmp78, label %land.lhs.true79, label %if.end82

land.lhs.true79:                                  ; preds = %if.end76
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i64 2
  %call80 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %arrayidx) #8
  br i1 %call80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %land.lhs.true79
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = bitcast %struct.bpf_verifier_env* %105 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %106, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.225, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %land.lhs.true79, %if.end76
  store i32 0, i32* %i, align 4
  br label %for.cond83

for.cond83:                                       ; preds = %for.inc90, %if.end82
  %107 = load i32, i32* %i, align 4
  %cmp84 = icmp slt i32 %107, 6
  br i1 %cmp84, label %for.body85, label %for.end92

for.body85:                                       ; preds = %for.cond83
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %110 = load i32, i32* %i, align 4
  %idxprom = sext i32 %110 to i64
  %arrayidx86 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %111 = load i32, i32* %arrayidx86, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %108, %struct.bpf_reg_state* noundef %109, i32 noundef %111) #8
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = load i32, i32* %i, align 4
  %idxprom87 = sext i32 %113 to i64
  %arrayidx88 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom87
  %114 = load i32, i32* %arrayidx88, align 4
  %call89 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %112, i32 noundef %114, i32 noundef 2) #8
  br label %for.inc90

for.inc90:                                        ; preds = %for.body85
  %115 = load i32, i32* %i, align 4
  %inc91 = add i32 %115, 1
  store i32 %inc91, i32* %i, align 4
  br label %for.cond83

for.end92:                                        ; preds = %for.cond83
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx93 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx93, i32 0, i32 12
  store i32 0, i32* %subreg_def, align 4
  %117 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %117, i32 0, i32 3
  %118 = load i32, i32* %ret_type, align 4
  %cmp94 = icmp eq i32 %118, 0
  br i1 %cmp94, label %if.then95, label %if.else96

if.then95:                                        ; preds = %for.end92
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %119, %struct.bpf_reg_state* noundef %120, i32 noundef 0) #8
  br label %if.end171

if.else96:                                        ; preds = %for.end92
  %121 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type97 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %121, i32 0, i32 3
  %122 = load i32, i32* %ret_type97, align 4
  %cmp98 = icmp eq i32 %122, 1
  br i1 %cmp98, label %if.then99, label %if.else101

if.then99:                                        ; preds = %if.else96
  %123 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx100 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %123, i64 0
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx100, i32 0, i32 0
  store i32 0, i32* %type, align 8
  br label %if.end170

if.else101:                                       ; preds = %if.else96
  %124 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type102 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %124, i32 0, i32 3
  %125 = load i32, i32* %ret_type102, align 4
  %cmp103 = icmp eq i32 %125, 3
  br i1 %cmp103, label %if.then107, label %lor.lhs.false104

lor.lhs.false104:                                 ; preds = %if.else101
  %126 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type105 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %126, i32 0, i32 3
  %127 = load i32, i32* %ret_type105, align 4
  %cmp106 = icmp eq i32 %127, 2
  br i1 %cmp106, label %if.then107, label %if.else133

if.then107:                                       ; preds = %lor.lhs.false104, %if.else101
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %128, %struct.bpf_reg_state* noundef %129, i32 noundef 0) #8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %130 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %cmp108 = icmp eq %struct.bpf_map* %130, null
  br i1 %cmp108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.then107
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = bitcast %struct.bpf_verifier_env* %131 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %132, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.226, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end110:                                        ; preds = %if.then107
  %map_ptr111 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %133 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr111, align 8
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx112 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %134, i64 0
  %135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx112, i32 0, i32 1
  %map_ptr113 = bitcast %union.anon.147* %135 to %struct.bpf_map**
  store %struct.bpf_map* %133, %struct.bpf_map** %map_ptr113, align 8
  %136 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type114 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %136, i32 0, i32 3
  %137 = load i32, i32* %ret_type114, align 4
  %cmp115 = icmp eq i32 %137, 2
  br i1 %cmp115, label %if.then116, label %if.else125

if.then116:                                       ; preds = %if.end110
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx117 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i64 0
  %type118 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx117, i32 0, i32 0
  store i32 4, i32* %type118, align 8
  %map_ptr119 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %139 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr119, align 8
  %call120 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %139) #8
  br i1 %call120, label %if.then121, label %if.end124

if.then121:                                       ; preds = %if.then116
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %140, i32 0, i32 13
  %141 = load i32, i32* %id_gen, align 4
  %inc122 = add i32 %141, 1
  store i32 %inc122, i32* %id_gen, align 4
  %142 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx123 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %142, i64 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx123, i32 0, i32 3
  store i32 %inc122, i32* %id, align 4
  br label %if.end124

if.end124:                                        ; preds = %if.then121, %if.then116
  br label %if.end132

if.else125:                                       ; preds = %if.end110
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx126 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %143, i64 0
  %type127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx126, i32 0, i32 0
  store i32 5, i32* %type127, align 8
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen128 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %144, i32 0, i32 13
  %145 = load i32, i32* %id_gen128, align 4
  %inc129 = add i32 %145, 1
  store i32 %inc129, i32* %id_gen128, align 4
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx130 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i64 0
  %id131 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx130, i32 0, i32 3
  store i32 %inc129, i32* %id131, align 4
  br label %if.end132

if.end132:                                        ; preds = %if.else125, %if.end124
  br label %if.end169

if.else133:                                       ; preds = %lor.lhs.false104
  %147 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type134 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %147, i32 0, i32 3
  %148 = load i32, i32* %ret_type134, align 4
  %cmp135 = icmp eq i32 %148, 4
  br i1 %cmp135, label %if.then136, label %if.else143

if.then136:                                       ; preds = %if.else133
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %149, %struct.bpf_reg_state* noundef %150, i32 noundef 0) #8
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx137 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %151, i64 0
  %type138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx137, i32 0, i32 0
  store i32 12, i32* %type138, align 8
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen139 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %152, i32 0, i32 13
  %153 = load i32, i32* %id_gen139, align 4
  %inc140 = add i32 %153, 1
  store i32 %inc140, i32* %id_gen139, align 4
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx141 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i64 0
  %id142 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx141, i32 0, i32 3
  store i32 %inc140, i32* %id142, align 4
  br label %if.end168

if.else143:                                       ; preds = %if.else133
  %155 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type144 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %155, i32 0, i32 3
  %156 = load i32, i32* %ret_type144, align 4
  %cmp145 = icmp eq i32 %156, 6
  br i1 %cmp145, label %if.then146, label %if.else153

if.then146:                                       ; preds = %if.else143
  %157 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %157, %struct.bpf_reg_state* noundef %158, i32 noundef 0) #8
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx147 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i64 0
  %type148 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx147, i32 0, i32 0
  store i32 14, i32* %type148, align 8
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen149 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %160, i32 0, i32 13
  %161 = load i32, i32* %id_gen149, align 4
  %inc150 = add i32 %161, 1
  store i32 %inc150, i32* %id_gen149, align 4
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx151 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %162, i64 0
  %id152 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx151, i32 0, i32 3
  store i32 %inc150, i32* %id152, align 4
  br label %if.end167

if.else153:                                       ; preds = %if.else143
  %163 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type154 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %163, i32 0, i32 3
  %164 = load i32, i32* %ret_type154, align 4
  %cmp155 = icmp eq i32 %164, 5
  br i1 %cmp155, label %if.then156, label %if.else163

if.then156:                                       ; preds = %if.else153
  %165 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %165, %struct.bpf_reg_state* noundef %166, i32 noundef 0) #8
  %167 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx157 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %167, i64 0
  %type158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx157, i32 0, i32 0
  store i32 16, i32* %type158, align 8
  %168 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen159 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %168, i32 0, i32 13
  %169 = load i32, i32* %id_gen159, align 4
  %inc160 = add i32 %169, 1
  store i32 %inc160, i32* %id_gen159, align 4
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx161 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %170, i64 0
  %id162 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx161, i32 0, i32 3
  store i32 %inc160, i32* %id162, align 4
  br label %if.end166

if.else163:                                       ; preds = %if.else153
  %171 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %172 = bitcast %struct.bpf_verifier_env* %171 to i8*
  %173 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type164 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %173, i32 0, i32 3
  %174 = load i32, i32* %ret_type164, align 4
  %175 = load i32, i32* %func_id.addr, align 4
  %call165 = call i8* @func_id_name(i32 noundef %175) #8
  %176 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %172, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.227, i64 0, i64 0), i32 noundef %174, i8* noundef %call165, i32 noundef %176) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end166:                                        ; preds = %if.then156
  br label %if.end167

if.end167:                                        ; preds = %if.end166, %if.then146
  br label %if.end168

if.end168:                                        ; preds = %if.end167, %if.then136
  br label %if.end169

if.end169:                                        ; preds = %if.end168, %if.end132
  br label %if.end170

if.end170:                                        ; preds = %if.end169, %if.then99
  br label %if.end171

if.end171:                                        ; preds = %if.end170, %if.then95
  %177 = load i32, i32* %func_id.addr, align 4
  %call172 = call zeroext i1 @is_ptr_cast_function(i32 noundef %177) #8
  br i1 %call172, label %if.then173, label %if.else177

if.then173:                                       ; preds = %if.end171
  %ref_obj_id174 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 7
  %178 = load i32, i32* %ref_obj_id174, align 8
  %179 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx175 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %179, i64 0
  %ref_obj_id176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx175, i32 0, i32 4
  store i32 %178, i32* %ref_obj_id176, align 8
  br label %if.end190

if.else177:                                       ; preds = %if.end171
  %180 = load i32, i32* %func_id.addr, align 4
  %call178 = call zeroext i1 @is_acquire_function(i32 noundef %180) #8
  br i1 %call178, label %if.then179, label %if.end189

if.then179:                                       ; preds = %if.else177
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %182 = load i32, i32* %insn_idx.addr, align 4
  %call181 = call i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %181, i32 noundef %182) #8
  store i32 %call181, i32* %id180, align 4
  %183 = load i32, i32* %id180, align 4
  %cmp182 = icmp slt i32 %183, 0
  br i1 %cmp182, label %if.then183, label %if.end184

if.then183:                                       ; preds = %if.then179
  %184 = load i32, i32* %id180, align 4
  store i32 %184, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %if.then179
  %185 = load i32, i32* %id180, align 4
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx185 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i64 0
  %id186 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx185, i32 0, i32 3
  store i32 %185, i32* %id186, align 4
  %187 = load i32, i32* %id180, align 4
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx187 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i64 0
  %ref_obj_id188 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx187, i32 0, i32 4
  store i32 %187, i32* %ref_obj_id188, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.end184, %if.else177
  br label %if.end190

if.end190:                                        ; preds = %if.end189, %if.then173
  %189 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %190 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type191 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %190, i32 0, i32 3
  %191 = load i32, i32* %ret_type191, align 4
  %192 = load i32, i32* %func_id.addr, align 4
  call void @do_refine_retval_range(%struct.bpf_reg_state* noundef %189, i32 noundef %191, i32 noundef %192, %struct.bpf_call_arg_meta* noundef %meta) #8
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %map_ptr192 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %194 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr192, align 8
  %195 = load i32, i32* %func_id.addr, align 4
  %call193 = call i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %193, %struct.bpf_map* noundef %194, i32 noundef %195) #8
  store i32 %call193, i32* %err, align 4
  %196 = load i32, i32* %err, align 4
  %tobool194 = icmp ne i32 %196, 0
  br i1 %tobool194, label %if.then195, label %if.end196

if.then195:                                       ; preds = %if.end190
  %197 = load i32, i32* %err, align 4
  store i32 %197, i32* %retval, align 4
  br label %return

if.end196:                                        ; preds = %if.end190
  %198 = load i32, i32* %func_id.addr, align 4
  %cmp197 = icmp eq i32 %198, 67
  br i1 %cmp197, label %land.lhs.true198, label %if.end214

land.lhs.true198:                                 ; preds = %if.end196
  %199 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog199 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %199, i32 0, i32 2
  %200 = load %struct.bpf_prog*, %struct.bpf_prog** %prog199, align 8
  %has_callchain_buf = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %200, i32 0, i32 1
  %bf.load200 = load i16, i16* %has_callchain_buf, align 2
  %bf.lshr201 = lshr i16 %bf.load200, 8
  %bf.clear202 = and i16 %bf.lshr201, 1
  %tobool203 = icmp ne i16 %bf.clear202, 0
  br i1 %tobool203, label %if.end214, label %if.then204

if.then204:                                       ; preds = %land.lhs.true198
  %201 = load i32, i32* @sysctl_perf_event_max_stack, align 4
  %call205 = call i32 @get_callchain_buffers(i32 noundef %201) #8
  store i32 %call205, i32* %err, align 4
  store i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.228, i64 0, i64 0), i8** %err_str, align 8
  %202 = load i32, i32* %err, align 4
  %tobool206 = icmp ne i32 %202, 0
  br i1 %tobool206, label %if.then207, label %if.end209

if.then207:                                       ; preds = %if.then204
  %203 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %204 = bitcast %struct.bpf_verifier_env* %203 to i8*
  %205 = load i8*, i8** %err_str, align 8
  %206 = load i32, i32* %func_id.addr, align 4
  %call208 = call i8* @func_id_name(i32 noundef %206) #8
  %207 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %204, i8* noundef %205, i8* noundef %call208, i32 noundef %207) #8
  %208 = load i32, i32* %err, align 4
  store i32 %208, i32* %retval, align 4
  br label %return

if.end209:                                        ; preds = %if.then204
  %209 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog210 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %209, i32 0, i32 2
  %210 = load %struct.bpf_prog*, %struct.bpf_prog** %prog210, align 8
  %has_callchain_buf211 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %210, i32 0, i32 1
  %bf.load212 = load i16, i16* %has_callchain_buf211, align 2
  %bf.clear213 = and i16 %bf.load212, -257
  %bf.set = or i16 %bf.clear213, 256
  store i16 %bf.set, i16* %has_callchain_buf211, align 2
  br label %if.end214

if.end214:                                        ; preds = %if.end209, %land.lhs.true198, %if.end196
  %211 = load i8, i8* %changes_data, align 1
  %tobool215 = trunc i8 %211 to i1
  br i1 %tobool215, label %if.then216, label %if.end217

if.then216:                                       ; preds = %if.end214
  %212 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %212) #8
  br label %if.end217

if.end217:                                        ; preds = %if.then216, %if.end214
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end217, %if.then207, %if.then195, %if.then183, %if.else163, %if.then109, %if.then81, %if.then72, %if.then66, %if.then60, %if.then55, %if.then51, %if.then47, %if.then43, %if.then39, %if.then35, %if.then28, %if.then20, %if.then14, %if.then8, %if.then
  %213 = load i32, i32* %retval, align 4
  ret i32 %213
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %env, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %r0 = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %callee, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arrayidx1, %struct.bpf_reg_state** %r0, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 0
  %8 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %8, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.260, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe2, align 8
  %dec = add i32 %12, -1
  store i32 %dec, i32* %curframe2, align 8
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 0
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe4, align 8
  %idxprom5 = zext i32 %15 to i64
  %arrayidx6 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 %idxprom5
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx6, align 8
  store %struct.bpf_func_state* %16, %struct.bpf_func_state** %caller, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 0
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %19 = bitcast %struct.bpf_reg_state* %arrayidx8 to i8*
  %20 = bitcast %struct.bpf_reg_state* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 104, i1 false)
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %call = call i32 @transfer_reference_state(%struct.bpf_func_state* noundef %21, %struct.bpf_func_state* noundef %22) #8
  store i32 %call, i32* %err, align 4
  %23 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %23, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %24 = load i32, i32* %err, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 1
  %26 = load i32, i32* %callsite, align 8
  %add = add i32 %26, 1
  %27 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %add, i32* %27, align 4
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %29 = load i32, i32* %level, align 8
  %and = and i32 %29, 3
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.261, i64 0, i64 0)) #8
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %32, %struct.bpf_func_state* noundef %33) #8
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32*, i32** %insn_idx.addr, align 8
  %37 = load i32, i32* %36, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.262, i64 0, i64 0), i32 noundef %37) #8
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %38, %struct.bpf_func_state* noundef %39) #8
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %40) #8
  %41 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame14 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %41, i32 0, i32 0
  %42 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe15 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %42, i32 0, i32 4
  %43 = load i32, i32* %curframe15, align 8
  %add16 = add i32 %43, 1
  %idxprom17 = zext i32 %add16 to i64
  %arrayidx18 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame14, i64 0, i64 %idxprom17
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx18, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then9, %if.then
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 4
  %3 = load i32, i32* %acquired_refs, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 5
  %7 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %7, i64 %idxprom
  %id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  %9 = load i32, i32* %id, align 4
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 5
  %11 = load %struct.util_est*, %struct.util_est** %refs1, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr %struct.util_est, %struct.util_est* %11, i64 %idxprom2
  %insn_idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx3, i32 0, i32 1
  %13 = load i32, i32* %insn_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.263, i64 0, i64 0), i32 noundef %9, i32 noundef %13) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 4
  %16 = load i32, i32* %acquired_refs4, align 4
  %tobool = icmp ne i32 %16, 0
  %17 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 -22, i32 0
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 14
  %1 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %1 to i1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %2, i32 noundef %3) #8
  %call1 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool, %struct.bpf_reg_state* noundef %call) #8
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_return_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %enforce_attach_type_range = alloca %struct.tnum, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %range = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %tmp11 = alloca %struct.tnum, align 8
  %tmp13 = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %0, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #8
  %1 = bitcast %struct.tnum* %range to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, i64* %4, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 2
  %8 = load i32, i32* %type, align 4
  switch i32 %8, label %sw.default [
    i32 18, label %sw.bb
    i32 8, label %sw.bb6
    i32 9, label %sw.bb16
    i32 13, label %sw.bb16
    i32 15, label %sw.bb16
    i32 23, label %sw.bb16
    i32 25, label %sw.bb16
  ]

sw.bb:                                            ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 2
  %10 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %10, i32 0, i32 3
  %11 = load i32, i32* %expected_attach_type, align 8
  %cmp = icmp eq i32 %11, 19
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 2
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %expected_attach_type3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 3
  %14 = load i32, i32* %expected_attach_type3, align 8
  %cmp4 = icmp eq i32 %14, 20
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %sw.bb
  %call5 = call { i64, i64 } @tnum_range(i64 noundef 1, i64 noundef 1) #8
  %15 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = extractvalue { i64, i64 } %call5, 0
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = extractvalue { i64, i64 } %call5, 1
  store i64 %19, i64* %18, align 8
  %20 = bitcast %struct.tnum* %range to i8*
  %21 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %21, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog7, align 8
  %expected_attach_type8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 3
  %24 = load i32, i32* %expected_attach_type8, align 8
  %cmp9 = icmp eq i32 %24, 1
  br i1 %cmp9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %sw.bb6
  %call12 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 3) #8
  %25 = bitcast %struct.tnum* %tmp11 to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call12, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call12, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.tnum* %range to i8*
  %31 = bitcast %struct.tnum* %tmp11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %31, i64 16, i1 false)
  %call14 = call { i64, i64 } @tnum_range(i64 noundef 2, i64 noundef 3) #8
  %32 = bitcast %struct.tnum* %tmp13 to { i64, i64 }*
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 0
  %34 = extractvalue { i64, i64 } %call14, 0
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %32, i32 0, i32 1
  %36 = extractvalue { i64, i64 } %call14, 1
  store i64 %36, i64* %35, align 8
  %37 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  %38 = bitcast %struct.tnum* %tmp13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 %38, i64 16, i1 false)
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %sw.bb6
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry, %entry, %entry, %entry, %entry
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb16, %if.end15, %if.end
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call17 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %39) #8
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call17, i64 0
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 0
  %41 = load i32, i32* %type18, align 8
  %cmp19 = icmp ne i32 %41, 1
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %sw.epilog
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type21, align 8
  %idxprom = zext i32 %45 to i64
  %arrayidx = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %46 = load i8*, i8** %arrayidx, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.264, i64 0, i64 0), i8* noundef %46) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %sw.epilog
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 5
  %48 = bitcast %struct.tnum* %range to { i64, i64 }*
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call23 = call zeroext i1 @tnum_in(i64 %50, i64 %52, i64 %55, i64 %57) #8
  br i1 %call23, label %if.end35, label %if.then24

if.then24:                                        ; preds = %if.end22
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.265, i64 0, i64 0)) #8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 5
  %61 = bitcast %struct.tnum* %var_off25 to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %call26 = call zeroext i1 @tnum_is_unknown(i64 %63, i64 %65) #8
  br i1 %call26, label %if.else, label %if.then27

if.then27:                                        ; preds = %if.then24
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 5
  %67 = bitcast %struct.tnum* %var_off28 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = load i64, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = load i64, i64* %70, align 8
  %call29 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %69, i64 %71) #8
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = bitcast %struct.bpf_verifier_env* %72 to i8*
  %arraydecay30 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %73, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.266, i64 0, i64 0), i8* noundef %arraydecay30) #8
  br label %if.end31

if.else:                                          ; preds = %if.then24
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.267, i64 0, i64 0)) #8
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.then27
  %arraydecay32 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %76 = bitcast %struct.tnum* %range to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call33 = call i32 @tnum_strn(i8* noundef %arraydecay32, i64 noundef 48, i64 %78, i64 %80) #8
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %82 = bitcast %struct.bpf_verifier_env* %81 to i8*
  %arraydecay34 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %82, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.268, i64 0, i64 0), i8* noundef %arraydecay34) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end22
  %83 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = load i64, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = load i64, i64* %86, align 8
  %call36 = call zeroext i1 @tnum_is_unknown(i64 %85, i64 %87) #8
  br i1 %call36, label %if.end41, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end35
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 5
  %89 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = load i64, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = load i64, i64* %92, align 8
  %94 = bitcast %struct.tnum* %var_off37 to { i64, i64 }*
  %95 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 0
  %96 = load i64, i64* %95, align 8
  %97 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 1
  %98 = load i64, i64* %97, align 8
  %call38 = call zeroext i1 @tnum_in(i64 %91, i64 %93, i64 %96, i64 %98) #8
  br i1 %call38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %land.lhs.true
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog40 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 2
  %100 = load %struct.bpf_prog*, %struct.bpf_prog** %prog40, align 8
  %enforce_expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %100, i32 0, i32 1
  %bf.load = load i16, i16* %enforce_expected_attach_type, align 2
  %bf.clear = and i16 %bf.load, -513
  %bf.set = or i16 %bf.clear, 512
  store i16 %bf.set, i16* %enforce_expected_attach_type, align 2
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %land.lhs.true, %if.end35
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.end31, %if.then20, %sw.default
  %101 = load i32, i32* %retval, align 4
  ret i32 %101
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @update_branch_counts(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %br = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp30 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end39, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 2
  %2 = load i32, i32* %branches, align 8
  %dec = add i32 %2, -1
  store i32 %dec, i32* %branches, align 8
  store i32 %dec, i32* %br, align 4
  %3 = load i32, i32* %br, align 4
  %cmp = icmp slt i32 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_once, align 4
  %4 = load i32, i32* %__ret_warn_once, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.body
  %5 = load i8, i8* @update_branch_counts.__warned, align 1
  %tobool3 = trunc i8 %5 to i1
  %lnot4 = xor i1 %tobool3, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.body
  %6 = phi i1 [ false, %while.body ], [ %lnot4, %land.rhs ]
  %lnot6 = xor i1 %6, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %tobool10 = icmp ne i64 %conv, 0
  br i1 %tobool10, label %if.then, label %if.end29

if.then:                                          ; preds = %land.end
  store i8 1, i8* @update_branch_counts.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool11 = icmp ne i32 %7, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %tobool17 = icmp ne i64 %conv16, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then18
  %8 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.269, i64 0, i64 0), i32 noundef %8) #8
  br label %do.body19

do.body19:                                        ; preds = %do.body
  br label %do.body20

do.body20:                                        ; preds = %do.body19
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 855, i32 2313, i64 12) #9, !srcloc !29
  br label %do.end

do.end:                                           ; preds = %do.body20
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 126) #9, !srcloc !30
  br label %do.end21

do.end21:                                         ; preds = %do.end
  br label %do.end22

do.end22:                                         ; preds = %do.end21
  br label %if.end

if.end:                                           ; preds = %do.end22, %if.then
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool23 = icmp ne i32 %9, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  store i64 %conv28, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.end, %land.end
  %11 = load i32, i32* %__ret_warn_once, align 4
  %tobool31 = icmp ne i32 %11, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  store i64 %conv36, i64* %tmp30, align 8
  %12 = load i64, i64* %tmp30, align 8
  %13 = load i32, i32* %br, align 4
  %tobool37 = icmp ne i32 %13, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end29
  br label %while.end

if.end39:                                         ; preds = %if.end29
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 1
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %15, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then38, %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %this_branch = alloca %struct.bpf_verifier_state*, align 8
  %other_branch = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %other_branch_regs = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %err = alloca i32, align 4
  %src_reg142 = alloca %struct.bpf_reg_state*, align 8
  %lo_reg0 = alloca %struct.bpf_reg_state, align 8
  %lo_reg1 = alloca %struct.bpf_reg_state, align 8
  %src_lo = alloca %struct.bpf_reg_state*, align 8
  %dst_lo = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %this_branch, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  store i32 -1, i32* %pred, align 4
  %8 = load i8, i8* %opcode, align 1
  %conv3 = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %9 = load i8, i8* %opcode, align 1
  %conv5 = zext i8 %9 to i32
  %cmp6 = icmp sgt i32 %conv5, 208
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i8, i8* %opcode, align 1
  %conv8 = zext i8 %12 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.270, i64 0, i64 0), i32 noundef %conv8) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %14 to i32
  %and11 = and i32 %conv10, 8
  %cmp12 = icmp eq i32 %and11, 8
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.271, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then14
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg19, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv20 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %19, i32 noundef %conv20, i32 noundef 0) #8
  store i32 %call, i32* %err, align 4
  %21 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %22 = load i32, i32* %err, align 4
  store i32 %22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load24 = load i8, i8* %src_reg23, align 1
  %bf.lshr25 = lshr i8 %bf.load24, 4
  %conv26 = zext i8 %bf.lshr25 to i32
  %call27 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %23, i32 noundef %conv26) #8
  br i1 %call27, label %if.then28, label %if.end33

if.then28:                                        ; preds = %if.end22
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load30 = load i8, i8* %src_reg29, align 1
  %bf.lshr31 = lshr i8 %bf.load30, 4
  %conv32 = zext i8 %bf.lshr31 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.272, i64 0, i64 0), i32 noundef %conv32) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end22
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load35 = load i8, i8* %src_reg34, align 1
  %bf.lshr36 = lshr i8 %bf.load35, 4
  %idxprom37 = zext i8 %bf.lshr36 to i64
  %arrayidx38 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom37
  store %struct.bpf_reg_state* %arrayidx38, %struct.bpf_reg_state** %src_reg, align 8
  br label %if.end47

if.else:                                          ; preds = %if.end
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.lshr41 = lshr i8 %bf.load40, 4
  %conv42 = zext i8 %bf.lshr41 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.else
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.271, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.else
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end33
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 1
  %bf.load49 = load i8, i8* %dst_reg48, align 1
  %bf.clear = and i8 %bf.load49, 15
  %conv50 = zext i8 %bf.clear to i32
  %call51 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %33, i32 noundef %conv50, i32 noundef 0) #8
  store i32 %call51, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %35, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end47
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end47
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load56 = load i8, i8* %dst_reg55, align 1
  %bf.clear57 = and i8 %bf.load56, 15
  %idxprom58 = zext i8 %bf.clear57 to i64
  %arrayidx59 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i64 %idxprom58
  store %struct.bpf_reg_state* %arrayidx59, %struct.bpf_reg_state** %dst_reg, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 0
  %40 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %40 to i32
  %and62 = and i32 %conv61, 7
  %cmp63 = icmp eq i32 %and62, 6
  %frombool = zext i1 %cmp63 to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code65, align 4
  %conv66 = zext i8 %42 to i32
  %and67 = and i32 %conv66, 8
  %cmp68 = icmp eq i32 %and67, 0
  br i1 %cmp68, label %if.then70, label %if.else75

if.then70:                                        ; preds = %if.end54
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm71, align 4
  %conv72 = sext i32 %45 to i64
  %46 = load i8, i8* %opcode, align 1
  %47 = load i8, i8* %is_jmp32, align 1
  %tobool73 = trunc i8 %47 to i1
  %call74 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %43, i64 noundef %conv72, i8 noundef zeroext %46, i1 noundef zeroext %tobool73) #8
  store i32 %call74, i32* %pred, align 4
  br label %if.end85

if.else75:                                        ; preds = %if.end54
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type, align 8
  %cmp76 = icmp eq i32 %49, 1
  br i1 %cmp76, label %land.lhs.true, label %if.end84

land.lhs.true:                                    ; preds = %if.else75
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call78 = call zeroext i1 @tnum_is_const(i64 %53, i64 %55) #8
  br i1 %call78, label %if.then80, label %if.end84

if.then80:                                        ; preds = %land.lhs.true
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off81, i32 0, i32 0
  %58 = load i64, i64* %value, align 8
  %59 = load i8, i8* %opcode, align 1
  %60 = load i8, i8* %is_jmp32, align 1
  %tobool82 = trunc i8 %60 to i1
  %call83 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %56, i64 noundef %58, i8 noundef zeroext %59, i1 noundef zeroext %tobool82) #8
  store i32 %call83, i32* %pred, align 4
  br label %if.end84

if.end84:                                         ; preds = %if.then80, %land.lhs.true, %if.else75
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.then70
  %61 = load i32, i32* %pred, align 4
  %cmp86 = icmp sge i32 %61, 0
  br i1 %cmp86, label %if.then88, label %if.end111

if.then88:                                        ; preds = %if.end85
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg89 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %63, i32 0, i32 1
  %bf.load90 = load i8, i8* %dst_reg89, align 1
  %bf.clear91 = and i8 %bf.load90, 15
  %conv92 = zext i8 %bf.clear91 to i32
  %call93 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %62, i32 noundef %conv92) #8
  store i32 %call93, i32* %err, align 4
  %64 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %64, i32 0, i32 0
  %65 = load i8, i8* %code94, align 4
  %conv95 = zext i8 %65 to i32
  %and96 = and i32 %conv95, 8
  %cmp97 = icmp eq i32 %and96, 8
  br i1 %cmp97, label %land.lhs.true99, label %if.end107

land.lhs.true99:                                  ; preds = %if.then88
  %66 = load i32, i32* %err, align 4
  %tobool100 = icmp ne i32 %66, 0
  br i1 %tobool100, label %if.end107, label %if.then101

if.then101:                                       ; preds = %land.lhs.true99
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %68, i32 0, i32 1
  %bf.load103 = load i8, i8* %src_reg102, align 1
  %bf.lshr104 = lshr i8 %bf.load103, 4
  %conv105 = zext i8 %bf.lshr104 to i32
  %call106 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %67, i32 noundef %conv105) #8
  store i32 %call106, i32* %err, align 4
  br label %if.end107

if.end107:                                        ; preds = %if.then101, %land.lhs.true99, %if.then88
  %69 = load i32, i32* %err, align 4
  %tobool108 = icmp ne i32 %69, 0
  br i1 %tobool108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.end107
  %70 = load i32, i32* %err, align 4
  store i32 %70, i32* %retval, align 4
  br label %return

if.end110:                                        ; preds = %if.end107
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %if.end85
  %71 = load i32, i32* %pred, align 4
  %cmp112 = icmp eq i32 %71, 1
  br i1 %cmp112, label %if.then114, label %if.else116

if.then114:                                       ; preds = %if.end111
  %72 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %72, i32 0, i32 2
  %73 = load i16, i16* %off, align 2
  %conv115 = sext i16 %73 to i32
  %74 = load i32*, i32** %insn_idx.addr, align 8
  %75 = load i32, i32* %74, align 4
  %add = add i32 %75, %conv115
  store i32 %add, i32* %74, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.else116:                                       ; preds = %if.end111
  %76 = load i32, i32* %pred, align 4
  %cmp117 = icmp eq i32 %76, 0
  br i1 %cmp117, label %if.then119, label %if.end120

if.then119:                                       ; preds = %if.else116
  store i32 0, i32* %retval, align 4
  br label %return

if.end120:                                        ; preds = %if.else116
  br label %if.end121

if.end121:                                        ; preds = %if.end120
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load i32*, i32** %insn_idx.addr, align 8
  %79 = load i32, i32* %78, align 4
  %80 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off122 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %80, i32 0, i32 2
  %81 = load i16, i16* %off122, align 2
  %conv123 = sext i16 %81 to i32
  %add124 = add i32 %79, %conv123
  %add125 = add i32 %add124, 1
  %82 = load i32*, i32** %insn_idx.addr, align 8
  %83 = load i32, i32* %82, align 4
  %call126 = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %77, i32 noundef %add125, i32 noundef %83, i1 noundef zeroext false) #8
  store %struct.bpf_verifier_state* %call126, %struct.bpf_verifier_state** %other_branch, align 8
  %84 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %tobool127 = icmp ne %struct.bpf_verifier_state* %84, null
  br i1 %tobool127, label %if.end129, label %if.then128

if.then128:                                       ; preds = %if.end121
  store i32 -14, i32* %retval, align 4
  br label %return

if.end129:                                        ; preds = %if.end121
  %85 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %frame130 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %85, i32 0, i32 0
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %curframe131 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 4
  %87 = load i32, i32* %curframe131, align 8
  %idxprom132 = zext i32 %87 to i64
  %arrayidx133 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame130, i64 0, i64 %idxprom132
  %88 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx133, align 8
  %regs134 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %88, i32 0, i32 0
  %arraydecay135 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs134, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay135, %struct.bpf_reg_state** %other_branch_regs, align 8
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %89, i32 0, i32 0
  %90 = load i8, i8* %code136, align 4
  %conv137 = zext i8 %90 to i32
  %and138 = and i32 %conv137, 8
  %cmp139 = icmp eq i32 %and138, 8
  br i1 %cmp139, label %if.then141, label %if.else232

if.then141:                                       ; preds = %if.end129
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %92 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg143 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %92, i32 0, i32 1
  %bf.load144 = load i8, i8* %src_reg143, align 1
  %bf.lshr145 = lshr i8 %bf.load144, 4
  %idxprom146 = zext i8 %bf.lshr145 to i64
  %arrayidx147 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %91, i64 %idxprom146
  store %struct.bpf_reg_state* %arrayidx147, %struct.bpf_reg_state** %src_reg142, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %94 = bitcast %struct.bpf_reg_state* %lo_reg0 to i8*
  %95 = bitcast %struct.bpf_reg_state* %93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %94, i8* align 8 %95, i64 104, i1 false)
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg142, align 8
  %97 = bitcast %struct.bpf_reg_state* %lo_reg1 to i8*
  %98 = bitcast %struct.bpf_reg_state* %96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %97, i8* align 8 %98, i64 104, i1 false)
  store %struct.bpf_reg_state* %lo_reg0, %struct.bpf_reg_state** %dst_lo, align 8
  store %struct.bpf_reg_state* %lo_reg1, %struct.bpf_reg_state** %src_lo, align 8
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %99, i32 noundef 4) #8
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %100, i32 noundef 4) #8
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type148 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 0
  %102 = load i32, i32* %type148, align 8
  %cmp149 = icmp eq i32 %102, 1
  br i1 %cmp149, label %land.lhs.true151, label %if.end231

land.lhs.true151:                                 ; preds = %if.then141
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg142, align 8
  %type152 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 0
  %104 = load i32, i32* %type152, align 8
  %cmp153 = icmp eq i32 %104, 1
  br i1 %cmp153, label %if.then155, label %if.end231

if.then155:                                       ; preds = %land.lhs.true151
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg142, align 8
  %var_off156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i32 0, i32 5
  %106 = bitcast %struct.tnum* %var_off156 to { i64, i64 }*
  %107 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %106, i32 0, i32 0
  %108 = load i64, i64* %107, align 8
  %109 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %106, i32 0, i32 1
  %110 = load i64, i64* %109, align 8
  %call157 = call zeroext i1 @tnum_is_const(i64 %108, i64 %110) #8
  br i1 %call157, label %if.then166, label %lor.lhs.false159

lor.lhs.false159:                                 ; preds = %if.then155
  %111 = load i8, i8* %is_jmp32, align 1
  %tobool160 = trunc i8 %111 to i1
  br i1 %tobool160, label %land.lhs.true162, label %if.else179

land.lhs.true162:                                 ; preds = %lor.lhs.false159
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off163 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 5
  %113 = bitcast %struct.tnum* %var_off163 to { i64, i64 }*
  %114 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 0
  %115 = load i64, i64* %114, align 8
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 1
  %117 = load i64, i64* %116, align 8
  %call164 = call zeroext i1 @tnum_is_const(i64 %115, i64 %117) #8
  br i1 %call164, label %if.then166, label %if.else179

if.then166:                                       ; preds = %land.lhs.true162, %if.then155
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 1
  %bf.load168 = load i8, i8* %dst_reg167, align 1
  %bf.clear169 = and i8 %bf.load168, 15
  %idxprom170 = zext i8 %bf.clear169 to i64
  %arrayidx171 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i64 %idxprom170
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %121 = load i8, i8* %is_jmp32, align 1
  %tobool172 = trunc i8 %121 to i1
  br i1 %tobool172, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then166
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_lo, align 8
  %var_off174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 5
  %value175 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off174, i32 0, i32 0
  %123 = load i64, i64* %value175, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then166
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg142, align 8
  %var_off176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 5
  %value177 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off176, i32 0, i32 0
  %125 = load i64, i64* %value177, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %123, %cond.true ], [ %125, %cond.false ]
  %126 = load i8, i8* %opcode, align 1
  %127 = load i8, i8* %is_jmp32, align 1
  %tobool178 = trunc i8 %127 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx171, %struct.bpf_reg_state* noundef %120, i64 noundef %cond, i8 noundef zeroext %126, i1 noundef zeroext %tobool178) #8
  br label %if.end230

if.else179:                                       ; preds = %land.lhs.true162, %lor.lhs.false159
  %128 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off180 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %128, i32 0, i32 5
  %129 = bitcast %struct.tnum* %var_off180 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call181 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #8
  br i1 %call181, label %if.then190, label %lor.lhs.false183

lor.lhs.false183:                                 ; preds = %if.else179
  %134 = load i8, i8* %is_jmp32, align 1
  %tobool184 = trunc i8 %134 to i1
  br i1 %tobool184, label %land.lhs.true186, label %if.else207

land.lhs.true186:                                 ; preds = %lor.lhs.false183
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off187 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %135, i32 0, i32 5
  %136 = bitcast %struct.tnum* %var_off187 to { i64, i64 }*
  %137 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %136, i32 0, i32 0
  %138 = load i64, i64* %137, align 8
  %139 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %136, i32 0, i32 1
  %140 = load i64, i64* %139, align 8
  %call188 = call zeroext i1 @tnum_is_const(i64 %138, i64 %140) #8
  br i1 %call188, label %if.then190, label %if.else207

if.then190:                                       ; preds = %land.lhs.true186, %if.else179
  %141 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg191 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %142, i32 0, i32 1
  %bf.load192 = load i8, i8* %src_reg191, align 1
  %bf.lshr193 = lshr i8 %bf.load192, 4
  %idxprom194 = zext i8 %bf.lshr193 to i64
  %arrayidx195 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %141, i64 %idxprom194
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg142, align 8
  %144 = load i8, i8* %is_jmp32, align 1
  %tobool196 = trunc i8 %144 to i1
  br i1 %tobool196, label %cond.true198, label %cond.false201

cond.true198:                                     ; preds = %if.then190
  %145 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_lo, align 8
  %var_off199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %145, i32 0, i32 5
  %value200 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off199, i32 0, i32 0
  %146 = load i64, i64* %value200, align 8
  br label %cond.end204

cond.false201:                                    ; preds = %if.then190
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 5
  %value203 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off202, i32 0, i32 0
  %148 = load i64, i64* %value203, align 8
  br label %cond.end204

cond.end204:                                      ; preds = %cond.false201, %cond.true198
  %cond205 = phi i64 [ %146, %cond.true198 ], [ %148, %cond.false201 ]
  %149 = load i8, i8* %opcode, align 1
  %150 = load i8, i8* %is_jmp32, align 1
  %tobool206 = trunc i8 %150 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %arrayidx195, %struct.bpf_reg_state* noundef %143, i64 noundef %cond205, i8 noundef zeroext %149, i1 noundef zeroext %tobool206) #8
  br label %if.end229

if.else207:                                       ; preds = %land.lhs.true186, %lor.lhs.false183
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool208 = trunc i8 %151 to i1
  br i1 %tobool208, label %if.end228, label %land.lhs.true209

land.lhs.true209:                                 ; preds = %if.else207
  %152 = load i8, i8* %opcode, align 1
  %conv210 = zext i8 %152 to i32
  %cmp211 = icmp eq i32 %conv210, 16
  br i1 %cmp211, label %if.then217, label %lor.lhs.false213

lor.lhs.false213:                                 ; preds = %land.lhs.true209
  %153 = load i8, i8* %opcode, align 1
  %conv214 = zext i8 %153 to i32
  %cmp215 = icmp eq i32 %conv214, 80
  br i1 %cmp215, label %if.then217, label %if.end228

if.then217:                                       ; preds = %lor.lhs.false213, %land.lhs.true209
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %155 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %155, i32 0, i32 1
  %bf.load219 = load i8, i8* %src_reg218, align 1
  %bf.lshr220 = lshr i8 %bf.load219, 4
  %idxprom221 = zext i8 %bf.lshr220 to i64
  %arrayidx222 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i64 %idxprom221
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %157 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg223 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %157, i32 0, i32 1
  %bf.load224 = load i8, i8* %dst_reg223, align 1
  %bf.clear225 = and i8 %bf.load224, 15
  %idxprom226 = zext i8 %bf.clear225 to i64
  %arrayidx227 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i64 %idxprom226
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg142, align 8
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %160 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %arrayidx222, %struct.bpf_reg_state* noundef %arrayidx227, %struct.bpf_reg_state* noundef %158, %struct.bpf_reg_state* noundef %159, i8 noundef zeroext %160) #8
  br label %if.end228

if.end228:                                        ; preds = %if.then217, %lor.lhs.false213, %if.else207
  br label %if.end229

if.end229:                                        ; preds = %if.end228, %cond.end204
  br label %if.end230

if.end230:                                        ; preds = %if.end229, %cond.end
  br label %if.end231

if.end231:                                        ; preds = %if.end230, %land.lhs.true151, %if.then141
  br label %if.end246

if.else232:                                       ; preds = %if.end129
  %161 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type233 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %161, i32 0, i32 0
  %162 = load i32, i32* %type233, align 8
  %cmp234 = icmp eq i32 %162, 1
  br i1 %cmp234, label %if.then236, label %if.end245

if.then236:                                       ; preds = %if.else232
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %164 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg237 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %164, i32 0, i32 1
  %bf.load238 = load i8, i8* %dst_reg237, align 1
  %bf.clear239 = and i8 %bf.load238, 15
  %idxprom240 = zext i8 %bf.clear239 to i64
  %arrayidx241 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %163, i64 %idxprom240
  %165 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %166 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm242 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %166, i32 0, i32 3
  %167 = load i32, i32* %imm242, align 4
  %conv243 = sext i32 %167 to i64
  %168 = load i8, i8* %opcode, align 1
  %169 = load i8, i8* %is_jmp32, align 1
  %tobool244 = trunc i8 %169 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx241, %struct.bpf_reg_state* noundef %165, i64 noundef %conv243, i8 noundef zeroext %168, i1 noundef zeroext %tobool244) #8
  br label %if.end245

if.end245:                                        ; preds = %if.then236, %if.else232
  br label %if.end246

if.end246:                                        ; preds = %if.end245, %if.end231
  %170 = load i8, i8* %is_jmp32, align 1
  %tobool247 = trunc i8 %170 to i1
  br i1 %tobool247, label %if.else285, label %land.lhs.true248

land.lhs.true248:                                 ; preds = %if.end246
  %171 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code249 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %171, i32 0, i32 0
  %172 = load i8, i8* %code249, align 4
  %conv250 = zext i8 %172 to i32
  %and251 = and i32 %conv250, 8
  %cmp252 = icmp eq i32 %and251, 0
  br i1 %cmp252, label %land.lhs.true254, label %if.else285

land.lhs.true254:                                 ; preds = %land.lhs.true248
  %173 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm255 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %173, i32 0, i32 3
  %174 = load i32, i32* %imm255, align 4
  %cmp256 = icmp eq i32 %174, 0
  br i1 %cmp256, label %land.lhs.true258, label %if.else285

land.lhs.true258:                                 ; preds = %land.lhs.true254
  %175 = load i8, i8* %opcode, align 1
  %conv259 = zext i8 %175 to i32
  %cmp260 = icmp eq i32 %conv259, 16
  br i1 %cmp260, label %land.lhs.true266, label %lor.lhs.false262

lor.lhs.false262:                                 ; preds = %land.lhs.true258
  %176 = load i8, i8* %opcode, align 1
  %conv263 = zext i8 %176 to i32
  %cmp264 = icmp eq i32 %conv263, 80
  br i1 %cmp264, label %land.lhs.true266, label %if.else285

land.lhs.true266:                                 ; preds = %lor.lhs.false262, %land.lhs.true258
  %177 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type267 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %177, i32 0, i32 0
  %178 = load i32, i32* %type267, align 8
  %call268 = call zeroext i1 @reg_type_may_be_null(i32 noundef %178) #8
  br i1 %call268, label %if.then270, label %if.else285

if.then270:                                       ; preds = %land.lhs.true266
  %179 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %180 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %180, i32 0, i32 1
  %bf.load272 = load i8, i8* %dst_reg271, align 1
  %bf.clear273 = and i8 %bf.load272, 15
  %conv274 = zext i8 %bf.clear273 to i32
  %181 = load i8, i8* %opcode, align 1
  %conv275 = zext i8 %181 to i32
  %cmp276 = icmp eq i32 %conv275, 80
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %179, i32 noundef %conv274, i1 noundef zeroext %cmp276) #8
  %182 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %183 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg278 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %183, i32 0, i32 1
  %bf.load279 = load i8, i8* %dst_reg278, align 1
  %bf.clear280 = and i8 %bf.load279, 15
  %conv281 = zext i8 %bf.clear280 to i32
  %184 = load i8, i8* %opcode, align 1
  %conv282 = zext i8 %184 to i32
  %cmp283 = icmp eq i32 %conv282, 16
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %182, i32 noundef %conv281, i1 noundef zeroext %cmp283) #8
  br label %if.end305

if.else285:                                       ; preds = %land.lhs.true266, %lor.lhs.false262, %land.lhs.true254, %land.lhs.true248, %if.end246
  %185 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %188 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg286 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %188, i32 0, i32 1
  %bf.load287 = load i8, i8* %src_reg286, align 1
  %bf.lshr288 = lshr i8 %bf.load287, 4
  %idxprom289 = zext i8 %bf.lshr288 to i64
  %arrayidx290 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %187, i64 %idxprom289
  %189 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %190 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %call291 = call zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %185, %struct.bpf_reg_state* noundef %186, %struct.bpf_reg_state* noundef %arrayidx290, %struct.bpf_verifier_state* noundef %189, %struct.bpf_verifier_state* noundef %190) #8
  br i1 %call291, label %if.end304, label %land.lhs.true292

land.lhs.true292:                                 ; preds = %if.else285
  %191 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %192 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg293 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %192, i32 0, i32 1
  %bf.load294 = load i8, i8* %dst_reg293, align 1
  %bf.clear295 = and i8 %bf.load294, 15
  %conv296 = zext i8 %bf.clear295 to i32
  %call297 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %191, i32 noundef %conv296) #8
  br i1 %call297, label %if.then299, label %if.end304

if.then299:                                       ; preds = %land.lhs.true292
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = bitcast %struct.bpf_verifier_env* %193 to i8*
  %195 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg300 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %195, i32 0, i32 1
  %bf.load301 = load i8, i8* %dst_reg300, align 1
  %bf.clear302 = and i8 %bf.load301, 15
  %conv303 = zext i8 %bf.clear302 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %194, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.272, i64 0, i64 0), i32 noundef %conv303) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end304:                                        ; preds = %land.lhs.true292, %if.else285
  br label %if.end305

if.end305:                                        ; preds = %if.end304, %if.then270
  %196 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %196, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %197 = load i32, i32* %level, align 8
  %and306 = and i32 %197, 3
  %tobool307 = icmp ne i32 %and306, 0
  br i1 %tobool307, label %if.then308, label %if.end313

if.then308:                                       ; preds = %if.end305
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %199 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame309 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %199, i32 0, i32 0
  %200 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe310 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %200, i32 0, i32 4
  %201 = load i32, i32* %curframe310, align 8
  %idxprom311 = zext i32 %201 to i64
  %arrayidx312 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame309, i64 0, i64 %idxprom311
  %202 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx312, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %198, %struct.bpf_func_state* noundef %202) #8
  br label %if.end313

if.end313:                                        ; preds = %if.then308, %if.end305
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end313, %if.then299, %if.then128, %if.then119, %if.then114, %if.then109, %if.then53, %if.then45, %if.then28, %if.then21, %if.then17, %if.then
  %203 = load i32, i32* %retval, align 4
  ret i32 %203
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %mode = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 224
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %mode, align 1
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 2
  %5 = load i32, i32* %type, align 4
  %call2 = call zeroext i1 @may_access_skb(i32 noundef %5) #8
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.273, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 3
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 3
  %10 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, %struct.bpf_insn*)* %10, null
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 21
  %14 = load i32, i32* %subprog_cnt, align 8
  %cmp = icmp ugt i32 %14, 1
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.275, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv8 = zext i8 %bf.clear to i32
  %cmp9 = icmp ne i32 %conv8, 0
  br i1 %cmp9, label %if.then28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 2
  %19 = load i16, i16* %off, align 2
  %conv11 = sext i16 %19 to i32
  %cmp12 = icmp ne i32 %conv11, 0
  br i1 %cmp12, label %if.then28, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %lor.lhs.false
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code15 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 0
  %21 = load i8, i8* %code15, align 4
  %conv16 = zext i8 %21 to i32
  %and17 = and i32 %conv16, 24
  %cmp18 = icmp eq i32 %and17, 24
  br i1 %cmp18, label %if.then28, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false14
  %22 = load i8, i8* %mode, align 1
  %conv21 = zext i8 %22 to i32
  %cmp22 = icmp eq i32 %conv21, 32
  br i1 %cmp22, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %lor.lhs.false20
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 1
  %bf.load24 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load24, 4
  %conv25 = zext i8 %bf.lshr to i32
  %cmp26 = icmp ne i32 %conv25, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true, %lor.lhs.false14, %lor.lhs.false, %if.end7
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.276, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %land.lhs.true, %lor.lhs.false20
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call30 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %26, i32 noundef 6, i32 noundef 0) #8
  store i32 %call30, i32* %err, align 4
  %27 = load i32, i32* %err, align 4
  %tobool31 = icmp ne i32 %27, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  %28 = load i32, i32* %err, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end29
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call34 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %29) #8
  store i32 %call34, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool35 = icmp ne i32 %30, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end33
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.277, i64 0, i64 0)) #8
  %33 = load i32, i32* %err, align 4
  store i32 %33, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end33
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 8
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %35, i32 0, i32 5
  %36 = load i32, i32* %active_spin_lock, align 4
  %tobool38 = icmp ne i32 %36, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end37
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.278, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end37
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i64 6
  %type41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  %40 = load i32, i32* %type41, align 8
  %cmp42 = icmp ne i32 %40, 2
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end40
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.279, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.end40
  %43 = load i8, i8* %mode, align 1
  %conv46 = zext i8 %43 to i32
  %cmp47 = icmp eq i32 %conv46, 64
  br i1 %cmp47, label %if.then49, label %if.end58

if.then49:                                        ; preds = %if.end45
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg50 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 1
  %bf.load51 = load i8, i8* %src_reg50, align 1
  %bf.lshr52 = lshr i8 %bf.load51, 4
  %conv53 = zext i8 %bf.lshr52 to i32
  %call54 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %44, i32 noundef %conv53, i32 noundef 0) #8
  store i32 %call54, i32* %err, align 4
  %46 = load i32, i32* %err, align 4
  %tobool55 = icmp ne i32 %46, 0
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.then49
  %47 = load i32, i32* %err, align 4
  store i32 %47, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %if.then49
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end45
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end58
  %48 = load i32, i32* %i, align 4
  %cmp59 = icmp slt i32 %48, 6
  br i1 %cmp59, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom = sext i32 %51 to i64
  %arrayidx61 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %52 = load i32, i32* %arrayidx61, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %49, %struct.bpf_reg_state* noundef %50, i32 noundef %52) #8
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load i32, i32* %i, align 4
  %idxprom62 = sext i32 %54 to i64
  %arrayidx63 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom62
  %55 = load i32, i32* %arrayidx63, align 4
  %call64 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %53, i32 noundef %55, i32 noundef 2) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %56 = load i32, i32* %i, align 4
  %inc = add i32 %56, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %57, %struct.bpf_reg_state* noundef %58, i32 noundef 0) #8
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %59, i32 0, i32 0
  %60 = load i32, i32* %insn_idx, align 8
  %add = add i32 %60, 1
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx65 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx65, i32 0, i32 12
  store i32 %add, i32* %subreg_def, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then56, %if.then44, %if.then39, %if.then36, %if.then32, %if.then28, %if.then6, %if.then3, %if.then
  %62 = load i32, i32* %retval, align 4
  ret i32 %62
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %imm = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call1 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #8
  store %struct.bpf_reg_state* %call1, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.280, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 2
  %7 = load i16, i16* %off, align 2
  %conv3 = sext i16 %7 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.281, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv8 = zext i8 %bf.clear to i32
  %call9 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %10, i32 noundef %conv8, i32 noundef 1) #8
  store i32 %call9, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end7
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 1
  %bf.load12 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load12, 4
  %conv13 = zext i8 %bf.lshr to i32
  %cmp14 = icmp eq i32 %conv13, 0
  br i1 %cmp14, label %if.then16, label %if.end29

if.then16:                                        ; preds = %if.end11
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %15, i64 1
  %imm17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i32 0, i32 3
  %16 = load i32, i32* %imm17, align 4
  %conv18 = sext i32 %16 to i64
  %shl = shl i64 %conv18, 32
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 3
  %18 = load i32, i32* %imm19, align 4
  %conv20 = zext i32 %18 to i64
  %or = or i64 %shl, %conv20
  store i64 %or, i64* %imm, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load22 = load i8, i8* %dst_reg21, align 1
  %bf.clear23 = and i8 %bf.load22, 15
  %idxprom = zext i8 %bf.clear23 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i64 %idxprom
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 1
  %bf.load25 = load i8, i8* %dst_reg24, align 1
  %bf.clear26 = and i8 %bf.load25, 15
  %idxprom27 = zext i8 %bf.clear26 to i64
  %arrayidx28 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i64 %idxprom27
  %23 = load i64, i64* %imm, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx28, i64 noundef %23) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end11
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 11
  %25 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %26 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %25, i32 0, i32 0
  %27 = bitcast %union.anon.13* %26 to %struct.util_est*
  %map_index = getelementptr inbounds %struct.util_est, %struct.util_est* %27, i32 0, i32 0
  %28 = load i32, i32* %map_index, align 8
  %idxprom30 = zext i32 %28 to i64
  %arrayidx31 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom30
  %29 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx31, align 8
  store %struct.bpf_map* %29, %struct.bpf_map** %map, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg32 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load33 = load i8, i8* %dst_reg32, align 1
  %bf.clear34 = and i8 %bf.load33, 15
  %conv35 = zext i8 %bf.clear34 to i32
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %30, %struct.bpf_reg_state* noundef %31, i32 noundef %conv35) #8
  %33 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %35, i32 0, i32 1
  %bf.load37 = load i8, i8* %dst_reg36, align 1
  %bf.clear38 = and i8 %bf.load37, 15
  %idxprom39 = zext i8 %bf.clear38 to i64
  %arrayidx40 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i64 %idxprom39
  %36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx40, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %36 to %struct.bpf_map**
  store %struct.bpf_map* %33, %struct.bpf_map** %map_ptr, align 8
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg41 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %37, i32 0, i32 1
  %bf.load42 = load i8, i8* %src_reg41, align 1
  %bf.lshr43 = lshr i8 %bf.load42, 4
  %conv44 = zext i8 %bf.lshr43 to i32
  %cmp45 = icmp eq i32 %conv44, 2
  br i1 %cmp45, label %if.then47, label %if.else

if.then47:                                        ; preds = %if.end29
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 1
  %bf.load49 = load i8, i8* %dst_reg48, align 1
  %bf.clear50 = and i8 %bf.load49, 15
  %idxprom51 = zext i8 %bf.clear50 to i64
  %arrayidx52 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i64 %idxprom51
  %type53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx52, i32 0, i32 0
  store i32 4, i32* %type53, align 8
  %40 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %41 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %40, i32 0, i32 0
  %42 = bitcast %union.anon.13* %41 to %struct.util_est*
  %map_off = getelementptr inbounds %struct.util_est, %struct.util_est* %42, i32 0, i32 1
  %43 = load i32, i32* %map_off, align 4
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 1
  %bf.load55 = load i8, i8* %dst_reg54, align 1
  %bf.clear56 = and i8 %bf.load55, 15
  %idxprom57 = zext i8 %bf.clear56 to i64
  %arrayidx58 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i64 %idxprom57
  %off59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx58, i32 0, i32 2
  store i32 %43, i32* %off59, align 8
  %46 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call60 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %46) #8
  br i1 %call60, label %if.then61, label %if.end67

if.then61:                                        ; preds = %if.then47
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 13
  %48 = load i32, i32* %id_gen, align 4
  %inc = add i32 %48, 1
  store i32 %inc, i32* %id_gen, align 4
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg62 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 1
  %bf.load63 = load i8, i8* %dst_reg62, align 1
  %bf.clear64 = and i8 %bf.load63, 15
  %idxprom65 = zext i8 %bf.clear64 to i64
  %arrayidx66 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i64 %idxprom65
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx66, i32 0, i32 3
  store i32 %inc, i32* %id, align 4
  br label %if.end67

if.end67:                                         ; preds = %if.then61, %if.then47
  br label %if.end83

if.else:                                          ; preds = %if.end29
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 1
  %bf.load69 = load i8, i8* %src_reg68, align 1
  %bf.lshr70 = lshr i8 %bf.load69, 4
  %conv71 = zext i8 %bf.lshr70 to i32
  %cmp72 = icmp eq i32 %conv71, 1
  br i1 %cmp72, label %if.then74, label %if.else81

if.then74:                                        ; preds = %if.else
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %53 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %53, i32 0, i32 1
  %bf.load76 = load i8, i8* %dst_reg75, align 1
  %bf.clear77 = and i8 %bf.load76, 15
  %idxprom78 = zext i8 %bf.clear77 to i64
  %arrayidx79 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i64 %idxprom78
  %type80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx79, i32 0, i32 0
  store i32 3, i32* %type80, align 8
  br label %if.end82

if.else81:                                        ; preds = %if.else
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.274, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.then74
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.end67
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end83, %if.else81, %if.then16, %if.then10, %if.then6, %if.then
  %56 = load i32, i32* %retval, align 4
  ret i32 %56
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 973, i32 2305, i64 12) #9, !srcloc !31
  br label %do.end

do.end:                                           ; preds = %do.body7
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 127) #9, !srcloc !32
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %2, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  store i64 %conv14, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool15 = icmp ne i64 %3, 0
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.67, i64 0, i64 0), i32 noundef %6) #8
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then16
  %7 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp ult i32 %7, 11
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %add.ptr) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end19:                                         ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %idx.ext20 = zext i32 %12 to i64
  %add.ptr21 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i64 %idx.ext20
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %add.ptr21) #8
  br label %return

return:                                           ; preds = %if.end19, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 8
  %1 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp sge i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %0) #8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 0, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_skb(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1122, i32 2305, i64 12) #9, !srcloc !33
  br label %do.end

do.end:                                           ; preds = %do.body7
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 145) #9, !srcloc !34
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %2, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  store i64 %conv14, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool15 = icmp ne i64 %3, 0
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.66, i64 0, i64 0), i32 noundef %6) #8
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then16
  %7 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp ult i32 %7, 10
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %add.ptr) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end19:                                         ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %idx.ext20 = zext i32 %12 to i64
  %add.ptr21 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i64 %idx.ext20
  call void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %add.ptr21) #8
  br label %return

return:                                           ; preds = %if.end19, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1099, i32 2305, i64 12) #9, !srcloc !35
  br label %do.end

do.end:                                           ; preds = %do.body7
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 144) #9, !srcloc !36
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %2, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  store i64 %conv14, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool15 = icmp ne i64 %3, 0
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.123, i64 0, i64 0), i32 noundef %6) #8
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then16
  %7 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp ult i32 %7, 10
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %add.ptr) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end19:                                         ; preds = %if.end
  %11 = load i32, i32* %regno.addr, align 4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %idx.ext20 = zext i32 %11 to i64
  %add.ptr21 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 %idx.ext20
  store %struct.bpf_reg_state* %add.ptr21, %struct.bpf_reg_state** %regs.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %13) #8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 21
  %15 = load i32, i32* %subprog_cnt, align 8
  %cmp22 = icmp ugt i32 %15, 1
  br i1 %cmp22, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end19
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 14
  %17 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool24 = trunc i8 %17 to i1
  %lnot25 = xor i1 %tobool24, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end19
  %18 = phi i1 [ true, %if.end19 ], [ %lnot25, %lor.rhs ]
  %19 = zext i1 %18 to i64
  %cond = select i1 %18, i32 1, i32 0
  %tobool27 = icmp ne i32 %cond, 0
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 14
  %frombool = zext i1 %tobool27 to i8
  store i8 %frombool, i8* %precise, align 4
  br label %return

return:                                           ; preds = %lor.end, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef %1, i32 noundef -1) #8
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %prev_insn_idx, i1 noundef zeroext %speculative) #0 {
entry:
  %retval = alloca %struct.bpf_verifier_state*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %prev_insn_idx.addr = alloca i32, align 4
  %speculative.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %prev_insn_idx, i32* %prev_insn_idx.addr, align 4
  %frombool = zext i1 %speculative to i8
  store i8 %frombool, i8* %speculative.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %call = call i8* @kzalloc(i64 noundef 136, i32 noundef 3264) #8
  %2 = bitcast i8* %call to %struct.bpf_verifier_stack_elem*
  store %struct.bpf_verifier_stack_elem* %2, %struct.bpf_verifier_stack_elem** %elem, align 8
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %tobool = icmp ne %struct.bpf_verifier_stack_elem* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err28

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %insn_idx.addr, align 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %insn_idx1 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %5, i32 0, i32 1
  store i32 %4, i32* %insn_idx1, align 8
  %6 = load i32, i32* %prev_insn_idx.addr, align 4
  %7 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %7, i32 0, i32 2
  store i32 %6, i32* %prev_insn_idx2, align 4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 4
  %9 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %10 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %10, i32 0, i32 3
  store %struct.bpf_verifier_stack_elem* %9, %struct.bpf_verifier_stack_elem** %next, align 8
  %11 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %11, %struct.bpf_verifier_stack_elem** %head3, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 5
  %14 = load i32, i32* %stack_size, align 8
  %inc = add i32 %14, 1
  store i32 %inc, i32* %stack_size, align 8
  %15 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %15, i32 0, i32 0
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call4 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %st, %struct.bpf_verifier_state* noundef %16) #8
  store i32 %call4, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %tobool5 = icmp ne i32 %17, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %err28

if.end7:                                          ; preds = %if.end
  %18 = load i8, i8* %speculative.addr, align 1
  %tobool8 = trunc i8 %18 to i1
  %conv = zext i1 %tobool8 to i32
  %19 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st9 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %19, i32 0, i32 0
  %speculative10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st9, i32 0, i32 6
  %20 = load i8, i8* %speculative10, align 8
  %tobool11 = trunc i8 %20 to i1
  %conv12 = zext i1 %tobool11 to i32
  %or = or i32 %conv12, %conv
  %tobool13 = icmp ne i32 %or, 0
  %frombool14 = zext i1 %tobool13 to i8
  store i8 %frombool14, i8* %speculative10, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 5
  %22 = load i32, i32* %stack_size15, align 8
  %cmp = icmp sgt i32 %22, 8192
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end7
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 5
  %26 = load i32, i32* %stack_size18, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.143, i64 0, i64 0), i32 noundef %26) #8
  br label %err28

if.end19:                                         ; preds = %if.end7
  %27 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st20 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %27, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st20, i32 0, i32 1
  %28 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %tobool21 = icmp ne %struct.bpf_verifier_state* %28, null
  br i1 %tobool21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end19
  %29 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st23 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %29, i32 0, i32 0
  %parent24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st23, i32 0, i32 1
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent24, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %30, i32 0, i32 2
  %31 = load i32, i32* %branches, align 8
  %inc25 = add i32 %31, 1
  store i32 %inc25, i32* %branches, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end19
  %32 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st27 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %32, i32 0, i32 0
  store %struct.bpf_verifier_state* %st27, %struct.bpf_verifier_state** %retval, align 8
  br label %return

err28:                                            ; preds = %if.then17, %if.then6, %if.then
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 8
  %34 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %34, i1 noundef zeroext true) #8
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state30, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err28
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %36, i32* noundef null, i32* noundef null) #8
  %tobool32 = icmp ne i32 %call31, 0
  %lnot = xor i1 %tobool32, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end26
  %37 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %retval, align 8
  ret %struct.bpf_verifier_state* %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 14
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 16
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %vstate, i32 noundef %regno, i1 noundef zeroext %is_null) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %regno.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %ref_obj_id = alloca i32, align 4
  %id = alloca i32, align 4
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom2
  %ref_obj_id4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 4
  %7 = load i32, i32* %ref_obj_id4, align 8
  store i32 %7, i32* %ref_obj_id, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idxprom5 = zext i32 %9 to i64
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idxprom5
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 3
  %10 = load i32, i32* %id7, align 4
  store i32 %10, i32* %id, align 4
  %11 = load i32, i32* %ref_obj_id, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %entry
  %12 = load i32, i32* %ref_obj_id, align 4
  %13 = load i32, i32* %id, align 4
  %cmp = icmp eq i32 %12, %13
  br i1 %cmp, label %land.lhs.true8, label %if.end27

land.lhs.true8:                                   ; preds = %land.lhs.true
  %14 = load i8, i8* %is_null.addr, align 1
  %tobool9 = trunc i8 %14 to i1
  br i1 %tobool9, label %if.then, label %if.end27

if.then:                                          ; preds = %land.lhs.true8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %16 = load i32, i32* %id, align 4
  %call = call i32 @release_reference_state(%struct.bpf_func_state* noundef %15, i32 noundef %16) #8
  %tobool10 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %17 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %17, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext16 to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then18
  br label %do.body19

do.body19:                                        ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 5994, i32 2307, i64 12) #9, !srcloc !37
  br label %do.end

do.end:                                           ; preds = %do.body19
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 210) #9, !srcloc !38
  br label %do.end20

do.end20:                                         ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end20, %if.then
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool21 = icmp ne i32 %18, 0
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  store i64 %conv26, i64* %tmp, align 8
  %19 = load i64, i64* %tmp, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.end, %land.lhs.true8, %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end27
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 4
  %22 = load i32, i32* %curframe28, align 8
  %cmp29 = icmp ule i32 %20, %22
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame31 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %24 to i64
  %arrayidx33 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame31, i64 0, i64 %idxprom32
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx33, align 8
  %26 = load i32, i32* %id, align 4
  %27 = load i8, i8* %is_null.addr, align 1
  %tobool34 = trunc i8 %27 to i1
  call void @__mark_ptr_or_null_regs(%struct.bpf_func_state* noundef %25, i32 noundef %26, i1 noundef zeroext %tobool34) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_verifier_state* noundef %this_branch, %struct.bpf_verifier_state* noundef %other_branch) #0 {
entry:
  %retval = alloca i1, align 1
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %this_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  %other_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_verifier_state* %this_branch, %struct.bpf_verifier_state** %this_branch.addr, align 8
  store %struct.bpf_verifier_state* %other_branch, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 8
  %cmp = icmp ne i32 %and, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 7
  %cmp5 = icmp eq i32 %and4, 6
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 0
  %5 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %5 to i32
  %and11 = and i32 %conv10, 240
  switch i32 %and11, label %sw.default [
    i32 32, label %sw.bb
    i32 160, label %sw.bb43
    i32 48, label %sw.bb80
    i32 176, label %sw.bb117
  ]

sw.bb:                                            ; preds = %if.end8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp12 = icmp eq i32 %7, 8
  br i1 %cmp12, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %9, 9
  br i1 %cmp15, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %sw.bb
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type17, align 8
  %cmp18 = icmp eq i32 %11, 7
  br i1 %cmp18, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %lor.lhs.false
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %12, i32 noundef 8) #8
  br i1 %call, label %if.then22, label %if.else

if.then22:                                        ; preds = %land.lhs.true20, %land.lhs.true
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type23, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef %16, i1 noundef zeroext false) #8
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true20, %lor.lhs.false
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type24, align 8
  %cmp25 = icmp eq i32 %18, 9
  br i1 %cmp25, label %land.lhs.true27, label %lor.lhs.false31

land.lhs.true27:                                  ; preds = %if.else
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type28, align 8
  %cmp29 = icmp eq i32 %20, 8
  br i1 %cmp29, label %if.then38, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %land.lhs.true27, %if.else
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call32 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %21, i32 noundef 8) #8
  br i1 %call32, label %land.lhs.true34, label %if.else40

land.lhs.true34:                                  ; preds = %lor.lhs.false31
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %23, 7
  br i1 %cmp36, label %if.then38, label %if.else40

if.then38:                                        ; preds = %land.lhs.true34, %land.lhs.true27
  %24 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 0
  %27 = load i32, i32* %type39, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %24, %struct.bpf_reg_state* noundef %25, i32 noundef %27, i1 noundef zeroext true) #8
  br label %if.end41

if.else40:                                        ; preds = %land.lhs.true34, %lor.lhs.false31
  store i1 false, i1* %retval, align 1
  br label %return

if.end41:                                         ; preds = %if.then38
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then22
  br label %sw.epilog

sw.bb43:                                          ; preds = %if.end8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 0
  %29 = load i32, i32* %type44, align 8
  %cmp45 = icmp eq i32 %29, 8
  br i1 %cmp45, label %land.lhs.true47, label %lor.lhs.false51

land.lhs.true47:                                  ; preds = %sw.bb43
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type48 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type48, align 8
  %cmp49 = icmp eq i32 %31, 9
  br i1 %cmp49, label %if.then58, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %land.lhs.true47, %sw.bb43
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type52, align 8
  %cmp53 = icmp eq i32 %33, 7
  br i1 %cmp53, label %land.lhs.true55, label %if.else60

land.lhs.true55:                                  ; preds = %lor.lhs.false51
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call56 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %34, i32 noundef 8) #8
  br i1 %call56, label %if.then58, label %if.else60

if.then58:                                        ; preds = %land.lhs.true55, %land.lhs.true47
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 0
  %38 = load i32, i32* %type59, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %35, %struct.bpf_reg_state* noundef %36, i32 noundef %38, i1 noundef zeroext true) #8
  br label %if.end79

if.else60:                                        ; preds = %land.lhs.true55, %lor.lhs.false51
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type61, align 8
  %cmp62 = icmp eq i32 %40, 9
  br i1 %cmp62, label %land.lhs.true64, label %lor.lhs.false68

land.lhs.true64:                                  ; preds = %if.else60
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type65, align 8
  %cmp66 = icmp eq i32 %42, 8
  br i1 %cmp66, label %if.then75, label %lor.lhs.false68

lor.lhs.false68:                                  ; preds = %land.lhs.true64, %if.else60
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call69 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %43, i32 noundef 8) #8
  br i1 %call69, label %land.lhs.true71, label %if.else77

land.lhs.true71:                                  ; preds = %lor.lhs.false68
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type72, align 8
  %cmp73 = icmp eq i32 %45, 7
  br i1 %cmp73, label %if.then75, label %if.else77

if.then75:                                        ; preds = %land.lhs.true71, %land.lhs.true64
  %46 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type76, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %46, %struct.bpf_reg_state* noundef %47, i32 noundef %49, i1 noundef zeroext false) #8
  br label %if.end78

if.else77:                                        ; preds = %land.lhs.true71, %lor.lhs.false68
  store i1 false, i1* %retval, align 1
  br label %return

if.end78:                                         ; preds = %if.then75
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.then58
  br label %sw.epilog

sw.bb80:                                          ; preds = %if.end8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  %51 = load i32, i32* %type81, align 8
  %cmp82 = icmp eq i32 %51, 8
  br i1 %cmp82, label %land.lhs.true84, label %lor.lhs.false88

land.lhs.true84:                                  ; preds = %sw.bb80
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 0
  %53 = load i32, i32* %type85, align 8
  %cmp86 = icmp eq i32 %53, 9
  br i1 %cmp86, label %if.then95, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %land.lhs.true84, %sw.bb80
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 0
  %55 = load i32, i32* %type89, align 8
  %cmp90 = icmp eq i32 %55, 7
  br i1 %cmp90, label %land.lhs.true92, label %if.else97

land.lhs.true92:                                  ; preds = %lor.lhs.false88
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call93 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %56, i32 noundef 8) #8
  br i1 %call93, label %if.then95, label %if.else97

if.then95:                                        ; preds = %land.lhs.true92, %land.lhs.true84
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 0
  %60 = load i32, i32* %type96, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %57, %struct.bpf_reg_state* noundef %58, i32 noundef %60, i1 noundef zeroext true) #8
  br label %if.end116

if.else97:                                        ; preds = %land.lhs.true92, %lor.lhs.false88
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type98, align 8
  %cmp99 = icmp eq i32 %62, 9
  br i1 %cmp99, label %land.lhs.true101, label %lor.lhs.false105

land.lhs.true101:                                 ; preds = %if.else97
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 0
  %64 = load i32, i32* %type102, align 8
  %cmp103 = icmp eq i32 %64, 8
  br i1 %cmp103, label %if.then112, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %land.lhs.true101, %if.else97
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call106 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %65, i32 noundef 8) #8
  br i1 %call106, label %land.lhs.true108, label %if.else114

land.lhs.true108:                                 ; preds = %lor.lhs.false105
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %67, 7
  br i1 %cmp110, label %if.then112, label %if.else114

if.then112:                                       ; preds = %land.lhs.true108, %land.lhs.true101
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type113 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 0
  %71 = load i32, i32* %type113, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %68, %struct.bpf_reg_state* noundef %69, i32 noundef %71, i1 noundef zeroext false) #8
  br label %if.end115

if.else114:                                       ; preds = %land.lhs.true108, %lor.lhs.false105
  store i1 false, i1* %retval, align 1
  br label %return

if.end115:                                        ; preds = %if.then112
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then95
  br label %sw.epilog

sw.bb117:                                         ; preds = %if.end8
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type118 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 0
  %73 = load i32, i32* %type118, align 8
  %cmp119 = icmp eq i32 %73, 8
  br i1 %cmp119, label %land.lhs.true121, label %lor.lhs.false125

land.lhs.true121:                                 ; preds = %sw.bb117
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type122 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 0
  %75 = load i32, i32* %type122, align 8
  %cmp123 = icmp eq i32 %75, 9
  br i1 %cmp123, label %if.then132, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %land.lhs.true121, %sw.bb117
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 0
  %77 = load i32, i32* %type126, align 8
  %cmp127 = icmp eq i32 %77, 7
  br i1 %cmp127, label %land.lhs.true129, label %if.else134

land.lhs.true129:                                 ; preds = %lor.lhs.false125
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call130 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %78, i32 noundef 8) #8
  br i1 %call130, label %if.then132, label %if.else134

if.then132:                                       ; preds = %land.lhs.true129, %land.lhs.true121
  %79 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type133 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 0
  %82 = load i32, i32* %type133, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %79, %struct.bpf_reg_state* noundef %80, i32 noundef %82, i1 noundef zeroext false) #8
  br label %if.end153

if.else134:                                       ; preds = %land.lhs.true129, %lor.lhs.false125
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 0
  %84 = load i32, i32* %type135, align 8
  %cmp136 = icmp eq i32 %84, 9
  br i1 %cmp136, label %land.lhs.true138, label %lor.lhs.false142

land.lhs.true138:                                 ; preds = %if.else134
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type139 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 0
  %86 = load i32, i32* %type139, align 8
  %cmp140 = icmp eq i32 %86, 8
  br i1 %cmp140, label %if.then149, label %lor.lhs.false142

lor.lhs.false142:                                 ; preds = %land.lhs.true138, %if.else134
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call143 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %87, i32 noundef 8) #8
  br i1 %call143, label %land.lhs.true145, label %if.else151

land.lhs.true145:                                 ; preds = %lor.lhs.false142
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type146 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 0
  %89 = load i32, i32* %type146, align 8
  %cmp147 = icmp eq i32 %89, 7
  br i1 %cmp147, label %if.then149, label %if.else151

if.then149:                                       ; preds = %land.lhs.true145, %land.lhs.true138
  %90 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 0
  %93 = load i32, i32* %type150, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %90, %struct.bpf_reg_state* noundef %91, i32 noundef %93, i1 noundef zeroext true) #8
  br label %if.end152

if.else151:                                       ; preds = %land.lhs.true145, %lor.lhs.false142
  store i1 false, i1* %retval, align 1
  br label %return

if.end152:                                        ; preds = %if.then149
  br label %if.end153

if.end153:                                        ; preds = %if.end152, %if.then132
  br label %sw.epilog

sw.default:                                       ; preds = %if.end8
  store i1 false, i1* %retval, align 1
  br label %return

sw.epilog:                                        ; preds = %if.end153, %if.end116, %if.end79, %if.end42
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.else151, %if.else114, %if.else77, %if.else40, %if.then7, %if.then
  %94 = load i1, i1* %retval, align 1
  ret i1 %94
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %reg, i32 noundef %which) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %which.addr = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %which, i32* %which.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load i32, i32* %which.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 3
  %4 = load i32, i32* %id, align 4
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 2
  %6 = load i32, i32* %off, align 8
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true2
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %10, i64 %12, i64 noundef 0) #8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true2, %land.lhs.true, %entry
  %13 = phi i1 [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i1 noundef zeroext %range_right_open) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %range_right_open.addr = alloca i8, align 1
  %new_range = alloca i16, align 2
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %frombool = zext i1 %range_right_open to i8
  store i8 %frombool, i8* %range_right_open.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 2
  %1 = load i32, i32* %off, align 8
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %3 = load i32, i32* %off1, align 8
  %cmp2 = icmp eq i32 %3, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, i8* %range_right_open.addr, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  %6 = load i64, i64* %umax_value, align 8
  %cmp3 = icmp ugt i64 %6, 65535
  br i1 %cmp3, label %if.then9, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 9
  %8 = load i64, i64* %umax_value5, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 2
  %10 = load i32, i32* %off6, align 8
  %conv = sext i32 %10 to i64
  %add = add i64 %8, %conv
  %cmp7 = icmp ugt i64 %add, 65535
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false4, %if.end
  br label %for.end

if.end10:                                         ; preds = %lor.lhs.false4
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %12 = load i32, i32* %off11, align 8
  %conv12 = trunc i32 %12 to i16
  store i16 %conv12, i16* %new_range, align 2
  %13 = load i8, i8* %range_right_open.addr, align 1
  %tobool13 = trunc i8 %13 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end10
  %14 = load i16, i16* %new_range, align 2
  %dec = add i16 %14, -1
  store i16 %dec, i16* %new_range, align 2
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end10
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end15
  %15 = load i32, i32* %i, align 4
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %16, i32 0, i32 4
  %17 = load i32, i32* %curframe, align 8
  %cmp16 = icmp ule i32 %15, %17
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 0
  %19 = load i32, i32* %i, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %22 = load i32, i32* %type.addr, align 4
  %23 = load i16, i16* %new_range, align 2
  call void @__find_good_pkt_pointers(%struct.bpf_func_state* noundef %20, %struct.bpf_reg_state* noundef %21, i32 noundef %22, i16 noundef zeroext %23) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then9, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__find_good_pkt_pointers(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i16 noundef zeroext %new_range) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %new_range.addr = alloca i16, align 2
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %__UNIQUE_ID___x165 = alloca i16, align 2
  %__UNIQUE_ID___y166 = alloca i16, align 2
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x167 = alloca i16, align 2
  %__UNIQUE_ID___y168 = alloca i16, align 2
  %tmp46 = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  store i16 %new_range, i16* %new_range.addr, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  %5 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %4, %5
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 3
  %7 = load i32, i32* %id, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 3
  %9 = load i32, i32* %id3, align 4
  %cmp4 = icmp eq i32 %7, %9
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 1
  %range = bitcast %union.anon.147* %11 to i16*
  %12 = load i16, i16* %range, align 8
  store i16 %12, i16* %__UNIQUE_ID___x165, align 2
  %13 = load i16, i16* %new_range.addr, align 2
  store i16 %13, i16* %__UNIQUE_ID___y166, align 2
  %14 = load i16, i16* %__UNIQUE_ID___x165, align 2
  %conv = zext i16 %14 to i32
  %15 = load i16, i16* %__UNIQUE_ID___y166, align 2
  %conv5 = zext i16 %15 to i32
  %cmp6 = icmp sgt i32 %conv, %conv5
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %16 = load i16, i16* %__UNIQUE_ID___x165, align 2
  %conv8 = zext i16 %16 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %17 = load i16, i16* %__UNIQUE_ID___y166, align 2
  %conv9 = zext i16 %17 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ %conv9, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %18 = load i32, i32* %tmp, align 4
  %conv10 = trunc i32 %18 to i16
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 1
  %range11 = bitcast %union.anon.147* %20 to i16*
  store i16 %conv10, i16* %range11, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 6
  %24 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %24, 8
  %cmp12 = icmp slt i32 %22, %div
  br i1 %cmp12, label %land.lhs.true14, label %cond.false25

land.lhs.true14:                                  ; preds = %for.end
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 7
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom15 = sext i32 %27 to i64
  %arrayidx16 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom15
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx16, i32 0, i32 1
  %arrayidx17 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %28 = load i8, i8* %arrayidx17, align 8
  %conv18 = zext i8 %28 to i32
  %cmp19 = icmp eq i32 %conv18, 1
  br i1 %cmp19, label %cond.true21, label %cond.false25

cond.true21:                                      ; preds = %land.lhs.true14
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 7
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack22, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %31 to i64
  %arrayidx24 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom23
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx24, i32 0, i32 0
  br label %cond.end26

cond.false25:                                     ; preds = %land.lhs.true14, %for.end
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true21
  %cond27 = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true21 ], [ null, %cond.false25 ]
  store %struct.bpf_reg_state* %cond27, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond28

for.cond28:                                       ; preds = %cond.end81, %cond.end26
  %32 = load i32, i32* %i, align 4
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 6
  %34 = load i32, i32* %allocated_stack29, align 8
  %div30 = sdiv i32 %34, 8
  %cmp31 = icmp slt i32 %32, %div30
  br i1 %cmp31, label %for.body33, label %for.end83

for.body33:                                       ; preds = %for.cond28
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %35, null
  br i1 %tobool, label %if.end35, label %if.then34

if.then34:                                        ; preds = %for.body33
  br label %for.inc60

if.end35:                                         ; preds = %for.body33
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type36, align 8
  %38 = load i32, i32* %type.addr, align 4
  %cmp37 = icmp eq i32 %37, %38
  br i1 %cmp37, label %land.lhs.true39, label %if.end59

land.lhs.true39:                                  ; preds = %if.end35
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 3
  %40 = load i32, i32* %id40, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 3
  %42 = load i32, i32* %id41, align 4
  %cmp42 = icmp eq i32 %40, %42
  br i1 %cmp42, label %if.then44, label %if.end59

if.then44:                                        ; preds = %land.lhs.true39
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 1
  %range45 = bitcast %union.anon.147* %44 to i16*
  %45 = load i16, i16* %range45, align 8
  store i16 %45, i16* %__UNIQUE_ID___x167, align 2
  %46 = load i16, i16* %new_range.addr, align 2
  store i16 %46, i16* %__UNIQUE_ID___y168, align 2
  %47 = load i16, i16* %__UNIQUE_ID___x167, align 2
  %conv47 = zext i16 %47 to i32
  %48 = load i16, i16* %__UNIQUE_ID___y168, align 2
  %conv48 = zext i16 %48 to i32
  %cmp49 = icmp sgt i32 %conv47, %conv48
  br i1 %cmp49, label %cond.true51, label %cond.false53

cond.true51:                                      ; preds = %if.then44
  %49 = load i16, i16* %__UNIQUE_ID___x167, align 2
  %conv52 = zext i16 %49 to i32
  br label %cond.end55

cond.false53:                                     ; preds = %if.then44
  %50 = load i16, i16* %__UNIQUE_ID___y168, align 2
  %conv54 = zext i16 %50 to i32
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false53, %cond.true51
  %cond56 = phi i32 [ %conv52, %cond.true51 ], [ %conv54, %cond.false53 ]
  store i32 %cond56, i32* %tmp46, align 4
  %51 = load i32, i32* %tmp46, align 4
  %conv57 = trunc i32 %51 to i16
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 1
  %range58 = bitcast %union.anon.147* %53 to i16*
  store i16 %conv57, i16* %range58, align 8
  br label %if.end59

if.end59:                                         ; preds = %cond.end55, %land.lhs.true39, %if.end35
  br label %for.inc60

for.inc60:                                        ; preds = %if.end59, %if.then34
  %54 = load i32, i32* %i, align 4
  %inc61 = add i32 %54, 1
  store i32 %inc61, i32* %i, align 4
  %55 = load i32, i32* %i, align 4
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack62 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %56, i32 0, i32 6
  %57 = load i32, i32* %allocated_stack62, align 8
  %div63 = sdiv i32 %57, 8
  %cmp64 = icmp slt i32 %55, %div63
  br i1 %cmp64, label %land.lhs.true66, label %cond.false80

land.lhs.true66:                                  ; preds = %for.inc60
  %58 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack67 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %58, i32 0, i32 7
  %59 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack67, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom68 = sext i32 %60 to i64
  %arrayidx69 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %59, i64 %idxprom68
  %slot_type70 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx69, i32 0, i32 1
  %arrayidx71 = getelementptr [8 x i8], [8 x i8]* %slot_type70, i64 0, i64 0
  %61 = load i8, i8* %arrayidx71, align 8
  %conv72 = zext i8 %61 to i32
  %cmp73 = icmp eq i32 %conv72, 1
  br i1 %cmp73, label %cond.true75, label %cond.false80

cond.true75:                                      ; preds = %land.lhs.true66
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack76 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %62, i32 0, i32 7
  %63 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack76, align 8
  %64 = load i32, i32* %i, align 4
  %idxprom77 = sext i32 %64 to i64
  %arrayidx78 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %63, i64 %idxprom77
  %spilled_ptr79 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx78, i32 0, i32 0
  br label %cond.end81

cond.false80:                                     ; preds = %land.lhs.true66, %for.inc60
  br label %cond.end81

cond.end81:                                       ; preds = %cond.false80, %cond.true75
  %cond82 = phi %struct.bpf_reg_state* [ %spilled_ptr79, %cond.true75 ], [ null, %cond.false80 ]
  store %struct.bpf_reg_state* %cond82, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond28

for.end83:                                        ; preds = %for.cond28
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference_state(%struct.bpf_func_state* noundef %state, i32 noundef %ptr_id) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ptr_id.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %last_idx = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ptr_id, i32* %ptr_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 4
  %1 = load i32, i32* %acquired_refs, align 4
  %sub = sub i32 %1, 1
  store i32 %sub, i32* %last_idx, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 4
  %4 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 5
  %6 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %6, i64 %idxprom
  %id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  %8 = load i32, i32* %id, align 4
  %9 = load i32, i32* %ptr_id.addr, align 4
  %cmp2 = icmp eq i32 %8, %9
  br i1 %cmp2, label %if.then, label %if.end15

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %last_idx, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %last_idx, align 4
  %cmp3 = icmp ne i32 %11, %12
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 5
  %14 = load %struct.util_est*, %struct.util_est** %refs5, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr %struct.util_est, %struct.util_est* %14, i64 %idxprom6
  %16 = bitcast %struct.util_est* %arrayidx7 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 5
  %18 = load %struct.util_est*, %struct.util_est** %refs8, align 8
  %19 = load i32, i32* %last_idx, align 4
  %idxprom9 = sext i32 %19 to i64
  %arrayidx10 = getelementptr %struct.util_est, %struct.util_est* %18, i64 %idxprom9
  %20 = bitcast %struct.util_est* %arrayidx10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %16, i8* align 4 %20, i64 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 5
  %22 = load %struct.util_est*, %struct.util_est** %refs11, align 8
  %23 = load i32, i32* %last_idx, align 4
  %idxprom12 = sext i32 %23 to i64
  %arrayidx13 = getelementptr %struct.util_est, %struct.util_est* %22, i64 %idxprom12
  %24 = bitcast %struct.util_est* %arrayidx13 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %24, i8 0, i64 8, i1 false)
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 4
  %26 = load i32, i32* %acquired_refs14, align 4
  %dec = add i32 %26, -1
  store i32 %dec, i32* %acquired_refs14, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %27 = load i32, i32* %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end
  %28 = load i32, i32* %retval, align 4
  ret i32 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_ptr_or_null_regs(%struct.bpf_func_state* noundef %state, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 0
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %4 = load i32, i32* %id.addr, align 4
  %5 = load i8, i8* %is_null.addr, align 1
  %tobool = trunc i8 %5 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %1, %struct.bpf_reg_state* noundef %arrayidx, i32 noundef %4, i1 noundef zeroext %tobool) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %7 = load i32, i32* %i, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 6
  %9 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %9, 8
  %cmp1 = icmp slt i32 %7, %div
  br i1 %cmp1, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 7
  %11 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %11, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arrayidx4 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %13 = load i8, i8* %arrayidx4, align 8
  %conv = zext i8 %13 to i32
  %cmp5 = icmp eq i32 %conv, 1
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack7, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %15, i64 %idxprom8
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx9, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond10

for.cond10:                                       ; preds = %cond.end39, %cond.end
  %17 = load i32, i32* %i, align 4
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 6
  %19 = load i32, i32* %allocated_stack11, align 8
  %div12 = sdiv i32 %19, 8
  %cmp13 = icmp slt i32 %17, %div12
  br i1 %cmp13, label %for.body15, label %for.end41

for.body15:                                       ; preds = %for.cond10
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool16 = icmp ne %struct.bpf_reg_state* %20, null
  br i1 %tobool16, label %if.end, label %if.then

if.then:                                          ; preds = %for.body15
  br label %for.inc18

if.end:                                           ; preds = %for.body15
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %23 = load i32, i32* %id.addr, align 4
  %24 = load i8, i8* %is_null.addr, align 1
  %tobool17 = trunc i8 %24 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %21, %struct.bpf_reg_state* noundef %22, i32 noundef %23, i1 noundef zeroext %tobool17) #8
  br label %for.inc18

for.inc18:                                        ; preds = %if.end, %if.then
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 6
  %28 = load i32, i32* %allocated_stack20, align 8
  %div21 = sdiv i32 %28, 8
  %cmp22 = icmp slt i32 %26, %div21
  br i1 %cmp22, label %land.lhs.true24, label %cond.false38

land.lhs.true24:                                  ; preds = %for.inc18
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 7
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %31 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %arrayidx29 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 0
  %32 = load i8, i8* %arrayidx29, align 8
  %conv30 = zext i8 %32 to i32
  %cmp31 = icmp eq i32 %conv30, 1
  br i1 %cmp31, label %cond.true33, label %cond.false38

cond.true33:                                      ; preds = %land.lhs.true24
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack34 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 7
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack34, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %35 to i64
  %arrayidx36 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom35
  %spilled_ptr37 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx36, i32 0, i32 0
  br label %cond.end39

cond.false38:                                     ; preds = %land.lhs.true24, %for.inc18
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true33
  %cond40 = phi %struct.bpf_reg_state* [ %spilled_ptr37, %cond.true33 ], [ null, %cond.false38 ]
  store %struct.bpf_reg_state* %cond40, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond10

for.end41:                                        ; preds = %for.cond10
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %reg, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @reg_type_may_be_null(i32 noundef %1) #8
  br i1 %call, label %land.lhs.true, label %if.end81

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 3
  %3 = load i32, i32* %id1, align 4
  %4 = load i32, i32* %id.addr, align 4
  %cmp = icmp eq i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end81

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 6
  %6 = load i64, i64* %smin_value, align 8
  %tobool = icmp ne i64 %6, 0
  br i1 %tobool, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 7
  %8 = load i64, i64* %smax_value, align 8
  %tobool2 = icmp ne i64 %8, 0
  br i1 %tobool2, label %lor.end, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 5
  %10 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call4 = call zeroext i1 @tnum_equals_const(i64 %12, i64 %14, i64 noundef 0) #8
  br i1 %call4, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %lor.lhs.false3
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 2
  %16 = load i32, i32* %off, align 8
  %tobool5 = icmp ne i32 %16, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false3, %lor.lhs.false, %if.then
  %17 = phi i1 [ true, %lor.lhs.false3 ], [ true, %lor.lhs.false ], [ true, %if.then ], [ %tobool5, %lor.rhs ]
  %lnot = xor i1 %17, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %18, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext11 to i64
  %tobool12 = icmp ne i64 %conv, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %lor.end
  br label %do.body

do.body:                                          ; preds = %if.then13
  br label %do.body14

do.body14:                                        ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 5919, i32 2307, i64 12) #9, !srcloc !39
  br label %do.end

do.end:                                           ; preds = %do.body14
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 209) #9, !srcloc !40
  br label %do.end15

do.end15:                                         ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end15, %lor.end
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %19, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  store i64 %conv21, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  %tobool22 = icmp ne i64 %20, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %21) #8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 2
  store i32 0, i32* %off24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end
  %23 = load i8, i8* %is_null.addr, align 1
  %tobool26 = trunc i8 %23 to i1
  br i1 %tobool26, label %if.then27, label %if.else

if.then27:                                        ; preds = %if.end25
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  store i32 1, i32* %type28, align 8
  br label %if.end71

if.else:                                          ; preds = %if.end25
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 0
  %26 = load i32, i32* %type29, align 8
  %cmp30 = icmp eq i32 %26, 5
  br i1 %cmp30, label %if.then32, label %if.else49

if.then32:                                        ; preds = %if.else
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %28 to %struct.bpf_map**
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %29, i32 0, i32 1
  %30 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool33 = icmp ne %struct.bpf_map* %30, null
  br i1 %tobool33, label %if.then34, label %if.else39

if.then34:                                        ; preds = %if.then32
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 0
  store i32 3, i32* %type35, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 1
  %map_ptr36 = bitcast %union.anon.147* %33 to %struct.bpf_map**
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr36, align 8
  %inner_map_meta37 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %34, i32 0, i32 1
  %35 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta37, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 1
  %map_ptr38 = bitcast %union.anon.147* %37 to %struct.bpf_map**
  store %struct.bpf_map* %35, %struct.bpf_map** %map_ptr38, align 8
  br label %if.end48

if.else39:                                        ; preds = %if.then32
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 1
  %map_ptr40 = bitcast %union.anon.147* %39 to %struct.bpf_map**
  %40 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr40, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %40, i32 0, i32 3
  %41 = load i32, i32* %map_type, align 8
  %cmp41 = icmp eq i32 %41, 17
  br i1 %cmp41, label %if.then43, label %if.else45

if.then43:                                        ; preds = %if.else39
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 0
  store i32 18, i32* %type44, align 8
  br label %if.end47

if.else45:                                        ; preds = %if.else39
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 0
  store i32 4, i32* %type46, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.else45, %if.then43
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then34
  br label %if.end70

if.else49:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type50 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type50, align 8
  %cmp51 = icmp eq i32 %45, 12
  br i1 %cmp51, label %if.then53, label %if.else55

if.then53:                                        ; preds = %if.else49
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 0
  store i32 11, i32* %type54, align 8
  br label %if.end69

if.else55:                                        ; preds = %if.else49
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 0
  %48 = load i32, i32* %type56, align 8
  %cmp57 = icmp eq i32 %48, 14
  br i1 %cmp57, label %if.then59, label %if.else61

if.then59:                                        ; preds = %if.else55
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  store i32 13, i32* %type60, align 8
  br label %if.end68

if.else61:                                        ; preds = %if.else55
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type62 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  %51 = load i32, i32* %type62, align 8
  %cmp63 = icmp eq i32 %51, 16
  br i1 %cmp63, label %if.then65, label %if.end67

if.then65:                                        ; preds = %if.else61
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 0
  store i32 15, i32* %type66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then65, %if.else61
  br label %if.end68

if.end68:                                         ; preds = %if.end67, %if.then59
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.then53
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.end48
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then27
  %53 = load i8, i8* %is_null.addr, align 1
  %tobool72 = trunc i8 %53 to i1
  br i1 %tobool72, label %if.then73, label %if.else75

if.then73:                                        ; preds = %if.end71
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 3
  store i32 0, i32* %id74, align 4
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 4
  store i32 0, i32* %ref_obj_id, align 8
  br label %if.end80

if.else75:                                        ; preds = %if.end71
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call76 = call zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %56) #8
  br i1 %call76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.else75
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 3
  store i32 0, i32* %id78, align 4
  br label %if.end79

if.end79:                                         ; preds = %if.then77, %if.else75
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %if.then73
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %3 to %struct.bpf_map**
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %call = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %4) #8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %spi) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %spi.addr = alloca i32, align 4
  %st = alloca %struct.bpf_verifier_state*, align 8
  %first_idx = alloca i32, align 4
  %last_idx = alloca i32, align 4
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %reg_mask = alloca i32, align 4
  %stack_mask = alloca i64, align 8
  %skip_first = alloca i8, align 1
  %new_marks = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp39 = alloca i64, align 8
  %mask = alloca [1 x i64], align 8
  %history = alloca i32, align 4
  %__ret_warn_once112 = alloca i32, align 4
  %__ret_warn_on126 = alloca i32, align 4
  %tmp142 = alloca i64, align 8
  %tmp150 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %st, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 7
  %3 = load i32, i32* %first_insn_idx, align 4
  store i32 %3, i32* %first_idx, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 0
  %5 = load i32, i32* %insn_idx, align 8
  store i32 %5, i32* %last_idx, align 4
  %6 = load i32, i32* %regno.addr, align 4
  %cmp = icmp sge i32 %6, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, i32* %regno.addr, align 4
  %shl = shl i32 1, %7
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shl, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %reg_mask, align 4
  %8 = load i32, i32* %spi.addr, align 4
  %cmp1 = icmp sge i32 %8, 0
  br i1 %cmp1, label %cond.true2, label %cond.false4

cond.true2:                                       ; preds = %cond.end
  %9 = load i32, i32* %spi.addr, align 4
  %sh_prom = zext i32 %9 to i64
  %shl3 = shl i64 1, %sh_prom
  br label %cond.end5

cond.false4:                                      ; preds = %cond.end
  br label %cond.end5

cond.end5:                                        ; preds = %cond.false4, %cond.true2
  %cond6 = phi i64 [ %shl3, %cond.true2 ], [ 0, %cond.false4 ]
  store i64 %cond6, i64* %stack_mask, align 8
  store i8 1, i8* %skip_first, align 1
  store i8 0, i8* %new_marks, align 1
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 14
  %11 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end5
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %14 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %15, %struct.bpf_func_state** %func, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %cmp7 = icmp sge i32 %16, 0
  br i1 %cmp7, label %if.then8, label %if.end51

if.then8:                                         ; preds = %if.end
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %18 = load i32, i32* %regno.addr, align 4
  %idxprom9 = sext i32 %18 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom9
  store %struct.bpf_reg_state* %arrayidx10, %struct.bpf_reg_state** %reg, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type, align 8
  %cmp11 = icmp ne i32 %20, 1
  br i1 %cmp11, label %if.then12, label %if.end46

if.then12:                                        ; preds = %if.then8
  store i32 1, i32* %__ret_warn_once, align 4
  %21 = load i32, i32* %__ret_warn_once, align 4
  %tobool13 = icmp ne i32 %21, 0
  br i1 %tobool13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then12
  %22 = load i8, i8* @__mark_chain_precision.__warned, align 1
  %tobool14 = trunc i8 %22 to i1
  %lnot = xor i1 %tobool14, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then12
  %23 = phi i1 [ false, %if.then12 ], [ %lnot, %land.rhs ]
  %lnot15 = xor i1 %23, true
  %lnot16 = xor i1 %lnot15, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end38

if.then18:                                        ; preds = %land.end
  store i8 1, i8* @__mark_chain_precision.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %24 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %24, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.then18
  br label %do.body

do.body:                                          ; preds = %if.then26
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([19 x i8], [19 x i8]* @.str.76, i64 0, i64 0)) #8
  br label %do.body27

do.body27:                                        ; preds = %do.body
  br label %do.body28

do.body28:                                        ; preds = %do.body27
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1774, i32 2313, i64 12) #9, !srcloc !41
  br label %do.end

do.end:                                           ; preds = %do.body28
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 149) #9, !srcloc !42
  br label %do.end29

do.end29:                                         ; preds = %do.end
  br label %do.end30

do.end30:                                         ; preds = %do.end29
  br label %if.end31

if.end31:                                         ; preds = %do.end30, %if.then18
  %25 = load i32, i32* %__ret_warn_on, align 4
  %tobool32 = icmp ne i32 %25, 0
  %lnot33 = xor i1 %tobool32, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %conv37 = sext i32 %lnot.ext36 to i64
  store i64 %conv37, i64* %tmp, align 8
  %26 = load i64, i64* %tmp, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.end31, %land.end
  %27 = load i32, i32* %__ret_warn_once, align 4
  %tobool40 = icmp ne i32 %27, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  store i64 %conv45, i64* %tmp39, align 8
  %28 = load i64, i64* %tmp39, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.then8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 14
  %30 = load i8, i8* %precise, align 4
  %tobool47 = trunc i8 %30 to i1
  br i1 %tobool47, label %if.else, label %if.then48

if.then48:                                        ; preds = %if.end46
  store i8 1, i8* %new_marks, align 1
  br label %if.end49

if.else:                                          ; preds = %if.end46
  store i32 0, i32* %reg_mask, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then48
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise50 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 14
  store i8 1, i8* %precise50, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.end49, %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end51
  %32 = load i32, i32* %spi.addr, align 4
  %cmp52 = icmp sge i32 %32, 0
  br i1 %cmp52, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 7
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %35 = load i32, i32* %spi.addr, align 4
  %idxprom54 = sext i32 %35 to i64
  %arrayidx55 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom54
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx55, i32 0, i32 1
  %arrayidx56 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %36 = load i8, i8* %arrayidx56, align 8
  %conv57 = zext i8 %36 to i32
  %cmp58 = icmp ne i32 %conv57, 1
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %while.body
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end61:                                         ; preds = %while.body
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack62 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 7
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack62, align 8
  %39 = load i32, i32* %spi.addr, align 4
  %idxprom63 = sext i32 %39 to i64
  %arrayidx64 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom63
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx64, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 0
  %41 = load i32, i32* %type65, align 8
  %cmp66 = icmp ne i32 %41, 1
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end61
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end69:                                         ; preds = %if.end61
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 14
  %43 = load i8, i8* %precise70, align 4
  %tobool71 = trunc i8 %43 to i1
  br i1 %tobool71, label %if.else73, label %if.then72

if.then72:                                        ; preds = %if.end69
  store i8 1, i8* %new_marks, align 1
  br label %if.end74

if.else73:                                        ; preds = %if.end69
  store i64 0, i64* %stack_mask, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.else73, %if.then72
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 14
  store i8 1, i8* %precise75, align 4
  br label %while.end

while.end:                                        ; preds = %if.end74, %if.then68, %if.then60, %while.cond
  %45 = load i8, i8* %new_marks, align 1
  %tobool76 = trunc i8 %45 to i1
  br i1 %tobool76, label %if.end78, label %if.then77

if.then77:                                        ; preds = %while.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end78:                                         ; preds = %while.end
  %46 = load i32, i32* %reg_mask, align 4
  %tobool79 = icmp ne i32 %46, 0
  br i1 %tobool79, label %if.end82, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end78
  %47 = load i64, i64* %stack_mask, align 8
  %tobool80 = icmp ne i64 %47, 0
  br i1 %tobool80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %land.lhs.true, %if.end78
  br label %for.cond

for.cond:                                         ; preds = %if.end259, %if.end82
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %48, i32 0, i32 10
  %49 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %49, i32* %history, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %51 = load i32, i32* %level, align 8
  %and = and i32 %51, 3
  %tobool83 = icmp ne i32 %and, 0
  br i1 %tobool83, label %if.then84, label %if.end85

if.then84:                                        ; preds = %for.cond
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i32, i32* %last_idx, align 4
  %55 = load i32, i32* %first_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.77, i64 0, i64 0), i32 noundef %54, i32 noundef %55) #8
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %for.cond
  %56 = load i32, i32* %last_idx, align 4
  store i32 %56, i32* %i, align 4
  br label %for.cond86

for.cond86:                                       ; preds = %if.end157, %if.end85
  %57 = load i8, i8* %skip_first, align 1
  %tobool87 = trunc i8 %57 to i1
  br i1 %tobool87, label %if.then88, label %if.else89

if.then88:                                        ; preds = %for.cond86
  store i32 0, i32* %err, align 4
  store i8 0, i8* %skip_first, align 1
  br label %if.end90

if.else89:                                        ; preds = %for.cond86
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load i32, i32* %i, align 4
  %call = call i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %58, i32 noundef %59, i32* noundef %reg_mask, i64* noundef %stack_mask) #8
  store i32 %call, i32* %err, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.else89, %if.then88
  %60 = load i32, i32* %err, align 4
  %cmp91 = icmp eq i32 %60, -524
  br i1 %cmp91, label %if.then93, label %if.else94

if.then93:                                        ; preds = %if.end90
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %61, %struct.bpf_verifier_state* noundef %62) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.else94:                                        ; preds = %if.end90
  %63 = load i32, i32* %err, align 4
  %tobool95 = icmp ne i32 %63, 0
  br i1 %tobool95, label %if.then96, label %if.end97

if.then96:                                        ; preds = %if.else94
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end97:                                         ; preds = %if.else94
  br label %if.end98

if.end98:                                         ; preds = %if.end97
  %65 = load i32, i32* %reg_mask, align 4
  %tobool99 = icmp ne i32 %65, 0
  br i1 %tobool99, label %if.end103, label %land.lhs.true100

land.lhs.true100:                                 ; preds = %if.end98
  %66 = load i64, i64* %stack_mask, align 8
  %tobool101 = icmp ne i64 %66, 0
  br i1 %tobool101, label %if.end103, label %if.then102

if.then102:                                       ; preds = %land.lhs.true100
  store i32 0, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %land.lhs.true100, %if.end98
  %67 = load i32, i32* %i, align 4
  %68 = load i32, i32* %first_idx, align 4
  %cmp104 = icmp eq i32 %67, %68
  br i1 %cmp104, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.end103
  br label %for.end

if.end107:                                        ; preds = %if.end103
  %69 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %70 = load i32, i32* %i, align 4
  %call108 = call i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %69, i32 noundef %70, i32* noundef %history) #8
  store i32 %call108, i32* %i, align 4
  %71 = load i32, i32* %i, align 4
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %72, i32 0, i32 2
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %73, i32 0, i32 4
  %74 = load i32, i32* %len, align 4
  %cmp109 = icmp uge i32 %71, %74
  br i1 %cmp109, label %if.then111, label %if.end157

if.then111:                                       ; preds = %if.end107
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.78, i64 0, i64 0), i32 noundef %77) #8
  store i32 1, i32* %__ret_warn_once112, align 4
  %78 = load i32, i32* %__ret_warn_once112, align 4
  %tobool113 = icmp ne i32 %78, 0
  br i1 %tobool113, label %land.rhs114, label %land.end118

land.rhs114:                                      ; preds = %if.then111
  %79 = load i8, i8* @__mark_chain_precision.__warned.79, align 1
  %tobool115 = trunc i8 %79 to i1
  %lnot116 = xor i1 %tobool115, true
  br label %land.end118

land.end118:                                      ; preds = %land.rhs114, %if.then111
  %80 = phi i1 [ false, %if.then111 ], [ %lnot116, %land.rhs114 ]
  %lnot119 = xor i1 %80, true
  %lnot121 = xor i1 %lnot119, true
  %lnot.ext122 = zext i1 %lnot121 to i32
  %conv123 = sext i32 %lnot.ext122 to i64
  %tobool124 = icmp ne i64 %conv123, 0
  br i1 %tobool124, label %if.then125, label %if.end149

if.then125:                                       ; preds = %land.end118
  store i8 1, i8* @__mark_chain_precision.__warned.79, align 1
  store i32 1, i32* %__ret_warn_on126, align 4
  %81 = load i32, i32* %__ret_warn_on126, align 4
  %tobool127 = icmp ne i32 %81, 0
  %lnot128 = xor i1 %tobool127, true
  %lnot130 = xor i1 %lnot128, true
  %lnot.ext131 = zext i1 %lnot130 to i32
  %conv132 = sext i32 %lnot.ext131 to i64
  %tobool133 = icmp ne i64 %conv132, 0
  br i1 %tobool133, label %if.then134, label %if.end141

if.then134:                                       ; preds = %if.then125
  br label %do.body135

do.body135:                                       ; preds = %if.then134
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.80, i64 0, i64 0)) #8
  br label %do.body136

do.body136:                                       ; preds = %do.body135
  br label %do.body137

do.body137:                                       ; preds = %do.body136
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1842, i32 2313, i64 12) #9, !srcloc !43
  br label %do.end138

do.end138:                                        ; preds = %do.body137
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 150) #9, !srcloc !44
  br label %do.end139

do.end139:                                        ; preds = %do.end138
  br label %do.end140

do.end140:                                        ; preds = %do.end139
  br label %if.end141

if.end141:                                        ; preds = %do.end140, %if.then125
  %82 = load i32, i32* %__ret_warn_on126, align 4
  %tobool143 = icmp ne i32 %82, 0
  %lnot144 = xor i1 %tobool143, true
  %lnot146 = xor i1 %lnot144, true
  %lnot.ext147 = zext i1 %lnot146 to i32
  %conv148 = sext i32 %lnot.ext147 to i64
  store i64 %conv148, i64* %tmp142, align 8
  %83 = load i64, i64* %tmp142, align 8
  br label %if.end149

if.end149:                                        ; preds = %if.end141, %land.end118
  %84 = load i32, i32* %__ret_warn_once112, align 4
  %tobool151 = icmp ne i32 %84, 0
  %lnot152 = xor i1 %tobool151, true
  %lnot154 = xor i1 %lnot152, true
  %lnot.ext155 = zext i1 %lnot154 to i32
  %conv156 = sext i32 %lnot.ext155 to i64
  store i64 %conv156, i64* %tmp150, align 8
  %85 = load i64, i64* %tmp150, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end157:                                        ; preds = %if.end107
  br label %for.cond86

for.end:                                          ; preds = %if.then106
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 1
  %87 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %87, %struct.bpf_verifier_state** %st, align 8
  %88 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %tobool158 = icmp ne %struct.bpf_verifier_state* %88, null
  br i1 %tobool158, label %if.end160, label %if.then159

if.then159:                                       ; preds = %for.end
  br label %for.end261

if.end160:                                        ; preds = %for.end
  store i8 0, i8* %new_marks, align 1
  %89 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame161 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %89, i32 0, i32 0
  %90 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe162 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %90, i32 0, i32 4
  %91 = load i32, i32* %curframe162, align 8
  %idxprom163 = zext i32 %91 to i64
  %arrayidx164 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame161, i64 0, i64 %idxprom163
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx164, align 8
  store %struct.bpf_func_state* %92, %struct.bpf_func_state** %func, align 8
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %93 = load i32, i32* %reg_mask, align 4
  %conv165 = zext i32 %93 to i64
  call void @bitmap_from_u64(i64* noundef %arraydecay, i64 noundef %conv165) #8
  %arraydecay166 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %call167 = call i64 @find_first_bit(i64* noundef %arraydecay166, i64 noundef 32) #8
  %conv168 = trunc i64 %call167 to i32
  store i32 %conv168, i32* %i, align 4
  br label %for.cond169

for.cond169:                                      ; preds = %for.inc, %if.end160
  %94 = load i32, i32* %i, align 4
  %cmp170 = icmp slt i32 %94, 32
  br i1 %cmp170, label %for.body, label %for.end191

for.body:                                         ; preds = %for.cond169
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs172 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 0
  %96 = load i32, i32* %i, align 4
  %idxprom173 = sext i32 %96 to i64
  %arrayidx174 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs172, i64 0, i64 %idxprom173
  store %struct.bpf_reg_state* %arrayidx174, %struct.bpf_reg_state** %reg, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type175 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 0
  %98 = load i32, i32* %type175, align 8
  %cmp176 = icmp ne i32 %98, 1
  br i1 %cmp176, label %if.then178, label %if.end181

if.then178:                                       ; preds = %for.body
  %99 = load i32, i32* %i, align 4
  %shl179 = shl i32 1, %99
  %neg = xor i32 %shl179, -1
  %100 = load i32, i32* %reg_mask, align 4
  %and180 = and i32 %100, %neg
  store i32 %and180, i32* %reg_mask, align 4
  br label %for.inc

if.end181:                                        ; preds = %for.body
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 14
  %102 = load i8, i8* %precise182, align 4
  %tobool183 = trunc i8 %102 to i1
  br i1 %tobool183, label %if.end185, label %if.then184

if.then184:                                       ; preds = %if.end181
  store i8 1, i8* %new_marks, align 1
  br label %if.end185

if.end185:                                        ; preds = %if.then184, %if.end181
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise186 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 14
  store i8 1, i8* %precise186, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end185, %if.then178
  %arraydecay187 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %104 = load i32, i32* %i, align 4
  %add = add i32 %104, 1
  %conv188 = sext i32 %add to i64
  %call189 = call i64 @find_next_bit(i64* noundef %arraydecay187, i64 noundef 32, i64 noundef %conv188) #8
  %conv190 = trunc i64 %call189 to i32
  store i32 %conv190, i32* %i, align 4
  br label %for.cond169

for.end191:                                       ; preds = %for.cond169
  %arraydecay192 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %105 = load i64, i64* %stack_mask, align 8
  call void @bitmap_from_u64(i64* noundef %arraydecay192, i64 noundef %105) #8
  %arraydecay193 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %call194 = call i64 @find_first_bit(i64* noundef %arraydecay193, i64 noundef 64) #8
  %conv195 = trunc i64 %call194 to i32
  store i32 %conv195, i32* %i, align 4
  br label %for.cond196

for.cond196:                                      ; preds = %for.inc236, %for.end191
  %106 = load i32, i32* %i, align 4
  %cmp197 = icmp slt i32 %106, 64
  br i1 %cmp197, label %for.body199, label %for.end242

for.body199:                                      ; preds = %for.cond196
  %107 = load i32, i32* %i, align 4
  %108 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %108, i32 0, i32 6
  %109 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %109, 8
  %cmp200 = icmp sge i32 %107, %div
  br i1 %cmp200, label %if.then202, label %if.end203

if.then202:                                       ; preds = %for.body199
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %110, %struct.bpf_verifier_state* noundef %111) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end203:                                        ; preds = %for.body199
  %112 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack204 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %112, i32 0, i32 7
  %113 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack204, align 8
  %114 = load i32, i32* %i, align 4
  %idxprom205 = sext i32 %114 to i64
  %arrayidx206 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %113, i64 %idxprom205
  %slot_type207 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx206, i32 0, i32 1
  %arrayidx208 = getelementptr [8 x i8], [8 x i8]* %slot_type207, i64 0, i64 0
  %115 = load i8, i8* %arrayidx208, align 8
  %conv209 = zext i8 %115 to i32
  %cmp210 = icmp ne i32 %conv209, 1
  br i1 %cmp210, label %if.then212, label %if.end217

if.then212:                                       ; preds = %if.end203
  %116 = load i32, i32* %i, align 4
  %sh_prom213 = zext i32 %116 to i64
  %shl214 = shl i64 1, %sh_prom213
  %neg215 = xor i64 %shl214, -1
  %117 = load i64, i64* %stack_mask, align 8
  %and216 = and i64 %117, %neg215
  store i64 %and216, i64* %stack_mask, align 8
  br label %for.inc236

if.end217:                                        ; preds = %if.end203
  %118 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack218 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %118, i32 0, i32 7
  %119 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack218, align 8
  %120 = load i32, i32* %i, align 4
  %idxprom219 = sext i32 %120 to i64
  %arrayidx220 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %119, i64 %idxprom219
  %spilled_ptr221 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx220, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr221, %struct.bpf_reg_state** %reg, align 8
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type222 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %121, i32 0, i32 0
  %122 = load i32, i32* %type222, align 8
  %cmp223 = icmp ne i32 %122, 1
  br i1 %cmp223, label %if.then225, label %if.end230

if.then225:                                       ; preds = %if.end217
  %123 = load i32, i32* %i, align 4
  %sh_prom226 = zext i32 %123 to i64
  %shl227 = shl i64 1, %sh_prom226
  %neg228 = xor i64 %shl227, -1
  %124 = load i64, i64* %stack_mask, align 8
  %and229 = and i64 %124, %neg228
  store i64 %and229, i64* %stack_mask, align 8
  br label %for.inc236

if.end230:                                        ; preds = %if.end217
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise231 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 14
  %126 = load i8, i8* %precise231, align 4
  %tobool232 = trunc i8 %126 to i1
  br i1 %tobool232, label %if.end234, label %if.then233

if.then233:                                       ; preds = %if.end230
  store i8 1, i8* %new_marks, align 1
  br label %if.end234

if.end234:                                        ; preds = %if.then233, %if.end230
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise235 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i32 0, i32 14
  store i8 1, i8* %precise235, align 4
  br label %for.inc236

for.inc236:                                       ; preds = %if.end234, %if.then225, %if.then212
  %arraydecay237 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %128 = load i32, i32* %i, align 4
  %add238 = add i32 %128, 1
  %conv239 = sext i32 %add238 to i64
  %call240 = call i64 @find_next_bit(i64* noundef %arraydecay237, i64 noundef 64, i64 noundef %conv239) #8
  %conv241 = trunc i64 %call240 to i32
  store i32 %conv241, i32* %i, align 4
  br label %for.cond196

for.end242:                                       ; preds = %for.cond196
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log243 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %129, i32 0, i32 18
  %level244 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log243, i32 0, i32 0
  %130 = load i32, i32* %level244, align 8
  %and245 = and i32 %130, 3
  %tobool246 = icmp ne i32 %and245, 0
  br i1 %tobool246, label %if.then247, label %if.end251

if.then247:                                       ; preds = %for.end242
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %131, %struct.bpf_func_state* noundef %132) #8
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = bitcast %struct.bpf_verifier_env* %133 to i8*
  %135 = load i8, i8* %new_marks, align 1
  %tobool248 = trunc i8 %135 to i1
  %136 = zext i1 %tobool248 to i64
  %cond250 = select i1 %tobool248, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.82, i64 0, i64 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.83, i64 0, i64 0)
  %137 = load i32, i32* %reg_mask, align 4
  %138 = load i64, i64* %stack_mask, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %134, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.81, i64 0, i64 0), i8* noundef %cond250, i32 noundef %137, i64 noundef %138) #8
  br label %if.end251

if.end251:                                        ; preds = %if.then247, %for.end242
  %139 = load i32, i32* %reg_mask, align 4
  %tobool252 = icmp ne i32 %139, 0
  br i1 %tobool252, label %if.end256, label %land.lhs.true253

land.lhs.true253:                                 ; preds = %if.end251
  %140 = load i64, i64* %stack_mask, align 8
  %tobool254 = icmp ne i64 %140, 0
  br i1 %tobool254, label %if.end256, label %if.then255

if.then255:                                       ; preds = %land.lhs.true253
  br label %for.end261

if.end256:                                        ; preds = %land.lhs.true253, %if.end251
  %141 = load i8, i8* %new_marks, align 1
  %tobool257 = trunc i8 %141 to i1
  br i1 %tobool257, label %if.end259, label %if.then258

if.then258:                                       ; preds = %if.end256
  br label %for.end261

if.end259:                                        ; preds = %if.end256
  %142 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %142, i32 0, i32 8
  %143 = load i32, i32* %last_insn_idx, align 8
  store i32 %143, i32* %last_idx, align 4
  %144 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx260 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %144, i32 0, i32 7
  %145 = load i32, i32* %first_insn_idx260, align 4
  store i32 %145, i32* %first_idx, align 4
  br label %for.cond

for.end261:                                       ; preds = %if.then258, %if.then255, %if.then159
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end261, %if.then202, %if.end149, %if.then102, %if.then96, %if.then93, %if.then81, %if.then77, %if.end38, %if.then
  %146 = load i32, i32* %retval, align 4
  ret i32 %146
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx, i32* noundef %reg_mask, i64* noundef %stack_mask) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %reg_mask.addr = alloca i32*, align 8
  %stack_mask.addr = alloca i64*, align 8
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  %dreg = alloca i32, align 4
  %sreg = alloca i32, align 4
  %spi = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp114 = alloca i64, align 8
  %__ret_warn_once160 = alloca i32, align 4
  %__ret_warn_on174 = alloca i32, align 4
  %tmp190 = alloca i64, align 8
  %tmp198 = alloca i64, align 8
  %__ret_warn_once247 = alloca i32, align 4
  %__ret_warn_on261 = alloca i32, align 4
  %tmp277 = alloca i64, align 8
  %tmp285 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %reg_mask, i32** %reg_mask.addr, align 8
  store i64* %stack_mask, i64** %stack_mask.addr, align 8
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* null, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = bitcast %struct.bpf_verifier_env* %0 to i8*
  store i8* %1, i8** %private_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %4 to [0 x %struct.bpf_insn]*
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %5 = load i32, i32* %idx.addr, align 4
  %idx.ext = sext i32 %5 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %class, align 1
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %9 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %opcode, align 1
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 0
  %11 = load i8, i8* %code6, align 4
  %conv7 = zext i8 %11 to i32
  %and8 = and i32 %conv7, 224
  %conv9 = trunc i32 %and8 to i8
  store i8 %conv9, i8* %mode, align 1
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv10 = zext i8 %bf.clear to i32
  %shl = shl i32 1, %conv10
  store i32 %shl, i32* %dreg, align 4
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load11 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load11, 4
  %conv12 = zext i8 %bf.lshr to i32
  %shl13 = shl i32 1, %conv12
  store i32 %shl13, i32* %sreg, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %15 to i32
  %cmp = icmp eq i32 %conv15, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %17 = load i32, i32* %level, align 8
  %and17 = and i32 %17, 3
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32*, i32** %reg_mask.addr, align 8
  %21 = load i32, i32* %20, align 4
  %22 = load i64*, i64** %stack_mask.addr, align 8
  %23 = load i64, i64* %22, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.84, i64 0, i64 0), i32 noundef %21, i64 noundef %23) #8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i32, i32* %idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i64 0, i64 0), i32 noundef %26) #8
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 14
  %29 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool19 = trunc i8 %29 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %27, i1 noundef zeroext %tobool19) #8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end
  %30 = load i8, i8* %class, align 1
  %conv21 = zext i8 %30 to i32
  %cmp22 = icmp eq i32 %conv21, 4
  br i1 %cmp22, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %31 = load i8, i8* %class, align 1
  %conv24 = zext i8 %31 to i32
  %cmp25 = icmp eq i32 %conv24, 7
  br i1 %cmp25, label %if.then27, label %if.else56

if.then27:                                        ; preds = %lor.lhs.false, %if.end20
  %32 = load i32*, i32** %reg_mask.addr, align 8
  %33 = load i32, i32* %32, align 4
  %34 = load i32, i32* %dreg, align 4
  %and28 = and i32 %33, %34
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then27
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.then27
  %35 = load i8, i8* %opcode, align 1
  %conv32 = zext i8 %35 to i32
  %cmp33 = icmp eq i32 %conv32, 176
  br i1 %cmp33, label %if.then35, label %if.else46

if.then35:                                        ; preds = %if.end31
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 0
  %37 = load i8, i8* %code36, align 4
  %conv37 = zext i8 %37 to i32
  %and38 = and i32 %conv37, 8
  %cmp39 = icmp eq i32 %and38, 8
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.then35
  %38 = load i32, i32* %dreg, align 4
  %neg = xor i32 %38, -1
  %39 = load i32*, i32** %reg_mask.addr, align 8
  %40 = load i32, i32* %39, align 4
  %and42 = and i32 %40, %neg
  store i32 %and42, i32* %39, align 4
  %41 = load i32, i32* %sreg, align 4
  %42 = load i32*, i32** %reg_mask.addr, align 8
  %43 = load i32, i32* %42, align 4
  %or = or i32 %43, %41
  store i32 %or, i32* %42, align 4
  br label %if.end45

if.else:                                          ; preds = %if.then35
  %44 = load i32, i32* %dreg, align 4
  %neg43 = xor i32 %44, -1
  %45 = load i32*, i32** %reg_mask.addr, align 8
  %46 = load i32, i32* %45, align 4
  %and44 = and i32 %46, %neg43
  store i32 %and44, i32* %45, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.else, %if.then41
  br label %if.end55

if.else46:                                        ; preds = %if.end31
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %47, i32 0, i32 0
  %48 = load i8, i8* %code47, align 4
  %conv48 = zext i8 %48 to i32
  %and49 = and i32 %conv48, 8
  %cmp50 = icmp eq i32 %and49, 8
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.else46
  %49 = load i32, i32* %sreg, align 4
  %50 = load i32*, i32** %reg_mask.addr, align 8
  %51 = load i32, i32* %50, align 4
  %or53 = or i32 %51, %49
  store i32 %or53, i32* %50, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.else46
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end45
  br label %if.end324

if.else56:                                        ; preds = %lor.lhs.false
  %52 = load i8, i8* %class, align 1
  %conv57 = zext i8 %52 to i32
  %cmp58 = icmp eq i32 %conv57, 1
  br i1 %cmp58, label %if.then60, label %if.else124

if.then60:                                        ; preds = %if.else56
  %53 = load i32*, i32** %reg_mask.addr, align 8
  %54 = load i32, i32* %53, align 4
  %55 = load i32, i32* %dreg, align 4
  %and61 = and i32 %54, %55
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %if.then60
  store i32 0, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.then60
  %56 = load i32, i32* %dreg, align 4
  %neg65 = xor i32 %56, -1
  %57 = load i32*, i32** %reg_mask.addr, align 8
  %58 = load i32, i32* %57, align 4
  %and66 = and i32 %58, %neg65
  store i32 %and66, i32* %57, align 4
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 1
  %bf.load68 = load i8, i8* %src_reg67, align 1
  %bf.lshr69 = lshr i8 %bf.load68, 4
  %conv70 = zext i8 %bf.lshr69 to i32
  %cmp71 = icmp ne i32 %conv70, 10
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end64
  store i32 0, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end64
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 0
  %61 = load i8, i8* %code75, align 4
  %conv76 = zext i8 %61 to i32
  %and77 = and i32 %conv76, 24
  %cmp78 = icmp ne i32 %and77, 24
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end74
  store i32 0, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.end74
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %62, i32 0, i32 2
  %63 = load i16, i16* %off, align 2
  %conv82 = sext i16 %63 to i32
  %sub = sub i32 0, %conv82
  %sub83 = sub i32 %sub, 1
  %div = sdiv i32 %sub83, 8
  store i32 %div, i32* %spi, align 4
  %64 = load i32, i32* %spi, align 4
  %cmp84 = icmp uge i32 %64, 64
  br i1 %cmp84, label %if.then86, label %if.end121

if.then86:                                        ; preds = %if.end81
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = bitcast %struct.bpf_verifier_env* %65 to i8*
  %67 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %66, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.85, i64 0, i64 0), i32 noundef %67) #8
  store i32 1, i32* %__ret_warn_once, align 4
  %68 = load i32, i32* %__ret_warn_once, align 4
  %tobool87 = icmp ne i32 %68, 0
  br i1 %tobool87, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then86
  %69 = load i8, i8* @backtrack_insn.__warned, align 1
  %tobool88 = trunc i8 %69 to i1
  %lnot = xor i1 %tobool88, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then86
  %70 = phi i1 [ false, %if.then86 ], [ %lnot, %land.rhs ]
  %lnot89 = xor i1 %70, true
  %lnot90 = xor i1 %lnot89, true
  %lnot.ext = zext i1 %lnot90 to i32
  %conv91 = sext i32 %lnot.ext to i64
  %tobool92 = icmp ne i64 %conv91, 0
  br i1 %tobool92, label %if.then93, label %if.end113

if.then93:                                        ; preds = %land.end
  store i8 1, i8* @backtrack_insn.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %71 = load i32, i32* %__ret_warn_on, align 4
  %tobool94 = icmp ne i32 %71, 0
  %lnot95 = xor i1 %tobool94, true
  %lnot97 = xor i1 %lnot95, true
  %lnot.ext98 = zext i1 %lnot97 to i32
  %conv99 = sext i32 %lnot.ext98 to i64
  %tobool100 = icmp ne i64 %conv99, 0
  br i1 %tobool100, label %if.then101, label %if.end106

if.then101:                                       ; preds = %if.then93
  br label %do.body

do.body:                                          ; preds = %if.then101
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.80, i64 0, i64 0)) #8
  br label %do.body102

do.body102:                                       ; preds = %do.body
  br label %do.body103

do.body103:                                       ; preds = %do.body102
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1611, i32 2313, i64 12) #9, !srcloc !45
  br label %do.end

do.end:                                           ; preds = %do.body103
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 146) #9, !srcloc !46
  br label %do.end104

do.end104:                                        ; preds = %do.end
  br label %do.end105

do.end105:                                        ; preds = %do.end104
  br label %if.end106

if.end106:                                        ; preds = %do.end105, %if.then93
  %72 = load i32, i32* %__ret_warn_on, align 4
  %tobool107 = icmp ne i32 %72, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  store i64 %conv112, i64* %tmp, align 8
  %73 = load i64, i64* %tmp, align 8
  br label %if.end113

if.end113:                                        ; preds = %if.end106, %land.end
  %74 = load i32, i32* %__ret_warn_once, align 4
  %tobool115 = icmp ne i32 %74, 0
  %lnot116 = xor i1 %tobool115, true
  %lnot118 = xor i1 %lnot116, true
  %lnot.ext119 = zext i1 %lnot118 to i32
  %conv120 = sext i32 %lnot.ext119 to i64
  store i64 %conv120, i64* %tmp114, align 8
  %75 = load i64, i64* %tmp114, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end121:                                        ; preds = %if.end81
  %76 = load i32, i32* %spi, align 4
  %sh_prom = zext i32 %76 to i64
  %shl122 = shl i64 1, %sh_prom
  %77 = load i64*, i64** %stack_mask.addr, align 8
  %78 = load i64, i64* %77, align 8
  %or123 = or i64 %78, %shl122
  store i64 %or123, i64* %77, align 8
  br label %if.end323

if.else124:                                       ; preds = %if.else56
  %79 = load i8, i8* %class, align 1
  %conv125 = zext i8 %79 to i32
  %cmp126 = icmp eq i32 %conv125, 3
  br i1 %cmp126, label %if.then132, label %lor.lhs.false128

lor.lhs.false128:                                 ; preds = %if.else124
  %80 = load i8, i8* %class, align 1
  %conv129 = zext i8 %80 to i32
  %cmp130 = icmp eq i32 %conv129, 2
  br i1 %cmp130, label %if.then132, label %if.else222

if.then132:                                       ; preds = %lor.lhs.false128, %if.else124
  %81 = load i32*, i32** %reg_mask.addr, align 8
  %82 = load i32, i32* %81, align 4
  %83 = load i32, i32* %dreg, align 4
  %and133 = and i32 %82, %83
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %if.then132
  store i32 -524, i32* %retval, align 4
  br label %return

if.end136:                                        ; preds = %if.then132
  %84 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg137 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %84, i32 0, i32 1
  %bf.load138 = load i8, i8* %dst_reg137, align 1
  %bf.clear139 = and i8 %bf.load138, 15
  %conv140 = zext i8 %bf.clear139 to i32
  %cmp141 = icmp ne i32 %conv140, 10
  br i1 %cmp141, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.end136
  store i32 0, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %if.end136
  %85 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code145 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %85, i32 0, i32 0
  %86 = load i8, i8* %code145, align 4
  %conv146 = zext i8 %86 to i32
  %and147 = and i32 %conv146, 24
  %cmp148 = icmp ne i32 %and147, 24
  br i1 %cmp148, label %if.then150, label %if.end151

if.then150:                                       ; preds = %if.end144
  store i32 0, i32* %retval, align 4
  br label %return

if.end151:                                        ; preds = %if.end144
  %87 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off152 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %87, i32 0, i32 2
  %88 = load i16, i16* %off152, align 2
  %conv153 = sext i16 %88 to i32
  %sub154 = sub i32 0, %conv153
  %sub155 = sub i32 %sub154, 1
  %div156 = sdiv i32 %sub155, 8
  store i32 %div156, i32* %spi, align 4
  %89 = load i32, i32* %spi, align 4
  %cmp157 = icmp uge i32 %89, 64
  br i1 %cmp157, label %if.then159, label %if.end205

if.then159:                                       ; preds = %if.end151
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = bitcast %struct.bpf_verifier_env* %90 to i8*
  %92 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %91, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.85, i64 0, i64 0), i32 noundef %92) #8
  store i32 1, i32* %__ret_warn_once160, align 4
  %93 = load i32, i32* %__ret_warn_once160, align 4
  %tobool161 = icmp ne i32 %93, 0
  br i1 %tobool161, label %land.rhs162, label %land.end166

land.rhs162:                                      ; preds = %if.then159
  %94 = load i8, i8* @backtrack_insn.__warned.86, align 1
  %tobool163 = trunc i8 %94 to i1
  %lnot164 = xor i1 %tobool163, true
  br label %land.end166

land.end166:                                      ; preds = %land.rhs162, %if.then159
  %95 = phi i1 [ false, %if.then159 ], [ %lnot164, %land.rhs162 ]
  %lnot167 = xor i1 %95, true
  %lnot169 = xor i1 %lnot167, true
  %lnot.ext170 = zext i1 %lnot169 to i32
  %conv171 = sext i32 %lnot.ext170 to i64
  %tobool172 = icmp ne i64 %conv171, 0
  br i1 %tobool172, label %if.then173, label %if.end197

if.then173:                                       ; preds = %land.end166
  store i8 1, i8* @backtrack_insn.__warned.86, align 1
  store i32 1, i32* %__ret_warn_on174, align 4
  %96 = load i32, i32* %__ret_warn_on174, align 4
  %tobool175 = icmp ne i32 %96, 0
  %lnot176 = xor i1 %tobool175, true
  %lnot178 = xor i1 %lnot176, true
  %lnot.ext179 = zext i1 %lnot178 to i32
  %conv180 = sext i32 %lnot.ext179 to i64
  %tobool181 = icmp ne i64 %conv180, 0
  br i1 %tobool181, label %if.then182, label %if.end189

if.then182:                                       ; preds = %if.then173
  br label %do.body183

do.body183:                                       ; preds = %if.then182
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.80, i64 0, i64 0)) #8
  br label %do.body184

do.body184:                                       ; preds = %do.body183
  br label %do.body185

do.body185:                                       ; preds = %do.body184
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1630, i32 2313, i64 12) #9, !srcloc !47
  br label %do.end186

do.end186:                                        ; preds = %do.body185
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 147) #9, !srcloc !48
  br label %do.end187

do.end187:                                        ; preds = %do.end186
  br label %do.end188

do.end188:                                        ; preds = %do.end187
  br label %if.end189

if.end189:                                        ; preds = %do.end188, %if.then173
  %97 = load i32, i32* %__ret_warn_on174, align 4
  %tobool191 = icmp ne i32 %97, 0
  %lnot192 = xor i1 %tobool191, true
  %lnot194 = xor i1 %lnot192, true
  %lnot.ext195 = zext i1 %lnot194 to i32
  %conv196 = sext i32 %lnot.ext195 to i64
  store i64 %conv196, i64* %tmp190, align 8
  %98 = load i64, i64* %tmp190, align 8
  br label %if.end197

if.end197:                                        ; preds = %if.end189, %land.end166
  %99 = load i32, i32* %__ret_warn_once160, align 4
  %tobool199 = icmp ne i32 %99, 0
  %lnot200 = xor i1 %tobool199, true
  %lnot202 = xor i1 %lnot200, true
  %lnot.ext203 = zext i1 %lnot202 to i32
  %conv204 = sext i32 %lnot.ext203 to i64
  store i64 %conv204, i64* %tmp198, align 8
  %100 = load i64, i64* %tmp198, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end205:                                        ; preds = %if.end151
  %101 = load i64*, i64** %stack_mask.addr, align 8
  %102 = load i64, i64* %101, align 8
  %103 = load i32, i32* %spi, align 4
  %sh_prom206 = zext i32 %103 to i64
  %shl207 = shl i64 1, %sh_prom206
  %and208 = and i64 %102, %shl207
  %tobool209 = icmp ne i64 %and208, 0
  br i1 %tobool209, label %if.end211, label %if.then210

if.then210:                                       ; preds = %if.end205
  store i32 0, i32* %retval, align 4
  br label %return

if.end211:                                        ; preds = %if.end205
  %104 = load i32, i32* %spi, align 4
  %sh_prom212 = zext i32 %104 to i64
  %shl213 = shl i64 1, %sh_prom212
  %neg214 = xor i64 %shl213, -1
  %105 = load i64*, i64** %stack_mask.addr, align 8
  %106 = load i64, i64* %105, align 8
  %and215 = and i64 %106, %neg214
  store i64 %and215, i64* %105, align 8
  %107 = load i8, i8* %class, align 1
  %conv216 = zext i8 %107 to i32
  %cmp217 = icmp eq i32 %conv216, 3
  br i1 %cmp217, label %if.then219, label %if.end221

if.then219:                                       ; preds = %if.end211
  %108 = load i32, i32* %sreg, align 4
  %109 = load i32*, i32** %reg_mask.addr, align 8
  %110 = load i32, i32* %109, align 4
  %or220 = or i32 %110, %108
  store i32 %or220, i32* %109, align 4
  br label %if.end221

if.end221:                                        ; preds = %if.then219, %if.end211
  br label %if.end322

if.else222:                                       ; preds = %lor.lhs.false128
  %111 = load i8, i8* %class, align 1
  %conv223 = zext i8 %111 to i32
  %cmp224 = icmp eq i32 %conv223, 5
  br i1 %cmp224, label %if.then230, label %lor.lhs.false226

lor.lhs.false226:                                 ; preds = %if.else222
  %112 = load i8, i8* %class, align 1
  %conv227 = zext i8 %112 to i32
  %cmp228 = icmp eq i32 %conv227, 6
  br i1 %cmp228, label %if.then230, label %if.else300

if.then230:                                       ; preds = %lor.lhs.false226, %if.else222
  %113 = load i8, i8* %opcode, align 1
  %conv231 = zext i8 %113 to i32
  %cmp232 = icmp eq i32 %conv231, 128
  br i1 %cmp232, label %if.then234, label %if.else293

if.then234:                                       ; preds = %if.then230
  %114 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg235 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %114, i32 0, i32 1
  %bf.load236 = load i8, i8* %src_reg235, align 1
  %bf.lshr237 = lshr i8 %bf.load236, 4
  %conv238 = zext i8 %bf.lshr237 to i32
  %cmp239 = icmp eq i32 %conv238, 1
  br i1 %cmp239, label %if.then241, label %if.end242

if.then241:                                       ; preds = %if.then234
  store i32 -524, i32* %retval, align 4
  br label %return

if.end242:                                        ; preds = %if.then234
  %115 = load i32*, i32** %reg_mask.addr, align 8
  %116 = load i32, i32* %115, align 4
  %and243 = and i32 %116, -2
  store i32 %and243, i32* %115, align 4
  %117 = load i32*, i32** %reg_mask.addr, align 8
  %118 = load i32, i32* %117, align 4
  %and244 = and i32 %118, 63
  %tobool245 = icmp ne i32 %and244, 0
  br i1 %tobool245, label %if.then246, label %if.end292

if.then246:                                       ; preds = %if.end242
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = bitcast %struct.bpf_verifier_env* %119 to i8*
  %121 = load i32*, i32** %reg_mask.addr, align 8
  %122 = load i32, i32* %121, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %120, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.87, i64 0, i64 0), i32 noundef %122) #8
  store i32 1, i32* %__ret_warn_once247, align 4
  %123 = load i32, i32* %__ret_warn_once247, align 4
  %tobool248 = icmp ne i32 %123, 0
  br i1 %tobool248, label %land.rhs249, label %land.end253

land.rhs249:                                      ; preds = %if.then246
  %124 = load i8, i8* @backtrack_insn.__warned.88, align 1
  %tobool250 = trunc i8 %124 to i1
  %lnot251 = xor i1 %tobool250, true
  br label %land.end253

land.end253:                                      ; preds = %land.rhs249, %if.then246
  %125 = phi i1 [ false, %if.then246 ], [ %lnot251, %land.rhs249 ]
  %lnot254 = xor i1 %125, true
  %lnot256 = xor i1 %lnot254, true
  %lnot.ext257 = zext i1 %lnot256 to i32
  %conv258 = sext i32 %lnot.ext257 to i64
  %tobool259 = icmp ne i64 %conv258, 0
  br i1 %tobool259, label %if.then260, label %if.end284

if.then260:                                       ; preds = %land.end253
  store i8 1, i8* @backtrack_insn.__warned.88, align 1
  store i32 1, i32* %__ret_warn_on261, align 4
  %126 = load i32, i32* %__ret_warn_on261, align 4
  %tobool262 = icmp ne i32 %126, 0
  %lnot263 = xor i1 %tobool262, true
  %lnot265 = xor i1 %lnot263, true
  %lnot.ext266 = zext i1 %lnot265 to i32
  %conv267 = sext i32 %lnot.ext266 to i64
  %tobool268 = icmp ne i64 %conv267, 0
  br i1 %tobool268, label %if.then269, label %if.end276

if.then269:                                       ; preds = %if.then260
  br label %do.body270

do.body270:                                       ; preds = %if.then269
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.80, i64 0, i64 0)) #8
  br label %do.body271

do.body271:                                       ; preds = %do.body270
  br label %do.body272

do.body272:                                       ; preds = %do.body271
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1649, i32 2313, i64 12) #9, !srcloc !49
  br label %do.end273

do.end273:                                        ; preds = %do.body272
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 148) #9, !srcloc !50
  br label %do.end274

do.end274:                                        ; preds = %do.end273
  br label %do.end275

do.end275:                                        ; preds = %do.end274
  br label %if.end276

if.end276:                                        ; preds = %do.end275, %if.then260
  %127 = load i32, i32* %__ret_warn_on261, align 4
  %tobool278 = icmp ne i32 %127, 0
  %lnot279 = xor i1 %tobool278, true
  %lnot281 = xor i1 %lnot279, true
  %lnot.ext282 = zext i1 %lnot281 to i32
  %conv283 = sext i32 %lnot.ext282 to i64
  store i64 %conv283, i64* %tmp277, align 8
  %128 = load i64, i64* %tmp277, align 8
  br label %if.end284

if.end284:                                        ; preds = %if.end276, %land.end253
  %129 = load i32, i32* %__ret_warn_once247, align 4
  %tobool286 = icmp ne i32 %129, 0
  %lnot287 = xor i1 %tobool286, true
  %lnot289 = xor i1 %lnot287, true
  %lnot.ext290 = zext i1 %lnot289 to i32
  %conv291 = sext i32 %lnot.ext290 to i64
  store i64 %conv291, i64* %tmp285, align 8
  %130 = load i64, i64* %tmp285, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end292:                                        ; preds = %if.end242
  br label %if.end299

if.else293:                                       ; preds = %if.then230
  %131 = load i8, i8* %opcode, align 1
  %conv294 = zext i8 %131 to i32
  %cmp295 = icmp eq i32 %conv294, 144
  br i1 %cmp295, label %if.then297, label %if.end298

if.then297:                                       ; preds = %if.else293
  store i32 -524, i32* %retval, align 4
  br label %return

if.end298:                                        ; preds = %if.else293
  br label %if.end299

if.end299:                                        ; preds = %if.end298, %if.end292
  br label %if.end321

if.else300:                                       ; preds = %lor.lhs.false226
  %132 = load i8, i8* %class, align 1
  %conv301 = zext i8 %132 to i32
  %cmp302 = icmp eq i32 %conv301, 0
  br i1 %cmp302, label %if.then304, label %if.end320

if.then304:                                       ; preds = %if.else300
  %133 = load i32*, i32** %reg_mask.addr, align 8
  %134 = load i32, i32* %133, align 4
  %135 = load i32, i32* %dreg, align 4
  %and305 = and i32 %134, %135
  %tobool306 = icmp ne i32 %and305, 0
  br i1 %tobool306, label %if.end308, label %if.then307

if.then307:                                       ; preds = %if.then304
  store i32 0, i32* %retval, align 4
  br label %return

if.end308:                                        ; preds = %if.then304
  %136 = load i32, i32* %dreg, align 4
  %neg309 = xor i32 %136, -1
  %137 = load i32*, i32** %reg_mask.addr, align 8
  %138 = load i32, i32* %137, align 4
  %and310 = and i32 %138, %neg309
  store i32 %and310, i32* %137, align 4
  %139 = load i8, i8* %mode, align 1
  %conv311 = zext i8 %139 to i32
  %cmp312 = icmp eq i32 %conv311, 64
  br i1 %cmp312, label %if.then318, label %lor.lhs.false314

lor.lhs.false314:                                 ; preds = %if.end308
  %140 = load i8, i8* %mode, align 1
  %conv315 = zext i8 %140 to i32
  %cmp316 = icmp eq i32 %conv315, 32
  br i1 %cmp316, label %if.then318, label %if.end319

if.then318:                                       ; preds = %lor.lhs.false314, %if.end308
  store i32 -524, i32* %retval, align 4
  br label %return

if.end319:                                        ; preds = %lor.lhs.false314
  br label %if.end320

if.end320:                                        ; preds = %if.end319, %if.else300
  br label %if.end321

if.end321:                                        ; preds = %if.end320, %if.end299
  br label %if.end322

if.end322:                                        ; preds = %if.end321, %if.end221
  br label %if.end323

if.end323:                                        ; preds = %if.end322, %if.end121
  br label %if.end324

if.end324:                                        ; preds = %if.end323, %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end324, %if.then318, %if.then307, %if.then297, %if.end284, %if.then241, %if.then210, %if.end197, %if.then150, %if.then143, %if.then135, %if.end113, %if.then80, %if.then73, %if.then63, %if.then30, %if.then
  %141 = load i32, i32* %retval, align 4
  ret i32 %141
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %for.body, label %for.end35

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc31, %for.body
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %1, %3
  br i1 %cmp, label %for.body2, label %for.end33

for.body2:                                        ; preds = %for.cond1
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %6, %struct.bpf_func_state** %func, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body2
  %7 = load i32, i32* %j, align 4
  %cmp4 = icmp slt i32 %7, 10
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %9 = load i32, i32* %j, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  store %struct.bpf_reg_state* %arrayidx7, %struct.bpf_reg_state** %reg, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type, align 8
  %cmp8 = icmp ne i32 %11, 1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body5
  br label %for.inc

if.end:                                           ; preds = %for.body5
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 14
  store i8 1, i8* %precise, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %13 = load i32, i32* %j, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  store i32 0, i32* %j, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc28, %for.end
  %14 = load i32, i32* %j, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 6
  %16 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %16, 8
  %cmp10 = icmp slt i32 %14, %div
  br i1 %cmp10, label %for.body11, label %for.end30

for.body11:                                       ; preds = %for.cond9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 7
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %19 = load i32, i32* %j, align 4
  %idxprom12 = sext i32 %19 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom12
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 1
  %arrayidx14 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %20 = load i8, i8* %arrayidx14, align 8
  %conv = zext i8 %20 to i32
  %cmp15 = icmp ne i32 %conv, 1
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body11
  br label %for.inc28

if.end18:                                         ; preds = %for.body11
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack19 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 7
  %22 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack19, align 8
  %23 = load i32, i32* %j, align 4
  %idxprom20 = sext i32 %23 to i64
  %arrayidx21 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %22, i64 %idxprom20
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx21, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type22, align 8
  %cmp23 = icmp ne i32 %25, 1
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end18
  br label %for.inc28

if.end26:                                         ; preds = %if.end18
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 14
  store i8 1, i8* %precise27, align 4
  br label %for.inc28

for.inc28:                                        ; preds = %if.end26, %if.then25, %if.then17
  %27 = load i32, i32* %j, align 4
  %inc29 = add i32 %27, 1
  store i32 %inc29, i32* %j, align 4
  br label %for.cond9

for.end30:                                        ; preds = %for.cond9
  br label %for.inc31

for.inc31:                                        ; preds = %for.end30
  %28 = load i32, i32* %i, align 4
  %inc32 = add i32 %28, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond1

for.end33:                                        ; preds = %for.cond1
  br label %for.inc34

for.inc34:                                        ; preds = %for.end33
  %29 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %29, i32 0, i32 1
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %30, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.end35:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %st, i32 noundef %i, i32* noundef %history) #0 {
entry:
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i.addr = alloca i32, align 4
  %history.addr = alloca i32*, align 8
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  store i32* %history, i32** %history.addr, align 8
  %0 = load i32*, i32** %history.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %5 = load i32, i32* %cnt, align 4
  %sub = sub i32 %5, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %4, i64 %idxprom
  %idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 1
  %6 = load i32, i32* %idx, align 4
  %7 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 9
  %9 = load %struct.util_est*, %struct.util_est** %jmp_history1, align 8
  %10 = load i32, i32* %cnt, align 4
  %sub2 = sub i32 %10, 1
  %idxprom3 = zext i32 %sub2 to i64
  %arrayidx4 = getelementptr %struct.util_est, %struct.util_est* %9, i64 %idxprom3
  %prev_idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx4, i32 0, i32 0
  %11 = load i32, i32* %prev_idx, align 4
  store i32 %11, i32* %i.addr, align 4
  %12 = load i32*, i32** %history.addr, align 8
  %13 = load i32, i32* %12, align 4
  %dec = add i32 %13, -1
  store i32 %dec, i32* %12, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %i.addr, align 4
  %dec5 = add i32 %14, -1
  store i32 %dec5, i32* %i.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %15 = load i32, i32* %i.addr, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bitmap_from_u64(i64* noundef %dst, i64 noundef %mask) #0 {
entry:
  %dst.addr = alloca i64*, align 8
  %mask.addr = alloca i64, align 8
  store i64* %dst, i64** %dst.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  %0 = load i64, i64* %mask.addr, align 8
  %and = and i64 %0, -1
  %1 = load i64*, i64** %dst.addr, align 8
  %arrayidx = getelementptr i64, i64* %1, i64 0
  store i64 %and, i64* %arrayidx, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @find_first_bit(i64* noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @find_next_bit(i64* noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_unknown(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %neg = xor i64 %3, -1
  %tobool = icmp ne i64 %neg, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @transfer_reference_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 4
  %2 = load i32, i32* %acquired_refs, align 4
  %call = call i32 @realloc_reference_state(%struct.bpf_func_state* noundef %0, i32 noundef %2, i1 noundef zeroext false) #8
  store i32 %call, i32* %err, align 4
  %3 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %err, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call1 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %5, %struct.bpf_func_state* noundef %6) #8
  store i32 %call1, i32* %err, align 4
  %7 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %7, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %8 = load i32, i32* %err, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_proto(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call = call zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %0) #8
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call1 = call zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %1) #8
  br i1 %call1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %2 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %3 = load i32, i32* %func_id.addr, align 4
  %call2 = call zeroext i1 @check_refcount_ok(%struct.bpf_func_proto* noundef %2, i32 noundef %3) #8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %call2, %land.rhs ]
  %5 = zext i1 %4 to i64
  %cond = select i1 %4, i32 0, i32 -22
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %arg_type, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %arg_type.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %expected_type = alloca i32, align 4
  %type = alloca i32, align 4
  %err = alloca i32, align 4
  %zero_size_allowed = alloca i8, align 1
  %size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %arg_type, i32* %arg_type.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  store i32 %4, i32* %type, align 4
  store i32 0, i32* %err, align 4
  %5 = load i32, i32* %arg_type.addr, align 4
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load i32, i32* %regno.addr, align 4
  %call2 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %6, i32 noundef %7, i32 noundef 0) #8
  store i32 %call2, i32* %err, align 4
  %8 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %9 = load i32, i32* %err, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %10 = load i32, i32* %arg_type.addr, align 4
  %cmp5 = icmp eq i32 %10, 12
  br i1 %cmp5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %call7 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %11, i32 noundef %12) #8
  br i1 %call7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.229, i64 0, i64 0), i32 noundef %15) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then6
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end4
  %16 = load i32, i32* %type, align 4
  %call11 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %16) #8
  br i1 %call11, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end10
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call12 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %17, %struct.bpf_call_arg_meta* noundef %18, i32 noundef 1) #8
  br i1 %call12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %land.lhs.true
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.230, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %land.lhs.true, %if.end10
  %21 = load i32, i32* %arg_type.addr, align 4
  %cmp15 = icmp eq i32 %21, 2
  br i1 %cmp15, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end14
  %22 = load i32, i32* %arg_type.addr, align 4
  %cmp16 = icmp eq i32 %22, 3
  br i1 %cmp16, label %if.then21, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %23 = load i32, i32* %arg_type.addr, align 4
  %cmp18 = icmp eq i32 %23, 4
  br i1 %cmp18, label %if.then21, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %lor.lhs.false17
  %24 = load i32, i32* %arg_type.addr, align 4
  %cmp20 = icmp eq i32 %24, 5
  br i1 %cmp20, label %if.then21, label %if.else34

if.then21:                                        ; preds = %lor.lhs.false19, %lor.lhs.false17, %lor.lhs.false, %if.end14
  store i32 6, i32* %expected_type, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call22 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %25) #8
  br i1 %call22, label %land.lhs.true23, label %if.else

land.lhs.true23:                                  ; preds = %if.then21
  %26 = load i32, i32* %arg_type.addr, align 4
  %cmp24 = icmp eq i32 %26, 5
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %land.lhs.true23
  br label %if.end33

if.else:                                          ; preds = %land.lhs.true23, %if.then21
  %27 = load i32, i32* %type, align 4
  %call26 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %27) #8
  br i1 %call26, label %if.end32, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %if.else
  %28 = load i32, i32* %type, align 4
  %cmp28 = icmp ne i32 %28, 4
  br i1 %cmp28, label %land.lhs.true29, label %if.end32

land.lhs.true29:                                  ; preds = %land.lhs.true27
  %29 = load i32, i32* %type, align 4
  %30 = load i32, i32* %expected_type, align 4
  %cmp30 = icmp ne i32 %29, %30
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true29
  br label %err_type

if.end32:                                         ; preds = %land.lhs.true29, %land.lhs.true27, %if.else
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then25
  br label %if.end137

if.else34:                                        ; preds = %lor.lhs.false19
  %31 = load i32, i32* %arg_type.addr, align 4
  %cmp35 = icmp eq i32 %31, 9
  br i1 %cmp35, label %if.then38, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %if.else34
  %32 = load i32, i32* %arg_type.addr, align 4
  %cmp37 = icmp eq i32 %32, 10
  br i1 %cmp37, label %if.then38, label %if.else42

if.then38:                                        ; preds = %lor.lhs.false36, %if.else34
  store i32 1, i32* %expected_type, align 4
  %33 = load i32, i32* %type, align 4
  %34 = load i32, i32* %expected_type, align 4
  %cmp39 = icmp ne i32 %33, %34
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.then38
  br label %err_type

if.end41:                                         ; preds = %if.then38
  br label %if.end136

if.else42:                                        ; preds = %lor.lhs.false36
  %35 = load i32, i32* %arg_type.addr, align 4
  %cmp43 = icmp eq i32 %35, 1
  br i1 %cmp43, label %if.then44, label %if.else48

if.then44:                                        ; preds = %if.else42
  store i32 3, i32* %expected_type, align 4
  %36 = load i32, i32* %type, align 4
  %37 = load i32, i32* %expected_type, align 4
  %cmp45 = icmp ne i32 %36, %37
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.then44
  br label %err_type

if.end47:                                         ; preds = %if.then44
  br label %if.end135

if.else48:                                        ; preds = %if.else42
  %38 = load i32, i32* %arg_type.addr, align 4
  %cmp49 = icmp eq i32 %38, 11
  br i1 %cmp49, label %if.then50, label %if.else58

if.then50:                                        ; preds = %if.else48
  store i32 2, i32* %expected_type, align 4
  %39 = load i32, i32* %type, align 4
  %40 = load i32, i32* %expected_type, align 4
  %cmp51 = icmp ne i32 %39, %40
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then50
  br label %err_type

if.end53:                                         ; preds = %if.then50
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %43 = load i32, i32* %regno.addr, align 4
  %call54 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %41, %struct.bpf_reg_state* noundef %42, i32 noundef %43) #8
  store i32 %call54, i32* %err, align 4
  %44 = load i32, i32* %err, align 4
  %cmp55 = icmp slt i32 %44, 0
  br i1 %cmp55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end53
  %45 = load i32, i32* %err, align 4
  store i32 %45, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %if.end53
  br label %if.end134

if.else58:                                        ; preds = %if.else48
  %46 = load i32, i32* %arg_type.addr, align 4
  %cmp59 = icmp eq i32 %46, 14
  br i1 %cmp59, label %if.then60, label %if.else75

if.then60:                                        ; preds = %if.else58
  store i32 13, i32* %expected_type, align 4
  %47 = load i32, i32* %type, align 4
  %call61 = call zeroext i1 @type_is_sk_pointer(i32 noundef %47) #8
  br i1 %call61, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.then60
  br label %err_type

if.end63:                                         ; preds = %if.then60
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 4
  %49 = load i32, i32* %ref_obj_id, align 8
  %tobool64 = icmp ne i32 %49, 0
  br i1 %tobool64, label %if.then65, label %if.end74

if.then65:                                        ; preds = %if.end63
  %50 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id66 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %50, i32 0, i32 7
  %51 = load i32, i32* %ref_obj_id66, align 8
  %tobool67 = icmp ne i32 %51, 0
  br i1 %tobool67, label %if.then68, label %if.end71

if.then68:                                        ; preds = %if.then65
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i32, i32* %regno.addr, align 4
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 4
  %56 = load i32, i32* %ref_obj_id69, align 8
  %57 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id70 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %57, i32 0, i32 7
  %58 = load i32, i32* %ref_obj_id70, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([70 x i8], [70 x i8]* @.str.231, i64 0, i64 0), i32 noundef %54, i32 noundef %56, i32 noundef %58) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.then65
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 4
  %60 = load i32, i32* %ref_obj_id72, align 8
  %61 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id73 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %61, i32 0, i32 7
  store i32 %60, i32* %ref_obj_id73, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.end71, %if.end63
  br label %if.end133

if.else75:                                        ; preds = %if.else58
  %62 = load i32, i32* %arg_type.addr, align 4
  %cmp76 = icmp eq i32 %62, 17
  br i1 %cmp76, label %if.then77, label %if.else81

if.then77:                                        ; preds = %if.else75
  store i32 11, i32* %expected_type, align 4
  %63 = load i32, i32* %type, align 4
  %64 = load i32, i32* %expected_type, align 4
  %cmp78 = icmp ne i32 %63, %64
  br i1 %cmp78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.then77
  br label %err_type

if.end80:                                         ; preds = %if.then77
  br label %if.end132

if.else81:                                        ; preds = %if.else75
  %65 = load i32, i32* %arg_type.addr, align 4
  %cmp82 = icmp eq i32 %65, 13
  br i1 %cmp82, label %if.then83, label %if.else101

if.then83:                                        ; preds = %if.else81
  %66 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %66, i32 0, i32 8
  %67 = load i32, i32* %func_id, align 4
  %cmp84 = icmp eq i32 %67, 93
  br i1 %cmp84, label %if.then85, label %if.else90

if.then85:                                        ; preds = %if.then83
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = load i32, i32* %regno.addr, align 4
  %call86 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %68, i32 noundef %69, i1 noundef zeroext true) #8
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.then85
  store i32 -13, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.then85
  br label %if.end100

if.else90:                                        ; preds = %if.then83
  %70 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id91 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %70, i32 0, i32 8
  %71 = load i32, i32* %func_id91, align 4
  %cmp92 = icmp eq i32 %71, 94
  br i1 %cmp92, label %if.then93, label %if.else98

if.then93:                                        ; preds = %if.else90
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load i32, i32* %regno.addr, align 4
  %call94 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %72, i32 noundef %73, i1 noundef zeroext false) #8
  %tobool95 = icmp ne i32 %call94, 0
  br i1 %tobool95, label %if.then96, label %if.end97

if.then96:                                        ; preds = %if.then93
  store i32 -13, i32* %retval, align 4
  br label %return

if.end97:                                         ; preds = %if.then93
  br label %if.end99

if.else98:                                        ; preds = %if.else90
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.232, i64 0, i64 0)) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end99:                                         ; preds = %if.end97
  br label %if.end100

if.end100:                                        ; preds = %if.end99, %if.end89
  br label %if.end131

if.else101:                                       ; preds = %if.else81
  %76 = load i32, i32* %arg_type.addr, align 4
  %call102 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %76) #8
  br i1 %call102, label %if.then103, label %if.else118

if.then103:                                       ; preds = %if.else101
  store i32 6, i32* %expected_type, align 4
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call104 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %77) #8
  br i1 %call104, label %land.lhs.true105, label %if.else108

land.lhs.true105:                                 ; preds = %if.then103
  %78 = load i32, i32* %arg_type.addr, align 4
  %cmp106 = icmp eq i32 %78, 7
  br i1 %cmp106, label %if.then107, label %if.else108

if.then107:                                       ; preds = %land.lhs.true105
  br label %if.end116

if.else108:                                       ; preds = %land.lhs.true105, %if.then103
  %79 = load i32, i32* %type, align 4
  %call109 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %79) #8
  br i1 %call109, label %if.end115, label %land.lhs.true110

land.lhs.true110:                                 ; preds = %if.else108
  %80 = load i32, i32* %type, align 4
  %cmp111 = icmp ne i32 %80, 4
  br i1 %cmp111, label %land.lhs.true112, label %if.end115

land.lhs.true112:                                 ; preds = %land.lhs.true110
  %81 = load i32, i32* %type, align 4
  %82 = load i32, i32* %expected_type, align 4
  %cmp113 = icmp ne i32 %81, %82
  br i1 %cmp113, label %if.then114, label %if.end115

if.then114:                                       ; preds = %land.lhs.true112
  br label %err_type

if.end115:                                        ; preds = %land.lhs.true112, %land.lhs.true110, %if.else108
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then107
  %83 = load i32, i32* %arg_type.addr, align 4
  %cmp117 = icmp eq i32 %83, 8
  %84 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %84, i32 0, i32 1
  %frombool = zext i1 %cmp117 to i8
  store i8 %frombool, i8* %raw_mode, align 8
  br label %if.end130

if.else118:                                       ; preds = %if.else101
  %85 = load i32, i32* %arg_type.addr, align 4
  %call119 = call zeroext i1 @arg_type_is_int_ptr(i32 noundef %85) #8
  br i1 %call119, label %if.then120, label %if.else128

if.then120:                                       ; preds = %if.else118
  store i32 6, i32* %expected_type, align 4
  %86 = load i32, i32* %type, align 4
  %call121 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %86) #8
  br i1 %call121, label %if.end127, label %land.lhs.true122

land.lhs.true122:                                 ; preds = %if.then120
  %87 = load i32, i32* %type, align 4
  %cmp123 = icmp ne i32 %87, 4
  br i1 %cmp123, label %land.lhs.true124, label %if.end127

land.lhs.true124:                                 ; preds = %land.lhs.true122
  %88 = load i32, i32* %type, align 4
  %89 = load i32, i32* %expected_type, align 4
  %cmp125 = icmp ne i32 %88, %89
  br i1 %cmp125, label %if.then126, label %if.end127

if.then126:                                       ; preds = %land.lhs.true124
  br label %err_type

if.end127:                                        ; preds = %land.lhs.true124, %land.lhs.true122, %if.then120
  br label %if.end129

if.else128:                                       ; preds = %if.else118
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = bitcast %struct.bpf_verifier_env* %90 to i8*
  %92 = load i32, i32* %arg_type.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %91, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.233, i64 0, i64 0), i32 noundef %92) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end129:                                        ; preds = %if.end127
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %if.end116
  br label %if.end131

if.end131:                                        ; preds = %if.end130, %if.end100
  br label %if.end132

if.end132:                                        ; preds = %if.end131, %if.end80
  br label %if.end133

if.end133:                                        ; preds = %if.end132, %if.end74
  br label %if.end134

if.end134:                                        ; preds = %if.end133, %if.end57
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.end47
  br label %if.end136

if.end136:                                        ; preds = %if.end135, %if.end41
  br label %if.end137

if.end137:                                        ; preds = %if.end136, %if.end33
  %93 = load i32, i32* %arg_type.addr, align 4
  %cmp138 = icmp eq i32 %93, 1
  br i1 %cmp138, label %if.then139, label %if.else141

if.then139:                                       ; preds = %if.end137
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %95 to %struct.bpf_map**
  %96 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %97 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr140 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %97, i32 0, i32 0
  store %struct.bpf_map* %96, %struct.bpf_map** %map_ptr140, align 8
  br label %if.end212

if.else141:                                       ; preds = %if.end137
  %98 = load i32, i32* %arg_type.addr, align 4
  %cmp142 = icmp eq i32 %98, 2
  br i1 %cmp142, label %if.then143, label %if.else150

if.then143:                                       ; preds = %if.else141
  %99 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr144 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %99, i32 0, i32 0
  %100 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr144, align 8
  %tobool145 = icmp ne %struct.bpf_map* %100, null
  br i1 %tobool145, label %if.end147, label %if.then146

if.then146:                                       ; preds = %if.then143
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %102 = bitcast %struct.bpf_verifier_env* %101 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %102, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.234, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end147:                                        ; preds = %if.then143
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %104 = load i32, i32* %regno.addr, align 4
  %105 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr148 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %105, i32 0, i32 0
  %106 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr148, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %106, i32 0, i32 4
  %107 = load i32, i32* %key_size, align 4
  %call149 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %103, i32 noundef %104, i32 noundef %107, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef null) #8
  store i32 %call149, i32* %err, align 4
  br label %if.end211

if.else150:                                       ; preds = %if.else141
  %108 = load i32, i32* %arg_type.addr, align 4
  %cmp151 = icmp eq i32 %108, 3
  br i1 %cmp151, label %if.then158, label %lor.lhs.false152

lor.lhs.false152:                                 ; preds = %if.else150
  %109 = load i32, i32* %arg_type.addr, align 4
  %cmp153 = icmp eq i32 %109, 5
  br i1 %cmp153, label %land.lhs.true154, label %lor.lhs.false156

land.lhs.true154:                                 ; preds = %lor.lhs.false152
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call155 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %110) #8
  br i1 %call155, label %lor.lhs.false156, label %if.then158

lor.lhs.false156:                                 ; preds = %land.lhs.true154, %lor.lhs.false152
  %111 = load i32, i32* %arg_type.addr, align 4
  %cmp157 = icmp eq i32 %111, 4
  br i1 %cmp157, label %if.then158, label %if.else168

if.then158:                                       ; preds = %lor.lhs.false156, %land.lhs.true154, %if.else150
  %112 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr159 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %112, i32 0, i32 0
  %113 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr159, align 8
  %tobool160 = icmp ne %struct.bpf_map* %113, null
  br i1 %tobool160, label %if.end162, label %if.then161

if.then161:                                       ; preds = %if.then158
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = bitcast %struct.bpf_verifier_env* %114 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %115, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.235, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end162:                                        ; preds = %if.then158
  %116 = load i32, i32* %arg_type.addr, align 4
  %cmp163 = icmp eq i32 %116, 4
  %117 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode164 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %117, i32 0, i32 1
  %frombool165 = zext i1 %cmp163 to i8
  store i8 %frombool165, i8* %raw_mode164, align 8
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %119 = load i32, i32* %regno.addr, align 4
  %120 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr166 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %120, i32 0, i32 0
  %121 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr166, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %121, i32 0, i32 5
  %122 = load i32, i32* %value_size, align 32
  %123 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call167 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %118, i32 noundef %119, i32 noundef %122, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %123) #8
  store i32 %call167, i32* %err, align 4
  br label %if.end210

if.else168:                                       ; preds = %lor.lhs.false156
  %124 = load i32, i32* %arg_type.addr, align 4
  %call169 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %124) #8
  br i1 %call169, label %if.then170, label %if.else199

if.then170:                                       ; preds = %if.else168
  %125 = load i32, i32* %arg_type.addr, align 4
  %cmp171 = icmp eq i32 %125, 10
  %frombool172 = zext i1 %cmp171 to i8
  store i8 %frombool172, i8* %zero_size_allowed, align 1
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 7
  %127 = load i64, i64* %smax_value, align 8
  %128 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_smax_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %128, i32 0, i32 5
  store i64 %127, i64* %msize_smax_value, align 8
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %129, i32 0, i32 9
  %130 = load i64, i64* %umax_value, align 8
  %131 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_umax_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %131, i32 0, i32 6
  store i64 %130, i64* %msize_umax_value, align 8
  %132 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %132, i32 0, i32 5
  %133 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %134 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 0
  %135 = load i64, i64* %134, align 8
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 1
  %137 = load i64, i64* %136, align 8
  %call173 = call zeroext i1 @tnum_is_const(i64 %135, i64 %137) #8
  br i1 %call173, label %if.end175, label %if.then174

if.then174:                                       ; preds = %if.then170
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end175

if.end175:                                        ; preds = %if.then174, %if.then170
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 6
  %139 = load i64, i64* %smin_value, align 8
  %cmp176 = icmp slt i64 %139, 0
  br i1 %cmp176, label %if.then177, label %if.end178

if.then177:                                       ; preds = %if.end175
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  %142 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.236, i64 0, i64 0), i32 noundef %142) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end178:                                        ; preds = %if.end175
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %143, i32 0, i32 8
  %144 = load i64, i64* %umin_value, align 8
  %cmp179 = icmp eq i64 %144, 0
  br i1 %cmp179, label %if.then180, label %if.end186

if.then180:                                       ; preds = %if.end178
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %146 = load i32, i32* %regno.addr, align 4
  %sub = sub i32 %146, 1
  %147 = load i8, i8* %zero_size_allowed, align 1
  %tobool181 = trunc i8 %147 to i1
  %148 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call182 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %145, i32 noundef %sub, i32 noundef 0, i1 noundef zeroext %tobool181, %struct.bpf_call_arg_meta* noundef %148) #8
  store i32 %call182, i32* %err, align 4
  %149 = load i32, i32* %err, align 4
  %tobool183 = icmp ne i32 %149, 0
  br i1 %tobool183, label %if.then184, label %if.end185

if.then184:                                       ; preds = %if.then180
  %150 = load i32, i32* %err, align 4
  store i32 %150, i32* %retval, align 4
  br label %return

if.end185:                                        ; preds = %if.then180
  br label %if.end186

if.end186:                                        ; preds = %if.end185, %if.end178
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value187 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %151, i32 0, i32 9
  %152 = load i64, i64* %umax_value187, align 8
  %cmp188 = icmp uge i64 %152, 536870912
  br i1 %cmp188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %if.end186
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = bitcast %struct.bpf_verifier_env* %153 to i8*
  %155 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %154, i8* noundef getelementptr inbounds ([71 x i8], [71 x i8]* @.str.237, i64 0, i64 0), i32 noundef %155) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end190:                                        ; preds = %if.end186
  %156 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %157 = load i32, i32* %regno.addr, align 4
  %sub191 = sub i32 %157, 1
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 9
  %159 = load i64, i64* %umax_value192, align 8
  %conv = trunc i64 %159 to i32
  %160 = load i8, i8* %zero_size_allowed, align 1
  %tobool193 = trunc i8 %160 to i1
  %161 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call194 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %156, i32 noundef %sub191, i32 noundef %conv, i1 noundef zeroext %tobool193, %struct.bpf_call_arg_meta* noundef %161) #8
  store i32 %call194, i32* %err, align 4
  %162 = load i32, i32* %err, align 4
  %tobool195 = icmp ne i32 %162, 0
  br i1 %tobool195, label %if.end198, label %if.then196

if.then196:                                       ; preds = %if.end190
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %164 = load i32, i32* %regno.addr, align 4
  %call197 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %163, i32 noundef %164) #8
  store i32 %call197, i32* %err, align 4
  br label %if.end198

if.end198:                                        ; preds = %if.then196, %if.end190
  br label %if.end209

if.else199:                                       ; preds = %if.else168
  %165 = load i32, i32* %arg_type.addr, align 4
  %call200 = call zeroext i1 @arg_type_is_int_ptr(i32 noundef %165) #8
  br i1 %call200, label %if.then201, label %if.end208

if.then201:                                       ; preds = %if.else199
  %166 = load i32, i32* %arg_type.addr, align 4
  %call202 = call i32 @int_ptr_type_to_size(i32 noundef %166) #8
  store i32 %call202, i32* %size, align 4
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %168 = load i32, i32* %regno.addr, align 4
  %169 = load i32, i32* %size, align 4
  %170 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call203 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %167, i32 noundef %168, i32 noundef %169, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %170) #8
  store i32 %call203, i32* %err, align 4
  %171 = load i32, i32* %err, align 4
  %tobool204 = icmp ne i32 %171, 0
  br i1 %tobool204, label %if.then205, label %if.end206

if.then205:                                       ; preds = %if.then201
  %172 = load i32, i32* %err, align 4
  store i32 %172, i32* %retval, align 4
  br label %return

if.end206:                                        ; preds = %if.then201
  %173 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %175 = load i32, i32* %size, align 4
  %call207 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %173, %struct.bpf_reg_state* noundef %174, i32 noundef 0, i32 noundef %175, i1 noundef zeroext true) #8
  store i32 %call207, i32* %err, align 4
  br label %if.end208

if.end208:                                        ; preds = %if.end206, %if.else199
  br label %if.end209

if.end209:                                        ; preds = %if.end208, %if.end198
  br label %if.end210

if.end210:                                        ; preds = %if.end209, %if.end162
  br label %if.end211

if.end211:                                        ; preds = %if.end210, %if.end147
  br label %if.end212

if.end212:                                        ; preds = %if.end211, %if.then139
  %176 = load i32, i32* %err, align 4
  store i32 %176, i32* %retval, align 4
  br label %return

err_type:                                         ; preds = %if.then126, %if.then114, %if.then79, %if.then62, %if.then52, %if.then46, %if.then40, %if.then31
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %178 = bitcast %struct.bpf_verifier_env* %177 to i8*
  %179 = load i32, i32* %regno.addr, align 4
  %180 = load i32, i32* %type, align 4
  %idxprom213 = zext i32 %180 to i64
  %arrayidx214 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom213
  %181 = load i8*, i8** %arrayidx214, align 8
  %182 = load i32, i32* %expected_type, align 4
  %idxprom215 = zext i32 %182 to i64
  %arrayidx216 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom215
  %183 = load i8*, i8** %arrayidx216, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %178, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.238, i64 0, i64 0), i32 noundef %179, i8* noundef %181, i8* noundef %183) #8
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_type, %if.end212, %if.then205, %if.then189, %if.then184, %if.then177, %if.then161, %if.then146, %if.else128, %if.else98, %if.then96, %if.then88, %if.then68, %if.then56, %if.then13, %if.end9, %if.then8, %if.then3, %if.then
  %184 = load i32, i32* %retval, align 4
  ret i32 %184
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_map(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %3, i32 0, i32 0
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 12
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %6, 1
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp ne i32 %7, 2
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %8, 3
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %land.lhs.true4
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %9, 87
  br i1 %cmp7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %10, 88
  br i1 %cmp9, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %11, 89
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true10
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp12 = icmp eq %struct.bpf_map* %12, null
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.226, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %15, i32 0, i32 7
  %16 = load i32, i32* %map_flags, align 8
  %and = and i32 %16, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true15, label %if.end23

land.lhs.true15:                                  ; preds = %if.end14
  %17 = load i32, i32* %func_id.addr, align 4
  %cmp16 = icmp eq i32 %17, 3
  br i1 %cmp16, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true15
  %18 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp eq i32 %18, 2
  br i1 %cmp17, label %if.then22, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp19 = icmp eq i32 %19, 87
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false18
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp21 = icmp eq i32 %20, 88
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %lor.lhs.false20, %lor.lhs.false18, %lor.lhs.false, %land.lhs.true15
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.257, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %lor.lhs.false20, %if.end14
  %23 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %24 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %23, i32 0, i32 0
  %map_state = bitcast %union.anon.13* %24 to i64*
  %25 = load i64, i64* %map_state, align 8
  %and24 = and i64 %25, -2
  %26 = inttoptr i64 %and24 to %struct.bpf_map*
  %tobool25 = icmp ne %struct.bpf_map* %26, null
  br i1 %tobool25, label %if.else, label %if.then26

if.then26:                                        ; preds = %if.end23
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %28 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr27 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %28, i32 0, i32 0
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr27, align 8
  %30 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr28 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %30, i32 0, i32 0
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr28, align 8
  %unpriv_array = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 15
  %32 = load i8, i8* %unpriv_array, align 8
  %tobool29 = trunc i8 %32 to i1
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %27, %struct.bpf_map* noundef %29, i1 noundef zeroext %tobool29) #8
  br label %if.end39

if.else:                                          ; preds = %if.end23
  %33 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %34 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %33, i32 0, i32 0
  %map_state30 = bitcast %union.anon.13* %34 to i64*
  %35 = load i64, i64* %map_state30, align 8
  %and31 = and i64 %35, -2
  %36 = inttoptr i64 %and31 to %struct.bpf_map*
  %37 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr32 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %37, i32 0, i32 0
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr32, align 8
  %cmp33 = icmp ne %struct.bpf_map* %36, %38
  br i1 %cmp33, label %if.then34, label %if.end38

if.then34:                                        ; preds = %if.else
  %39 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %40 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr35 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %40, i32 0, i32 0
  %41 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr35, align 8
  %unpriv_array36 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %41, i32 0, i32 15
  %42 = load i8, i8* %unpriv_array36, align 8
  %tobool37 = trunc i8 %42 to i1
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %39, %struct.bpf_map* noundef inttoptr (i64 -2401263026318485698 to %struct.bpf_map*), i1 noundef zeroext %tobool37) #8
  br label %if.end38

if.end38:                                         ; preds = %if.then34, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then26
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end39, %if.then22, %if.then13, %if.then
  %43 = load i32, i32* %retval, align 4
  ret i32 %43
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_release_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 86
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference(%struct.bpf_verifier_env* noundef %env, i32 noundef %ref_obj_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %err = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %2) #8
  %3 = load i32, i32* %ref_obj_id.addr, align 4
  %call1 = call i32 @release_reference_state(%struct.bpf_func_state* noundef %call, i32 noundef %3) #8
  store i32 %call1, i32* %err, align 4
  %4 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %err, align 4
  store i32 %5, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 0
  %11 = load i32, i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %13 = load i32, i32* %ref_obj_id.addr, align 4
  call void @release_reg_references(%struct.bpf_verifier_env* noundef %9, %struct.bpf_func_state* noundef %12, i32 noundef %13) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %5, i64 %7, i64 noundef 0) #8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ptr_cast_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 96
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 95
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_acquire_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 84
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 85
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp eq i32 %2, 99
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %new_ofs = alloca i32, align 4
  %id = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 4
  %2 = load i32, i32* %acquired_refs, align 4
  store i32 %2, i32* %new_ofs, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 4
  %5 = load i32, i32* %acquired_refs1, align 4
  %add = add i32 %5, 1
  %call2 = call i32 @realloc_reference_state(%struct.bpf_func_state* noundef %3, i32 noundef %add, i1 noundef zeroext true) #8
  store i32 %call2, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 13
  %9 = load i32, i32* %id_gen, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %id_gen, align 4
  store i32 %inc, i32* %id, align 4
  %10 = load i32, i32* %id, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  %12 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %13 = load i32, i32* %new_ofs, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %12, i64 %idxprom
  %id3 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  store i32 %10, i32* %id3, align 4
  %14 = load i32, i32* %insn_idx.addr, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 5
  %16 = load %struct.util_est*, %struct.util_est** %refs4, align 8
  %17 = load i32, i32* %new_ofs, align 4
  %idxprom5 = sext i32 %17 to i64
  %arrayidx6 = getelementptr %struct.util_est, %struct.util_est* %16, i64 %idxprom5
  %insn_idx7 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx6, i32 0, i32 1
  store i32 %14, i32* %insn_idx7, align 4
  %18 = load i32, i32* %id, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @do_refine_retval_range(%struct.bpf_reg_state* noundef %regs, i32 noundef %ret_type, i32 noundef %func_id, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %ret_type.addr = alloca i32, align 4
  %func_id.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %ret_reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %ret_type, i32* %ret_type.addr, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 0
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %ret_reg, align 8
  %1 = load i32, i32* %ret_type.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %2, 67
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp ne i32 %3, 45
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_smax_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 5
  %5 = load i64, i64* %msize_smax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  store i64 %5, i64* %smax_value, align 8
  %7 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_umax_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %7, i32 0, i32 6
  %8 = load i64, i64* %msize_umax_value, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 9
  store i64 %8, i64* %umax_value, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %10) #8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %11) #8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type, align 8
  switch i32 %2, label %sw.default [
    i32 3, label %sw.bb
    i32 4, label %sw.bb3
    i32 7, label %sw.bb10
    i32 8, label %sw.bb14
    i32 19, label %sw.bb20
    i32 21, label %sw.bb20
    i32 14, label %sw.bb24
    i32 25, label %sw.bb24
    i32 16, label %sw.bb30
    i32 17, label %sw.bb34
    i32 12, label %sw.bb40
    i32 13, label %sw.bb40
    i32 15, label %sw.bb44
    i32 18, label %sw.bb54
    i32 20, label %sw.bb64
    i32 22, label %sw.bb68
    i32 23, label %sw.bb68
    i32 24, label %sw.bb76
  ]

sw.bb:                                            ; preds = %if.end
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %3, 12
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %sw.bb
  br label %error

if.end2:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 22
  br i1 %cmp4, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %sw.bb3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %5, 25
  br i1 %cmp5, label %land.lhs.true6, label %if.end9

land.lhs.true6:                                   ; preds = %land.lhs.true
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %6, 55
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %land.lhs.true6
  br label %error

if.end9:                                          ; preds = %land.lhs.true6, %land.lhs.true, %sw.bb3
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %7, 27
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %sw.bb10
  br label %error

if.end13:                                         ; preds = %sw.bb10
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp15 = icmp ne i32 %8, 33
  br i1 %cmp15, label %land.lhs.true16, label %if.end19

land.lhs.true16:                                  ; preds = %sw.bb14
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp ne i32 %9, 37
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true16
  br label %error

if.end19:                                         ; preds = %land.lhs.true16, %sw.bb14
  br label %sw.epilog

sw.bb20:                                          ; preds = %if.end, %if.end
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp21 = icmp ne i32 %10, 81
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %sw.bb20
  br label %error

if.end23:                                         ; preds = %sw.bb20
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end, %if.end
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp25 = icmp ne i32 %11, 51
  br i1 %cmp25, label %land.lhs.true26, label %if.end29

land.lhs.true26:                                  ; preds = %sw.bb24
  %12 = load i32, i32* %func_id.addr, align 4
  %cmp27 = icmp ne i32 %12, 1
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true26
  br label %error

if.end29:                                         ; preds = %land.lhs.true26, %sw.bb24
  br label %sw.epilog

sw.bb30:                                          ; preds = %if.end
  %13 = load i32, i32* %func_id.addr, align 4
  %cmp31 = icmp ne i32 %13, 51
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %sw.bb30
  br label %error

if.end33:                                         ; preds = %sw.bb30
  br label %sw.epilog

sw.bb34:                                          ; preds = %if.end
  %14 = load i32, i32* %func_id.addr, align 4
  %cmp35 = icmp ne i32 %14, 51
  br i1 %cmp35, label %land.lhs.true36, label %if.end39

land.lhs.true36:                                  ; preds = %sw.bb34
  %15 = load i32, i32* %func_id.addr, align 4
  %cmp37 = icmp ne i32 %15, 1
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %land.lhs.true36
  br label %error

if.end39:                                         ; preds = %land.lhs.true36, %sw.bb34
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end, %if.end
  %16 = load i32, i32* %func_id.addr, align 4
  %cmp41 = icmp ne i32 %16, 1
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %sw.bb40
  br label %error

if.end43:                                         ; preds = %sw.bb40
  br label %sw.epilog

sw.bb44:                                          ; preds = %if.end
  %17 = load i32, i32* %func_id.addr, align 4
  %cmp45 = icmp ne i32 %17, 52
  br i1 %cmp45, label %land.lhs.true46, label %if.end53

land.lhs.true46:                                  ; preds = %sw.bb44
  %18 = load i32, i32* %func_id.addr, align 4
  %cmp47 = icmp ne i32 %18, 53
  br i1 %cmp47, label %land.lhs.true48, label %if.end53

land.lhs.true48:                                  ; preds = %land.lhs.true46
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp49 = icmp ne i32 %19, 3
  br i1 %cmp49, label %land.lhs.true50, label %if.end53

land.lhs.true50:                                  ; preds = %land.lhs.true48
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp51 = icmp ne i32 %20, 60
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %land.lhs.true50
  br label %error

if.end53:                                         ; preds = %land.lhs.true50, %land.lhs.true48, %land.lhs.true46, %sw.bb44
  br label %sw.epilog

sw.bb54:                                          ; preds = %if.end
  %21 = load i32, i32* %func_id.addr, align 4
  %cmp55 = icmp ne i32 %21, 72
  br i1 %cmp55, label %land.lhs.true56, label %if.end63

land.lhs.true56:                                  ; preds = %sw.bb54
  %22 = load i32, i32* %func_id.addr, align 4
  %cmp57 = icmp ne i32 %22, 70
  br i1 %cmp57, label %land.lhs.true58, label %if.end63

land.lhs.true58:                                  ; preds = %land.lhs.true56
  %23 = load i32, i32* %func_id.addr, align 4
  %cmp59 = icmp ne i32 %23, 3
  br i1 %cmp59, label %land.lhs.true60, label %if.end63

land.lhs.true60:                                  ; preds = %land.lhs.true58
  %24 = load i32, i32* %func_id.addr, align 4
  %cmp61 = icmp ne i32 %24, 71
  br i1 %cmp61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %land.lhs.true60
  br label %error

if.end63:                                         ; preds = %land.lhs.true60, %land.lhs.true58, %land.lhs.true56, %sw.bb54
  br label %sw.epilog

sw.bb64:                                          ; preds = %if.end
  %25 = load i32, i32* %func_id.addr, align 4
  %cmp65 = icmp ne i32 %25, 82
  br i1 %cmp65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %sw.bb64
  br label %error

if.end67:                                         ; preds = %sw.bb64
  br label %sw.epilog

sw.bb68:                                          ; preds = %if.end, %if.end
  %26 = load i32, i32* %func_id.addr, align 4
  %cmp69 = icmp ne i32 %26, 89
  br i1 %cmp69, label %land.lhs.true70, label %if.end75

land.lhs.true70:                                  ; preds = %sw.bb68
  %27 = load i32, i32* %func_id.addr, align 4
  %cmp71 = icmp ne i32 %27, 88
  br i1 %cmp71, label %land.lhs.true72, label %if.end75

land.lhs.true72:                                  ; preds = %land.lhs.true70
  %28 = load i32, i32* %func_id.addr, align 4
  %cmp73 = icmp ne i32 %28, 87
  br i1 %cmp73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %land.lhs.true72
  br label %error

if.end75:                                         ; preds = %land.lhs.true72, %land.lhs.true70, %sw.bb68
  br label %sw.epilog

sw.bb76:                                          ; preds = %if.end
  %29 = load i32, i32* %func_id.addr, align 4
  %cmp77 = icmp ne i32 %29, 107
  br i1 %cmp77, label %land.lhs.true78, label %if.end81

land.lhs.true78:                                  ; preds = %sw.bb76
  %30 = load i32, i32* %func_id.addr, align 4
  %cmp79 = icmp ne i32 %30, 108
  br i1 %cmp79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %land.lhs.true78
  br label %error

if.end81:                                         ; preds = %land.lhs.true78, %sw.bb76
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end81, %if.end75, %if.end67, %if.end63, %if.end53, %if.end43, %if.end39, %if.end33, %if.end29, %if.end23, %if.end19, %if.end13, %if.end9, %if.end2
  %31 = load i32, i32* %func_id.addr, align 4
  switch i32 %31, label %sw.default155 [
    i32 12, label %sw.bb82
    i32 22, label %sw.bb90
    i32 25, label %sw.bb90
    i32 55, label %sw.bb90
    i32 27, label %sw.bb95
    i32 37, label %sw.bb100
    i32 33, label %sw.bb100
    i32 51, label %sw.bb105
    i32 52, label %sw.bb119
    i32 60, label %sw.bb119
    i32 53, label %sw.bb119
    i32 72, label %sw.bb124
    i32 71, label %sw.bb124
    i32 70, label %sw.bb124
    i32 81, label %sw.bb129
    i32 82, label %sw.bb137
    i32 89, label %sw.bb142
    i32 88, label %sw.bb142
    i32 87, label %sw.bb142
    i32 107, label %sw.bb150
    i32 108, label %sw.bb150
  ]

sw.bb82:                                          ; preds = %sw.epilog
  %32 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type83 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %32, i32 0, i32 3
  %33 = load i32, i32* %map_type83, align 8
  %cmp84 = icmp ne i32 %33, 3
  br i1 %cmp84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %sw.bb82
  br label %error

if.end86:                                         ; preds = %sw.bb82
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 21
  %35 = load i32, i32* %subprog_cnt, align 8
  %cmp87 = icmp ugt i32 %35, 1
  br i1 %cmp87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.end86
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.258, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.end86
  br label %sw.epilog156

sw.bb90:                                          ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type91 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %38, i32 0, i32 3
  %39 = load i32, i32* %map_type91, align 8
  %cmp92 = icmp ne i32 %39, 4
  br i1 %cmp92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %sw.bb90
  br label %error

if.end94:                                         ; preds = %sw.bb90
  br label %sw.epilog156

sw.bb95:                                          ; preds = %sw.epilog
  %40 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type96 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %40, i32 0, i32 3
  %41 = load i32, i32* %map_type96, align 8
  %cmp97 = icmp ne i32 %41, 7
  br i1 %cmp97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %sw.bb95
  br label %error

if.end99:                                         ; preds = %sw.bb95
  br label %sw.epilog156

sw.bb100:                                         ; preds = %sw.epilog, %sw.epilog
  %42 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type101 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %42, i32 0, i32 3
  %43 = load i32, i32* %map_type101, align 8
  %cmp102 = icmp ne i32 %43, 8
  br i1 %cmp102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %sw.bb100
  br label %error

if.end104:                                        ; preds = %sw.bb100
  br label %sw.epilog156

sw.bb105:                                         ; preds = %sw.epilog
  %44 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type106 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %44, i32 0, i32 3
  %45 = load i32, i32* %map_type106, align 8
  %cmp107 = icmp ne i32 %45, 14
  br i1 %cmp107, label %land.lhs.true108, label %if.end118

land.lhs.true108:                                 ; preds = %sw.bb105
  %46 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type109 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %46, i32 0, i32 3
  %47 = load i32, i32* %map_type109, align 8
  %cmp110 = icmp ne i32 %47, 25
  br i1 %cmp110, label %land.lhs.true111, label %if.end118

land.lhs.true111:                                 ; preds = %land.lhs.true108
  %48 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type112 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %48, i32 0, i32 3
  %49 = load i32, i32* %map_type112, align 8
  %cmp113 = icmp ne i32 %49, 16
  br i1 %cmp113, label %land.lhs.true114, label %if.end118

land.lhs.true114:                                 ; preds = %land.lhs.true111
  %50 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type115 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %50, i32 0, i32 3
  %51 = load i32, i32* %map_type115, align 8
  %cmp116 = icmp ne i32 %51, 17
  br i1 %cmp116, label %if.then117, label %if.end118

if.then117:                                       ; preds = %land.lhs.true114
  br label %error

if.end118:                                        ; preds = %land.lhs.true114, %land.lhs.true111, %land.lhs.true108, %sw.bb105
  br label %sw.epilog156

sw.bb119:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %52 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type120 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %52, i32 0, i32 3
  %53 = load i32, i32* %map_type120, align 8
  %cmp121 = icmp ne i32 %53, 15
  br i1 %cmp121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %sw.bb119
  br label %error

if.end123:                                        ; preds = %sw.bb119
  br label %sw.epilog156

sw.bb124:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %54 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type125 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %54, i32 0, i32 3
  %55 = load i32, i32* %map_type125, align 8
  %cmp126 = icmp ne i32 %55, 18
  br i1 %cmp126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %sw.bb124
  br label %error

if.end128:                                        ; preds = %sw.bb124
  br label %sw.epilog156

sw.bb129:                                         ; preds = %sw.epilog
  %56 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type130 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %56, i32 0, i32 3
  %57 = load i32, i32* %map_type130, align 8
  %cmp131 = icmp ne i32 %57, 19
  br i1 %cmp131, label %land.lhs.true132, label %if.end136

land.lhs.true132:                                 ; preds = %sw.bb129
  %58 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type133 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %58, i32 0, i32 3
  %59 = load i32, i32* %map_type133, align 8
  %cmp134 = icmp ne i32 %59, 21
  br i1 %cmp134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %land.lhs.true132
  br label %error

if.end136:                                        ; preds = %land.lhs.true132, %sw.bb129
  br label %sw.epilog156

sw.bb137:                                         ; preds = %sw.epilog
  %60 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type138 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %60, i32 0, i32 3
  %61 = load i32, i32* %map_type138, align 8
  %cmp139 = icmp ne i32 %61, 20
  br i1 %cmp139, label %if.then140, label %if.end141

if.then140:                                       ; preds = %sw.bb137
  br label %error

if.end141:                                        ; preds = %sw.bb137
  br label %sw.epilog156

sw.bb142:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %62 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type143 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %62, i32 0, i32 3
  %63 = load i32, i32* %map_type143, align 8
  %cmp144 = icmp ne i32 %63, 22
  br i1 %cmp144, label %land.lhs.true145, label %if.end149

land.lhs.true145:                                 ; preds = %sw.bb142
  %64 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type146 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %64, i32 0, i32 3
  %65 = load i32, i32* %map_type146, align 8
  %cmp147 = icmp ne i32 %65, 23
  br i1 %cmp147, label %if.then148, label %if.end149

if.then148:                                       ; preds = %land.lhs.true145
  br label %error

if.end149:                                        ; preds = %land.lhs.true145, %sw.bb142
  br label %sw.epilog156

sw.bb150:                                         ; preds = %sw.epilog, %sw.epilog
  %66 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type151 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %66, i32 0, i32 3
  %67 = load i32, i32* %map_type151, align 8
  %cmp152 = icmp ne i32 %67, 24
  br i1 %cmp152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %sw.bb150
  br label %error

if.end154:                                        ; preds = %sw.bb150
  br label %sw.epilog156

sw.default155:                                    ; preds = %sw.epilog
  br label %sw.epilog156

sw.epilog156:                                     ; preds = %sw.default155, %if.end154, %if.end149, %if.end141, %if.end136, %if.end128, %if.end123, %if.end118, %if.end104, %if.end99, %if.end94, %if.end89
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then153, %if.then148, %if.then140, %if.then135, %if.then127, %if.then122, %if.then117, %if.then103, %if.then98, %if.then93, %if.then85, %if.then80, %if.then74, %if.then66, %if.then62, %if.then52, %if.then42, %if.then38, %if.then32, %if.then28, %if.then22, %if.then18, %if.then12, %if.then8, %if.then1
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = bitcast %struct.bpf_verifier_env* %68 to i8*
  %70 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type157 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %70, i32 0, i32 3
  %71 = load i32, i32* %map_type157, align 8
  %72 = load i32, i32* %func_id.addr, align 4
  %call = call i8* @func_id_name(i32 noundef %72) #8
  %73 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %69, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.259, i64 0, i64 0), i32 noundef %71, i8* noundef %call, i32 noundef %73) #8
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %error, %sw.epilog156, %if.then88, %if.then
  %74 = load i32, i32* %retval, align 4
  ret i32 %74
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_callchain_buffers(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @__clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %5, %struct.bpf_func_state* noundef %8) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  %call = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %arrayidx) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 6
  %10 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %10, 8
  %cmp2 = icmp slt i32 %8, %div
  br i1 %cmp2, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %13 to i64
  %arrayidx4 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom3
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx4, i32 0, i32 1
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %14 = load i8, i8* %arrayidx5, align 8
  %conv = zext i8 %14 to i32
  %cmp6 = icmp eq i32 %conv, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 7
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack8, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %17 to i64
  %arrayidx10 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom9
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx10, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %cond.end43, %cond.end
  %18 = load i32, i32* %i, align 4
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 6
  %20 = load i32, i32* %allocated_stack12, align 8
  %div13 = sdiv i32 %20, 8
  %cmp14 = icmp slt i32 %18, %div13
  br i1 %cmp14, label %for.body16, label %for.end45

for.body16:                                       ; preds = %for.cond11
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %21, null
  br i1 %tobool, label %if.end18, label %if.then17

if.then17:                                        ; preds = %for.body16
  br label %for.inc22

if.end18:                                         ; preds = %for.body16
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call19 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %22) #8
  br i1 %call19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end18
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %23) #8
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end18
  br label %for.inc22

for.inc22:                                        ; preds = %if.end21, %if.then17
  %24 = load i32, i32* %i, align 4
  %inc23 = add i32 %24, 1
  store i32 %inc23, i32* %i, align 4
  %25 = load i32, i32* %i, align 4
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 6
  %27 = load i32, i32* %allocated_stack24, align 8
  %div25 = sdiv i32 %27, 8
  %cmp26 = icmp slt i32 %25, %div25
  br i1 %cmp26, label %land.lhs.true28, label %cond.false42

land.lhs.true28:                                  ; preds = %for.inc22
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 7
  %29 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack29, align 8
  %30 = load i32, i32* %i, align 4
  %idxprom30 = sext i32 %30 to i64
  %arrayidx31 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %29, i64 %idxprom30
  %slot_type32 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx31, i32 0, i32 1
  %arrayidx33 = getelementptr [8 x i8], [8 x i8]* %slot_type32, i64 0, i64 0
  %31 = load i8, i8* %arrayidx33, align 8
  %conv34 = zext i8 %31 to i32
  %cmp35 = icmp eq i32 %conv34, 1
  br i1 %cmp35, label %cond.true37, label %cond.false42

cond.true37:                                      ; preds = %land.lhs.true28
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack38 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 7
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack38, align 8
  %34 = load i32, i32* %i, align 4
  %idxprom39 = sext i32 %34 to i64
  %arrayidx40 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom39
  %spilled_ptr41 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx40, i32 0, i32 0
  br label %cond.end43

cond.false42:                                     ; preds = %land.lhs.true28, %for.inc22
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false42, %cond.true37
  %cond44 = phi %struct.bpf_reg_state* [ %spilled_ptr41, %cond.true37 ], [ null, %cond.false42 ]
  store %struct.bpf_reg_state* %cond44, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond11

for.end45:                                        ; preds = %for.cond11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %0) #8
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %2, 9
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_is_pkt_pointer(i32 noundef %1) #8
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_pkt_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_reg_references(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %ref_obj_id) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  %ref_obj_id2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %ref_obj_id2, align 8
  %5 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp3 = icmp eq i32 %4, %5
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %10 = load i32, i32* %i, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 6
  %12 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %12, 8
  %cmp4 = icmp slt i32 %10, %div
  br i1 %cmp4, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 7
  %14 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %14, i64 %idxprom5
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 1
  %arrayidx7 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %16 = load i8, i8* %arrayidx7, align 8
  %conv = zext i8 %16 to i32
  %cmp8 = icmp eq i32 %conv, 1
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 7
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack10, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %19 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom11
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond13

for.cond13:                                       ; preds = %cond.end47, %cond.end
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 6
  %22 = load i32, i32* %allocated_stack14, align 8
  %div15 = sdiv i32 %22, 8
  %cmp16 = icmp slt i32 %20, %div15
  br i1 %cmp16, label %for.body18, label %for.end49

for.body18:                                       ; preds = %for.cond13
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %23, null
  br i1 %tobool, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.body18
  br label %for.inc26

if.end20:                                         ; preds = %for.body18
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 4
  %25 = load i32, i32* %ref_obj_id21, align 8
  %26 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp22 = icmp eq i32 %25, %26
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end20
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %27) #8
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end20
  br label %for.inc26

for.inc26:                                        ; preds = %if.end25, %if.then19
  %28 = load i32, i32* %i, align 4
  %inc27 = add i32 %28, 1
  store i32 %inc27, i32* %i, align 4
  %29 = load i32, i32* %i, align 4
  %30 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack28 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %30, i32 0, i32 6
  %31 = load i32, i32* %allocated_stack28, align 8
  %div29 = sdiv i32 %31, 8
  %cmp30 = icmp slt i32 %29, %div29
  br i1 %cmp30, label %land.lhs.true32, label %cond.false46

land.lhs.true32:                                  ; preds = %for.inc26
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack33 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 7
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack33, align 8
  %34 = load i32, i32* %i, align 4
  %idxprom34 = sext i32 %34 to i64
  %arrayidx35 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom34
  %slot_type36 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx35, i32 0, i32 1
  %arrayidx37 = getelementptr [8 x i8], [8 x i8]* %slot_type36, i64 0, i64 0
  %35 = load i8, i8* %arrayidx37, align 8
  %conv38 = zext i8 %35 to i32
  %cmp39 = icmp eq i32 %conv38, 1
  br i1 %cmp39, label %cond.true41, label %cond.false46

cond.true41:                                      ; preds = %land.lhs.true32
  %36 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %36, i32 0, i32 7
  %37 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom43 = sext i32 %38 to i64
  %arrayidx44 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %37, i64 %idxprom43
  %spilled_ptr45 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx44, i32 0, i32 0
  br label %cond.end47

cond.false46:                                     ; preds = %land.lhs.true32, %for.inc26
  br label %cond.end47

cond.end47:                                       ; preds = %cond.false46, %cond.true41
  %cond48 = phi %struct.bpf_reg_state* [ %spilled_ptr45, %cond.true41 ], [ null, %cond.false46 ]
  store %struct.bpf_reg_state* %cond48, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond13

for.end49:                                        ; preds = %for.cond13
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %aux, %struct.bpf_map* noundef %map, i1 noundef zeroext %unpriv) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %unpriv.addr = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %frombool = zext i1 %unpriv to i8
  store i8 %frombool, i8* %unpriv.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %0) #8
  %conv = zext i1 %call to i32
  %1 = load i8, i8* %unpriv.addr, align 1
  %tobool = trunc i8 %1 to i1
  %conv1 = zext i1 %tobool to i32
  %or = or i32 %conv1, %conv
  %tobool2 = icmp ne i32 %or, 0
  %frombool3 = zext i1 %tobool2 to i8
  store i8 %frombool3, i8* %unpriv.addr, align 1
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %3 = ptrtoint %struct.bpf_map* %2 to i64
  %4 = load i8, i8* %unpriv.addr, align 1
  %tobool4 = trunc i8 %4 to i1
  %5 = zext i1 %tobool4 to i64
  %cond = select i1 %tobool4, i64 1, i64 0
  %or6 = or i64 %3, %cond
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %7 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %6, i32 0, i32 0
  %map_state = bitcast %union.anon.13* %7 to i64*
  store i64 %or6, i64* %map_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %t.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 2
  %2 = load i32, i32* %type, align 4
  switch i32 %2, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb
    i32 19, label %sw.bb
    i32 21, label %sw.bb
    i32 22, label %sw.bb
    i32 8, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb1
    i32 6, label %sw.bb1
    i32 12, label %sw.bb1
    i32 14, label %sw.bb1
    i32 16, label %sw.bb1
    i32 25, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %3 = load i32, i32* %t.addr, align 4
  %cmp = icmp eq i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb1

sw.bb1:                                           ; preds = %if.end, %entry, %entry, %entry, %entry, %entry, %entry
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool = icmp ne %struct.bpf_call_arg_meta* %4, null
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %sw.bb1
  %5 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %5, i32 0, i32 2
  %6 = load i8, i8* %pkt_access, align 1
  %tobool3 = trunc i8 %6 to i1
  store i1 %tobool3, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb1
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 15
  store i8 1, i8* %seen_direct_write, align 1
  store i1 true, i1* %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry
  %8 = load i32, i32* %t.addr, align 4
  %cmp6 = icmp eq i32 %8, 2
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %sw.bb5
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 15
  store i8 1, i8* %seen_direct_write8, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %sw.bb5
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %if.end9, %if.end4, %if.then2, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 2
  %1 = load i32, i32* %off, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load i32, i32* %regno.addr, align 4
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 2
  %6 = load i32, i32* %off1, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.174, i64 0, i64 0), i32 noundef %4, i32 noundef %6) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #8
  br i1 %call, label %lor.lhs.false, label %if.then4

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %tobool3 = icmp ne i64 %14, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call6 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %18, i64 %20) #8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %arraydecay7 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.175, i64 0, i64 0), i8* noundef %arraydecay7) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then4, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_sk_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 13
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 15
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 18
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i1 noundef zeroext %is_lock) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %is_lock.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %is_const = alloca i8, align 1
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_lock to i8
  store i8 %frombool, i8* %is_lock.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %4, %struct.bpf_verifier_state** %cur, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %6 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %8, i64 %10) #8
  %frombool2 = zext i1 %call1 to i8
  store i8 %frombool2, i8* %is_const, align 1
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %12 to %struct.bpf_map**
  %13 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %13, %struct.bpf_map** %map, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %15 = load i64, i64* %value, align 8
  store i64 %15, i64* %val, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 0
  %17 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %17, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.239, i64 0, i64 0), i32 noundef %20) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %21 = load i8, i8* %is_const, align 1
  %tobool = trunc i8 %21 to i1
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([82 x i8], [82 x i8]* @.str.240, i64 0, i64 0), i32 noundef %24) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %25, i32 0, i32 13
  %26 = load %struct.btf*, %struct.btf** %btf, align 64
  %tobool6 = icmp ne %struct.btf* %26, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %29, i32 0, i32 21
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.241, i64 0, i64 0), i8* noundef %arraydecay) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end5
  %30 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call9 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %30) #8
  br i1 %call9, label %if.end25, label %if.then10

if.then10:                                        ; preds = %if.end8
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 8
  %32 = load i32, i32* %spin_lock_off, align 4
  %cmp11 = icmp eq i32 %32, -7
  br i1 %cmp11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.then10
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name13 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %35, i32 0, i32 21
  %arraydecay14 = getelementptr inbounds [16 x i8], [16 x i8]* %name13, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.242, i64 0, i64 0), i8* noundef %arraydecay14) #8
  br label %if.end24

if.else:                                          ; preds = %if.then10
  %36 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off15 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %36, i32 0, i32 8
  %37 = load i32, i32* %spin_lock_off15, align 4
  %cmp16 = icmp eq i32 %37, -2
  br i1 %cmp16, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.else
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = bitcast %struct.bpf_verifier_env* %38 to i8*
  %40 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name18 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %40, i32 0, i32 21
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %name18, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %39, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.243, i64 0, i64 0), i8* noundef %arraydecay19) #8
  br label %if.end23

if.else20:                                        ; preds = %if.else
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name21 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %43, i32 0, i32 21
  %arraydecay22 = getelementptr inbounds [16 x i8], [16 x i8]* %name21, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.244, i64 0, i64 0), i8* noundef %arraydecay22) #8
  br label %if.end23

if.end23:                                         ; preds = %if.else20, %if.then17
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then12
  store i32 -22, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end8
  %44 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off26 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %44, i32 0, i32 8
  %45 = load i32, i32* %spin_lock_off26, align 4
  %conv = sext i32 %45 to i64
  %46 = load i64, i64* %val, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 2
  %48 = load i32, i32* %off, align 8
  %conv27 = sext i32 %48 to i64
  %add = add i64 %46, %conv27
  %cmp28 = icmp ne i64 %conv, %add
  br i1 %cmp28, label %if.then30, label %if.end34

if.then30:                                        ; preds = %if.end25
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = bitcast %struct.bpf_verifier_env* %49 to i8*
  %51 = load i64, i64* %val, align 8
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 2
  %53 = load i32, i32* %off31, align 8
  %conv32 = sext i32 %53 to i64
  %add33 = add i64 %51, %conv32
  call void (i8*, i8*, ...) @verbose(i8* noundef %50, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.245, i64 0, i64 0), i64 noundef %add33) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end25
  %54 = load i8, i8* %is_lock.addr, align 1
  %tobool35 = trunc i8 %54 to i1
  br i1 %tobool35, label %if.then36, label %if.else41

if.then36:                                        ; preds = %if.end34
  %55 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %55, i32 0, i32 5
  %56 = load i32, i32* %active_spin_lock, align 4
  %tobool37 = icmp ne i32 %56, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then36
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.246, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end39:                                         ; preds = %if.then36
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 3
  %60 = load i32, i32* %id, align 4
  %61 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock40 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %61, i32 0, i32 5
  store i32 %60, i32* %active_spin_lock40, align 4
  br label %if.end53

if.else41:                                        ; preds = %if.end34
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock42 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %62, i32 0, i32 5
  %63 = load i32, i32* %active_spin_lock42, align 4
  %tobool43 = icmp ne i32 %63, 0
  br i1 %tobool43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %if.else41
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.247, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.else41
  %66 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock46 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %66, i32 0, i32 5
  %67 = load i32, i32* %active_spin_lock46, align 4
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 3
  %69 = load i32, i32* %id47, align 4
  %cmp48 = icmp ne i32 %67, %69
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end45
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.248, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.end45
  %72 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock52 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %72, i32 0, i32 5
  store i32 0, i32* %active_spin_lock52, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.end51, %if.end39
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end53, %if.then50, %if.then44, %if.then38, %if.then30, %if.end24, %if.then7, %if.then4, %if.then
  %73 = load i32, i32* %retval, align 4
  ret i32 %73
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_ptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 6
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %2, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_int_ptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 15
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 16
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 8
  switch i32 %4, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 4, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry, %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 2
  %8 = load i32, i32* %off, align 8
  %9 = load i32, i32* %access_size.addr, align 4
  %10 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %10 to i1
  %call1 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %5, i32 noundef %6, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool) #8
  store i32 %call1, i32* %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 2
  %14 = load i32, i32* %off3, align 8
  %15 = load i32, i32* %access_size.addr, align 4
  %16 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool4 = icmp ne %struct.bpf_call_arg_meta* %16, null
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb2
  %17 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %17, i32 0, i32 1
  %18 = load i8, i8* %raw_mode, align 8
  %tobool5 = trunc i8 %18 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb2
  %19 = phi i1 [ false, %sw.bb2 ], [ %tobool5, %land.rhs ]
  %20 = zext i1 %19 to i64
  %cond = select i1 %19, i32 2, i32 1
  %call6 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %14, i32 noundef %15, i32 noundef %cond) #8
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load i32, i32* %regno.addr, align 4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 2
  %24 = load i32, i32* %off8, align 8
  %25 = load i32, i32* %access_size.addr, align 4
  %26 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool9 = trunc i8 %26 to i1
  %call10 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %21, i32 noundef %22, i32 noundef %24, i32 noundef %25, i1 noundef zeroext %tobool9) #8
  store i32 %call10, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %regno.addr, align 4
  %29 = load i32, i32* %access_size.addr, align 4
  %30 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool11 = trunc i8 %30 to i1
  %31 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call12 = call i32 @check_stack_boundary(%struct.bpf_verifier_env* noundef %27, i32 noundef %28, i32 noundef %29, i1 noundef zeroext %tobool11, %struct.bpf_call_arg_meta* noundef %31) #8
  store i32 %call12, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.end, %if.then, %sw.bb
  %32 = load i32, i32* %retval, align 4
  ret i32 %32
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_size(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 9
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @int_ptr_type_to_size(i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 15
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 4, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 16
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store i32 8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %strict = alloca i8, align 1
  %pointer_desc = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 6
  %1 = load i8, i8* %strict_alignment, align 4
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool1 = trunc i8 %2 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  %frombool2 = zext i1 %3 to i8
  store i8 %frombool2, i8* %strict, align 1
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.50, i64 0, i64 0), i8** %pointer_desc, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  %5 = load i32, i32* %type, align 8
  switch i32 %5, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 10, label %sw.bb4
    i32 4, label %sw.bb5
    i32 2, label %sw.bb6
    i32 6, label %sw.bb7
    i32 11, label %sw.bb8
    i32 13, label %sw.bb9
    i32 15, label %sw.bb10
    i32 18, label %sw.bb11
  ]

sw.bb:                                            ; preds = %lor.end, %lor.end
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %10 = load i8, i8* %strict, align 1
  %tobool3 = trunc i8 %10 to i1
  %call = call i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool3) #8
  store i32 %call, i32* %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.162, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.163, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.164, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.165, i64 0, i64 0), i8** %pointer_desc, align 8
  store i8 1, i8* %strict, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.166, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.167, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.168, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.169, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %lor.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %13 = load i8*, i8** %pointer_desc, align 8
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i8, i8* %strict, align 1
  %tobool12 = trunc i8 %16 to i1
  %call13 = call i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i8* noundef %13, i32 noundef %14, i32 noundef %15, i1 noundef zeroext %tobool12) #8
  store i32 %call13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %ip_align = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 2, i32* %ip_align, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load i32, i32* %ip_align, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 2
  %5 = load i32, i32* %off1, align 8
  %add = add i32 %3, %5
  %6 = load i32, i32* %off.addr, align 4
  %add2 = add i32 %add, %6
  %conv = sext i32 %add2 to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #8
  %7 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call3 = call { i64, i64 } @tnum_add(i64 %14, i64 %16, i64 %19, i64 %21) #8
  %22 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 0
  %24 = extractvalue { i64, i64 } %call3, 0
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 1
  %26 = extractvalue { i64, i64 } %call3, 1
  store i64 %26, i64* %25, align 8
  %27 = bitcast %struct.tnum* %reg_off to i8*
  %28 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %28, i64 16, i1 false)
  %29 = load i32, i32* %size.addr, align 4
  %conv4 = sext i32 %29 to i64
  %30 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call zeroext i1 @tnum_is_aligned(i64 %32, i64 %34, i64 noundef %conv4) #8
  br i1 %call5, label %if.end11, label %if.then6

if.then6:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off7 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call8 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %38, i64 %40) #8
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %ip_align, align 4
  %arraydecay9 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 2
  %45 = load i32, i32* %off10, align 8
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.170, i64 0, i64 0), i32 noundef %43, i8* noundef %arraydecay9, i32 noundef %45, i32 noundef %46, i32 noundef %47) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then6, %if.then
  %48 = load i32, i32* %retval, align 4
  ret i32 %48
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i8* noundef %pointer_desc, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %pointer_desc.addr = alloca i8*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i8* %pointer_desc, i8** %pointer_desc.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 2
  %4 = load i32, i32* %off1, align 8
  %5 = load i32, i32* %off.addr, align 4
  %add = add i32 %4, %5
  %conv = sext i32 %add to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #8
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %16 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call2 = call { i64, i64 } @tnum_add(i64 %13, i64 %15, i64 %18, i64 %20) #8
  %21 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call2, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call2, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.tnum* %reg_off to i8*
  %27 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %28 to i64
  %29 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call4 = call zeroext i1 @tnum_is_aligned(i64 %31, i64 %33, i64 noundef %conv3) #8
  br i1 %call4, label %if.end10, label %if.then5

if.then5:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 5
  %35 = bitcast %struct.tnum* %var_off6 to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 8
  %call7 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %37, i64 %39) #8
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load i8*, i8** %pointer_desc.addr, align 8
  %arraydecay8 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 2
  %44 = load i32, i32* %off9, align 8
  %45 = load i32, i32* %off.addr, align 4
  %46 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.171, i64 0, i64 0), i8* noundef %42, i8* noundef %arraydecay8, i32 noundef %44, i32 noundef %45, i32 noundef %46) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then5, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_packet_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %__UNIQUE_ID___x151 = alloca i32, align 4
  %__UNIQUE_ID___y152 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.144, i64 0, i64 0), i32 noundef %7) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %10 = load i32, i32* %off.addr, align 4
  %11 = load i32, i32* %size.addr, align 4
  %12 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %12 to i1
  %call1 = call i32 @__check_packet_access(%struct.bpf_verifier_env* noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %11, i1 noundef zeroext %tobool) #8
  store i32 %call1, i32* %err, align 4
  %13 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %13, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.185, i64 0, i64 0), i32 noundef %16) #8
  %17 = load i32, i32* %err, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 2
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 7
  %20 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %20, i32 0, i32 3
  %21 = load i32, i32* %max_pkt_offset, align 4
  store i32 %21, i32* %__UNIQUE_ID___x151, align 4
  %22 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %22 to i64
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 9
  %24 = load i64, i64* %umax_value, align 8
  %add = add i64 %conv, %24
  %25 = load i32, i32* %size.addr, align 4
  %conv5 = sext i32 %25 to i64
  %add6 = add i64 %add, %conv5
  %sub = sub i64 %add6, 1
  %conv7 = trunc i64 %sub to i32
  store i32 %conv7, i32* %__UNIQUE_ID___y152, align 4
  %26 = load i32, i32* %__UNIQUE_ID___x151, align 4
  %27 = load i32, i32* %__UNIQUE_ID___y152, align 4
  %cmp8 = icmp ugt i32 %26, %27
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %28 = load i32, i32* %__UNIQUE_ID___x151, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end4
  %29 = load i32, i32* %__UNIQUE_ID___y152, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %28, %cond.true ], [ %29, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %30 = load i32, i32* %tmp, align 4
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 2
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %prog10, align 8
  %aux11 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %32, i32 0, i32 7
  %33 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux11, align 8
  %max_pkt_offset12 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %33, i32 0, i32 3
  store i32 %30, i32* %max_pkt_offset12, align 4
  %34 = load i32, i32* %err, align 4
  store i32 %34, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then3, %if.then
  %35 = load i32, i32* %retval, align 4
  ret i32 %35
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %cap = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %3 to %struct.bpf_map**
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call1 = call i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %5) #8
  store i32 %call1, i32* %cap, align 4
  %6 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %6, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %cap, align 4
  %conv = zext i32 %7 to i64
  %and = and i64 %conv, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %10, i32 0, i32 5
  %11 = load i32, i32* %value_size, align 32
  %12 = load i32, i32* %off.addr, align 4
  %13 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.172, i64 0, i64 0), i32 noundef %11, i32 noundef %12, i32 noundef %13) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %14, 1
  br i1 %cmp2, label %land.lhs.true4, label %if.end10

land.lhs.true4:                                   ; preds = %if.end
  %15 = load i32, i32* %cap, align 4
  %conv5 = zext i32 %15 to i64
  %and6 = and i64 %conv5, 1
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 5
  %19 = load i32, i32* %value_size9, align 32
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.173, i64 0, i64 0), i32 noundef %19, i32 noundef %20, i32 noundef %21) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true4, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %lock = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %9 = load i32, i32* %level, align 8
  %and = and i32 %9, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %10, %struct.bpf_func_state* noundef %11) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %13, 0
  br i1 %cmp, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  %15 = load i64, i64* %smin_value3, align 8
  %cmp4 = icmp eq i64 %15, -9223372036854775808
  br i1 %cmp4, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %16 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %16 to i64
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value5, align 8
  %add = add i64 %conv, %18
  %19 = load i32, i32* %off.addr, align 4
  %conv6 = sext i32 %19 to i64
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 6
  %21 = load i64, i64* %smin_value7, align 8
  %add8 = add i64 %conv6, %21
  %conv9 = trunc i64 %add8 to i32
  %conv10 = sext i32 %conv9 to i64
  %cmp11 = icmp ne i64 %add, %conv10
  br i1 %cmp11, label %if.then19, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value14, align 8
  %24 = load i32, i32* %off.addr, align 4
  %conv15 = sext i32 %24 to i64
  %add16 = add i64 %23, %conv15
  %cmp17 = icmp slt i64 %add16, 0
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %lor.lhs.false13, %lor.lhs.false, %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.144, i64 0, i64 0), i32 noundef %27) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %lor.lhs.false13, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load i32, i32* %regno.addr, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  %31 = load i64, i64* %smin_value21, align 8
  %32 = load i32, i32* %off.addr, align 4
  %conv22 = sext i32 %32 to i64
  %add23 = add i64 %31, %conv22
  %conv24 = trunc i64 %add23 to i32
  %33 = load i32, i32* %size.addr, align 4
  %34 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool25 = trunc i8 %34 to i1
  %call = call i32 @__check_map_access(%struct.bpf_verifier_env* noundef %28, i32 noundef %29, i32 noundef %conv24, i32 noundef %33, i1 noundef zeroext %tobool25) #8
  store i32 %call, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %35, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end20
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.145, i64 0, i64 0), i32 noundef %38) #8
  %39 = load i32, i32* %err, align 4
  store i32 %39, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end20
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 9
  %41 = load i64, i64* %umax_value, align 8
  %cmp29 = icmp uge i64 %41, 536870912
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.146, i64 0, i64 0), i32 noundef %44) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end28
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load i32, i32* %regno.addr, align 4
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 9
  %48 = load i64, i64* %umax_value33, align 8
  %49 = load i32, i32* %off.addr, align 4
  %conv34 = sext i32 %49 to i64
  %add35 = add i64 %48, %conv34
  %conv36 = trunc i64 %add35 to i32
  %50 = load i32, i32* %size.addr, align 4
  %51 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool37 = trunc i8 %51 to i1
  %call38 = call i32 @__check_map_access(%struct.bpf_verifier_env* noundef %45, i32 noundef %46, i32 noundef %conv36, i32 noundef %50, i1 noundef zeroext %tobool37) #8
  store i32 %call38, i32* %err, align 4
  %52 = load i32, i32* %err, align 4
  %tobool39 = icmp ne i32 %52, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end32
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.147, i64 0, i64 0), i32 noundef %55) #8
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %if.end32
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %57 to %struct.bpf_map**
  %58 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %call42 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %58) #8
  br i1 %call42, label %if.then43, label %if.end63

if.then43:                                        ; preds = %if.end41
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 1
  %map_ptr44 = bitcast %union.anon.147* %60 to %struct.bpf_map**
  %61 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr44, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %61, i32 0, i32 8
  %62 = load i32, i32* %spin_lock_off, align 4
  store i32 %62, i32* %lock, align 4
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 6
  %64 = load i64, i64* %smin_value45, align 8
  %65 = load i32, i32* %off.addr, align 4
  %conv46 = sext i32 %65 to i64
  %add47 = add i64 %64, %conv46
  %66 = load i32, i32* %lock, align 4
  %conv48 = zext i32 %66 to i64
  %add49 = add i64 %conv48, 4
  %cmp50 = icmp ult i64 %add47, %add49
  br i1 %cmp50, label %land.lhs.true52, label %if.end62

land.lhs.true52:                                  ; preds = %if.then43
  %67 = load i32, i32* %lock, align 4
  %conv53 = zext i32 %67 to i64
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 9
  %69 = load i64, i64* %umax_value54, align 8
  %70 = load i32, i32* %off.addr, align 4
  %conv55 = sext i32 %70 to i64
  %add56 = add i64 %69, %conv55
  %71 = load i32, i32* %size.addr, align 4
  %conv57 = sext i32 %71 to i64
  %add58 = add i64 %add56, %conv57
  %cmp59 = icmp ult i64 %conv53, %add58
  br i1 %cmp59, label %if.then61, label %if.end62

if.then61:                                        ; preds = %land.lhs.true52
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = bitcast %struct.bpf_verifier_env* %72 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %73, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.148, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end62:                                         ; preds = %land.lhs.true52, %if.then43
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.end41
  %74 = load i32, i32* %err, align 4
  store i32 %74, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end63, %if.then61, %if.then31, %if.then27, %if.then19
  %75 = load i32, i32* %retval, align 4
  ret i32 %75
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_boundary(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  %stype = alloca i8*, align 8
  %tn_buf124 = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #8
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  %5 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %5, 6
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %6 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %7 = load i32, i32* %access_size.addr, align 4
  %cmp2 = icmp eq i32 %7, 0
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call4 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %8) #8
  br i1 %call4, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true3
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %if.then
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load i32, i32* %regno.addr, align 4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type6, align 8
  %idxprom = zext i32 %13 to i64
  %arrayidx = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %14 = load i8*, i8** %arrayidx, align 8
  %15 = load i8*, i8** getelementptr inbounds ([19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 6), align 16
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.238, i64 0, i64 0), i32 noundef %11, i8* noundef %14, i8* noundef %15) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %entry
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 5
  %17 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call8 = call zeroext i1 @tnum_is_const(i64 %19, i64 %21) #8
  br i1 %call8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 0
  %23 = load i64, i64* %value, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 2
  %25 = load i32, i32* %off, align 8
  %conv = sext i32 %25 to i64
  %add = add i64 %23, %conv
  %conv11 = trunc i64 %add to i32
  store i32 %conv11, i32* %max_off, align 4
  store i32 %conv11, i32* %min_off, align 4
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load i32, i32* %regno.addr, align 4
  %28 = load i32, i32* %min_off, align 4
  %29 = load i32, i32* %access_size.addr, align 4
  %30 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool12 = trunc i8 %30 to i1
  %call13 = call i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef %29, i1 noundef zeroext %tobool12) #8
  store i32 %call13, i32* %err, align 4
  %31 = load i32, i32* %err, align 4
  %tobool14 = icmp ne i32 %31, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then9
  %32 = load i32, i32* %err, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.then9
  br label %if.end55

if.else:                                          ; preds = %if.end7
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 14
  %34 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool17 = trunc i8 %34 to i1
  br i1 %tobool17, label %if.end22, label %if.then18

if.then18:                                        ; preds = %if.else
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off19 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call20 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %38, i64 %40) #8
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %regno.addr, align 4
  %arraydecay21 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([76 x i8], [76 x i8]* @.str.249, i64 0, i64 0), i32 noundef %43, i8* noundef %arraydecay21) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.else
  %44 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool23 = icmp ne %struct.bpf_call_arg_meta* %44, null
  br i1 %tobool23, label %land.lhs.true24, label %if.end28

land.lhs.true24:                                  ; preds = %if.end22
  %45 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %45, i32 0, i32 1
  %46 = load i8, i8* %raw_mode, align 8
  %tobool25 = trunc i8 %46 to i1
  br i1 %tobool25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true24
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %land.lhs.true24, %if.end22
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 7
  %48 = load i64, i64* %smax_value, align 8
  %cmp29 = icmp sge i64 %48, 536870912
  br i1 %cmp29, label %if.then34, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end28
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 7
  %50 = load i64, i64* %smax_value31, align 8
  %cmp32 = icmp sle i64 %50, -536870912
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %lor.lhs.false, %if.end28
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.250, i64 0, i64 0), i32 noundef %53) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %lor.lhs.false
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 6
  %55 = load i64, i64* %smin_value, align 8
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 2
  %57 = load i32, i32* %off36, align 8
  %conv37 = sext i32 %57 to i64
  %add38 = add i64 %55, %conv37
  %conv39 = trunc i64 %add38 to i32
  store i32 %conv39, i32* %min_off, align 4
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 7
  %59 = load i64, i64* %smax_value40, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 2
  %61 = load i32, i32* %off41, align 8
  %conv42 = sext i32 %61 to i64
  %add43 = add i64 %59, %conv42
  %conv44 = trunc i64 %add43 to i32
  store i32 %conv44, i32* %max_off, align 4
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = load i32, i32* %regno.addr, align 4
  %64 = load i32, i32* %min_off, align 4
  %65 = load i32, i32* %access_size.addr, align 4
  %66 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool45 = trunc i8 %66 to i1
  %call46 = call i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %62, i32 noundef %63, i32 noundef %64, i32 noundef %65, i1 noundef zeroext %tobool45) #8
  store i32 %call46, i32* %err, align 4
  %67 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %67, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end35
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = bitcast %struct.bpf_verifier_env* %68 to i8*
  %70 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %69, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.251, i64 0, i64 0), i32 noundef %70) #8
  %71 = load i32, i32* %err, align 4
  store i32 %71, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.end35
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load i32, i32* %regno.addr, align 4
  %74 = load i32, i32* %max_off, align 4
  %75 = load i32, i32* %access_size.addr, align 4
  %76 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool50 = trunc i8 %76 to i1
  %call51 = call i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %72, i32 noundef %73, i32 noundef %74, i32 noundef %75, i1 noundef zeroext %tobool50) #8
  store i32 %call51, i32* %err, align 4
  %77 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %77, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end49
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = bitcast %struct.bpf_verifier_env* %78 to i8*
  %80 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %79, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.252, i64 0, i64 0), i32 noundef %80) #8
  %81 = load i32, i32* %err, align 4
  store i32 %81, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end49
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end16
  %82 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool56 = icmp ne %struct.bpf_call_arg_meta* %82, null
  br i1 %tobool56, label %land.lhs.true57, label %if.end64

land.lhs.true57:                                  ; preds = %if.end55
  %83 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode58 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %83, i32 0, i32 1
  %84 = load i8, i8* %raw_mode58, align 8
  %tobool59 = trunc i8 %84 to i1
  br i1 %tobool59, label %if.then61, label %if.end64

if.then61:                                        ; preds = %land.lhs.true57
  %85 = load i32, i32* %access_size.addr, align 4
  %86 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %access_size62 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %86, i32 0, i32 4
  store i32 %85, i32* %access_size62, align 8
  %87 = load i32, i32* %regno.addr, align 4
  %88 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %regno63 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %88, i32 0, i32 3
  store i32 %87, i32* %regno63, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %land.lhs.true57, %if.end55
  %89 = load i32, i32* %min_off, align 4
  store i32 %89, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc140, %if.end64
  %90 = load i32, i32* %i, align 4
  %91 = load i32, i32* %max_off, align 4
  %92 = load i32, i32* %access_size.addr, align 4
  %add65 = add i32 %91, %92
  %cmp66 = icmp slt i32 %90, %add65
  br i1 %cmp66, label %for.body, label %for.end142

for.body:                                         ; preds = %for.cond
  %93 = load i32, i32* %i, align 4
  %sub = sub i32 0, %93
  %sub68 = sub i32 %sub, 1
  store i32 %sub68, i32* %slot, align 4
  %94 = load i32, i32* %slot, align 4
  %div = sdiv i32 %94, 8
  store i32 %div, i32* %spi, align 4
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 6
  %96 = load i32, i32* %allocated_stack, align 8
  %97 = load i32, i32* %slot, align 4
  %cmp69 = icmp sle i32 %96, %97
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %for.body
  br label %err118

if.end72:                                         ; preds = %for.body
  %98 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %98, i32 0, i32 7
  %99 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %100 = load i32, i32* %spi, align 4
  %idxprom73 = sext i32 %100 to i64
  %arrayidx74 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %99, i64 %idxprom73
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx74, i32 0, i32 1
  %101 = load i32, i32* %slot, align 4
  %rem = srem i32 %101, 8
  %idxprom75 = sext i32 %rem to i64
  %arrayidx76 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom75
  store i8* %arrayidx76, i8** %stype, align 8
  %102 = load i8*, i8** %stype, align 8
  %103 = load i8, i8* %102, align 1
  %conv77 = zext i8 %103 to i32
  %cmp78 = icmp eq i32 %conv77, 2
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end72
  br label %mark

if.end81:                                         ; preds = %if.end72
  %104 = load i8*, i8** %stype, align 8
  %105 = load i8, i8* %104, align 1
  %conv82 = zext i8 %105 to i32
  %cmp83 = icmp eq i32 %conv82, 3
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.end81
  %106 = load i8*, i8** %stype, align 8
  store i8 2, i8* %106, align 1
  br label %mark

if.end86:                                         ; preds = %if.end81
  %107 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack87 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %107, i32 0, i32 7
  %108 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack87, align 8
  %109 = load i32, i32* %spi, align 4
  %idxprom88 = sext i32 %109 to i64
  %arrayidx89 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %108, i64 %idxprom88
  %slot_type90 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx89, i32 0, i32 1
  %arrayidx91 = getelementptr [8 x i8], [8 x i8]* %slot_type90, i64 0, i64 0
  %110 = load i8, i8* %arrayidx91, align 8
  %conv92 = zext i8 %110 to i32
  %cmp93 = icmp eq i32 %conv92, 1
  br i1 %cmp93, label %land.lhs.true95, label %if.end117

land.lhs.true95:                                  ; preds = %if.end86
  %111 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack96 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %111, i32 0, i32 7
  %112 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack96, align 8
  %113 = load i32, i32* %spi, align 4
  %idxprom97 = sext i32 %113 to i64
  %arrayidx98 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %112, i64 %idxprom97
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx98, i32 0, i32 0
  %type99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  %114 = load i32, i32* %type99, align 8
  %cmp100 = icmp eq i32 %114, 1
  br i1 %cmp100, label %if.then102, label %if.end117

if.then102:                                       ; preds = %land.lhs.true95
  %115 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack103 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %115, i32 0, i32 7
  %116 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack103, align 8
  %117 = load i32, i32* %spi, align 4
  %idxprom104 = sext i32 %117 to i64
  %arrayidx105 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %116, i64 %idxprom104
  %spilled_ptr106 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx105, i32 0, i32 0
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %spilled_ptr106) #8
  store i32 0, i32* %j, align 4
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc, %if.then102
  %118 = load i32, i32* %j, align 4
  %cmp108 = icmp slt i32 %118, 8
  br i1 %cmp108, label %for.body110, label %for.end

for.body110:                                      ; preds = %for.cond107
  %119 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack111 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %119, i32 0, i32 7
  %120 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack111, align 8
  %121 = load i32, i32* %spi, align 4
  %idxprom112 = sext i32 %121 to i64
  %arrayidx113 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %120, i64 %idxprom112
  %slot_type114 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx113, i32 0, i32 1
  %122 = load i32, i32* %j, align 4
  %idxprom115 = sext i32 %122 to i64
  %arrayidx116 = getelementptr [8 x i8], [8 x i8]* %slot_type114, i64 0, i64 %idxprom115
  store i8 2, i8* %arrayidx116, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body110
  %123 = load i32, i32* %j, align 4
  %inc = add i32 %123, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond107

for.end:                                          ; preds = %for.cond107
  br label %mark

if.end117:                                        ; preds = %land.lhs.true95, %if.end86
  br label %err118

err118:                                           ; preds = %if.end117, %if.then71
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off119 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 5
  %125 = bitcast %struct.tnum* %var_off119 to { i64, i64 }*
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 0
  %127 = load i64, i64* %126, align 8
  %128 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 1
  %129 = load i64, i64* %128, align 8
  %call120 = call zeroext i1 @tnum_is_const(i64 %127, i64 %129) #8
  br i1 %call120, label %if.then121, label %if.else123

if.then121:                                       ; preds = %err118
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = bitcast %struct.bpf_verifier_env* %130 to i8*
  %132 = load i32, i32* %min_off, align 4
  %133 = load i32, i32* %i, align 4
  %134 = load i32, i32* %min_off, align 4
  %sub122 = sub i32 %133, %134
  %135 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %131, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.253, i64 0, i64 0), i32 noundef %132, i32 noundef %sub122, i32 noundef %135) #8
  br label %if.end130

if.else123:                                       ; preds = %err118
  %arraydecay125 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf124, i64 0, i64 0
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %137 = bitcast %struct.tnum* %var_off126 to { i64, i64 }*
  %138 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %137, i32 0, i32 0
  %139 = load i64, i64* %138, align 8
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %137, i32 0, i32 1
  %141 = load i64, i64* %140, align 8
  %call127 = call i32 @tnum_strn(i8* noundef %arraydecay125, i64 noundef 48, i64 %139, i64 %141) #8
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = bitcast %struct.bpf_verifier_env* %142 to i8*
  %arraydecay128 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf124, i64 0, i64 0
  %144 = load i32, i32* %i, align 4
  %145 = load i32, i32* %min_off, align 4
  %sub129 = sub i32 %144, %145
  %146 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %143, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.254, i64 0, i64 0), i8* noundef %arraydecay128, i32 noundef %sub129, i32 noundef %146) #8
  br label %if.end130

if.end130:                                        ; preds = %if.else123, %if.then121
  store i32 -13, i32* %retval, align 4
  br label %return

mark:                                             ; preds = %for.end, %if.then85, %if.then80
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %148 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack131 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %148, i32 0, i32 7
  %149 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack131, align 8
  %150 = load i32, i32* %spi, align 4
  %idxprom132 = sext i32 %150 to i64
  %arrayidx133 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %149, i64 %idxprom132
  %spilled_ptr134 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx133, i32 0, i32 0
  %151 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack135 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %151, i32 0, i32 7
  %152 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack135, align 8
  %153 = load i32, i32* %spi, align 4
  %idxprom136 = sext i32 %153 to i64
  %arrayidx137 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %152, i64 %idxprom136
  %spilled_ptr138 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx137, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr138, i32 0, i32 10
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call139 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %147, %struct.bpf_reg_state* noundef %spilled_ptr134, %struct.bpf_reg_state* noundef %154, i8 noundef zeroext 2) #8
  br label %for.inc140

for.inc140:                                       ; preds = %mark
  %155 = load i32, i32* %i, align 4
  %inc141 = add i32 %155, 1
  store i32 %inc141, i32* %i, align 4
  br label %for.cond

for.end142:                                       ; preds = %for.cond
  %156 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %157 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %158 = load i32, i32* %min_off, align 4
  %call143 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %156, %struct.bpf_func_state* noundef %157, i32 noundef %158) #8
  store i32 %call143, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end142, %if.end130, %if.then61, %if.then53, %if.then48, %if.then34, %if.then18, %if.then15, %if.end, %if.then5
  %159 = load i32, i32* %retval, align 4
  ret i32 %159
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 11
  %4 = load i32, i32* %frameno, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load i32, i32* %off.addr, align 4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %3, -512
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %4 = load i32, i32* %off.addr, align 4
  %5 = load i32, i32* %access_size.addr, align 4
  %add = add i32 %4, %5
  %cmp3 = icmp sgt i32 %add, 0
  br i1 %cmp3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %6 = load i32, i32* %access_size.addr, align 4
  %cmp5 = icmp slt i32 %6, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %7 = load i32, i32* %access_size.addr, align 4
  %cmp7 = icmp eq i32 %7, 0
  br i1 %cmp7, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %lor.lhs.false6
  %8 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.end13, label %if.then

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 5
  %10 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call8 = call zeroext i1 @tnum_is_const(i64 %12, i64 %14) #8
  br i1 %call8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load i32, i32* %regno.addr, align 4
  %18 = load i32, i32* %off.addr, align 4
  %19 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.255, i64 0, i64 0), i32 noundef %17, i32 noundef %18, i32 noundef %19) #8
  br label %if.end

if.else:                                          ; preds = %if.then
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 5
  %21 = bitcast %struct.tnum* %var_off10 to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = load i64, i64* %24, align 8
  %call11 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %23, i64 %25) #8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load i32, i32* %regno.addr, align 4
  %arraydecay12 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %29 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.256, i64 0, i64 0), i32 noundef %28, i8* noundef %arraydecay12, i32 noundef %29) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then9
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %land.lhs.true, %lor.lhs.false6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.end
  %30 = load i32, i32* %retval, align 4
  ret i32 %30
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %state, %struct.bpf_reg_state* noundef %parent, i8 noundef zeroext %flag) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_reg_state*, align 8
  %parent.addr = alloca %struct.bpf_reg_state*, align 8
  %flag.addr = alloca i8, align 1
  %writes = alloca i8, align 1
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %state, %struct.bpf_reg_state** %state.addr, align 8
  store %struct.bpf_reg_state* %parent, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 %flag, i8* %flag.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 10
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent1, align 8
  %cmp = icmp eq %struct.bpf_reg_state* %0, %2
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %writes, align 1
  store i32 0, i32* %cnt, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8, i8* %writes, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 13
  %6 = load i32, i32* %live, align 8
  %and = and i32 %6, 4
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  %8 = load i32, i32* %live4, align 8
  %and5 = and i32 %8, 8
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 0
  %12 = load i32, i32* %type, align 8
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %13 = load i8*, i8** %arrayidx, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %15 = load i64, i64* %value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 2
  %17 = load i32, i32* %off, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.73, i64 0, i64 0), i8* noundef %13, i64 noundef %15, i32 noundef %17) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 13
  %19 = load i32, i32* %live9, align 8
  %and10 = and i32 %19, 3
  %20 = load i8, i8* %flag.addr, align 1
  %conv = zext i8 %20 to i32
  %cmp11 = icmp eq i32 %and10, %conv
  br i1 %cmp11, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 13
  %22 = load i32, i32* %live13, align 8
  %and14 = and i32 %22, 2
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end8
  br label %while.end

if.end17:                                         ; preds = %lor.lhs.false
  %23 = load i8, i8* %flag.addr, align 1
  %conv18 = zext i8 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  %25 = load i32, i32* %live19, align 8
  %or = or i32 %25, %conv18
  store i32 %or, i32* %live19, align 8
  %26 = load i8, i8* %flag.addr, align 1
  %conv20 = zext i8 %26 to i32
  %cmp21 = icmp eq i32 %conv20, 2
  br i1 %cmp21, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.end17
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 13
  %28 = load i32, i32* %live24, align 8
  %and25 = and i32 %28, -2
  store i32 %and25, i32* %live24, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.end17
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  store %struct.bpf_reg_state* %29, %struct.bpf_reg_state** %state.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 10
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent27, align 8
  store %struct.bpf_reg_state* %31, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 1, i8* %writes, align 1
  %32 = load i32, i32* %cnt, align 4
  %inc = add i32 %32, 1
  store i32 %inc, i32* %cnt, align 4
  br label %while.cond

while.end:                                        ; preds = %if.then16, %if.then, %while.cond
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 30
  %34 = load i32, i32* %longest_mark_read_walk, align 4
  %35 = load i32, i32* %cnt, align 4
  %cmp28 = icmp ult i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %while.end
  %36 = load i32, i32* %cnt, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk31 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 30
  store i32 %36, i32* %longest_mark_read_walk31, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %while.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then7
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %func, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %stack = alloca i16, align 2
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %func, %struct.bpf_func_state** %func.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 19
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 3
  %2 = load i32, i32* %subprogno, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %3 = load i16, i16* %stack_depth, align 4
  store i16 %3, i16* %stack, align 2
  %4 = load i16, i16* %stack, align 2
  %conv = zext i16 %4 to i32
  %5 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %5
  %cmp = icmp sge i32 %conv, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %off.addr, align 4
  %sub2 = sub i32 0, %6
  %conv3 = trunc i32 %sub2 to i16
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 19
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 3
  %9 = load i32, i32* %subprogno5, align 8
  %idxprom6 = zext i32 %9 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info4, i64 0, i64 %idxprom6
  %stack_depth8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 2
  store i16 %conv3, i16* %stack_depth8, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_map_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %3 to %struct.bpf_map**
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, i32* %size.addr, align 4
  %cmp1 = icmp slt i32 %6, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %7 = load i32, i32* %size.addr, align 4
  %cmp3 = icmp eq i32 %7, 0
  br i1 %cmp3, label %land.lhs.true, label %lor.lhs.false4

land.lhs.true:                                    ; preds = %lor.lhs.false2
  %8 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %lor.lhs.false4, label %if.then

lor.lhs.false4:                                   ; preds = %land.lhs.true, %lor.lhs.false2
  %9 = load i32, i32* %off.addr, align 4
  %10 = load i32, i32* %size.addr, align 4
  %add = add i32 %9, %10
  %11 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %11, i32 0, i32 5
  %12 = load i32, i32* %value_size, align 32
  %cmp5 = icmp ugt i32 %add, %12
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false4, %land.lhs.true, %lor.lhs.false, %entry
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size6 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %15, i32 0, i32 5
  %16 = load i32, i32* %value_size6, align 32
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.149, i64 0, i64 0), i32 noundef %16, i32 noundef %17, i32 noundef %18) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %access_flags = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 7
  %1 = load i32, i32* %map_flags, align 8
  %and = and i32 %1, 384
  store i32 %and, i32* %access_flags, align 4
  %2 = load i32, i32* %access_flags, align 4
  %and1 = and i32 %2, 128
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %access_flags, align 4
  %and2 = and i32 %3, 256
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store i32 2, i32* %retval, align 4
  br label %return

if.else5:                                         ; preds = %if.else
  store i32 3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else5, %if.then4, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_packet_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i32, i32* %size.addr, align 4
  %cmp1 = icmp slt i32 %4, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %5 = load i32, i32* %size.addr, align 4
  %cmp3 = icmp eq i32 %5, 0
  br i1 %cmp3, label %land.lhs.true, label %lor.lhs.false4

land.lhs.true:                                    ; preds = %lor.lhs.false2
  %6 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %lor.lhs.false4, label %if.then

lor.lhs.false4:                                   ; preds = %land.lhs.true, %lor.lhs.false2
  %7 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %7 to i64
  %8 = load i32, i32* %size.addr, align 4
  %conv5 = sext i32 %8 to i64
  %add = add i64 %conv, %conv5
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 1
  %range = bitcast %union.anon.147* %10 to i16*
  %11 = load i16, i16* %range, align 8
  %conv6 = zext i16 %11 to i64
  %cmp7 = icmp ugt i64 %add, %conv6
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false4, %land.lhs.true, %lor.lhs.false, %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i32, i32* %regno.addr, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 3
  %18 = load i32, i32* %id, align 4
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 2
  %20 = load i32, i32* %off9, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 1
  %range10 = bitcast %union.anon.147* %22 to i16*
  %23 = load i16, i16* %range10, align 8
  %conv11 = zext i16 %23 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.186, i64 0, i64 0), i32 noundef %14, i32 noundef %15, i32 noundef %16, i32 noundef %18, i32 noundef %20, i32 noundef %conv11) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg1_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %1 = load i32, i32* %arg1_type, align 8
  %cmp = icmp eq i32 %1, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %count, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg2_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %3, i32 0, i32 5
  %4 = load i32, i32* %arg2_type, align 4
  %cmp1 = icmp eq i32 %4, 8
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load i32, i32* %count, align 4
  %inc3 = add i32 %5, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %6 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg3_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %6, i32 0, i32 6
  %7 = load i32, i32* %arg3_type, align 8
  %cmp5 = icmp eq i32 %7, 8
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %8 = load i32, i32* %count, align 4
  %inc7 = add i32 %8, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %9 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg4_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %9, i32 0, i32 7
  %10 = load i32, i32* %arg4_type, align 4
  %cmp9 = icmp eq i32 %10, 8
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %11 = load i32, i32* %count, align 4
  %inc11 = add i32 %11, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %12 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg5_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %12, i32 0, i32 8
  %13 = load i32, i32* %arg5_type, align 8
  %cmp13 = icmp eq i32 %13, 8
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %14 = load i32, i32* %count, align 4
  %inc15 = add i32 %14, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %15 = load i32, i32* %count, align 4
  %cmp17 = icmp sle i32 %15, 1
  ret i1 %cmp17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg1_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %1 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_is_mem_size(i32 noundef %1) #8
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg5_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %2, i32 0, i32 8
  %3 = load i32, i32* %arg5_type, align 8
  %call1 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %3) #8
  br i1 %call1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg1_type3 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 4
  %5 = load i32, i32* %arg1_type3, align 8
  %6 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg2_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %6, i32 0, i32 5
  %7 = load i32, i32* %arg2_type, align 4
  %call4 = call zeroext i1 @check_args_pair_invalid(i32 noundef %5, i32 noundef %7) #8
  br i1 %call4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false2
  %8 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg2_type6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %8, i32 0, i32 5
  %9 = load i32, i32* %arg2_type6, align 4
  %10 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg3_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %10, i32 0, i32 6
  %11 = load i32, i32* %arg3_type, align 8
  %call7 = call zeroext i1 @check_args_pair_invalid(i32 noundef %9, i32 noundef %11) #8
  br i1 %call7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false5
  %12 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg3_type9 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %12, i32 0, i32 6
  %13 = load i32, i32* %arg3_type9, align 8
  %14 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg4_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %14, i32 0, i32 7
  %15 = load i32, i32* %arg4_type, align 4
  %call10 = call zeroext i1 @check_args_pair_invalid(i32 noundef %13, i32 noundef %15) #8
  br i1 %call10, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %16 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg4_type12 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %16, i32 0, i32 7
  %17 = load i32, i32* %arg4_type12, align 4
  %18 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg5_type13 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %18, i32 0, i32 8
  %19 = load i32, i32* %arg5_type13, align 8
  %call14 = call zeroext i1 @check_args_pair_invalid(i32 noundef %17, i32 noundef %19) #8
  br i1 %call14, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false11, %lor.lhs.false8, %lor.lhs.false5, %lor.lhs.false2, %lor.lhs.false, %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false11
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %20 = load i1, i1* %retval, align 1
  ret i1 %20
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_refcount_ok(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg1_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %1 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %1) #8
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %count, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg2_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %3, i32 0, i32 5
  %4 = load i32, i32* %arg2_type, align 4
  %call1 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %4) #8
  br i1 %call1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load i32, i32* %count, align 4
  %inc3 = add i32 %5, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %6 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg3_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %6, i32 0, i32 6
  %7 = load i32, i32* %arg3_type, align 8
  %call5 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %7) #8
  br i1 %call5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %8 = load i32, i32* %count, align 4
  %inc7 = add i32 %8, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %9 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg4_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %9, i32 0, i32 7
  %10 = load i32, i32* %arg4_type, align 4
  %call9 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %10) #8
  br i1 %call9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %11 = load i32, i32* %count, align 4
  %inc11 = add i32 %11, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %12 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %arg5_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %12, i32 0, i32 8
  %13 = load i32, i32* %arg5_type, align 8
  %call13 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %13) #8
  br i1 %call13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %14 = load i32, i32* %count, align 4
  %inc15 = add i32 %14, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %15 = load i32, i32* %func_id.addr, align 4
  %call17 = call zeroext i1 @is_acquire_function(i32 noundef %15) #8
  br i1 %call17, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end16
  %16 = load i32, i32* %count, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %if.end16
  %17 = load i32, i32* %count, align 4
  %cmp = icmp sle i32 %17, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end19, %if.then18
  %18 = load i1, i1* %retval, align 1
  ret i1 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_may_be_refcounted(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 14
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_args_pair_invalid(i32 noundef %arg_curr, i32 noundef %arg_next) #0 {
entry:
  %arg_curr.addr = alloca i32, align 4
  %arg_next.addr = alloca i32, align 4
  store i32 %arg_curr, i32* %arg_curr.addr, align 4
  store i32 %arg_next, i32* %arg_next.addr, align 4
  %0 = load i32, i32* %arg_curr.addr, align 4
  %call = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %0) #8
  br i1 %call, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %arg_next.addr, align 4
  %call1 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %1) #8
  br i1 %call1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, i32* %arg_curr.addr, align 4
  %call2 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %2) #8
  br i1 %call2, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %3 = load i32, i32* %arg_next.addr, align 4
  %call3 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %3) #8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %4 = phi i1 [ false, %lor.rhs ], [ %call3, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %4, %land.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %3) #8
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 10
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_sk_pointer(i32 noundef %3) #8
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch_ok(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 false, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %off, i32 noundef %size, i32 noundef %t, i32* noundef %reg_type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %reg_type.addr = alloca i32*, align 8
  %info = alloca %struct.util_est, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32* %reg_type, i32** %reg_type.addr, align 8
  %reg_type1 = getelementptr inbounds %struct.util_est, %struct.util_est* %info, i32 0, i32 0
  %0 = load i32*, i32** %reg_type.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %reg_type1, align 4
  %ctx_field_size = getelementptr inbounds %struct.util_est, %struct.util_est* %info, i32 0, i32 1
  store i32 0, i32* %ctx_field_size, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 3
  %3 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %is_valid_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %3, i32 0, i32 1
  %4 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.util_est*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.util_est*)** %is_valid_access, align 8
  %tobool = icmp ne i1 (i32, i32, i32, %struct.bpf_prog*, %struct.util_est*)* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 3
  %6 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops2, align 8
  %is_valid_access3 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %6, i32 0, i32 1
  %7 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.util_est*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.util_est*)** %is_valid_access3, align 8
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %10 = load i32, i32* %t.addr, align 4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 2
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 %7(i32 noundef %8, i32 noundef %9, i32 noundef %10, %struct.bpf_prog* noundef %12, %struct.util_est* noundef %info) #8
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true
  %reg_type4 = getelementptr inbounds %struct.util_est, %struct.util_est* %info, i32 0, i32 0
  %13 = load i32, i32* %reg_type4, align 4
  %14 = load i32*, i32** %reg_type.addr, align 8
  store i32 %13, i32* %14, align 4
  %ctx_field_size5 = getelementptr inbounds %struct.util_est, %struct.util_est* %info, i32 0, i32 1
  %15 = load i32, i32* %ctx_field_size5, align 4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 16
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %18 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %18 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %17, i64 %idxprom
  %ctx_field_size6 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 1
  store i32 %15, i32* %ctx_field_size6, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 2
  %20 = load %struct.bpf_prog*, %struct.bpf_prog** %prog7, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %20, i32 0, i32 7
  %21 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_ctx_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %21, i32 0, i32 2
  %22 = load i32, i32* %max_ctx_offset, align 8
  %23 = load i32, i32* %off.addr, align 4
  %24 = load i32, i32* %size.addr, align 4
  %add = add i32 %23, %24
  %cmp = icmp ult i32 %22, %add
  br i1 %cmp, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %25 = load i32, i32* %off.addr, align 4
  %26 = load i32, i32* %size.addr, align 4
  %add9 = add i32 %25, %26
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog10, align 8
  %aux11 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 7
  %29 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux11, align 8
  %max_ctx_offset12 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %29, i32 0, i32 2
  store i32 %add9, i32* %max_ctx_offset12, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %land.lhs.true, %entry
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i32, i32* %off.addr, align 4
  %33 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.176, i64 0, i64 0), i32 noundef %32, i32 noundef %33) #8
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.end
  %34 = load i32, i32* %retval, align 4
  ret i32 %34
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #8
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %9, i64 %11) #8
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %arraydecay3 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.150, i64 0, i64 0), i8* noundef %arraydecay3, i32 noundef %14, i32 noundef %15) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load i32, i32* %off.addr, align 4
  %cmp = icmp sge i32 %16, 0
  br i1 %cmp, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %cmp4 = icmp slt i32 %17, -512
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.151, i64 0, i64 0), i32 noundef %20, i32 noundef %21) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %err = alloca i32, align 4
  %dst_reg = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %sanitize = alloca i8, align 1
  %poff = alloca i32*, align 8
  %soff = alloca i32, align 4
  %type111 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %0
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %1 = load i32, i32* %slot, align 4
  %div = sdiv i32 %1, 8
  store i32 %div, i32* %spi, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %4 to [0 x %struct.bpf_insn]*
  %5 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom
  %dst_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg2, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst_reg, align 4
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %reg, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %7 = load i32, i32* %slot, align 4
  %add = add i32 %7, 1
  %sub3 = sub i32 %add, 1
  %or = or i32 %sub3, 7
  %add4 = add i32 %or, 1
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 4
  %9 = load i32, i32* %acquired_refs, align 4
  %call = call i32 @realloc_func_state(%struct.bpf_func_state* noundef %6, i32 noundef %add4, i32 noundef %9, i1 noundef zeroext true) #8
  store i32 %call, i32* %err, align 4
  %10 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load i32, i32* %err, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 14
  %13 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool5 = trunc i8 %13 to i1
  br i1 %tobool5, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %16 = load i32, i32* %spi, align 4
  %idxprom6 = sext i32 %16 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %15, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %arrayidx8 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %17 = load i8, i8* %arrayidx8, align 8
  %conv9 = zext i8 %17 to i32
  %cmp = icmp eq i32 %conv9, 1
  br i1 %cmp, label %land.lhs.true11, label %if.end15

land.lhs.true11:                                  ; preds = %land.lhs.true
  %18 = load i32, i32* %size.addr, align 4
  %cmp12 = icmp ne i32 %18, 8
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true11
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.177, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true11, %land.lhs.true, %if.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 8
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %22, i32 0, i32 0
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %23, i32 0, i32 8
  %24 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state16, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %24, i32 0, i32 4
  %25 = load i32, i32* %curframe, align 8
  %idxprom17 = zext i32 %25 to i64
  %arrayidx18 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom17
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx18, align 8
  store %struct.bpf_func_state* %26, %struct.bpf_func_state** %cur, align 8
  %27 = load i32, i32* %value_regno.addr, align 4
  %cmp19 = icmp sge i32 %27, 0
  br i1 %cmp19, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end15
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 0
  %29 = load i32, i32* %value_regno.addr, align 4
  %idxprom22 = sext i32 %29 to i64
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom22
  store %struct.bpf_reg_state* %arrayidx23, %struct.bpf_reg_state** %reg, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end15
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool25 = icmp ne %struct.bpf_reg_state* %30, null
  br i1 %tobool25, label %land.lhs.true26, label %if.else

land.lhs.true26:                                  ; preds = %if.end24
  %31 = load i32, i32* %size.addr, align 4
  %cmp27 = icmp eq i32 %31, 8
  br i1 %cmp27, label %land.lhs.true29, label %if.else

land.lhs.true29:                                  ; preds = %land.lhs.true26
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call30 = call zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %32) #8
  br i1 %call30, label %land.lhs.true32, label %if.else

land.lhs.true32:                                  ; preds = %land.lhs.true29
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call33 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %33) #8
  br i1 %call33, label %if.else, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %land.lhs.true32
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks35 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 14
  %35 = load i8, i8* %allow_ptr_leaks35, align 8
  %tobool36 = trunc i8 %35 to i1
  br i1 %tobool36, label %if.then38, label %if.else

if.then38:                                        ; preds = %land.lhs.true34
  %36 = load i32, i32* %dst_reg, align 4
  %cmp39 = icmp ne i32 %36, 10
  br i1 %cmp39, label %if.then41, label %if.end46

if.then41:                                        ; preds = %if.then38
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load i32, i32* %value_regno.addr, align 4
  %call42 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %37, i32 noundef %38) #8
  store i32 %call42, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %39, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then41
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.then41
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.then38
  %41 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %42 = load i32, i32* %spi, align 4
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @save_register_state(%struct.bpf_func_state* noundef %41, i32 noundef %42, %struct.bpf_reg_state* noundef %43) #8
  br label %if.end174

if.else:                                          ; preds = %land.lhs.true34, %land.lhs.true32, %land.lhs.true29, %land.lhs.true26, %if.end24
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool47 = icmp ne %struct.bpf_reg_state* %44, null
  br i1 %tobool47, label %land.lhs.true48, label %if.else110

land.lhs.true48:                                  ; preds = %if.else
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 0
  %46 = load i32, i32* %type, align 8
  %call49 = call zeroext i1 @is_spillable_regtype(i32 noundef %46) #8
  br i1 %call49, label %if.then51, label %if.else110

if.then51:                                        ; preds = %land.lhs.true48
  %47 = load i32, i32* %size.addr, align 4
  %cmp52 = icmp ne i32 %47, 8
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.then51
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %48, i32 noundef %49, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.54, i64 0, i64 0)) #8
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.178, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %if.then51
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %53 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %cmp56 = icmp ne %struct.bpf_func_state* %52, %53
  br i1 %cmp56, label %land.lhs.true58, label %if.end63

land.lhs.true58:                                  ; preds = %if.end55
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 0
  %55 = load i32, i32* %type59, align 8
  %cmp60 = icmp eq i32 %55, 6
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %land.lhs.true58
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.179, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %land.lhs.true58, %if.end55
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks64 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 14
  %59 = load i8, i8* %allow_ptr_leaks64, align 8
  %tobool65 = trunc i8 %59 to i1
  br i1 %tobool65, label %if.end109, label %if.then66

if.then66:                                        ; preds = %if.end63
  store i8 0, i8* %sanitize, align 1
  %60 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack67 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %60, i32 0, i32 7
  %61 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack67, align 8
  %62 = load i32, i32* %spi, align 4
  %idxprom68 = sext i32 %62 to i64
  %arrayidx69 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %61, i64 %idxprom68
  %slot_type70 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx69, i32 0, i32 1
  %arrayidx71 = getelementptr [8 x i8], [8 x i8]* %slot_type70, i64 0, i64 0
  %63 = load i8, i8* %arrayidx71, align 8
  %conv72 = zext i8 %63 to i32
  %cmp73 = icmp eq i32 %conv72, 1
  br i1 %cmp73, label %land.lhs.true75, label %if.end82

land.lhs.true75:                                  ; preds = %if.then66
  %64 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack76 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %64, i32 0, i32 7
  %65 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack76, align 8
  %66 = load i32, i32* %spi, align 4
  %idxprom77 = sext i32 %66 to i64
  %arrayidx78 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %65, i64 %idxprom77
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx78, i32 0, i32 0
  %call79 = call zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %spilled_ptr) #8
  br i1 %call79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true75
  store i8 1, i8* %sanitize, align 1
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %land.lhs.true75, %if.then66
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end82
  %67 = load i32, i32* %i, align 4
  %cmp83 = icmp slt i32 %67, 8
  br i1 %cmp83, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %68 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack85 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %68, i32 0, i32 7
  %69 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack85, align 8
  %70 = load i32, i32* %spi, align 4
  %idxprom86 = sext i32 %70 to i64
  %arrayidx87 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %69, i64 %idxprom86
  %slot_type88 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx87, i32 0, i32 1
  %71 = load i32, i32* %i, align 4
  %idxprom89 = sext i32 %71 to i64
  %arrayidx90 = getelementptr [8 x i8], [8 x i8]* %slot_type88, i64 0, i64 %idxprom89
  %72 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %72 to i32
  %cmp92 = icmp eq i32 %conv91, 2
  br i1 %cmp92, label %if.then94, label %if.end95

if.then94:                                        ; preds = %for.body
  store i8 1, i8* %sanitize, align 1
  br label %for.end

if.end95:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end95
  %73 = load i32, i32* %i, align 4
  %inc = add i32 %73, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then94, %for.cond
  %74 = load i8, i8* %sanitize, align 1
  %tobool96 = trunc i8 %74 to i1
  br i1 %tobool96, label %if.then97, label %if.end108

if.then97:                                        ; preds = %for.end
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 16
  %76 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %77 = load i32, i32* %insn_idx.addr, align 4
  %idxprom98 = sext i32 %77 to i64
  %arrayidx99 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %76, i64 %idxprom98
  %sanitize_stack_off = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx99, i32 0, i32 2
  store i32* %sanitize_stack_off, i32** %poff, align 8
  %78 = load i32, i32* %spi, align 4
  %sub100 = sub i32 0, %78
  %sub101 = sub i32 %sub100, 1
  %mul = mul i32 %sub101, 8
  store i32 %mul, i32* %soff, align 4
  %79 = load i32*, i32** %poff, align 8
  %80 = load i32, i32* %79, align 4
  %tobool102 = icmp ne i32 %80, 0
  br i1 %tobool102, label %land.lhs.true103, label %if.end107

land.lhs.true103:                                 ; preds = %if.then97
  %81 = load i32*, i32** %poff, align 8
  %82 = load i32, i32* %81, align 4
  %83 = load i32, i32* %soff, align 4
  %cmp104 = icmp ne i32 %82, %83
  br i1 %cmp104, label %if.then106, label %if.end107

if.then106:                                       ; preds = %land.lhs.true103
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %85 = bitcast %struct.bpf_verifier_env* %84 to i8*
  %86 = load i32, i32* %insn_idx.addr, align 4
  %87 = load i32*, i32** %poff, align 8
  %88 = load i32, i32* %87, align 4
  %89 = load i32, i32* %soff, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %85, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.180, i64 0, i64 0), i32 noundef %86, i32 noundef %88, i32 noundef %89) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end107:                                        ; preds = %land.lhs.true103, %if.then97
  %90 = load i32, i32* %soff, align 4
  %91 = load i32*, i32** %poff, align 8
  store i32 %90, i32* %91, align 4
  br label %if.end108

if.end108:                                        ; preds = %if.end107, %for.end
  br label %if.end109

if.end109:                                        ; preds = %if.end108, %if.end63
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %93 = load i32, i32* %spi, align 4
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @save_register_state(%struct.bpf_func_state* noundef %92, i32 noundef %93, %struct.bpf_reg_state* noundef %94) #8
  br label %if.end173

if.else110:                                       ; preds = %land.lhs.true48, %if.else
  store i8 2, i8* %type111, align 1
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack112 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 7
  %96 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack112, align 8
  %97 = load i32, i32* %spi, align 4
  %idxprom113 = sext i32 %97 to i64
  %arrayidx114 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %96, i64 %idxprom113
  %spilled_ptr115 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx114, i32 0, i32 0
  %type116 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr115, i32 0, i32 0
  store i32 0, i32* %type116, align 8
  %98 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack117 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %98, i32 0, i32 7
  %99 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack117, align 8
  %100 = load i32, i32* %spi, align 4
  %idxprom118 = sext i32 %100 to i64
  %arrayidx119 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %99, i64 %idxprom118
  %slot_type120 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx119, i32 0, i32 1
  %arrayidx121 = getelementptr [8 x i8], [8 x i8]* %slot_type120, i64 0, i64 0
  %101 = load i8, i8* %arrayidx121, align 8
  %conv122 = zext i8 %101 to i32
  %cmp123 = icmp eq i32 %conv122, 1
  br i1 %cmp123, label %if.then125, label %if.end139

if.then125:                                       ; preds = %if.else110
  store i32 0, i32* %i, align 4
  br label %for.cond126

for.cond126:                                      ; preds = %for.inc136, %if.then125
  %102 = load i32, i32* %i, align 4
  %cmp127 = icmp slt i32 %102, 8
  br i1 %cmp127, label %for.body129, label %for.end138

for.body129:                                      ; preds = %for.cond126
  %103 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack130 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %103, i32 0, i32 7
  %104 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack130, align 8
  %105 = load i32, i32* %spi, align 4
  %idxprom131 = sext i32 %105 to i64
  %arrayidx132 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %104, i64 %idxprom131
  %slot_type133 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx132, i32 0, i32 1
  %106 = load i32, i32* %i, align 4
  %idxprom134 = sext i32 %106 to i64
  %arrayidx135 = getelementptr [8 x i8], [8 x i8]* %slot_type133, i64 0, i64 %idxprom134
  store i8 2, i8* %arrayidx135, align 1
  br label %for.inc136

for.inc136:                                       ; preds = %for.body129
  %107 = load i32, i32* %i, align 4
  %inc137 = add i32 %107, 1
  store i32 %inc137, i32* %i, align 4
  br label %for.cond126

for.end138:                                       ; preds = %for.cond126
  br label %if.end139

if.end139:                                        ; preds = %for.end138, %if.else110
  %108 = load i32, i32* %size.addr, align 4
  %cmp140 = icmp eq i32 %108, 8
  br i1 %cmp140, label %if.then142, label %if.end148

if.then142:                                       ; preds = %if.end139
  %109 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack143 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %109, i32 0, i32 7
  %110 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack143, align 8
  %111 = load i32, i32* %spi, align 4
  %idxprom144 = sext i32 %111 to i64
  %arrayidx145 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %110, i64 %idxprom144
  %spilled_ptr146 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx145, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr146, i32 0, i32 13
  %112 = load i32, i32* %live, align 8
  %or147 = or i32 %112, 4
  store i32 %or147, i32* %live, align 8
  br label %if.end148

if.end148:                                        ; preds = %if.then142, %if.end139
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool149 = icmp ne %struct.bpf_reg_state* %113, null
  br i1 %tobool149, label %land.lhs.true150, label %if.end158

land.lhs.true150:                                 ; preds = %if.end148
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call151 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %114) #8
  br i1 %call151, label %if.then153, label %if.end158

if.then153:                                       ; preds = %land.lhs.true150
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %116 = load i32, i32* %value_regno.addr, align 4
  %call154 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %115, i32 noundef %116) #8
  store i32 %call154, i32* %err, align 4
  %117 = load i32, i32* %err, align 4
  %tobool155 = icmp ne i32 %117, 0
  br i1 %tobool155, label %if.then156, label %if.end157

if.then156:                                       ; preds = %if.then153
  %118 = load i32, i32* %err, align 4
  store i32 %118, i32* %retval, align 4
  br label %return

if.end157:                                        ; preds = %if.then153
  store i8 3, i8* %type111, align 1
  br label %if.end158

if.end158:                                        ; preds = %if.end157, %land.lhs.true150, %if.end148
  store i32 0, i32* %i, align 4
  br label %for.cond159

for.cond159:                                      ; preds = %for.inc170, %if.end158
  %119 = load i32, i32* %i, align 4
  %120 = load i32, i32* %size.addr, align 4
  %cmp160 = icmp slt i32 %119, %120
  br i1 %cmp160, label %for.body162, label %for.end172

for.body162:                                      ; preds = %for.cond159
  %121 = load i8, i8* %type111, align 1
  %122 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack163 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %122, i32 0, i32 7
  %123 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack163, align 8
  %124 = load i32, i32* %spi, align 4
  %idxprom164 = sext i32 %124 to i64
  %arrayidx165 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %123, i64 %idxprom164
  %slot_type166 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx165, i32 0, i32 1
  %125 = load i32, i32* %slot, align 4
  %126 = load i32, i32* %i, align 4
  %sub167 = sub i32 %125, %126
  %rem = srem i32 %sub167, 8
  %idxprom168 = sext i32 %rem to i64
  %arrayidx169 = getelementptr [8 x i8], [8 x i8]* %slot_type166, i64 0, i64 %idxprom168
  store i8 %121, i8* %arrayidx169, align 1
  br label %for.inc170

for.inc170:                                       ; preds = %for.body162
  %127 = load i32, i32* %i, align 4
  %inc171 = add i32 %127, 1
  store i32 %inc171, i32* %i, align 4
  br label %for.cond159

for.end172:                                       ; preds = %for.cond159
  br label %if.end173

if.end173:                                        ; preds = %for.end172, %if.end109
  br label %if.end174

if.end174:                                        ; preds = %if.end173, %if.end46
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end174, %if.then156, %if.then106, %if.then62, %if.then54, %if.then44, %if.then14, %if.then
  %128 = load i32, i32* %retval, align 4
  ret i32 %128
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %reg_state, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg_state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %stype = alloca i8*, align 8
  %zeros = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %reg_state, %struct.bpf_func_state** %reg_state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %6
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %7 = load i32, i32* %slot, align 4
  %div = sdiv i32 %7, 8
  store i32 %div, i32* %spi, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 6
  %9 = load i32, i32* %allocated_stack, align 8
  %10 = load i32, i32* %slot, align 4
  %cmp = icmp sle i32 %9, %10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.181, i64 0, i64 0), i32 noundef %13, i32 noundef %14) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 7
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %17 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %17 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  store i8* %arraydecay, i8** %stype, align 8
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 7
  %19 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack4, align 8
  %20 = load i32, i32* %spi, align 4
  %idxprom5 = sext i32 %20 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %19, i64 %idxprom5
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %21 = load i8*, i8** %stype, align 8
  %arrayidx7 = getelementptr i8, i8* %21, i64 0
  %22 = load i8, i8* %arrayidx7, align 1
  %conv = zext i8 %22 to i32
  %cmp8 = icmp eq i32 %conv, 1
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end
  %23 = load i32, i32* %size.addr, align 4
  %cmp11 = icmp ne i32 %23, 8
  br i1 %cmp11, label %if.then13, label %if.end26

if.then13:                                        ; preds = %if.then10
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type, align 8
  %cmp14 = icmp ne i32 %25, 1
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then13
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 0
  %28 = load i32, i32* %insn_idx, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %26, i32 noundef %28, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.54, i64 0, i64 0)) #8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.182, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.then13
  %31 = load i32, i32* %value_regno.addr, align 4
  %cmp18 = icmp sge i32 %31, 0
  br i1 %cmp18, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.end17
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 0
  %arraydecay21 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %34 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %32, %struct.bpf_reg_state* noundef %arraydecay21, i32 noundef %34) #8
  %35 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %35, i32 0, i32 0
  %36 = load i32, i32* %value_regno.addr, align 4
  %idxprom23 = sext i32 %36 to i64
  %arrayidx24 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs22, i64 0, i64 %idxprom23
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx24, i32 0, i32 13
  %37 = load i32, i32* %live, align 8
  %or = or i32 %37, 4
  store i32 %or, i32* %live, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then20, %if.end17
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 10
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %38, %struct.bpf_reg_state* noundef %39, %struct.bpf_reg_state* noundef %41, i8 noundef zeroext 2) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.then10
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %42 = load i32, i32* %i, align 4
  %cmp27 = icmp slt i32 %42, 8
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load i8*, i8** %stype, align 8
  %44 = load i32, i32* %slot, align 4
  %45 = load i32, i32* %i, align 4
  %sub29 = sub i32 %44, %45
  %rem = srem i32 %sub29, 8
  %idxprom30 = sext i32 %rem to i64
  %arrayidx31 = getelementptr i8, i8* %43, i64 %idxprom30
  %46 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %46 to i32
  %cmp33 = icmp ne i32 %conv32, 1
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %for.body
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.183, i64 0, i64 0)) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end36
  %49 = load i32, i32* %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %50 = load i32, i32* %value_regno.addr, align 4
  %cmp37 = icmp sge i32 %50, 0
  br i1 %cmp37, label %if.then39, label %if.end48

if.then39:                                        ; preds = %for.end
  %51 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs40 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %51, i32 0, i32 0
  %52 = load i32, i32* %value_regno.addr, align 4
  %idxprom41 = sext i32 %52 to i64
  %arrayidx42 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs40, i64 0, i64 %idxprom41
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %54 = bitcast %struct.bpf_reg_state* %arrayidx42 to i8*
  %55 = bitcast %struct.bpf_reg_state* %53 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %54, i8* align 8 %55, i64 104, i1 false)
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs43 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %56, i32 0, i32 0
  %57 = load i32, i32* %value_regno.addr, align 4
  %idxprom44 = sext i32 %57 to i64
  %arrayidx45 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs43, i64 0, i64 %idxprom44
  %live46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx45, i32 0, i32 13
  %58 = load i32, i32* %live46, align 8
  %or47 = or i32 %58, 4
  store i32 %or47, i32* %live46, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then39, %for.end
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 10
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent49, align 8
  %call50 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %59, %struct.bpf_reg_state* noundef %60, %struct.bpf_reg_state* noundef %62, i8 noundef zeroext 2) #8
  br label %if.end101

if.else:                                          ; preds = %if.end
  store i32 0, i32* %zeros, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc74, %if.else
  %63 = load i32, i32* %i, align 4
  %64 = load i32, i32* %size.addr, align 4
  %cmp52 = icmp slt i32 %63, %64
  br i1 %cmp52, label %for.body54, label %for.end76

for.body54:                                       ; preds = %for.cond51
  %65 = load i8*, i8** %stype, align 8
  %66 = load i32, i32* %slot, align 4
  %67 = load i32, i32* %i, align 4
  %sub55 = sub i32 %66, %67
  %rem56 = srem i32 %sub55, 8
  %idxprom57 = sext i32 %rem56 to i64
  %arrayidx58 = getelementptr i8, i8* %65, i64 %idxprom57
  %68 = load i8, i8* %arrayidx58, align 1
  %conv59 = zext i8 %68 to i32
  %cmp60 = icmp eq i32 %conv59, 2
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %for.body54
  br label %for.inc74

if.end63:                                         ; preds = %for.body54
  %69 = load i8*, i8** %stype, align 8
  %70 = load i32, i32* %slot, align 4
  %71 = load i32, i32* %i, align 4
  %sub64 = sub i32 %70, %71
  %rem65 = srem i32 %sub64, 8
  %idxprom66 = sext i32 %rem65 to i64
  %arrayidx67 = getelementptr i8, i8* %69, i64 %idxprom66
  %72 = load i8, i8* %arrayidx67, align 1
  %conv68 = zext i8 %72 to i32
  %cmp69 = icmp eq i32 %conv68, 3
  br i1 %cmp69, label %if.then71, label %if.end73

if.then71:                                        ; preds = %if.end63
  %73 = load i32, i32* %zeros, align 4
  %inc72 = add i32 %73, 1
  store i32 %inc72, i32* %zeros, align 4
  br label %for.inc74

if.end73:                                         ; preds = %if.end63
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  %76 = load i32, i32* %off.addr, align 4
  %77 = load i32, i32* %i, align 4
  %78 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.184, i64 0, i64 0), i32 noundef %76, i32 noundef %77, i32 noundef %78) #8
  store i32 -13, i32* %retval, align 4
  br label %return

for.inc74:                                        ; preds = %if.then71, %if.then62
  %79 = load i32, i32* %i, align 4
  %inc75 = add i32 %79, 1
  store i32 %inc75, i32* %i, align 4
  br label %for.cond51

for.end76:                                        ; preds = %for.cond51
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 10
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent77, align 8
  %call78 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %80, %struct.bpf_reg_state* noundef %81, %struct.bpf_reg_state* noundef %83, i8 noundef zeroext 2) #8
  %84 = load i32, i32* %value_regno.addr, align 4
  %cmp79 = icmp sge i32 %84, 0
  br i1 %cmp79, label %if.then81, label %if.end100

if.then81:                                        ; preds = %for.end76
  %85 = load i32, i32* %zeros, align 4
  %86 = load i32, i32* %size.addr, align 4
  %cmp82 = icmp eq i32 %85, %86
  br i1 %cmp82, label %if.then84, label %if.else91

if.then84:                                        ; preds = %if.then81
  %87 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs85 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %87, i32 0, i32 0
  %88 = load i32, i32* %value_regno.addr, align 4
  %idxprom86 = sext i32 %88 to i64
  %arrayidx87 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs85, i64 0, i64 %idxprom86
  call void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %arrayidx87) #8
  %89 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs88 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %89, i32 0, i32 0
  %90 = load i32, i32* %value_regno.addr, align 4
  %idxprom89 = sext i32 %90 to i64
  %arrayidx90 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs88, i64 0, i64 %idxprom89
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx90, i32 0, i32 14
  store i8 1, i8* %precise, align 4
  br label %if.end94

if.else91:                                        ; preds = %if.then81
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs92 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %92, i32 0, i32 0
  %arraydecay93 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs92, i64 0, i64 0
  %93 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %91, %struct.bpf_reg_state* noundef %arraydecay93, i32 noundef %93) #8
  br label %if.end94

if.end94:                                         ; preds = %if.else91, %if.then84
  %94 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs95 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %94, i32 0, i32 0
  %95 = load i32, i32* %value_regno.addr, align 4
  %idxprom96 = sext i32 %95 to i64
  %arrayidx97 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs95, i64 0, i64 %idxprom96
  %live98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx97, i32 0, i32 13
  %96 = load i32, i32* %live98, align 8
  %or99 = or i32 %96, 4
  store i32 %or99, i32* %live98, align 8
  br label %if.end100

if.end100:                                        ; preds = %if.end94, %for.end76
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.end48
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end101, %if.end73, %if.then35, %if.end25, %if.then16, %if.then
  %97 = load i32, i32* %retval, align 4
  ret i32 %97
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %2 to i64
  %3 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %3 to i64
  %add = add i64 %conv, %conv3
  %cmp4 = icmp ugt i64 %add, 56
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %off.addr, align 4
  %7 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.187, i64 0, i64 0), i32 noundef %6, i32 noundef %7) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_sock_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %info = alloca %struct.util_est, align 4
  %valid = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #8
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = bitcast %struct.util_est* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %3, i8 0, i64 8, i1 false)
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.144, i64 0, i64 0), i32 noundef %8) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  switch i32 %10, label %sw.default [
    i32 13, label %sw.bb
    i32 11, label %sw.bb2
    i32 15, label %sw.bb5
    i32 18, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %call1 = call zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.util_est* noundef %info) #8
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %valid, align 1
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.end
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i32, i32* %t.addr, align 4
  %call3 = call zeroext i1 @bpf_sock_is_valid_access(i32 noundef %14, i32 noundef %15, i32 noundef %16, %struct.util_est* noundef %info) #8
  %frombool4 = zext i1 %call3 to i8
  store i8 %frombool4, i8* %valid, align 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  %call6 = call zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef %17, i32 noundef %18, i32 noundef %19, %struct.util_est* noundef %info) #8
  %frombool7 = zext i1 %call6 to i8
  store i8 %frombool7, i8* %valid, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  %22 = load i32, i32* %t.addr, align 4
  %call9 = call zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef %20, i32 noundef %21, i32 noundef %22, %struct.util_est* noundef %info) #8
  %frombool10 = zext i1 %call9 to i8
  store i8 %frombool10, i8* %valid, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i8 0, i8* %valid, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb5, %sw.bb2, %sw.bb
  %23 = load i8, i8* %valid, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then11, label %if.end15

if.then11:                                        ; preds = %sw.epilog
  %ctx_field_size = getelementptr inbounds %struct.util_est, %struct.util_est* %info, i32 0, i32 1
  %24 = load i32, i32* %ctx_field_size, align 4
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 16
  %26 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %27 = load i32, i32* %insn_idx.addr, align 4
  %idxprom12 = sext i32 %27 to i64
  %arrayidx13 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %26, i64 %idxprom12
  %ctx_field_size14 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx13, i32 0, i32 1
  store i32 %24, i32* %ctx_field_size14, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %sw.epilog
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  %30 = load i32, i32* %regno.addr, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 0
  %32 = load i32, i32* %type16, align 8
  %idxprom17 = zext i32 %32 to i64
  %arrayidx18 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom17
  %33 = load i8*, i8** %arrayidx18, align 8
  %34 = load i32, i32* %off.addr, align 4
  %35 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.188, i64 0, i64 0), i32 noundef %30, i8* noundef %33, i32 noundef %34, i32 noundef %35) #8
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then11, %if.then
  %36 = load i32, i32* %retval, align 4
  ret i32 %36
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  %3 = load i32, i32* %regno.addr, align 4
  %4 = load i32, i32* %off.addr, align 4
  %5 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.189, i64 0, i64 0), i32 noundef %3, i32 noundef %4, i32 noundef %5) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #8
  br i1 %call, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %13 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %13, 0
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %15 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call4 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %17, i64 %19) #8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %regno.addr, align 4
  %23 = load i32, i32* %off.addr, align 4
  %arraydecay5 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.190, i64 0, i64 0), i32 noundef %22, i32 noundef %23, i8* noundef %arraydecay5) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %24 = load i32, i32* %off.addr, align 4
  %25 = load i32, i32* %size.addr, align 4
  %add = add i32 %24, %25
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 2
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 7
  %28 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_tp_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %28, i32 0, i32 4
  %29 = load i32, i32* %max_tp_access, align 8
  %cmp7 = icmp ugt i32 %add, %29
  br i1 %cmp7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end6
  %30 = load i32, i32* %off.addr, align 4
  %31 = load i32, i32* %size.addr, align 4
  %add9 = add i32 %30, %31
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 2
  %33 = load %struct.bpf_prog*, %struct.bpf_prog** %prog10, align 8
  %aux11 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %33, i32 0, i32 7
  %34 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux11, align 8
  %max_tp_access12 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %34, i32 0, i32 4
  store i32 %add9, i32* %max_tp_access12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then2, %if.then
  %35 = load i32, i32* %retval, align 4
  ret i32 %35
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.util_est* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.util_est* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.util_est* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.util_est* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @save_register_state(%struct.bpf_func_state* noundef %state, i32 noundef %spi, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %spi.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 7
  %1 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %2 = load i32, i32* %spi.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %1, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %4 = bitcast %struct.bpf_reg_state* %spilled_ptr to i8*
  %5 = bitcast %struct.bpf_reg_state* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 104, i1 false)
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 7
  %7 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %8 = load i32, i32* %spi.addr, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %7, i64 %idxprom2
  %spilled_ptr4 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr4, i32 0, i32 13
  %9 = load i32, i32* %live, align 8
  %or = or i32 %9, 4
  store i32 %or, i32* %live, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %10, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %13 = load i32, i32* %spi.addr, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %14 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %14 to i64
  %arrayidx9 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom8
  store i8 1, i8* %arrayidx9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_spillable_regtype(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 2, label %sw.bb
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 3, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_insn_zext(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %def_idx = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %subreg_def, align 4
  store i32 %1, i32* %def_idx, align 4
  %2 = load i32, i32* %def_idx, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 16
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %5 = load i32, i32* %def_idx, align 4
  %sub = sub i32 %5, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i64 %idxprom
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  store i8 1, i8* %zext_dst, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %subreg_def1, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %ptr_reg = alloca %struct.bpf_reg_state*, align 8
  %off_reg = alloca %struct.bpf_reg_state, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on94 = alloca i32, align 4
  %tmp115 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %ptr_reg, align 8
  %7 = bitcast %struct.bpf_reg_state* %off_reg to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %7, i8 0, i64 104, i1 false)
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg3, align 1
  %bf.clear = and i8 %bf.load, 15
  %idxprom4 = zext i8 %bf.clear to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %13, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* %14, %struct.bpf_reg_state** %ptr_reg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code7, align 4
  %conv8 = zext i8 %16 to i32
  %and9 = and i32 %conv8, 8
  %cmp10 = icmp eq i32 %and9, 8
  br i1 %cmp10, label %if.then12, label %if.else64

if.then12:                                        ; preds = %if.end
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.lshr = lshr i8 %bf.load14, 4
  %idxprom15 = zext i8 %bf.lshr to i64
  %arrayidx16 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i64 %idxprom15
  store %struct.bpf_reg_state* %arrayidx16, %struct.bpf_reg_state** %src_reg, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type17, align 8
  %cmp18 = icmp ne i32 %20, 1
  br i1 %cmp18, label %if.then20, label %if.else50

if.then20:                                        ; preds = %if.then12
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %22, 1
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.then20
  %23 = load i8, i8* %opcode, align 1
  %conv25 = zext i8 %23 to i32
  %cmp26 = icmp eq i32 %conv25, 16
  br i1 %cmp26, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.then24
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 14
  %25 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %if.then29, label %if.end34

if.then29:                                        ; preds = %land.lhs.true
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load31 = load i8, i8* %dst_reg30, align 1
  %bf.clear32 = and i8 %bf.load31, 15
  %conv33 = zext i8 %bf.clear32 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %27, i32 noundef %conv33) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %land.lhs.true, %if.then24
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, 15
  %conv38 = zext i8 %bf.clear37 to i32
  %32 = load i8, i8* %opcode, align 1
  %conv39 = zext i8 %32 to i32
  %shr = ashr i32 %conv39, 4
  %idxprom40 = sext i32 %shr to i64
  %arrayidx41 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom40
  %33 = load i8*, i8** %arrayidx41, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.124, i64 0, i64 0), i32 noundef %conv38, i8* noundef %33) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then20
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg42 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %35, i32 0, i32 1
  %bf.load43 = load i8, i8* %dst_reg42, align 1
  %bf.clear44 = and i8 %bf.load43, 15
  %conv45 = zext i8 %bf.clear44 to i32
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %34, i32 noundef %conv45) #8
  store i32 %call, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool46 = icmp ne i32 %36, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.else
  %37 = load i32, i32* %err, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.else
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call49 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %38, %struct.bpf_insn* noundef %39, %struct.bpf_reg_state* noundef %40, %struct.bpf_reg_state* noundef %41) #8
  store i32 %call49, i32* %retval, align 4
  br label %return

if.else50:                                        ; preds = %if.then12
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool51 = icmp ne %struct.bpf_reg_state* %42, null
  br i1 %tobool51, label %if.then52, label %if.end62

if.then52:                                        ; preds = %if.else50
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg53 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 1
  %bf.load54 = load i8, i8* %src_reg53, align 1
  %bf.lshr55 = lshr i8 %bf.load54, 4
  %conv56 = zext i8 %bf.lshr55 to i32
  %call57 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %43, i32 noundef %conv56) #8
  store i32 %call57, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %tobool58 = icmp ne i32 %45, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.then52
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.then52
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call61 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %47, %struct.bpf_insn* noundef %48, %struct.bpf_reg_state* noundef %49, %struct.bpf_reg_state* noundef %50) #8
  store i32 %call61, i32* %retval, align 4
  br label %return

if.end62:                                         ; preds = %if.else50
  br label %if.end63

if.end63:                                         ; preds = %if.end62
  br label %if.end71

if.else64:                                        ; preds = %if.end
  %type65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %off_reg, i32 0, i32 0
  store i32 1, i32* %type65, align 8
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 3
  %52 = load i32, i32* %imm, align 4
  %conv66 = sext i32 %52 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %off_reg, i64 noundef %conv66) #8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %src_reg, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool67 = icmp ne %struct.bpf_reg_state* %53, null
  br i1 %tobool67, label %if.then68, label %if.end70

if.then68:                                        ; preds = %if.else64
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call69 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %54, %struct.bpf_insn* noundef %55, %struct.bpf_reg_state* noundef %56, %struct.bpf_reg_state* noundef %57) #8
  store i32 %call69, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.else64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.end63
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool72 = icmp ne %struct.bpf_reg_state* %58, null
  %lnot = xor i1 %tobool72, true
  %lnot73 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot73 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %59 = load i32, i32* %__ret_warn_on, align 4
  %tobool74 = icmp ne i32 %59, 0
  %lnot75 = xor i1 %tobool74, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv79 = sext i32 %lnot.ext78 to i64
  %tobool80 = icmp ne i64 %conv79, 0
  br i1 %tobool80, label %if.then81, label %if.end84

if.then81:                                        ; preds = %if.end71
  br label %do.body

do.body:                                          ; preds = %if.then81
  br label %do.body82

do.body82:                                        ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 5214, i32 2307, i64 12) #9, !srcloc !51
  br label %do.end

do.end:                                           ; preds = %do.body82
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 163) #9, !srcloc !52
  br label %do.end83

do.end83:                                         ; preds = %do.end
  br label %if.end84

if.end84:                                         ; preds = %do.end83, %if.end71
  %60 = load i32, i32* %__ret_warn_on, align 4
  %tobool85 = icmp ne i32 %60, 0
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  store i64 %conv90, i64* %tmp, align 8
  %61 = load i64, i64* %tmp, align 8
  %tobool91 = icmp ne i64 %61, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end84
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %62, %struct.bpf_func_state* noundef %63) #8
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.125, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end93:                                         ; preds = %if.end84
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %tobool95 = icmp ne %struct.bpf_reg_state* %66, null
  %lnot96 = xor i1 %tobool95, true
  %lnot98 = xor i1 %lnot96, true
  %lnot100 = xor i1 %lnot98, true
  %lnot.ext101 = zext i1 %lnot100 to i32
  store i32 %lnot.ext101, i32* %__ret_warn_on94, align 4
  %67 = load i32, i32* %__ret_warn_on94, align 4
  %tobool102 = icmp ne i32 %67, 0
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  %conv107 = sext i32 %lnot.ext106 to i64
  %tobool108 = icmp ne i64 %conv107, 0
  br i1 %tobool108, label %if.then109, label %if.end114

if.then109:                                       ; preds = %if.end93
  br label %do.body110

do.body110:                                       ; preds = %if.then109
  br label %do.body111

do.body111:                                       ; preds = %do.body110
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 5219, i32 2305, i64 12) #9, !srcloc !53
  br label %do.end112

do.end112:                                        ; preds = %do.body111
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 164) #9, !srcloc !54
  br label %do.end113

do.end113:                                        ; preds = %do.end112
  br label %if.end114

if.end114:                                        ; preds = %do.end113, %if.end93
  %68 = load i32, i32* %__ret_warn_on94, align 4
  %tobool116 = icmp ne i32 %68, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  store i64 %conv121, i64* %tmp115, align 8
  %69 = load i64, i64* %tmp115, align 8
  %tobool122 = icmp ne i64 %69, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end114
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %70, %struct.bpf_func_state* noundef %71) #8
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = bitcast %struct.bpf_verifier_env* %72 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %73, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.126, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end124:                                        ; preds = %if.end114
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call125 = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %74, %struct.bpf_insn* noundef %75, %struct.bpf_reg_state* noundef %76, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %77) #8
  store i32 %call125, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end124, %if.then123, %if.then92, %if.then68, %if.end60, %if.then59, %if.end48, %if.then47, %if.end34, %if.then29
  %78 = load i32, i32* %retval, align 4
  ret i32 %78
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %off_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %smin_ptr = alloca i64, align 8
  %smax_ptr = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %umin_ptr = alloca i64, align 8
  %umax_ptr = alloca i64, align 8
  %dst = alloca i32, align 4
  %src = alloca i32, align 4
  %opcode = alloca i8, align 1
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp210 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #8
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value, align 8
  store i64 %14, i64* %smin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value, align 8
  store i64 %16, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value2, align 8
  store i64 %18, i64* %smin_ptr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 7
  %20 = load i64, i64* %smax_value3, align 8
  store i64 %20, i64* %smax_ptr, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value, align 8
  store i64 %22, i64* %umin_val, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 9
  %24 = load i64, i64* %umax_value, align 8
  store i64 %24, i64* %umax_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  %26 = load i64, i64* %umin_value4, align 8
  store i64 %26, i64* %umin_ptr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value5, align 8
  store i64 %28, i64* %umax_ptr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg6, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst, align 4
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 1
  %bf.load7 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load7, 4
  %conv8 = zext i8 %bf.lshr to i32
  store i32 %conv8, i32* %src, align 4
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 0
  %32 = load i8, i8* %code, align 4
  %conv9 = zext i8 %32 to i32
  %and = and i32 %conv9, 240
  %conv10 = trunc i32 %and to i8
  store i8 %conv10, i8* %opcode, align 1
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %34 = load i32, i32* %dst, align 4
  %idxprom11 = zext i32 %34 to i64
  %arrayidx12 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i64 %idxprom11
  store %struct.bpf_reg_state* %arrayidx12, %struct.bpf_reg_state** %dst_reg, align 8
  %35 = load i8, i8* %known, align 1
  %tobool = trunc i8 %35 to i1
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false17

land.lhs.true:                                    ; preds = %entry
  %36 = load i64, i64* %smin_val, align 8
  %37 = load i64, i64* %smax_val, align 8
  %cmp = icmp ne i64 %36, %37
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %38 = load i64, i64* %umin_val, align 8
  %39 = load i64, i64* %umax_val, align 8
  %cmp15 = icmp ne i64 %38, %39
  br i1 %cmp15, label %if.then, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false, %entry
  %40 = load i64, i64* %smin_val, align 8
  %41 = load i64, i64* %smax_val, align 8
  %cmp18 = icmp sgt i64 %40, %41
  br i1 %cmp18, label %if.then, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false17
  %42 = load i64, i64* %umin_val, align 8
  %43 = load i64, i64* %umax_val, align 8
  %cmp21 = icmp ugt i64 %42, %43
  br i1 %cmp21, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false20, %lor.lhs.false17, %lor.lhs.false, %land.lhs.true
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_reg_state* noundef %44) #8
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false20
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 0
  %46 = load i8, i8* %code23, align 4
  %conv24 = zext i8 %46 to i32
  %and25 = and i32 %conv24, 7
  %cmp26 = icmp ne i32 %and25, 7
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  %49 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.127, i64 0, i64 0), i32 noundef %49) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  %51 = load i32, i32* %type, align 8
  switch i32 %51, label %sw.default [
    i32 5, label %sw.bb
    i32 3, label %sw.bb33
    i32 9, label %sw.bb33
    i32 11, label %sw.bb33
    i32 12, label %sw.bb33
    i32 13, label %sw.bb33
    i32 14, label %sw.bb33
    i32 15, label %sw.bb33
    i32 16, label %sw.bb33
    i32 18, label %sw.bb33
    i32 4, label %sw.bb37
  ]

sw.bb:                                            ; preds = %if.end29
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i32, i32* %dst, align 4
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 0
  %56 = load i32, i32* %type30, align 8
  %idxprom31 = zext i32 %56 to i64
  %arrayidx32 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom31
  %57 = load i8*, i8** %arrayidx32, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.128, i64 0, i64 0), i32 noundef %54, i8* noundef %57) #8
  store i32 -13, i32* %retval, align 4
  br label %return

sw.bb33:                                          ; preds = %if.end29, %if.end29, %if.end29, %if.end29, %if.end29, %if.end29, %if.end29, %if.end29, %if.end29
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  %60 = load i32, i32* %dst, align 4
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type34, align 8
  %idxprom35 = zext i32 %62 to i64
  %arrayidx36 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom35
  %63 = load i8*, i8** %arrayidx36, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.129, i64 0, i64 0), i32 noundef %60, i8* noundef %63) #8
  store i32 -13, i32* %retval, align 4
  br label %return

sw.bb37:                                          ; preds = %if.end29
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 14
  %65 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool38 = trunc i8 %65 to i1
  br i1 %tobool38, label %if.end51, label %land.lhs.true39

land.lhs.true39:                                  ; preds = %sw.bb37
  %66 = load i8, i8* %known, align 1
  %tobool40 = trunc i8 %66 to i1
  br i1 %tobool40, label %if.end51, label %land.lhs.true41

land.lhs.true41:                                  ; preds = %land.lhs.true39
  %67 = load i64, i64* %smin_val, align 8
  %cmp42 = icmp slt i64 %67, 0
  %conv43 = zext i1 %cmp42 to i32
  %68 = load i64, i64* %smax_val, align 8
  %cmp44 = icmp slt i64 %68, 0
  %conv45 = zext i1 %cmp44 to i32
  %cmp46 = icmp ne i32 %conv43, %conv45
  br i1 %cmp46, label %if.then48, label %if.end51

if.then48:                                        ; preds = %land.lhs.true41
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = bitcast %struct.bpf_verifier_env* %69 to i8*
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %cmp49 = icmp eq %struct.bpf_reg_state* %71, %72
  br i1 %cmp49, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then48
  %73 = load i32, i32* %dst, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then48
  %74 = load i32, i32* %src, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %73, %cond.true ], [ %74, %cond.false ]
  call void (i8*, i8*, ...) @verbose(i8* noundef %70, i8* noundef getelementptr inbounds ([98 x i8], [98 x i8]* @.str.130, i64 0, i64 0), i32 noundef %cond) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %land.lhs.true41, %land.lhs.true39, %sw.bb37
  br label %sw.default

sw.default:                                       ; preds = %if.end51, %if.end29
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 0
  %76 = load i32, i32* %type52, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 0
  store i32 %76, i32* %type53, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 3
  %79 = load i32, i32* %id, align 4
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 3
  store i32 %79, i32* %id54, align 4
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 0
  %84 = load i32, i32* %type55, align 8
  %call56 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %81, %struct.bpf_reg_state* noundef %82, i32 noundef %84) #8
  br i1 %call56, label %lor.lhs.false57, label %if.then60

lor.lhs.false57:                                  ; preds = %sw.epilog
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i32 0, i32 0
  %88 = load i32, i32* %type58, align 8
  %call59 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %85, %struct.bpf_reg_state* noundef %86, i32 noundef %88) #8
  br i1 %call59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %lor.lhs.false57, %sw.epilog
  store i32 -22, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %lor.lhs.false57
  %89 = load i8, i8* %opcode, align 1
  %conv62 = zext i8 %89 to i32
  switch i32 %conv62, label %sw.default233 [
    i32 0, label %sw.bb63
    i32 16, label %sw.bb138
    i32 80, label %sw.bb229
    i32 64, label %sw.bb229
    i32 160, label %sw.bb229
  ]

sw.bb63:                                          ; preds = %if.end61
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %94 = load i64, i64* %smin_val, align 8
  %cmp64 = icmp slt i64 %94, 0
  %call66 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %90, %struct.bpf_insn* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, i1 noundef zeroext %cmp64) #8
  store i32 %call66, i32* %ret, align 4
  %95 = load i32, i32* %ret, align 4
  %cmp67 = icmp slt i32 %95, 0
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %sw.bb63
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %97 = bitcast %struct.bpf_verifier_env* %96 to i8*
  %98 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %97, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.131, i64 0, i64 0), i32 noundef %98) #8
  %99 = load i32, i32* %ret, align 4
  store i32 %99, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %sw.bb63
  %100 = load i8, i8* %known, align 1
  %tobool71 = trunc i8 %100 to i1
  br i1 %tobool71, label %land.lhs.true73, label %if.end95

land.lhs.true73:                                  ; preds = %if.end70
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 2
  %102 = load i32, i32* %off, align 8
  %conv74 = sext i32 %102 to i64
  %103 = load i64, i64* %smin_val, align 8
  %add = add i64 %conv74, %103
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 2
  %105 = load i32, i32* %off75, align 8
  %conv76 = sext i32 %105 to i64
  %106 = load i64, i64* %smin_val, align 8
  %add77 = add i64 %conv76, %106
  %conv78 = trunc i64 %add77 to i32
  %conv79 = sext i32 %conv78 to i64
  %cmp80 = icmp eq i64 %add, %conv79
  br i1 %cmp80, label %if.then82, label %if.end95

if.then82:                                        ; preds = %land.lhs.true73
  %107 = load i64, i64* %smin_ptr, align 8
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %108, i32 0, i32 6
  store i64 %107, i64* %smin_value83, align 8
  %109 = load i64, i64* %smax_ptr, align 8
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value84 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %110, i32 0, i32 7
  store i64 %109, i64* %smax_value84, align 8
  %111 = load i64, i64* %umin_ptr, align 8
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 8
  store i64 %111, i64* %umin_value85, align 8
  %113 = load i64, i64* %umax_ptr, align 8
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i32 0, i32 9
  store i64 %113, i64* %umax_value86, align 8
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 5
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i32 0, i32 5
  %117 = bitcast %struct.tnum* %var_off87 to i8*
  %118 = bitcast %struct.tnum* %var_off88 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %117, i8* align 8 %118, i64 16, i1 false)
  %119 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %119, i32 0, i32 2
  %120 = load i32, i32* %off89, align 8
  %conv90 = sext i32 %120 to i64
  %121 = load i64, i64* %smin_val, align 8
  %add91 = add i64 %conv90, %121
  %conv92 = trunc i64 %add91 to i32
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 2
  store i32 %conv92, i32* %off93, align 8
  %123 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %124 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %123, i32 0, i32 1
  %raw = bitcast %union.anon.147* %124 to i64*
  %125 = load i64, i64* %raw, align 8
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 1
  %raw94 = bitcast %union.anon.147* %127 to i64*
  store i64 %125, i64* %raw94, align 8
  br label %sw.epilog238

if.end95:                                         ; preds = %land.lhs.true73, %if.end70
  %128 = load i64, i64* %smin_ptr, align 8
  %129 = load i64, i64* %smin_val, align 8
  %call96 = call zeroext i1 @signed_add_overflows(i64 noundef %128, i64 noundef %129) #8
  br i1 %call96, label %if.then101, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.end95
  %130 = load i64, i64* %smax_ptr, align 8
  %131 = load i64, i64* %smax_val, align 8
  %call99 = call zeroext i1 @signed_add_overflows(i64 noundef %130, i64 noundef %131) #8
  br i1 %call99, label %if.then101, label %if.else

if.then101:                                       ; preds = %lor.lhs.false98, %if.end95
  %132 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %132, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value102, align 8
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value103, align 8
  br label %if.end108

if.else:                                          ; preds = %lor.lhs.false98
  %134 = load i64, i64* %smin_ptr, align 8
  %135 = load i64, i64* %smin_val, align 8
  %add104 = add i64 %134, %135
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value105 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 6
  store i64 %add104, i64* %smin_value105, align 8
  %137 = load i64, i64* %smax_ptr, align 8
  %138 = load i64, i64* %smax_val, align 8
  %add106 = add i64 %137, %138
  %139 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %139, i32 0, i32 7
  store i64 %add106, i64* %smax_value107, align 8
  br label %if.end108

if.end108:                                        ; preds = %if.else, %if.then101
  %140 = load i64, i64* %umin_ptr, align 8
  %141 = load i64, i64* %umin_val, align 8
  %add109 = add i64 %140, %141
  %142 = load i64, i64* %umin_ptr, align 8
  %cmp110 = icmp ult i64 %add109, %142
  br i1 %cmp110, label %if.then116, label %lor.lhs.false112

lor.lhs.false112:                                 ; preds = %if.end108
  %143 = load i64, i64* %umax_ptr, align 8
  %144 = load i64, i64* %umax_val, align 8
  %add113 = add i64 %143, %144
  %145 = load i64, i64* %umax_ptr, align 8
  %cmp114 = icmp ult i64 %add113, %145
  br i1 %cmp114, label %if.then116, label %if.else119

if.then116:                                       ; preds = %lor.lhs.false112, %if.end108
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value117 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i32 0, i32 8
  store i64 0, i64* %umin_value117, align 8
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value118 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 9
  store i64 -1, i64* %umax_value118, align 8
  br label %if.end124

if.else119:                                       ; preds = %lor.lhs.false112
  %148 = load i64, i64* %umin_ptr, align 8
  %149 = load i64, i64* %umin_val, align 8
  %add120 = add i64 %148, %149
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i32 0, i32 8
  store i64 %add120, i64* %umin_value121, align 8
  %151 = load i64, i64* %umax_ptr, align 8
  %152 = load i64, i64* %umax_val, align 8
  %add122 = add i64 %151, %152
  %153 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %153, i32 0, i32 9
  store i64 %add122, i64* %umax_value123, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.else119, %if.then116
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off125 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 5
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %155, i32 0, i32 5
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 5
  %157 = bitcast %struct.tnum* %var_off126 to { i64, i64 }*
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 0
  %159 = load i64, i64* %158, align 8
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 1
  %161 = load i64, i64* %160, align 8
  %162 = bitcast %struct.tnum* %var_off127 to { i64, i64 }*
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = load i64, i64* %163, align 8
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = load i64, i64* %165, align 8
  %call128 = call { i64, i64 } @tnum_add(i64 %159, i64 %161, i64 %164, i64 %166) #8
  %167 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %168 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 0
  %169 = extractvalue { i64, i64 } %call128, 0
  store i64 %169, i64* %168, align 8
  %170 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 1
  %171 = extractvalue { i64, i64 } %call128, 1
  store i64 %171, i64* %170, align 8
  %172 = bitcast %struct.tnum* %var_off125 to i8*
  %173 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %172, i8* align 8 %173, i64 16, i1 false)
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off129 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %174, i32 0, i32 2
  %175 = load i32, i32* %off129, align 8
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off130 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i32 0, i32 2
  store i32 %175, i32* %off130, align 8
  %177 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %177, i32 0, i32 1
  %raw131 = bitcast %union.anon.147* %178 to i64*
  %179 = load i64, i64* %raw131, align 8
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %181 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %180, i32 0, i32 1
  %raw132 = bitcast %union.anon.147* %181 to i64*
  store i64 %179, i64* %raw132, align 8
  %182 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call133 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %182) #8
  br i1 %call133, label %if.then134, label %if.end137

if.then134:                                       ; preds = %if.end124
  %183 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %183, i32 0, i32 13
  %184 = load i32, i32* %id_gen, align 4
  %inc = add i32 %184, 1
  store i32 %inc, i32* %id_gen, align 4
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %185, i32 0, i32 3
  store i32 %inc, i32* %id135, align 4
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %187 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i32 0, i32 1
  %raw136 = bitcast %union.anon.147* %187 to i64*
  store i64 0, i64* %raw136, align 8
  br label %if.end137

if.end137:                                        ; preds = %if.then134, %if.end124
  br label %sw.epilog238

sw.bb138:                                         ; preds = %if.end61
  %188 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %189 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %192 = load i64, i64* %smin_val, align 8
  %cmp139 = icmp slt i64 %192, 0
  %call141 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %188, %struct.bpf_insn* noundef %189, %struct.bpf_reg_state* noundef %190, %struct.bpf_reg_state* noundef %191, i1 noundef zeroext %cmp139) #8
  store i32 %call141, i32* %ret, align 4
  %193 = load i32, i32* %ret, align 4
  %cmp142 = icmp slt i32 %193, 0
  br i1 %cmp142, label %if.then144, label %if.end145

if.then144:                                       ; preds = %sw.bb138
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %195 = bitcast %struct.bpf_verifier_env* %194 to i8*
  %196 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %195, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.132, i64 0, i64 0), i32 noundef %196) #8
  %197 = load i32, i32* %ret, align 4
  store i32 %197, i32* %retval, align 4
  br label %return

if.end145:                                        ; preds = %sw.bb138
  %198 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %cmp146 = icmp eq %struct.bpf_reg_state* %198, %199
  br i1 %cmp146, label %if.then148, label %if.end149

if.then148:                                       ; preds = %if.end145
  %200 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %201 = bitcast %struct.bpf_verifier_env* %200 to i8*
  %202 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %201, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.133, i64 0, i64 0), i32 noundef %202) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end149:                                        ; preds = %if.end145
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i32 0, i32 0
  %204 = load i32, i32* %type150, align 8
  %cmp151 = icmp eq i32 %204, 6
  br i1 %cmp151, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.end149
  %205 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %206 = bitcast %struct.bpf_verifier_env* %205 to i8*
  %207 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %206, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.134, i64 0, i64 0), i32 noundef %207) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end154:                                        ; preds = %if.end149
  %208 = load i8, i8* %known, align 1
  %tobool155 = trunc i8 %208 to i1
  br i1 %tobool155, label %land.lhs.true157, label %if.end183

land.lhs.true157:                                 ; preds = %if.end154
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %209, i32 0, i32 2
  %210 = load i32, i32* %off158, align 8
  %conv159 = sext i32 %210 to i64
  %211 = load i64, i64* %smin_val, align 8
  %sub = sub i64 %conv159, %211
  %212 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off160 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %212, i32 0, i32 2
  %213 = load i32, i32* %off160, align 8
  %conv161 = sext i32 %213 to i64
  %214 = load i64, i64* %smin_val, align 8
  %sub162 = sub i64 %conv161, %214
  %conv163 = trunc i64 %sub162 to i32
  %conv164 = sext i32 %conv163 to i64
  %cmp165 = icmp eq i64 %sub, %conv164
  br i1 %cmp165, label %if.then167, label %if.end183

if.then167:                                       ; preds = %land.lhs.true157
  %215 = load i64, i64* %smin_ptr, align 8
  %216 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value168 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %216, i32 0, i32 6
  store i64 %215, i64* %smin_value168, align 8
  %217 = load i64, i64* %smax_ptr, align 8
  %218 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value169 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %218, i32 0, i32 7
  store i64 %217, i64* %smax_value169, align 8
  %219 = load i64, i64* %umin_ptr, align 8
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %220, i32 0, i32 8
  store i64 %219, i64* %umin_value170, align 8
  %221 = load i64, i64* %umax_ptr, align 8
  %222 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value171 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %222, i32 0, i32 9
  store i64 %221, i64* %umax_value171, align 8
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off172 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i32 0, i32 5
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off173 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %224, i32 0, i32 5
  %225 = bitcast %struct.tnum* %var_off172 to i8*
  %226 = bitcast %struct.tnum* %var_off173 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %225, i8* align 8 %226, i64 16, i1 false)
  %227 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %227, i32 0, i32 3
  %228 = load i32, i32* %id174, align 4
  %229 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id175 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %229, i32 0, i32 3
  store i32 %228, i32* %id175, align 4
  %230 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %230, i32 0, i32 2
  %231 = load i32, i32* %off176, align 8
  %conv177 = sext i32 %231 to i64
  %232 = load i64, i64* %smin_val, align 8
  %sub178 = sub i64 %conv177, %232
  %conv179 = trunc i64 %sub178 to i32
  %233 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off180 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %233, i32 0, i32 2
  store i32 %conv179, i32* %off180, align 8
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %235 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 1
  %raw181 = bitcast %union.anon.147* %235 to i64*
  %236 = load i64, i64* %raw181, align 8
  %237 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %238 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %237, i32 0, i32 1
  %raw182 = bitcast %union.anon.147* %238 to i64*
  store i64 %236, i64* %raw182, align 8
  br label %sw.epilog238

if.end183:                                        ; preds = %land.lhs.true157, %if.end154
  %239 = load i64, i64* %smin_ptr, align 8
  %240 = load i64, i64* %smax_val, align 8
  %call184 = call zeroext i1 @signed_sub_overflows(i64 noundef %239, i64 noundef %240) #8
  br i1 %call184, label %if.then189, label %lor.lhs.false186

lor.lhs.false186:                                 ; preds = %if.end183
  %241 = load i64, i64* %smax_ptr, align 8
  %242 = load i64, i64* %smin_val, align 8
  %call187 = call zeroext i1 @signed_sub_overflows(i64 noundef %241, i64 noundef %242) #8
  br i1 %call187, label %if.then189, label %if.else192

if.then189:                                       ; preds = %lor.lhs.false186, %if.end183
  %243 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value190 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %243, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value190, align 8
  %244 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %244, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value191, align 8
  br label %if.end197

if.else192:                                       ; preds = %lor.lhs.false186
  %245 = load i64, i64* %smin_ptr, align 8
  %246 = load i64, i64* %smax_val, align 8
  %sub193 = sub i64 %245, %246
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value194 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i32 0, i32 6
  store i64 %sub193, i64* %smin_value194, align 8
  %248 = load i64, i64* %smax_ptr, align 8
  %249 = load i64, i64* %smin_val, align 8
  %sub195 = sub i64 %248, %249
  %250 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value196 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %250, i32 0, i32 7
  store i64 %sub195, i64* %smax_value196, align 8
  br label %if.end197

if.end197:                                        ; preds = %if.else192, %if.then189
  %251 = load i64, i64* %umin_ptr, align 8
  %252 = load i64, i64* %umax_val, align 8
  %cmp198 = icmp ult i64 %251, %252
  br i1 %cmp198, label %if.then200, label %if.else203

if.then200:                                       ; preds = %if.end197
  %253 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value201 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %253, i32 0, i32 8
  store i64 0, i64* %umin_value201, align 8
  %254 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %254, i32 0, i32 9
  store i64 -1, i64* %umax_value202, align 8
  br label %if.end208

if.else203:                                       ; preds = %if.end197
  %255 = load i64, i64* %umin_ptr, align 8
  %256 = load i64, i64* %umax_val, align 8
  %sub204 = sub i64 %255, %256
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value205 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 8
  store i64 %sub204, i64* %umin_value205, align 8
  %258 = load i64, i64* %umax_ptr, align 8
  %259 = load i64, i64* %umin_val, align 8
  %sub206 = sub i64 %258, %259
  %260 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %260, i32 0, i32 9
  store i64 %sub206, i64* %umax_value207, align 8
  br label %if.end208

if.end208:                                        ; preds = %if.else203, %if.then200
  %261 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off209 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %261, i32 0, i32 5
  %262 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off211 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %262, i32 0, i32 5
  %263 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off212 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %263, i32 0, i32 5
  %264 = bitcast %struct.tnum* %var_off211 to { i64, i64 }*
  %265 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %264, i32 0, i32 0
  %266 = load i64, i64* %265, align 8
  %267 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %264, i32 0, i32 1
  %268 = load i64, i64* %267, align 8
  %269 = bitcast %struct.tnum* %var_off212 to { i64, i64 }*
  %270 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %269, i32 0, i32 0
  %271 = load i64, i64* %270, align 8
  %272 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %269, i32 0, i32 1
  %273 = load i64, i64* %272, align 8
  %call213 = call { i64, i64 } @tnum_sub(i64 %266, i64 %268, i64 %271, i64 %273) #8
  %274 = bitcast %struct.tnum* %tmp210 to { i64, i64 }*
  %275 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %274, i32 0, i32 0
  %276 = extractvalue { i64, i64 } %call213, 0
  store i64 %276, i64* %275, align 8
  %277 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %274, i32 0, i32 1
  %278 = extractvalue { i64, i64 } %call213, 1
  store i64 %278, i64* %277, align 8
  %279 = bitcast %struct.tnum* %var_off209 to i8*
  %280 = bitcast %struct.tnum* %tmp210 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %279, i8* align 8 %280, i64 16, i1 false)
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off214 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i32 0, i32 2
  %282 = load i32, i32* %off214, align 8
  %283 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %283, i32 0, i32 2
  store i32 %282, i32* %off215, align 8
  %284 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %285 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %284, i32 0, i32 1
  %raw216 = bitcast %union.anon.147* %285 to i64*
  %286 = load i64, i64* %raw216, align 8
  %287 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %288 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %287, i32 0, i32 1
  %raw217 = bitcast %union.anon.147* %288 to i64*
  store i64 %286, i64* %raw217, align 8
  %289 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call218 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %289) #8
  br i1 %call218, label %if.then219, label %if.end228

if.then219:                                       ; preds = %if.end208
  %290 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen220 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %290, i32 0, i32 13
  %291 = load i32, i32* %id_gen220, align 4
  %inc221 = add i32 %291, 1
  store i32 %inc221, i32* %id_gen220, align 4
  %292 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id222 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %292, i32 0, i32 3
  store i32 %inc221, i32* %id222, align 4
  %293 = load i64, i64* %smin_val, align 8
  %cmp223 = icmp slt i64 %293, 0
  br i1 %cmp223, label %if.then225, label %if.end227

if.then225:                                       ; preds = %if.then219
  %294 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %295 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %294, i32 0, i32 1
  %raw226 = bitcast %union.anon.147* %295 to i64*
  store i64 0, i64* %raw226, align 8
  br label %if.end227

if.end227:                                        ; preds = %if.then225, %if.then219
  br label %if.end228

if.end228:                                        ; preds = %if.end227, %if.end208
  br label %sw.epilog238

sw.bb229:                                         ; preds = %if.end61, %if.end61, %if.end61
  %296 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %297 = bitcast %struct.bpf_verifier_env* %296 to i8*
  %298 = load i32, i32* %dst, align 4
  %299 = load i8, i8* %opcode, align 1
  %conv230 = zext i8 %299 to i32
  %shr = ashr i32 %conv230, 4
  %idxprom231 = sext i32 %shr to i64
  %arrayidx232 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom231
  %300 = load i8*, i8** %arrayidx232, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %297, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.135, i64 0, i64 0), i32 noundef %298, i8* noundef %300) #8
  store i32 -13, i32* %retval, align 4
  br label %return

sw.default233:                                    ; preds = %if.end61
  %301 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %302 = bitcast %struct.bpf_verifier_env* %301 to i8*
  %303 = load i32, i32* %dst, align 4
  %304 = load i8, i8* %opcode, align 1
  %conv234 = zext i8 %304 to i32
  %shr235 = ashr i32 %conv234, 4
  %idxprom236 = sext i32 %shr235 to i64
  %arrayidx237 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom236
  %305 = load i8*, i8** %arrayidx237, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %302, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.136, i64 0, i64 0), i32 noundef %303, i8* noundef %305) #8
  store i32 -13, i32* %retval, align 4
  br label %return

sw.epilog238:                                     ; preds = %if.end228, %if.then167, %if.end137, %if.then82
  %306 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %307 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %308 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type239 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %308, i32 0, i32 0
  %309 = load i32, i32* %type239, align 8
  %call240 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %306, %struct.bpf_reg_state* noundef %307, i32 noundef %309) #8
  br i1 %call240, label %if.end242, label %if.then241

if.then241:                                       ; preds = %sw.epilog238
  store i32 -22, i32* %retval, align 4
  br label %return

if.end242:                                        ; preds = %sw.epilog238
  %310 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %310) #8
  %311 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %311) #8
  %312 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %312) #8
  %313 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks243 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %313, i32 0, i32 14
  %314 = load i8, i8* %allow_ptr_leaks243, align 8
  %tobool244 = trunc i8 %314 to i1
  br i1 %tobool244, label %if.end269, label %if.then245

if.then245:                                       ; preds = %if.end242
  %315 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type246 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %315, i32 0, i32 0
  %316 = load i32, i32* %type246, align 8
  %cmp247 = icmp eq i32 %316, 4
  br i1 %cmp247, label %land.lhs.true249, label %if.else254

land.lhs.true249:                                 ; preds = %if.then245
  %317 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %318 = load i32, i32* %dst, align 4
  %319 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off250 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %319, i32 0, i32 2
  %320 = load i32, i32* %off250, align 8
  %call251 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %317, i32 noundef %318, i32 noundef %320, i32 noundef 1, i1 noundef zeroext false) #8
  %tobool252 = icmp ne i32 %call251, 0
  br i1 %tobool252, label %if.then253, label %if.else254

if.then253:                                       ; preds = %land.lhs.true249
  %321 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %322 = bitcast %struct.bpf_verifier_env* %321 to i8*
  %323 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %322, i8* noundef getelementptr inbounds ([77 x i8], [77 x i8]* @.str.137, i64 0, i64 0), i32 noundef %323) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.else254:                                       ; preds = %land.lhs.true249, %if.then245
  %324 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type255 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %324, i32 0, i32 0
  %325 = load i32, i32* %type255, align 8
  %cmp256 = icmp eq i32 %325, 6
  br i1 %cmp256, label %land.lhs.true258, label %if.end267

land.lhs.true258:                                 ; preds = %if.else254
  %326 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %327 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %328 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off259 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %328, i32 0, i32 2
  %329 = load i32, i32* %off259, align 8
  %conv260 = sext i32 %329 to i64
  %330 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off261 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %330, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off261, i32 0, i32 0
  %331 = load i64, i64* %value, align 8
  %add262 = add i64 %conv260, %331
  %conv263 = trunc i64 %add262 to i32
  %call264 = call i32 @check_stack_access(%struct.bpf_verifier_env* noundef %326, %struct.bpf_reg_state* noundef %327, i32 noundef %conv263, i32 noundef 1) #8
  %tobool265 = icmp ne i32 %call264, 0
  br i1 %tobool265, label %if.then266, label %if.end267

if.then266:                                       ; preds = %land.lhs.true258
  %332 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %333 = bitcast %struct.bpf_verifier_env* %332 to i8*
  %334 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %333, i8* noundef getelementptr inbounds ([70 x i8], [70 x i8]* @.str.138, i64 0, i64 0), i32 noundef %334) #8
  store i32 -13, i32* %retval, align 4
  br label %return

if.end267:                                        ; preds = %land.lhs.true258, %if.else254
  br label %if.end268

if.end268:                                        ; preds = %if.end267
  br label %if.end269

if.end269:                                        ; preds = %if.end268, %if.end242
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end269, %if.then266, %if.then253, %if.then241, %sw.default233, %sw.bb229, %if.then153, %if.then148, %if.then144, %if.then69, %if.then60, %cond.end, %sw.bb33, %sw.bb, %if.then28, %if.then
  %335 = load i32, i32* %retval, align 4
  ret i32 %335
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %known = alloca i8, align 1
  %val = alloca i64, align 8
  %smin = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #8
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  store i64 %9, i64* %smin, align 8
  %10 = load i8, i8* %known, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load i64, i64* %val, align 8
  %cmp = icmp sge i64 %11, 536870912
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load i64, i64* %val, align 8
  %cmp2 = icmp sle i64 %12, -536870912
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load i32, i32* %type.addr, align 4
  %idxprom = zext i32 %15 to i64
  %arrayidx = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %16 = load i8*, i8** %arrayidx, align 8
  %17 = load i64, i64* %val, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.139, i64 0, i64 0), i8* noundef %16, i64 noundef %17) #8
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %19 = load i32, i32* %off, align 8
  %cmp3 = icmp sge i32 %19, 536870912
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 2
  %21 = load i32, i32* %off5, align 8
  %cmp6 = icmp sle i32 %21, -536870912
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %type.addr, align 4
  %idxprom8 = zext i32 %24 to i64
  %arrayidx9 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom8
  %25 = load i8*, i8** %arrayidx9, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 2
  %27 = load i32, i32* %off10, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.140, i64 0, i64 0), i8* noundef %25, i32 noundef %27) #8
  store i1 false, i1* %retval, align 1
  br label %return

if.end11:                                         ; preds = %lor.lhs.false4
  %28 = load i64, i64* %smin, align 8
  %cmp12 = icmp eq i64 %28, -9223372036854775808
  br i1 %cmp12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %type.addr, align 4
  %idxprom14 = zext i32 %31 to i64
  %arrayidx15 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom14
  %32 = load i8*, i8** %arrayidx15, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.141, i64 0, i64 0), i8* noundef %32) #8
  store i1 false, i1* %retval, align 1
  br label %return

if.end16:                                         ; preds = %if.end11
  %33 = load i64, i64* %smin, align 8
  %cmp17 = icmp sge i64 %33, 536870912
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end16
  %34 = load i64, i64* %smin, align 8
  %cmp19 = icmp sle i64 %34, -536870912
  br i1 %cmp19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %lor.lhs.false18, %if.end16
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load i64, i64* %smin, align 8
  %38 = load i32, i32* %type.addr, align 4
  %idxprom21 = zext i32 %38 to i64
  %arrayidx22 = getelementptr [19 x i8*], [19 x i8*]* @reg_type_str, i64 0, i64 %idxprom21
  %39 = load i8*, i8** %arrayidx22, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.142, i64 0, i64 0), i64 noundef %37, i8* noundef %39) #8
  store i1 false, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %lor.lhs.false18
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end23, %if.then20, %if.then13, %if.then7, %if.then
  %40 = load i1, i1* %retval, align 1
  ret i1 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %dst_reg, i1 noundef zeroext %off_is_neg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_is_neg.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %ptr_is_dst_reg = alloca i8, align 1
  %opcode = alloca i8, align 1
  %alu_state = alloca i32, align 4
  %alu_limit = alloca i32, align 4
  %tmp = alloca %struct.bpf_reg_state, align 8
  %ret = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %frombool = zext i1 %off_is_neg to i8
  store i8 %frombool, i8* %off_is_neg.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %2) #8
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp = icmp eq %struct.bpf_reg_state* %3, %4
  %frombool1 = zext i1 %cmp to i8
  store i8 %frombool1, i8* %ptr_is_dst_reg, align 1
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %5, i32 0, i32 0
  %6 = load i8, i8* %code, align 4
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call3 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %7, %struct.bpf_insn* noundef %8) #8
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 6
  %10 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %do_sim

if.end5:                                          ; preds = %if.end
  %11 = load i8, i8* %off_is_neg.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  %12 = zext i1 %tobool6 to i64
  %cond = select i1 %tobool6, i32 4, i32 0
  store i32 %cond, i32* %alu_state, align 4
  %13 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool8 = trunc i8 %13 to i1
  %14 = zext i1 %tobool8 to i64
  %cond10 = select i1 %tobool8, i32 1, i32 2
  %15 = load i32, i32* %alu_state, align 4
  %or = or i32 %15, %cond10
  store i32 %or, i32* %alu_state, align 4
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %17 = load i8, i8* %opcode, align 1
  %18 = load i8, i8* %off_is_neg.addr, align 1
  %tobool11 = trunc i8 %18 to i1
  %call12 = call i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %16, i32* noundef %alu_limit, i8 noundef zeroext %17, i1 noundef zeroext %tobool11) #8
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end5
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end5
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %20 = load i32, i32* %alu_state, align 4
  %21 = load i32, i32* %alu_limit, align 4
  %call16 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %19, i32 noundef %20, i32 noundef %21) #8
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  store i32 -13, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end15
  br label %do_sim

do_sim:                                           ; preds = %if.end19, %if.then4
  %22 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool20 = trunc i8 %22 to i1
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %do_sim
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = bitcast %struct.bpf_reg_state* %tmp to i8*
  %25 = bitcast %struct.bpf_reg_state* %23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %25, i64 104, i1 false)
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %28 = bitcast %struct.bpf_reg_state* %26 to i8*
  %29 = bitcast %struct.bpf_reg_state* %27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %28, i8* align 8 %29, i64 104, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %do_sim
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 0
  %32 = load i32, i32* %insn_idx, align 8
  %add = add i32 %32, 1
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 0
  %34 = load i32, i32* %insn_idx23, align 8
  %call24 = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %30, i32 noundef %add, i32 noundef %34, i1 noundef zeroext true) #8
  %tobool25 = icmp ne %struct.bpf_verifier_state* %call24, null
  %frombool26 = zext i1 %tobool25 to i8
  store i8 %frombool26, i8* %ret, align 1
  %35 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool27 = trunc i8 %35 to i1
  br i1 %tobool27, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end22
  %36 = load i8, i8* %ret, align 1
  %tobool28 = trunc i8 %36 to i1
  br i1 %tobool28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %38 = bitcast %struct.bpf_reg_state* %37 to i8*
  %39 = bitcast %struct.bpf_reg_state* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %38, i8* align 8 %39, i64 104, i1 false)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %land.lhs.true, %if.end22
  %40 = load i8, i8* %ret, align 1
  %tobool32 = trunc i8 %40 to i1
  %lnot = xor i1 %tobool32, true
  %41 = zext i1 %lnot to i64
  %cond33 = select i1 %lnot, i32 -14, i32 0
  store i32 %cond33, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then18, %if.then14, %if.then
  %42 = load i32, i32* %retval, align 4
  ret i32 %42
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %ptr_reg, i32* noundef %ptr_limit, i8 noundef zeroext %opcode, i1 noundef zeroext %off_is_neg) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %ptr_limit.addr = alloca i32*, align 8
  %opcode.addr = alloca i8, align 1
  %off_is_neg.addr = alloca i8, align 1
  %mask_to_left = alloca i8, align 1
  %off = alloca i32, align 4
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store i32* %ptr_limit, i32** %ptr_limit.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %off_is_neg to i8
  store i8 %frombool, i8* %off_is_neg.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* %off_is_neg.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i8, i8* %opcode.addr, align 1
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 16
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %3 = load i8, i8* %off_is_neg.addr, align 1
  %tobool6 = trunc i8 %3 to i1
  %lnot = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %4 = phi i1 [ false, %lor.rhs ], [ %lnot, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %4, %land.end ]
  %frombool7 = zext i1 %5 to i8
  store i8 %frombool7, i8* %mask_to_left, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  switch i32 %7, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %lor.end
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 2
  %9 = load i32, i32* %off8, align 8
  %conv9 = sext i32 %9 to i64
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %add = add i64 %conv9, %11
  %conv10 = trunc i64 %add to i32
  store i32 %conv10, i32* %off, align 4
  %12 = load i8, i8* %mask_to_left, align 1
  %tobool11 = trunc i8 %12 to i1
  br i1 %tobool11, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %13 = load i32, i32* %off, align 4
  %add12 = add i32 512, %13
  %14 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %add12, i32* %14, align 4
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %15 = load i32, i32* %off, align 4
  %sub = sub i32 0, %15
  %16 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %sub, i32* %16, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %lor.end
  %17 = load i8, i8* %mask_to_left, align 1
  %tobool14 = trunc i8 %17 to i1
  br i1 %tobool14, label %if.then15, label %if.else20

if.then15:                                        ; preds = %sw.bb13
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 2
  %21 = load i32, i32* %off16, align 8
  %conv17 = sext i32 %21 to i64
  %add18 = add i64 %19, %conv17
  %conv19 = trunc i64 %add18 to i32
  %22 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %conv19, i32* %22, align 4
  br label %if.end26

if.else20:                                        ; preds = %sw.bb13
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 6
  %24 = load i64, i64* %smin_value, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 2
  %26 = load i32, i32* %off21, align 8
  %conv22 = sext i32 %26 to i64
  %add23 = add i64 %24, %conv22
  %conv24 = trunc i64 %add23 to i32
  store i32 %conv24, i32* %off, align 4
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 1
  %map_ptr = bitcast %union.anon.147* %28 to %struct.bpf_map**
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %29, i32 0, i32 5
  %30 = load i32, i32* %value_size, align 32
  %31 = load i32, i32* %off, align 4
  %sub25 = sub i32 %30, %31
  %32 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %sub25, i32* %32, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.else20, %if.then15
  store i32 0, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %lor.end
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.end26, %if.end
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.ethtool_pauseparam* @find_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off) #0 {
entry:
  %retval = alloca %struct.ethtool_pauseparam*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 7
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 29
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, i32* %insn_off.addr, align 4
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  %cmp = icmp uge i32 %6, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.ethtool_pauseparam* null, %struct.ethtool_pauseparam** %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 7
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 26
  %11 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo4, align 8
  store %struct.ethtool_pauseparam* %11, %struct.ethtool_pauseparam** %linfo, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %nr_linfo, align 4
  %cmp5 = icmp ult i32 %12, %13
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, i32* %insn_off.addr, align 4
  %15 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = zext i32 %16 to i64
  %arrayidx = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %15, i64 %idxprom
  %insn_off6 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx, i32 0, i32 0
  %17 = load i32, i32* %insn_off6, align 4
  %cmp7 = icmp ult i32 %14, %17
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  br label %for.end

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then8, %for.cond
  %19 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %sub = sub i32 %20, 1
  %idxprom10 = zext i32 %sub to i64
  %arrayidx11 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %19, i64 %idxprom10
  store %struct.ethtool_pauseparam* %arrayidx11, %struct.ethtool_pauseparam** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %21 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %retval, align 8
  ret %struct.ethtool_pauseparam* %21
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @btf_name_by_offset(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ltrim(i8* noundef %s) #0 {
entry:
  %s.addr = alloca i8*, align 8
  store i8* %s, i8** %s.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %s.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = zext i8 %1 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, 32
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %s.addr, align 8
  %incdec.ptr = getelementptr i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load i8*, i8** %s.addr, align 8
  ret i8* %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_liveness(%struct.bpf_verifier_env* noundef %env, i32 noundef %live) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %live.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %live, i32* %live.addr, align 4
  %0 = load i32, i32* %live.addr, align 4
  %and = and i32 %0, 15
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110, i64 0, i64 0)) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %live.addr, align 4
  %and1 = and i32 %3, 3
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i64 0, i64 0)) #8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %6 = load i32, i32* %live.addr, align 4
  %and5 = and i32 %6, 4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.112, i64 0, i64 0)) #8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %9 = load i32, i32* %live.addr, align 4
  %and9 = and i32 %9, 8
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.113, i64 0, i64 0)) #8
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 15
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 16
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @test_bit(i64 noundef %nr, i64* noundef %addr) #0 {
entry:
  %nr.addr.i4 = alloca i64, align 8
  %addr.addr.i5 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  store i64 %nr, i64* %nr.addr, align 8
  store i64* %addr, i64** %addr.addr, align 8
  %0 = load i64*, i64** %addr.addr, align 8
  %1 = load i64, i64* %nr.addr, align 8
  %div = sdiv i64 %1, 64
  %add.ptr = getelementptr i64, i64* %0, i64 %div
  %2 = bitcast i64* %add.ptr to i8*
  %call = call zeroext i1 @kasan_check_read(i8* noundef %2, i32 noundef 8) #8
  %3 = load i64, i64* %nr.addr, align 8
  %4 = call i1 @llvm.is.constant.i64(i64 %3)
  br i1 %4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, i64* %nr.addr, align 8
  %6 = load i64*, i64** %addr.addr, align 8
  store i64 %5, i64* %nr.addr.i, align 8
  store i64* %6, i64** %addr.addr.i, align 8
  %7 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %7, 63
  %shl.i = shl i64 1, %and.i
  %8 = load i64*, i64** %addr.addr.i, align 8
  %9 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %9, 6
  %arrayidx.i = getelementptr i64, i64* %8, i64 %shr.i
  %10 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %10
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv = zext i1 %cmp.i to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %11 = load i64, i64* %nr.addr, align 8
  %12 = load i64*, i64** %addr.addr, align 8
  store i64 %11, i64* %nr.addr.i4, align 8
  store i64* %12, i64** %addr.addr.i5, align 8
  %13 = load i64*, i64** %addr.addr.i5, align 8
  %14 = load i64, i64* %nr.addr.i4, align 8
  %15 = call i8 asm sideeffect " btq  $2,$1\0A\09/* output condition code c*/\0A", "={@ccc},*m,Ir,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* elementtype(i64) %13, i64 %14) #9, !srcloc !55
  store i8 %15, i8* %oldbit.i, align 1
  %16 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %16 to i1
  %conv3 = zext i1 %tobool.i to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %conv3, %cond.false ]
  %tobool = icmp ne i32 %cond, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @kasan_check_read(i8* noundef %p, i32 noundef %size) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  ret i1 true
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_tsk_thread_flag(%struct.task_struct* noundef %tsk, i32 noundef %flag) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %call = call %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %0) #8
  %1 = load i32, i32* %flag.addr, align 4
  %call1 = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %call, i32 noundef %1) #8
  ret i32 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %task) #0 {
entry:
  %task.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %task, %struct.task_struct** %task.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %task.addr, align 8
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 9
  %7 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %8 = load i32, i32* %idx.addr, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 1
  %10 = load i32, i32* %callsite, align 8
  %xor = xor i32 %8, %10
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %11) #8
  %rem = urem i32 %xor, %call
  %idxprom1 = zext i32 %rem to i64
  %arrayidx2 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %7, i64 %idxprom1
  ret %struct.bpf_verifier_state_list** %arrayidx2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_live_states(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca i32, align 4
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn, i32* %insn.addr, align 4
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %insn.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #8
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call, align 8
  store %struct.bpf_verifier_state_list* %2, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %next, %entry
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %4, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 2
  %5 = load i32, i32* %branches, align 8
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %next

if.end:                                           ; preds = %while.body
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state2 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %6, i32 0, i32 0
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state2, i32 0, i32 3
  %7 = load i32, i32* %insn_idx, align 4
  %8 = load i32, i32* %insn.addr, align 4
  %cmp = icmp ne i32 %7, %8
  br i1 %cmp, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state3 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %9, i32 0, i32 0
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state3, i32 0, i32 4
  %10 = load i32, i32* %curframe, align 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe4, align 8
  %cmp5 = icmp ne i32 %10, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  br label %next

if.end7:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe8, align 8
  %cmp9 = icmp ule i32 %13, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state10 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %16, i32 0, i32 0
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state10, i32 0, i32 0
  %17 = load i32, i32* %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 1
  %19 = load i32, i32* %callsite, align 8
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %21 to i64
  %arrayidx13 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame11, i64 0, i64 %idxprom12
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx13, align 8
  %callsite14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 1
  %23 = load i32, i32* %callsite14, align 8
  %cmp15 = icmp ne i32 %19, %23
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body
  br label %next

if.end17:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state18 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %26, i32 0, i32 0
  call void @clean_verifier_state(%struct.bpf_verifier_env* noundef %25, %struct.bpf_verifier_state* noundef %state18) #8
  br label %next

next:                                             ; preds = %for.end, %if.then16, %if.then6, %if.then
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next19 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %27, i32 0, i32 1
  %28 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next19, align 8
  store %struct.bpf_verifier_state_list* %28, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %fold = alloca %struct.bpf_func_state*, align 8
  %fcur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %fr = alloca i32, align 4
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  store i32 %1, i32* %fr, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %4 = load i32, i32* %fr, align 4
  %cmp = icmp ne i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load i32, i32* %fr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %7, %struct.bpf_func_state** %fold, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 0
  %9 = load i32, i32* %fr, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom3
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %fcur, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %11, 11
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fold, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  %14 = bitcast %struct.bpf_reg_state* %arrayidx7 to i8*
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fcur, align 8
  %regs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs8, i64 0, i64 %idxprom9
  %17 = bitcast %struct.bpf_reg_state* %arrayidx10 to i8*
  %call = call i32 @memcmp(i8* noundef %14, i8* noundef %17, i64 noundef 80) #8
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end12:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then11, %if.then
  %19 = load i1, i1* %retval, align 1
  ret i1 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 6
  %5 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %speculative2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 6
  %7 = load i8, i8* %speculative2, align 8
  %tobool3 = trunc i8 %7 to i1
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 5
  %9 = load i32, i32* %active_spin_lock, align 4
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %active_spin_lock6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 5
  %11 = load i32, i32* %active_spin_lock6, align 4
  %cmp7 = icmp ne i32 %9, %11
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store i1 false, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end5
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe10, align 8
  %cmp11 = icmp ule i32 %12, %14
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 1
  %18 = load i32, i32* %callsite, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame12 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %20 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame12, i64 0, i64 %idxprom13
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx14, align 8
  %callsite15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 1
  %22 = load i32, i32* %callsite15, align 8
  %cmp16 = icmp ne i32 %18, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end18:                                         ; preds = %for.body
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame19 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %24 to i64
  %arrayidx21 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame19, i64 0, i64 %idxprom20
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx21, align 8
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %26, i32 0, i32 0
  %27 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %27 to i64
  %arrayidx24 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame22, i64 0, i64 %idxprom23
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx24, align 8
  %call = call zeroext i1 @func_states_equal(%struct.bpf_func_state* noundef %25, %struct.bpf_func_state* noundef %28) #8
  br i1 %call, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i1 false, i1* %retval, align 1
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %29 = load i32, i32* %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then25, %if.then17, %if.then8, %if.then4, %if.then
  %30 = load i1, i1* %retval, align 1
  ret i1 %30
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %vstate, %struct.bpf_verifier_state* noundef %vparent) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %vparent.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %parent_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %parent = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %frame = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %vparent, %struct.bpf_verifier_state** %vparent.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_on, align 4
  %4 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 4
  %6 = load i32, i32* %curframe5, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe6, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.72, i64 0, i64 0), i32 noundef %6, i32 noundef %8) #8
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.body8

do.body8:                                         ; preds = %do.body7
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9072, i32 2313, i64 12) #9, !srcloc !56
  br label %do.end

do.end:                                           ; preds = %do.body8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 217) #9, !srcloc !57
  br label %do.end9

do.end9:                                          ; preds = %do.end
  br label %do.end10

do.end10:                                         ; preds = %do.end9
  br label %if.end

if.end:                                           ; preds = %do.end10, %if.then
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool11 = icmp ne i32 %9, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  store i64 %conv16, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %entry
  br label %do.body18

do.body18:                                        ; preds = %if.end17
  br label %do.end19

do.end19:                                         ; preds = %do.body18
  store i32 0, i32* %frame, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc72, %do.end19
  %11 = load i32, i32* %frame, align 4
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe20 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 4
  %13 = load i32, i32* %curframe20, align 8
  %cmp21 = icmp ule i32 %11, %13
  br i1 %cmp21, label %for.body, label %for.end74

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %frame23 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 0
  %15 = load i32, i32* %frame, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame23, i64 0, i64 %idxprom
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %16, %struct.bpf_func_state** %parent, align 8
  %17 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %17, i32 0, i32 0
  %18 = load i32, i32* %frame, align 4
  %idxprom25 = sext i32 %18 to i64
  %arrayidx26 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame24, i64 0, i64 %idxprom25
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx26, align 8
  store %struct.bpf_func_state* %19, %struct.bpf_func_state** %state, align 8
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %20, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %parent_reg, align 8
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 0
  %arraydecay28 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs27, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay28, %struct.bpf_reg_state** %state_reg, align 8
  %22 = load i32, i32* %frame, align 4
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe29 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe29, align 8
  %cmp30 = icmp ult i32 %22, %24
  %25 = zext i1 %cmp30 to i64
  %cond = select i1 %cmp30, i32 6, i32 0
  store i32 %cond, i32* %i, align 4
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc, %for.body
  %26 = load i32, i32* %i, align 4
  %cmp33 = icmp slt i32 %26, 10
  br i1 %cmp33, label %for.body35, label %for.end

for.body35:                                       ; preds = %for.cond32
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %29 to i64
  %arrayidx37 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom36
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom38 = sext i32 %31 to i64
  %arrayidx39 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i64 %idxprom38
  %call = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %arrayidx37, %struct.bpf_reg_state* noundef %arrayidx39) #8
  store i32 %call, i32* %err, align 4
  %32 = load i32, i32* %err, align 4
  %cmp40 = icmp slt i32 %32, 0
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %for.body35
  %33 = load i32, i32* %err, align 4
  store i32 %33, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %for.body35
  %34 = load i32, i32* %err, align 4
  %cmp44 = icmp eq i32 %34, 2
  br i1 %cmp44, label %if.then46, label %if.end49

if.then46:                                        ; preds = %if.end43
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %37 = load i32, i32* %i, align 4
  %idxprom47 = sext i32 %37 to i64
  %arrayidx48 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i64 %idxprom47
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %35, %struct.bpf_reg_state* noundef %arrayidx48) #8
  br label %if.end49

if.end49:                                         ; preds = %if.then46, %if.end43
  br label %for.inc

for.inc:                                          ; preds = %if.end49
  %38 = load i32, i32* %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond32

for.end:                                          ; preds = %for.cond32
  store i32 0, i32* %i, align 4
  br label %for.cond50

for.cond50:                                       ; preds = %for.inc69, %for.end
  %39 = load i32, i32* %i, align 4
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 6
  %41 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %41, 8
  %cmp51 = icmp slt i32 %39, %div
  br i1 %cmp51, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond50
  %42 = load i32, i32* %i, align 4
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %allocated_stack53 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %43, i32 0, i32 6
  %44 = load i32, i32* %allocated_stack53, align 8
  %div54 = sdiv i32 %44, 8
  %cmp55 = icmp slt i32 %42, %div54
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond50
  %45 = phi i1 [ false, %for.cond50 ], [ %cmp55, %land.rhs ]
  br i1 %45, label %for.body57, label %for.end71

for.body57:                                       ; preds = %land.end
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 7
  %47 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %48 = load i32, i32* %i, align 4
  %idxprom58 = sext i32 %48 to i64
  %arrayidx59 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %47, i64 %idxprom58
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx59, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %parent_reg, align 8
  %49 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack60 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %49, i32 0, i32 7
  %50 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack60, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom61 = sext i32 %51 to i64
  %arrayidx62 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %50, i64 %idxprom61
  %spilled_ptr63 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx62, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr63, %struct.bpf_reg_state** %state_reg, align 8
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %call64 = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %52, %struct.bpf_reg_state* noundef %53, %struct.bpf_reg_state* noundef %54) #8
  store i32 %call64, i32* %err, align 4
  %55 = load i32, i32* %err, align 4
  %cmp65 = icmp slt i32 %55, 0
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %for.body57
  %56 = load i32, i32* %err, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %for.body57
  br label %for.inc69

for.inc69:                                        ; preds = %if.end68
  %57 = load i32, i32* %i, align 4
  %inc70 = add i32 %57, 1
  store i32 %inc70, i32* %i, align 4
  br label %for.cond50

for.end71:                                        ; preds = %land.end
  br label %for.inc72

for.inc72:                                        ; preds = %for.end71
  %58 = load i32, i32* %frame, align 4
  %inc73 = add i32 %58, 1
  store i32 %inc73, i32* %frame, align 4
  br label %for.cond

for.end74:                                        ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end74, %if.then67, %if.then42, %if.end
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %cnt = alloca i32, align 4
  %p = alloca %struct.util_est*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 10
  %1 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %cnt, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %5 = bitcast %struct.util_est* %4 to i8*
  %6 = load i32, i32* %cnt, align 4
  %conv = zext i32 %6 to i64
  %mul = mul i64 %conv, 8
  %call = call i8* @krealloc(i8* noundef %5, i64 noundef %mul, i32 noundef 1051840) #8
  %7 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %7, %struct.util_est** %p, align 8
  %8 = load %struct.util_est*, %struct.util_est** %p, align 8
  %tobool = icmp ne %struct.util_est* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 0
  %10 = load i32, i32* %insn_idx, align 8
  %11 = load %struct.util_est*, %struct.util_est** %p, align 8
  %12 = load i32, i32* %cnt, align 4
  %sub = sub i32 %12, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %11, i64 %idxprom
  %idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 1
  store i32 %10, i32* %idx, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 1
  %14 = load i32, i32* %prev_insn_idx, align 4
  %15 = load %struct.util_est*, %struct.util_est** %p, align 8
  %16 = load i32, i32* %cnt, align 4
  %sub1 = sub i32 %16, 1
  %idxprom2 = zext i32 %sub1 to i64
  %arrayidx3 = getelementptr %struct.util_est, %struct.util_est* %15, i64 %idxprom2
  %prev_idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx3, i32 0, i32 0
  store i32 %14, i32* %prev_idx, align 4
  %17 = load %struct.util_est*, %struct.util_est** %p, align 8
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 9
  store %struct.util_est* %17, %struct.util_est** %jmp_history4, align 8
  %19 = load i32, i32* %cnt, align 4
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 10
  store i32 %19, i32* %jmp_history_cnt5, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_precision(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %state_reg, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %5, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp ne i32 %7, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 14
  %9 = load i8, i8* %precise, align 4
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 18
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %11 = load i32, i32* %level, align 8
  %and = and i32 %11, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.74, i64 0, i64 0), i32 noundef %14) #8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load i32, i32* %i, align 4
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %15, i32 noundef %16) #8
  store i32 %call, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %cmp5 = icmp slt i32 %17, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %18 = load i32, i32* %err, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then
  %19 = load i32, i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %incdec.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 1
  store %struct.bpf_reg_state* %incdec.ptr, %struct.bpf_reg_state** %state_reg, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc41, %for.end
  %21 = load i32, i32* %i, align 4
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 6
  %23 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %23, 8
  %cmp9 = icmp slt i32 %21, %div
  br i1 %cmp9, label %for.body10, label %for.end43

for.body10:                                       ; preds = %for.cond8
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %24, i32 0, i32 7
  %25 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %26 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %25, i64 %idxprom11
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 1
  %arrayidx13 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %27 = load i8, i8* %arrayidx13, align 8
  %conv = zext i8 %27 to i32
  %cmp14 = icmp ne i32 %conv, 1
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body10
  br label %for.inc41

if.end17:                                         ; preds = %for.body10
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 7
  %29 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack18, align 8
  %30 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %30 to i64
  %arrayidx20 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %29, i64 %idxprom19
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx20, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %state_reg, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 0
  %32 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %32, 1
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %if.end17
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 14
  %34 = load i8, i8* %precise25, align 4
  %tobool26 = trunc i8 %34 to i1
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %lor.lhs.false24, %if.end17
  br label %for.inc41

if.end28:                                         ; preds = %lor.lhs.false24
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 18
  %level30 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log29, i32 0, i32 0
  %36 = load i32, i32* %level30, align 8
  %and31 = and i32 %36, 2
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end28
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load i32, i32* %i, align 4
  %sub = sub i32 0, %39
  %sub34 = sub i32 %sub, 1
  %mul = mul i32 %sub34, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.75, i64 0, i64 0), i32 noundef %mul) #8
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end28
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load i32, i32* %i, align 4
  %call36 = call i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %40, i32 noundef %41) #8
  store i32 %call36, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %cmp37 = icmp slt i32 %42, 0
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end35
  br label %for.inc41

for.inc41:                                        ; preds = %if.end40, %if.then27, %if.then16
  %44 = load i32, i32* %i, align 4
  %inc42 = add i32 %44, 1
  store i32 %inc42, i32* %i, align 4
  br label %for.cond8

for.end43:                                        ; preds = %for.cond8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end43, %if.then39, %if.then6
  %45 = load i32, i32* %retval, align 4
  ret i32 %45
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %spi) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %spi.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %spi.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef -1, i32 noundef %1) #8
  ret i32 %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @krealloc(i8* noundef, i64 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, %struct.bpf_reg_state* noundef %parent_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_flag = alloca i8, align 1
  %flag = alloca i8, align 1
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store %struct.bpf_reg_state* %parent_reg, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 13
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %parent_flag, align 1
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 13
  %3 = load i32, i32* %live1, align 8
  %and2 = and i32 %3, 3
  %conv3 = trunc i32 %and2 to i8
  store i8 %conv3, i8* %flag, align 1
  %4 = load i8, i8* %parent_flag, align 1
  %conv4 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv4, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8, i8* %flag, align 1
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %lor.lhs.false6, label %if.then

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %6 = load i8, i8* %parent_flag, align 1
  %conv7 = zext i8 %6 to i32
  %7 = load i8, i8* %flag, align 1
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp eq i32 %conv7, %conv8
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false6, %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false6
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %11 = load i8, i8* %flag, align 1
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %9, %struct.bpf_reg_state* noundef %10, i8 noundef zeroext %11) #8
  store i32 %call, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end
  %14 = load i8, i8* %flag, align 1
  %conv14 = zext i8 %14 to i32
  store i32 %conv14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @func_states_equal(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %idmap = alloca %struct.util_est*, align 8
  %ret = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  store i8 0, i8* %ret, align 1
  %call = call i8* @kcalloc(i64 noundef 75, i64 noundef 8, i32 noundef 3264) #8
  %0 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %0, %struct.util_est** %idmap, align 8
  %1 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %tobool = icmp ne %struct.util_est* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %2, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %6 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 %idxprom2
  %7 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %call4 = call zeroext i1 @regsafe(%struct.bpf_reg_state* noundef %arrayidx, %struct.bpf_reg_state* noundef %arrayidx3, %struct.util_est* noundef %7) #8
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %for.body
  br label %out_free

if.end6:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %11 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %call7 = call zeroext i1 @stacksafe(%struct.bpf_func_state* noundef %9, %struct.bpf_func_state* noundef %10, %struct.util_est* noundef %11) #8
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %for.end
  br label %out_free

if.end9:                                          ; preds = %for.end
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %call10 = call zeroext i1 @refsafe(%struct.bpf_func_state* noundef %12, %struct.bpf_func_state* noundef %13) #8
  br i1 %call10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  br label %out_free

if.end12:                                         ; preds = %if.end9
  store i8 1, i8* %ret, align 1
  br label %out_free

out_free:                                         ; preds = %if.end12, %if.then11, %if.then8, %if.then5
  %14 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %15 = bitcast %struct.util_est* %14 to i8*
  call void @kfree(i8* noundef %15) #8
  %16 = load i8, i8* %ret, align 1
  %tobool13 = trunc i8 %16 to i1
  store i1 %tobool13, i1* %retval, align 1
  br label %return

return:                                           ; preds = %out_free, %if.then
  %17 = load i1, i1* %retval, align 1
  ret i1 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @regsafe(%struct.bpf_reg_state* noundef %rold, %struct.bpf_reg_state* noundef %rcur, %struct.util_est* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %rold.addr = alloca %struct.bpf_reg_state*, align 8
  %rcur.addr = alloca %struct.bpf_reg_state*, align 8
  %idmap.addr = alloca %struct.util_est*, align 8
  %equal = alloca i8, align 1
  store %struct.bpf_reg_state* %rold, %struct.bpf_reg_state** %rold.addr, align 8
  store %struct.bpf_reg_state* %rcur, %struct.bpf_reg_state** %rcur.addr, align 8
  store %struct.util_est* %idmap, %struct.util_est** %idmap.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 13
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %3 = bitcast %struct.bpf_reg_state* %2 to i8*
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %5 = bitcast %struct.bpf_reg_state* %4 to i8*
  %call = call i32 @memcmp(i8* noundef %3, i8* noundef %5, i64 noundef 80) #8
  %cmp = icmp eq i32 %call, 0
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %equal, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp eq i32 %7, 6
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %8 = load i8, i8* %equal, align 1
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 11
  %10 = load i32, i32* %frameno, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %frameno4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %frameno4, align 8
  %cmp5 = icmp eq i32 %10, %12
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then2
  %13 = phi i1 [ false, %if.then2 ], [ %cmp5, %land.rhs ]
  store i1 %13, i1* %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.end
  %14 = load i8, i8* %equal, align 1
  %tobool7 = trunc i8 %14 to i1
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store i1 true, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end6
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type10, align 8
  %cmp11 = icmp eq i32 %16, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i1 true, i1* %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end9
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %18, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %if.end13
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type18, align 8
  switch i32 %20, label %sw.default [
    i32 1, label %sw.bb
    i32 4, label %sw.bb32
    i32 5, label %sw.bb42
    i32 7, label %sw.bb53
    i32 8, label %sw.bb53
    i32 2, label %sw.bb86
    i32 3, label %sw.bb86
    i32 9, label %sw.bb86
    i32 10, label %sw.bb86
    i32 11, label %sw.bb86
    i32 12, label %sw.bb86
    i32 13, label %sw.bb86
    i32 14, label %sw.bb86
    i32 15, label %sw.bb86
    i32 16, label %sw.bb86
    i32 18, label %sw.bb86
  ]

sw.bb:                                            ; preds = %if.end17
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type19, align 8
  %cmp20 = icmp eq i32 %22, 1
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %sw.bb
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 14
  %24 = load i8, i8* %precise, align 4
  %tobool22 = trunc i8 %24 to i1
  br i1 %tobool22, label %if.end26, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then21
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %precise23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 14
  %26 = load i8, i8* %precise23, align 4
  %tobool24 = trunc i8 %26 to i1
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %if.then21
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call27 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %27, %struct.bpf_reg_state* noundef %28) #8
  br i1 %call27, label %land.rhs28, label %land.end31

land.rhs28:                                       ; preds = %if.end26
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 5
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %36 = bitcast %struct.tnum* %var_off29 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call30 = call zeroext i1 @tnum_in(i64 %33, i64 %35, i64 %38, i64 %40) #8
  br label %land.end31

land.end31:                                       ; preds = %land.rhs28, %if.end26
  %41 = phi i1 [ false, %if.end26 ], [ %call30, %land.rhs28 ]
  store i1 %41, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

sw.bb32:                                          ; preds = %if.end17
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %43 = bitcast %struct.bpf_reg_state* %42 to i8*
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %45 = bitcast %struct.bpf_reg_state* %44 to i8*
  %call33 = call i32 @memcmp(i8* noundef %43, i8* noundef %45, i64 noundef 20) #8
  %cmp34 = icmp eq i32 %call33, 0
  br i1 %cmp34, label %land.lhs.true35, label %land.end41

land.lhs.true35:                                  ; preds = %sw.bb32
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call36 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %46, %struct.bpf_reg_state* noundef %47) #8
  br i1 %call36, label %land.rhs37, label %land.end41

land.rhs37:                                       ; preds = %land.lhs.true35
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off38 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 5
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 5
  %50 = bitcast %struct.tnum* %var_off38 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %55 = bitcast %struct.tnum* %var_off39 to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = load i64, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = load i64, i64* %58, align 8
  %call40 = call zeroext i1 @tnum_in(i64 %52, i64 %54, i64 %57, i64 %59) #8
  br label %land.end41

land.end41:                                       ; preds = %land.rhs37, %land.lhs.true35, %sw.bb32
  %60 = phi i1 [ false, %land.lhs.true35 ], [ false, %sw.bb32 ], [ %call40, %land.rhs37 ]
  store i1 %60, i1* %retval, align 1
  br label %return

sw.bb42:                                          ; preds = %if.end17
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type43, align 8
  %cmp44 = icmp ne i32 %62, 5
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %sw.bb42
  store i1 false, i1* %retval, align 1
  br label %return

if.end46:                                         ; preds = %sw.bb42
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %64 = bitcast %struct.bpf_reg_state* %63 to i8*
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %66 = bitcast %struct.bpf_reg_state* %65 to i8*
  %call47 = call i32 @memcmp(i8* noundef %64, i8* noundef %66, i64 noundef 20) #8
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end46
  store i1 false, i1* %retval, align 1
  br label %return

if.end50:                                         ; preds = %if.end46
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 3
  %68 = load i32, i32* %id, align 4
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 3
  %70 = load i32, i32* %id51, align 4
  %71 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %call52 = call zeroext i1 @check_ids(i32 noundef %68, i32 noundef %70, %struct.util_est* noundef %71) #8
  store i1 %call52, i1* %retval, align 1
  br label %return

sw.bb53:                                          ; preds = %if.end17, %if.end17
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 0
  %73 = load i32, i32* %type54, align 8
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 0
  %75 = load i32, i32* %type55, align 8
  %cmp56 = icmp ne i32 %73, %75
  br i1 %cmp56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %sw.bb53
  store i1 false, i1* %retval, align 1
  br label %return

if.end58:                                         ; preds = %sw.bb53
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 1
  %range = bitcast %union.anon.147* %77 to i16*
  %78 = load i16, i16* %range, align 8
  %conv = zext i16 %78 to i32
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %79, i32 0, i32 1
  %range59 = bitcast %union.anon.147* %80 to i16*
  %81 = load i16, i16* %range59, align 8
  %conv60 = zext i16 %81 to i32
  %cmp61 = icmp sgt i32 %conv, %conv60
  br i1 %cmp61, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end58
  store i1 false, i1* %retval, align 1
  br label %return

if.end64:                                         ; preds = %if.end58
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 2
  %83 = load i32, i32* %off, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 2
  %85 = load i32, i32* %off65, align 8
  %cmp66 = icmp ne i32 %83, %85
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end64
  store i1 false, i1* %retval, align 1
  br label %return

if.end69:                                         ; preds = %if.end64
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 3
  %87 = load i32, i32* %id70, align 4
  %tobool71 = icmp ne i32 %87, 0
  br i1 %tobool71, label %land.lhs.true72, label %if.end77

land.lhs.true72:                                  ; preds = %if.end69
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 3
  %89 = load i32, i32* %id73, align 4
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 3
  %91 = load i32, i32* %id74, align 4
  %92 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %call75 = call zeroext i1 @check_ids(i32 noundef %89, i32 noundef %91, %struct.util_est* noundef %92) #8
  br i1 %call75, label %if.end77, label %if.then76

if.then76:                                        ; preds = %land.lhs.true72
  store i1 false, i1* %retval, align 1
  br label %return

if.end77:                                         ; preds = %land.lhs.true72, %if.end69
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call78 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94) #8
  br i1 %call78, label %land.rhs80, label %land.end85

land.rhs80:                                       ; preds = %if.end77
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 5
  %97 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %98 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %97, i32 0, i32 0
  %99 = load i64, i64* %98, align 8
  %100 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %97, i32 0, i32 1
  %101 = load i64, i64* %100, align 8
  %102 = bitcast %struct.tnum* %var_off82 to { i64, i64 }*
  %103 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %102, i32 0, i32 0
  %104 = load i64, i64* %103, align 8
  %105 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %102, i32 0, i32 1
  %106 = load i64, i64* %105, align 8
  %call83 = call zeroext i1 @tnum_in(i64 %99, i64 %101, i64 %104, i64 %106) #8
  br label %land.end85

land.end85:                                       ; preds = %land.rhs80, %if.end77
  %107 = phi i1 [ false, %if.end77 ], [ %call83, %land.rhs80 ]
  store i1 %107, i1* %retval, align 1
  br label %return

sw.bb86:                                          ; preds = %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17
  br label %sw.default

sw.default:                                       ; preds = %sw.bb86, %if.end17
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %land.end85, %if.then76, %if.then68, %if.then63, %if.then57, %if.end50, %if.then49, %if.then45, %land.end41, %if.else, %land.end31, %if.then25, %if.then16, %if.then12, %if.then8, %land.end, %if.then
  %108 = load i1, i1* %retval, align 1
  ret i1 %108
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @stacksafe(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur, %struct.util_est* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %idmap.addr = alloca %struct.util_est*, align 8
  %i = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  store %struct.util_est* %idmap, %struct.util_est** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 6
  %2 = load i32, i32* %allocated_stack, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %i, align 4
  %div = sdiv i32 %3, 8
  store i32 %div, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 7
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %5, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 13
  %7 = load i32, i32* %live, align 8
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add = add i32 %8, 7
  store i32 %add, i32* %i, align 4
  br label %for.inc

if.end:                                           ; preds = %for.body
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 7
  %10 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %11 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %11 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %10, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %12 = load i32, i32* %i, align 4
  %rem = srem i32 %12, 8
  %idxprom4 = sext i32 %rem to i64
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom4
  %13 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %13 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  br label %for.inc

if.end9:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %allocated_stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 6
  %16 = load i32, i32* %allocated_stack10, align 8
  %cmp11 = icmp sge i32 %14, %16
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  store i1 false, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.end9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 7
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %19 = load i32, i32* %spi, align 4
  %idxprom16 = sext i32 %19 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom16
  %slot_type18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 1
  %20 = load i32, i32* %i, align 4
  %rem19 = srem i32 %20, 8
  %idxprom20 = sext i32 %rem19 to i64
  %arrayidx21 = getelementptr [8 x i8], [8 x i8]* %slot_type18, i64 0, i64 %idxprom20
  %21 = load i8, i8* %arrayidx21, align 1
  %conv22 = zext i8 %21 to i32
  %cmp23 = icmp eq i32 %conv22, 2
  br i1 %cmp23, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.end14
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 7
  %23 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %24 = load i32, i32* %spi, align 4
  %idxprom26 = sext i32 %24 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %23, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %25 = load i32, i32* %i, align 4
  %rem29 = srem i32 %25, 8
  %idxprom30 = sext i32 %rem29 to i64
  %arrayidx31 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 %idxprom30
  %26 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %26 to i32
  %cmp33 = icmp eq i32 %conv32, 3
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end36:                                         ; preds = %land.lhs.true, %if.end14
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 7
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack37, align 8
  %29 = load i32, i32* %spi, align 4
  %idxprom38 = sext i32 %29 to i64
  %arrayidx39 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom38
  %slot_type40 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx39, i32 0, i32 1
  %30 = load i32, i32* %i, align 4
  %rem41 = srem i32 %30, 8
  %idxprom42 = sext i32 %rem41 to i64
  %arrayidx43 = getelementptr [8 x i8], [8 x i8]* %slot_type40, i64 0, i64 %idxprom42
  %31 = load i8, i8* %arrayidx43, align 1
  %conv44 = zext i8 %31 to i32
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack45 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 7
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack45, align 8
  %34 = load i32, i32* %spi, align 4
  %idxprom46 = sext i32 %34 to i64
  %arrayidx47 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom46
  %slot_type48 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx47, i32 0, i32 1
  %35 = load i32, i32* %i, align 4
  %rem49 = srem i32 %35, 8
  %idxprom50 = sext i32 %rem49 to i64
  %arrayidx51 = getelementptr [8 x i8], [8 x i8]* %slot_type48, i64 0, i64 %idxprom50
  %36 = load i8, i8* %arrayidx51, align 1
  %conv52 = zext i8 %36 to i32
  %cmp53 = icmp ne i32 %conv44, %conv52
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end36
  store i1 false, i1* %retval, align 1
  br label %return

if.end56:                                         ; preds = %if.end36
  %37 = load i32, i32* %i, align 4
  %rem57 = srem i32 %37, 8
  %tobool58 = icmp ne i32 %rem57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end56
  br label %for.inc

if.end60:                                         ; preds = %if.end56
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 7
  %39 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack61, align 8
  %40 = load i32, i32* %spi, align 4
  %idxprom62 = sext i32 %40 to i64
  %arrayidx63 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %39, i64 %idxprom62
  %slot_type64 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx63, i32 0, i32 1
  %arrayidx65 = getelementptr [8 x i8], [8 x i8]* %slot_type64, i64 0, i64 0
  %41 = load i8, i8* %arrayidx65, align 8
  %conv66 = zext i8 %41 to i32
  %cmp67 = icmp ne i32 %conv66, 1
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end60
  br label %for.inc

if.end70:                                         ; preds = %if.end60
  %42 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack71 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %42, i32 0, i32 7
  %43 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack71, align 8
  %44 = load i32, i32* %spi, align 4
  %idxprom72 = sext i32 %44 to i64
  %arrayidx73 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %43, i64 %idxprom72
  %spilled_ptr74 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx73, i32 0, i32 0
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack75 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 7
  %46 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack75, align 8
  %47 = load i32, i32* %spi, align 4
  %idxprom76 = sext i32 %47 to i64
  %arrayidx77 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %46, i64 %idxprom76
  %spilled_ptr78 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx77, i32 0, i32 0
  %48 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %call = call zeroext i1 @regsafe(%struct.bpf_reg_state* noundef %spilled_ptr74, %struct.bpf_reg_state* noundef %spilled_ptr78, %struct.util_est* noundef %48) #8
  br i1 %call, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.end70
  store i1 false, i1* %retval, align 1
  br label %return

if.end80:                                         ; preds = %if.end70
  br label %for.inc

for.inc:                                          ; preds = %if.end80, %if.then69, %if.then59, %if.then35, %if.then8, %if.then
  %49 = load i32, i32* %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then79, %if.then55, %if.then13
  %50 = load i1, i1* %retval, align 1
  ret i1 %50
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @refsafe(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 4
  %1 = load i32, i32* %acquired_refs, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 4
  %3 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 5
  %5 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %6 = bitcast %struct.util_est* %5 to i8*
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 5
  %8 = load %struct.util_est*, %struct.util_est** %refs2, align 8
  %9 = bitcast %struct.util_est* %8 to i8*
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 4
  %11 = load i32, i32* %acquired_refs3, align 4
  %conv = sext i32 %11 to i64
  %mul = mul i64 8, %conv
  %call = call i32 @memcmp(i8* noundef %6, i8* noundef %9, i64 noundef %mul) #8
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @range_within(%struct.bpf_reg_state* noundef %old, %struct.bpf_reg_state* noundef %cur) #0 {
entry:
  %old.addr = alloca %struct.bpf_reg_state*, align 8
  %cur.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %old, %struct.bpf_reg_state** %old.addr, align 8
  store %struct.bpf_reg_state* %cur, %struct.bpf_reg_state** %cur.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  %cmp = icmp ule i64 %1, %3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value2, align 8
  %cmp3 = icmp uge i64 %5, %7
  br i1 %cmp3, label %land.lhs.true4, label %land.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value5, align 8
  %cmp6 = icmp sle i64 %9, %11
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  %15 = load i64, i64* %smax_value7, align 8
  %cmp8 = icmp sge i64 %13, %15
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true4, %land.lhs.true, %entry
  %16 = phi i1 [ false, %land.lhs.true4 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp8, %land.rhs ]
  ret i1 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_ids(i32 noundef %old_id, i32 noundef %cur_id, %struct.util_est* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %old_id.addr = alloca i32, align 4
  %cur_id.addr = alloca i32, align 4
  %idmap.addr = alloca %struct.util_est*, align 8
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %old_id, i32* %old_id.addr, align 4
  store i32 %cur_id, i32* %cur_id.addr, align 4
  store %struct.util_est* %idmap, %struct.util_est** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %0, 75
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %2 = load i32, i32* %i, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %1, i64 %idxprom
  %old = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  %3 = load i32, i32* %old, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %4 = load i32, i32* %old_id.addr, align 4
  %5 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = zext i32 %6 to i64
  %arrayidx2 = getelementptr %struct.util_est, %struct.util_est* %5, i64 %idxprom1
  %old3 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx2, i32 0, i32 0
  store i32 %4, i32* %old3, align 4
  %7 = load i32, i32* %cur_id.addr, align 4
  %8 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom4 = zext i32 %9 to i64
  %arrayidx5 = getelementptr %struct.util_est, %struct.util_est* %8, i64 %idxprom4
  %cur = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx5, i32 0, i32 1
  store i32 %7, i32* %cur, align 4
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  %10 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom6 = zext i32 %11 to i64
  %arrayidx7 = getelementptr %struct.util_est, %struct.util_est* %10, i64 %idxprom6
  %old8 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx7, i32 0, i32 0
  %12 = load i32, i32* %old8, align 4
  %13 = load i32, i32* %old_id.addr, align 4
  %cmp9 = icmp eq i32 %12, %13
  br i1 %cmp9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end
  %14 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %15 to i64
  %arrayidx12 = getelementptr %struct.util_est, %struct.util_est* %14, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx12, i32 0, i32 1
  %16 = load i32, i32* %cur13, align 4
  %17 = load i32, i32* %cur_id.addr, align 4
  %cmp14 = icmp eq i32 %16, %17
  store i1 %cmp14, i1* %retval, align 1
  br label %return

if.end15:                                         ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %__ret_warn_on, align 4
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %19, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool18 = icmp ne i64 %conv, 0
  br i1 %tobool18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %for.end
  br label %do.body

do.body:                                          ; preds = %if.then19
  br label %do.body20

do.body20:                                        ; preds = %do.body
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 8652, i32 2307, i64 12) #9, !srcloc !58
  br label %do.end

do.end:                                           ; preds = %do.body20
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 215) #9, !srcloc !59
  br label %do.end21

do.end21:                                         ; preds = %do.end
  br label %if.end22

if.end22:                                         ; preds = %do.end21, %for.end
  %20 = load i32, i32* %__ret_warn_on, align 4
  %tobool23 = icmp ne i32 %20, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  store i64 %conv28, i64* %tmp, align 8
  %21 = load i64, i64* %tmp, align 8
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end22, %if.then10, %if.then
  %22 = load i1, i1* %retval, align 1
  ret i1 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx1, i32 0, i32 13
  %2 = load i32, i32* %live, align 8
  %and = and i32 %2, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 4
  %5 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx3, align 8
  call void @clean_func_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %9) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_func_state*, align 8
  %live = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %st, %struct.bpf_func_state** %st.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 13
  %3 = load i32, i32* %live1, align 8
  store i32 %3, i32* %live, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 %idxprom3
  %live5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 13
  %6 = load i32, i32* %live5, align 8
  %or = or i32 %6, 8
  store i32 %or, i32* %live5, align 8
  %7 = load i32, i32* %live, align 4
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %9 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %9 to i64
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs6, i64 0, i64 %idxprom7
  call void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %arrayidx8) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc40, %for.end
  %11 = load i32, i32* %i, align 4
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 6
  %13 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %13, 8
  %cmp10 = icmp slt i32 %11, %div
  br i1 %cmp10, label %for.body11, label %for.end42

for.body11:                                       ; preds = %for.cond9
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %16 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %15, i64 %idxprom12
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 0
  %live14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 13
  %17 = load i32, i32* %live14, align 8
  store i32 %17, i32* %live, align 4
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 7
  %19 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %20 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %19, i64 %idxprom16
  %spilled_ptr18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 0
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr18, i32 0, i32 13
  %21 = load i32, i32* %live19, align 8
  %or20 = or i32 %21, 8
  store i32 %or20, i32* %live19, align 8
  %22 = load i32, i32* %live, align 4
  %and21 = and i32 %22, 3
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end39, label %if.then23

if.then23:                                        ; preds = %for.body11
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 7
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack24, align 8
  %25 = load i32, i32* %i, align 4
  %idxprom25 = sext i32 %25 to i64
  %arrayidx26 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %24, i64 %idxprom25
  %spilled_ptr27 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx26, i32 0, i32 0
  call void @__mark_reg_not_init(%struct.bpf_reg_state* noundef %spilled_ptr27) #8
  store i32 0, i32* %j, align 4
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc36, %if.then23
  %26 = load i32, i32* %j, align 4
  %cmp29 = icmp slt i32 %26, 8
  br i1 %cmp29, label %for.body30, label %for.end38

for.body30:                                       ; preds = %for.cond28
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 7
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack31, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %29 to i64
  %arrayidx33 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom32
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx33, i32 0, i32 1
  %30 = load i32, i32* %j, align 4
  %idxprom34 = sext i32 %30 to i64
  %arrayidx35 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom34
  store i8 0, i8* %arrayidx35, align 1
  br label %for.inc36

for.inc36:                                        ; preds = %for.body30
  %31 = load i32, i32* %j, align 4
  %inc37 = add i32 %31, 1
  store i32 %inc37, i32* %j, align 4
  br label %for.cond28

for.end38:                                        ; preds = %for.cond28
  br label %if.end39

if.end39:                                         ; preds = %for.end38, %for.body11
  br label %for.inc40

for.inc40:                                        ; preds = %if.end39
  %32 = load i32, i32* %i, align 4
  %inc41 = add i32 %32, 1
  store i32 %inc41, i32* %i, align 4
  br label %for.cond9

for.end42:                                        ; preds = %for.cond9
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_reg_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %4 = load i32, i32* %i, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3, i32 noundef %4) #8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 13
  store i32 0, i32* %live, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i64 %idxprom2
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 10
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %parent, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idxprom4
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx5, i32 0, i32 12
  store i32 0, i32* %subreg_def, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 10
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 0
  store i32 6, i32* %type, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef 10) #8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 2
  %16 = load i32, i32* %frameno, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx7 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i64 10
  %frameno8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx7, i32 0, i32 11
  store i32 %16, i32* %frameno8, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx9 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i64 1
  %type10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx9, i32 0, i32 0
  store i32 2, i32* %type10, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %19, %struct.bpf_reg_state* noundef %20, i32 noundef 1) #8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_insn(i32 noundef %t, i32 noundef %w, i32 noundef %e, %struct.bpf_verifier_env* noundef %env, i1 noundef zeroext %loop_ok) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %e.addr = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %loop_ok.addr = alloca i8, align 1
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  store i32 %t, i32* %t.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %e, i32* %e.addr, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %frombool = zext i1 %loop_ok to i8
  store i8 %frombool, i8* %loop_ok.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %insn_stack1 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg, i32 0, i32 1
  %1 = load i32*, i32** %insn_stack1, align 8
  store i32* %1, i32** %insn_stack, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 20
  %insn_state3 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg2, i32 0, i32 0
  %3 = load i32*, i32** %insn_state3, align 8
  store i32* %3, i32** %insn_state, align 8
  %4 = load i32, i32* %e.addr, align 4
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32*, i32** %insn_state, align 8
  %6 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr i32, i32* %5, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4
  %cmp4 = icmp sge i32 %7, 17
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %8 = load i32, i32* %e.addr, align 4
  %cmp5 = icmp eq i32 %8, 2
  br i1 %cmp5, label %land.lhs.true6, label %if.end11

land.lhs.true6:                                   ; preds = %if.end
  %9 = load i32*, i32** %insn_state, align 8
  %10 = load i32, i32* %t.addr, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr i32, i32* %9, i64 %idxprom7
  %11 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp sge i32 %11, 18
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true6
  store i32 0, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true6, %if.end
  %12 = load i32, i32* %w.addr, align 4
  %cmp12 = icmp slt i32 %12, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %13 = load i32, i32* %w.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 4
  %16 = load i32, i32* %len, align 4
  %cmp13 = icmp uge i32 %13, %16
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false, %if.end11
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %t.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i64 0, i64 0), i32 noundef %19) #8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %t.addr, align 4
  %23 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23, i64 0, i64 0), i32 noundef %22, i32 noundef %23) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %lor.lhs.false
  %24 = load i32, i32* %e.addr, align 4
  %cmp16 = icmp eq i32 %24, 2
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %w.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  %27 = load i32*, i32** %insn_state, align 8
  %28 = load i32, i32* %w.addr, align 4
  %idxprom19 = sext i32 %28 to i64
  %arrayidx20 = getelementptr i32, i32* %27, i64 %idxprom19
  %29 = load i32, i32* %arrayidx20, align 4
  %cmp21 = icmp eq i32 %29, 0
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end18
  %30 = load i32, i32* %e.addr, align 4
  %or = or i32 16, %30
  %31 = load i32*, i32** %insn_state, align 8
  %32 = load i32, i32* %t.addr, align 4
  %idxprom23 = sext i32 %32 to i64
  %arrayidx24 = getelementptr i32, i32* %31, i64 %idxprom23
  store i32 %or, i32* %arrayidx24, align 4
  %33 = load i32*, i32** %insn_state, align 8
  %34 = load i32, i32* %w.addr, align 4
  %idxprom25 = sext i32 %34 to i64
  %arrayidx26 = getelementptr i32, i32* %33, i64 %idxprom25
  store i32 16, i32* %arrayidx26, align 4
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 20
  %cur_stack = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg27, i32 0, i32 2
  %36 = load i32, i32* %cur_stack, align 8
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 2
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog28, align 8
  %len29 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %38, i32 0, i32 4
  %39 = load i32, i32* %len29, align 4
  %cmp30 = icmp uge i32 %36, %39
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then22
  store i32 -7, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then22
  %40 = load i32, i32* %w.addr, align 4
  %41 = load i32*, i32** %insn_stack, align 8
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg33 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 20
  %cur_stack34 = getelementptr inbounds %struct.anon.150, %struct.anon.150* %cfg33, i32 0, i32 2
  %43 = load i32, i32* %cur_stack34, align 8
  %inc = add i32 %43, 1
  store i32 %inc, i32* %cur_stack34, align 8
  %idxprom35 = sext i32 %43 to i64
  %arrayidx36 = getelementptr i32, i32* %41, i64 %idxprom35
  store i32 %40, i32* %arrayidx36, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end18
  %44 = load i32*, i32** %insn_state, align 8
  %45 = load i32, i32* %w.addr, align 4
  %idxprom37 = sext i32 %45 to i64
  %arrayidx38 = getelementptr i32, i32* %44, i64 %idxprom37
  %46 = load i32, i32* %arrayidx38, align 4
  %and = and i32 %46, 240
  %cmp39 = icmp eq i32 %and, 16
  br i1 %cmp39, label %if.then40, label %if.else45

if.then40:                                        ; preds = %if.else
  %47 = load i8, i8* %loop_ok.addr, align 1
  %tobool = trunc i8 %47 to i1
  br i1 %tobool, label %land.lhs.true41, label %if.end44

land.lhs.true41:                                  ; preds = %if.then40
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 14
  %49 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool42 = trunc i8 %49 to i1
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true41
  store i32 0, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %land.lhs.true41, %if.then40
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load i32, i32* %t.addr, align 4
  %52 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %50, i32 noundef %51, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i64 0, i64 0), i32 noundef %52) #8
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load i32, i32* %w.addr, align 4
  %55 = load i32, i32* %w.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %53, i32 noundef %54, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i64 0, i64 0), i32 noundef %55) #8
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32, i32* %t.addr, align 4
  %59 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.43, i64 0, i64 0), i32 noundef %58, i32 noundef %59) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.else45:                                        ; preds = %if.else
  %60 = load i32*, i32** %insn_state, align 8
  %61 = load i32, i32* %w.addr, align 4
  %idxprom46 = sext i32 %61 to i64
  %arrayidx47 = getelementptr i32, i32* %60, i64 %idxprom46
  %62 = load i32, i32* %arrayidx47, align 4
  %cmp48 = icmp eq i32 %62, 32
  br i1 %cmp48, label %if.then49, label %if.else53

if.then49:                                        ; preds = %if.else45
  %63 = load i32, i32* %e.addr, align 4
  %or50 = or i32 16, %63
  %64 = load i32*, i32** %insn_state, align 8
  %65 = load i32, i32* %t.addr, align 4
  %idxprom51 = sext i32 %65 to i64
  %arrayidx52 = getelementptr i32, i32* %64, i64 %idxprom51
  store i32 %or50, i32* %arrayidx52, align 4
  br label %if.end54

if.else53:                                        ; preds = %if.else45
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.44, i64 0, i64 0)) #8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then49
  br label %if.end55

if.end55:                                         ; preds = %if.end54
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.else53, %if.end44, %if.then43, %if.end32, %if.then31, %if.then14, %if.then10, %if.then
  %68 = load i32, i32* %retval, align 4
  ret i32 %68
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 16
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 6
  store i8 1, i8* %prune_point, align 1
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_get_by_fd(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_func(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval.i.i = alloca i1, align 1
  %addr.addr.i.i = alloca i8*, align 8
  %bytes.addr.i.i = alloca i64, align 8
  %is_source.addr.i.i = alloca i8, align 1
  %sz.i.i = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %i = alloca i32, align 4
  %nfuncs = alloca i32, align 4
  %urec_size = alloca i32, align 4
  %min_size = alloca i32, align 4
  %krec_size = alloca i32, align 4
  %krecord = alloca %struct.util_est*, align 8
  %type = alloca %struct.btf_type*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %urecord = alloca i8*, align 8
  %prev_offset = alloca i32, align 4
  %ret = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp13 = alloca i8*, align 8
  %__UNIQUE_ID___x211 = alloca i32, align 4
  %__UNIQUE_ID___y212 = alloca i32, align 4
  %tmp14 = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp33 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  store i32 8, i32* %krec_size, align 4
  store i32 0, i32* %prev_offset, align 4
  store i32 0, i32* %ret, align 4
  %0 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %1 = bitcast %union.bpf_attr* %0 to %struct.anon.1*
  %func_info_cnt = getelementptr inbounds %struct.anon.1, %struct.anon.1* %1, i32 0, i32 15
  %2 = load i32, i32* %func_info_cnt, align 8
  store i32 %2, i32* %nfuncs, align 4
  %3 = load i32, i32* %nfuncs, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %nfuncs, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 21
  %6 = load i32, i32* %subprog_cnt, align 8
  %cmp = icmp ne i32 %4, %6
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.27, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %9 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %10 = bitcast %union.bpf_attr* %9 to %struct.anon.1*
  %func_info_rec_size = getelementptr inbounds %struct.anon.1, %struct.anon.1* %10, i32 0, i32 13
  %11 = load i32, i32* %func_info_rec_size, align 4
  store i32 %11, i32* %urec_size, align 4
  %12 = load i32, i32* %urec_size, align 4
  %cmp3 = icmp ult i32 %12, 8
  br i1 %cmp3, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end2
  %13 = load i32, i32* %urec_size, align 4
  %cmp4 = icmp ugt i32 %13, 252
  br i1 %cmp4, label %if.then7, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %14 = load i32, i32* %urec_size, align 4
  %conv = zext i32 %14 to i64
  %rem = urem i64 %conv, 4
  %tobool6 = icmp ne i64 %rem, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false5, %lor.lhs.false, %if.end2
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load i32, i32* %urec_size, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.28, i64 0, i64 0), i32 noundef %17) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false5
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 2
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  store %struct.bpf_prog* %19, %struct.bpf_prog** %prog, align 8
  %20 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %20, i32 0, i32 7
  %21 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf10 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %21, i32 0, i32 24
  %22 = load %struct.btf*, %struct.btf** %btf10, align 8
  store %struct.btf* %22, %struct.btf** %btf, align 8
  %cmp11 = icmp eq i64* %__dummy, %__dummy2
  %conv12 = zext i1 %cmp11 to i32
  store i32 1, i32* %tmp, align 4
  %23 = load i32, i32* %tmp, align 4
  %24 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %25 = bitcast %union.bpf_attr* %24 to %struct.anon.1*
  %func_info = getelementptr inbounds %struct.anon.1, %struct.anon.1* %25, i32 0, i32 14
  %26 = load i64, i64* %func_info, align 8
  %27 = inttoptr i64 %26 to i8*
  store i8* %27, i8** %tmp13, align 8
  %28 = load i8*, i8** %tmp13, align 8
  store i8* %28, i8** %urecord, align 8
  %29 = load i32, i32* %krec_size, align 4
  store i32 %29, i32* %__UNIQUE_ID___x211, align 4
  %30 = load i32, i32* %urec_size, align 4
  store i32 %30, i32* %__UNIQUE_ID___y212, align 4
  %31 = load i32, i32* %__UNIQUE_ID___x211, align 4
  %32 = load i32, i32* %__UNIQUE_ID___y212, align 4
  %cmp15 = icmp ult i32 %31, %32
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  %33 = load i32, i32* %__UNIQUE_ID___x211, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %34 = load i32, i32* %__UNIQUE_ID___y212, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %33, %cond.true ], [ %34, %cond.false ]
  store i32 %cond, i32* %tmp14, align 4
  %35 = load i32, i32* %tmp14, align 4
  store i32 %35, i32* %min_size, align 4
  %36 = load i32, i32* %nfuncs, align 4
  %conv17 = zext i32 %36 to i64
  %37 = load i32, i32* %krec_size, align 4
  %conv18 = zext i32 %37 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv17, i64 noundef %conv18, i32 noundef 11456) #8
  %38 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %38, %struct.util_est** %krecord, align 8
  %39 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %tobool19 = icmp ne %struct.util_est* %39, null
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %cond.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %cond.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end21
  %40 = load i32, i32* %i, align 4
  %41 = load i32, i32* %nfuncs, align 4
  %cmp22 = icmp ult i32 %40, %41
  br i1 %cmp22, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %42 = load i8*, i8** %urecord, align 8
  %43 = load i32, i32* %krec_size, align 4
  %conv24 = zext i32 %43 to i64
  %44 = load i32, i32* %urec_size, align 4
  %conv25 = zext i32 %44 to i64
  %call26 = call i32 @bpf_check_uarg_tail_zero(i8* noundef %42, i64 noundef %conv24, i64 noundef %conv25) #8
  store i32 %call26, i32* %ret, align 4
  %45 = load i32, i32* %ret, align 4
  %tobool27 = icmp ne i32 %45, 0
  br i1 %tobool27, label %if.then28, label %if.end39

if.then28:                                        ; preds = %for.body
  %46 = load i32, i32* %ret, align 4
  %cmp29 = icmp eq i32 %46, -7
  br i1 %cmp29, label %if.then31, label %if.end38

if.then31:                                        ; preds = %if.then28
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.29, i64 0, i64 0)) #8
  call void @might_fault() #8
  %49 = load i32, i32* %min_size, align 4
  store i32 %49, i32* %__pu_val, align 4
  %50 = load i32, i32* %__pu_val, align 4
  %51 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %52 = bitcast %union.bpf_attr* %51 to %struct.anon.1*
  %func_info_rec_size32 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %52, i32 0, i32 13
  %53 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %50, i32* %func_info_rec_size32) #9, !srcloc !60
  store i32 %53, i32* %__ret_pu, align 4
  %54 = load i32, i32* %__ret_pu, align 4
  %conv34 = sext i32 %54 to i64
  store i64 %conv34, i64* %tmp33, align 8
  %55 = load i64, i64* %tmp33, align 8
  %tobool35 = icmp ne i64 %55, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.then31
  store i32 -14, i32* %ret, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.then31
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then28
  br label %err_free

if.end39:                                         ; preds = %for.body
  %56 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %57 = load i32, i32* %i, align 4
  %idxprom = zext i32 %57 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %56, i64 %idxprom
  %58 = bitcast %struct.util_est* %arrayidx to i8*
  %59 = load i8*, i8** %urecord, align 8
  %60 = load i32, i32* %min_size, align 4
  %conv40 = zext i32 %60 to i64
  store i8* %58, i8** %to.addr.i, align 8
  store i8* %59, i8** %from.addr.i, align 8
  store i64 %conv40, i64* %n.addr.i, align 8
  %61 = load i8*, i8** %to.addr.i, align 8
  %62 = load i64, i64* %n.addr.i, align 8
  store i8* %61, i8** %addr.addr.i.i, align 8
  store i64 %62, i64* %bytes.addr.i.i, align 8
  store i8 0, i8* %is_source.addr.i.i, align 1
  store i32 -1, i32* %sz.i.i, align 4
  %63 = load i32, i32* %sz.i.i, align 4
  %cmp.i.i = icmp sge i32 %63, 0
  br i1 %cmp.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %if.end39
  %64 = load i32, i32* %sz.i.i, align 4
  %conv.i.i = sext i32 %64 to i64
  %65 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp1.i.i = icmp ult i64 %conv.i.i, %65
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %if.end39
  %66 = phi i1 [ false, %if.end39 ], [ %cmp1.i.i, %land.rhs.i.i ]
  %lnot.i.i = xor i1 %66, true
  %lnot.ext.i.i = zext i1 %66 to i32
  %conv4.i.i = sext i32 %lnot.ext.i.i to i64
  br i1 %66, label %if.then.i.i, label %if.end10.i.i

if.then.i.i:                                      ; preds = %land.end.i.i
  %67 = load i64, i64* %bytes.addr.i.i, align 8
  %68 = call i1 @llvm.is.constant.i64(i64 %67) #9
  br i1 %68, label %if.else.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.then.i.i
  %69 = load i32, i32* %sz.i.i, align 4
  %70 = load i64, i64* %bytes.addr.i.i, align 8
  call void @copy_overflow(i32 noundef %69, i64 noundef %70) #10
  br label %if.end9.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %71 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool6.i.i = trunc i8 %71 to i1
  br i1 %tobool6.i.i, label %if.then7.i.i, label %if.else8.i.i

if.then7.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_from() #10
  br label %if.end.i.i

if.else8.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_to() #10
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.else8.i.i, %if.then7.i.i
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.end.i.i, %if.then5.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end10.i.i:                                     ; preds = %land.end.i.i
  %72 = load i8*, i8** %addr.addr.i.i, align 8
  %73 = load i64, i64* %bytes.addr.i.i, align 8
  %74 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool11.i.i = trunc i8 %74 to i1
  call void @check_object_size(i8* noundef %72, i64 noundef %73, i1 noundef zeroext %tobool11.i.i) #10
  store i1 true, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

check_copy_size.exit.i:                           ; preds = %if.end10.i.i, %if.end9.i.i
  %75 = load i1, i1* %retval.i.i, align 1
  %lnot.i = xor i1 %75, true
  %lnot.ext.i = zext i1 %75 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %75, label %if.then.i, label %copy_from_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit.i
  %76 = load i8*, i8** %to.addr.i, align 8
  %77 = load i8*, i8** %from.addr.i, align 8
  %78 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_from_user(i8* noundef %76, i8* noundef %77, i64 noundef %78) #10
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.then.i, %check_copy_size.exit.i
  %79 = load i64, i64* %n.addr.i, align 8
  %tobool42 = icmp ne i64 %79, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %copy_from_user.exit
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end44:                                         ; preds = %copy_from_user.exit
  %80 = load i32, i32* %i, align 4
  %cmp45 = icmp eq i32 %80, 0
  br i1 %cmp45, label %if.then47, label %if.else

if.then47:                                        ; preds = %if.end44
  %81 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %82 = load i32, i32* %i, align 4
  %idxprom48 = zext i32 %82 to i64
  %arrayidx49 = getelementptr %struct.util_est, %struct.util_est* %81, i64 %idxprom48
  %insn_off = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx49, i32 0, i32 0
  %83 = load i32, i32* %insn_off, align 4
  %tobool50 = icmp ne i32 %83, 0
  br i1 %tobool50, label %if.then51, label %if.end55

if.then51:                                        ; preds = %if.then47
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %85 = bitcast %struct.bpf_verifier_env* %84 to i8*
  %86 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %87 = load i32, i32* %i, align 4
  %idxprom52 = zext i32 %87 to i64
  %arrayidx53 = getelementptr %struct.util_est, %struct.util_est* %86, i64 %idxprom52
  %insn_off54 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx53, i32 0, i32 0
  %88 = load i32, i32* %insn_off54, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %85, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.30, i64 0, i64 0), i32 noundef %88) #8
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end55:                                         ; preds = %if.then47
  br label %if.end66

if.else:                                          ; preds = %if.end44
  %89 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %90 = load i32, i32* %i, align 4
  %idxprom56 = zext i32 %90 to i64
  %arrayidx57 = getelementptr %struct.util_est, %struct.util_est* %89, i64 %idxprom56
  %insn_off58 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx57, i32 0, i32 0
  %91 = load i32, i32* %insn_off58, align 4
  %92 = load i32, i32* %prev_offset, align 4
  %cmp59 = icmp ule i32 %91, %92
  br i1 %cmp59, label %if.then61, label %if.end65

if.then61:                                        ; preds = %if.else
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %94 = bitcast %struct.bpf_verifier_env* %93 to i8*
  %95 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %96 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %96 to i64
  %arrayidx63 = getelementptr %struct.util_est, %struct.util_est* %95, i64 %idxprom62
  %insn_off64 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx63, i32 0, i32 0
  %97 = load i32, i32* %insn_off64, align 4
  %98 = load i32, i32* %prev_offset, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %94, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.31, i64 0, i64 0), i32 noundef %97, i32 noundef %98) #8
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end65:                                         ; preds = %if.else
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.end55
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 19
  %100 = load i32, i32* %i, align 4
  %idxprom67 = zext i32 %100 to i64
  %arrayidx68 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom67
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx68, i32 0, i32 0
  %101 = load i32, i32* %start, align 4
  %102 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %103 = load i32, i32* %i, align 4
  %idxprom69 = zext i32 %103 to i64
  %arrayidx70 = getelementptr %struct.util_est, %struct.util_est* %102, i64 %idxprom69
  %insn_off71 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx70, i32 0, i32 0
  %104 = load i32, i32* %insn_off71, align 4
  %cmp72 = icmp ne i32 %101, %104
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end66
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = bitcast %struct.bpf_verifier_env* %105 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %106, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.32, i64 0, i64 0)) #8
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end75:                                         ; preds = %if.end66
  %107 = load %struct.btf*, %struct.btf** %btf, align 8
  %108 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %109 = load i32, i32* %i, align 4
  %idxprom76 = zext i32 %109 to i64
  %arrayidx77 = getelementptr %struct.util_est, %struct.util_est* %108, i64 %idxprom76
  %type_id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx77, i32 0, i32 1
  %110 = load i32, i32* %type_id, align 4
  %call78 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %107, i32 noundef %110) #8
  store %struct.btf_type* %call78, %struct.btf_type** %type, align 8
  %111 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %tobool79 = icmp ne %struct.btf_type* %111, null
  br i1 %tobool79, label %lor.lhs.false80, label %if.then83

lor.lhs.false80:                                  ; preds = %if.end75
  %112 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %112, i32 0, i32 1
  %113 = load i32, i32* %info, align 4
  %shr = lshr i32 %113, 24
  %and = and i32 %shr, 15
  %cmp81 = icmp ne i32 %and, 12
  br i1 %cmp81, label %if.then83, label %if.end87

if.then83:                                        ; preds = %lor.lhs.false80, %if.end75
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = bitcast %struct.bpf_verifier_env* %114 to i8*
  %116 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %117 = load i32, i32* %i, align 4
  %idxprom84 = zext i32 %117 to i64
  %arrayidx85 = getelementptr %struct.util_est, %struct.util_est* %116, i64 %idxprom84
  %type_id86 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx85, i32 0, i32 1
  %118 = load i32, i32* %type_id86, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %115, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.33, i64 0, i64 0), i32 noundef %118) #8
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end87:                                         ; preds = %lor.lhs.false80
  %119 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %120 = load i32, i32* %i, align 4
  %idxprom88 = zext i32 %120 to i64
  %arrayidx89 = getelementptr %struct.util_est, %struct.util_est* %119, i64 %idxprom88
  %insn_off90 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx89, i32 0, i32 0
  %121 = load i32, i32* %insn_off90, align 4
  store i32 %121, i32* %prev_offset, align 4
  %122 = load i32, i32* %urec_size, align 4
  %123 = load i8*, i8** %urecord, align 8
  %idx.ext = zext i32 %122 to i64
  %add.ptr = getelementptr i8, i8* %123, i64 %idx.ext
  store i8* %add.ptr, i8** %urecord, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end87
  %124 = load i32, i32* %i, align 4
  %inc = add i32 %124, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %125 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %126 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux91 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %126, i32 0, i32 7
  %127 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux91, align 8
  %func_info92 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %127, i32 0, i32 25
  store %struct.util_est* %125, %struct.util_est** %func_info92, align 8
  %128 = load i32, i32* %nfuncs, align 4
  %129 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux93 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %129, i32 0, i32 7
  %130 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux93, align 8
  %func_info_cnt94 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %130, i32 0, i32 28
  store i32 %128, i32* %func_info_cnt94, align 8
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then83, %if.then74, %if.then61, %if.then51, %if.then43, %if.end38
  %131 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %132 = bitcast %struct.util_est* %131 to i8*
  call void @kvfree(i8* noundef %132) #8
  %133 = load i32, i32* %ret, align 4
  store i32 %133, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %for.end, %if.then20, %if.then7, %if.then1, %if.then
  %134 = load i32, i32* %retval, align 4
  ret i32 %134
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_line(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval.i.i = alloca i1, align 1
  %addr.addr.i.i = alloca i8*, align 8
  %bytes.addr.i.i = alloca i64, align 8
  %is_source.addr.i.i = alloca i8, align 1
  %sz.i.i = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %i = alloca i32, align 4
  %s = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %ncopy = alloca i32, align 4
  %expected_size = alloca i32, align 4
  %rec_size = alloca i32, align 4
  %prev_offset = alloca i32, align 4
  %sub = alloca %struct.bpf_subprog_info*, align 8
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %ulinfo = alloca i8*, align 8
  %err = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp17 = alloca i8*, align 8
  %__UNIQUE_ID___x213 = alloca i32, align 4
  %__UNIQUE_ID___y214 = alloca i32, align 4
  %tmp18 = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp32 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  store i32 0, i32* %prev_offset, align 4
  %0 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %1 = bitcast %union.bpf_attr* %0 to %struct.anon.1*
  %line_info_cnt = getelementptr inbounds %struct.anon.1, %struct.anon.1* %1, i32 0, i32 18
  %2 = load i32, i32* %line_info_cnt, align 8
  store i32 %2, i32* %nr_linfo, align 4
  %3 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %5 = bitcast %union.bpf_attr* %4 to %struct.anon.1*
  %line_info_rec_size = getelementptr inbounds %struct.anon.1, %struct.anon.1* %5, i32 0, i32 16
  %6 = load i32, i32* %line_info_rec_size, align 4
  store i32 %6, i32* %rec_size, align 4
  %7 = load i32, i32* %rec_size, align 4
  %conv = zext i32 %7 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %8 = load i32, i32* %rec_size, align 4
  %cmp2 = icmp ugt i32 %8, 252
  br i1 %cmp2, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %9 = load i32, i32* %rec_size, align 4
  %conv5 = zext i32 %9 to i64
  %and = and i64 %conv5, 3
  %tobool6 = icmp ne i64 %and, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %lor.lhs.false, %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false4
  %10 = load i32, i32* %nr_linfo, align 4
  %conv9 = zext i32 %10 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv9, i64 noundef 16, i32 noundef 11456) #8
  %11 = bitcast i8* %call to %struct.ethtool_pauseparam*
  store %struct.ethtool_pauseparam* %11, %struct.ethtool_pauseparam** %linfo, align 8
  %12 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %tobool10 = icmp ne %struct.ethtool_pauseparam* %12, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  store i32 -12, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 2
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  store %struct.bpf_prog* %14, %struct.bpf_prog** %prog, align 8
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 7
  %16 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf14 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %16, i32 0, i32 24
  %17 = load %struct.btf*, %struct.btf** %btf14, align 8
  store %struct.btf* %17, %struct.btf** %btf, align 8
  store i32 0, i32* %s, align 4
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 19
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %sub, align 8
  %cmp15 = icmp eq i64* %__dummy, %__dummy2
  %conv16 = zext i1 %cmp15 to i32
  store i32 1, i32* %tmp, align 4
  %19 = load i32, i32* %tmp, align 4
  %20 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %21 = bitcast %union.bpf_attr* %20 to %struct.anon.1*
  %line_info = getelementptr inbounds %struct.anon.1, %struct.anon.1* %21, i32 0, i32 17
  %22 = load i64, i64* %line_info, align 8
  %23 = inttoptr i64 %22 to i8*
  store i8* %23, i8** %tmp17, align 8
  %24 = load i8*, i8** %tmp17, align 8
  store i8* %24, i8** %ulinfo, align 8
  store i32 16, i32* %expected_size, align 4
  %25 = load i32, i32* %expected_size, align 4
  store i32 %25, i32* %__UNIQUE_ID___x213, align 4
  %26 = load i32, i32* %rec_size, align 4
  store i32 %26, i32* %__UNIQUE_ID___y214, align 4
  %27 = load i32, i32* %__UNIQUE_ID___x213, align 4
  %28 = load i32, i32* %__UNIQUE_ID___y214, align 4
  %cmp19 = icmp ult i32 %27, %28
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %29 = load i32, i32* %__UNIQUE_ID___x213, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  %30 = load i32, i32* %__UNIQUE_ID___y214, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %29, %cond.true ], [ %30, %cond.false ]
  store i32 %cond, i32* %tmp18, align 4
  %31 = load i32, i32* %tmp18, align 4
  store i32 %31, i32* %ncopy, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %32 = load i32, i32* %i, align 4
  %33 = load i32, i32* %nr_linfo, align 4
  %cmp21 = icmp ult i32 %32, %33
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load i8*, i8** %ulinfo, align 8
  %35 = load i32, i32* %expected_size, align 4
  %conv23 = zext i32 %35 to i64
  %36 = load i32, i32* %rec_size, align 4
  %conv24 = zext i32 %36 to i64
  %call25 = call i32 @bpf_check_uarg_tail_zero(i8* noundef %34, i64 noundef %conv23, i64 noundef %conv24) #8
  store i32 %call25, i32* %err, align 4
  %37 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %37, 0
  br i1 %tobool26, label %if.then27, label %if.end38

if.then27:                                        ; preds = %for.body
  %38 = load i32, i32* %err, align 4
  %cmp28 = icmp eq i32 %38, -7
  br i1 %cmp28, label %if.then30, label %if.end37

if.then30:                                        ; preds = %if.then27
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.34, i64 0, i64 0)) #8
  call void @might_fault() #8
  %41 = load i32, i32* %expected_size, align 4
  store i32 %41, i32* %__pu_val, align 4
  %42 = load i32, i32* %__pu_val, align 4
  %43 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %44 = bitcast %union.bpf_attr* %43 to %struct.anon.1*
  %line_info_rec_size31 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %44, i32 0, i32 16
  %45 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %42, i32* %line_info_rec_size31) #9, !srcloc !61
  store i32 %45, i32* %__ret_pu, align 4
  %46 = load i32, i32* %__ret_pu, align 4
  %conv33 = sext i32 %46 to i64
  store i64 %conv33, i64* %tmp32, align 8
  %47 = load i64, i64* %tmp32, align 8
  %tobool34 = icmp ne i64 %47, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then30
  store i32 -14, i32* %err, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.then30
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then27
  br label %err_free

if.end38:                                         ; preds = %for.body
  %48 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %49 = load i32, i32* %i, align 4
  %idxprom = zext i32 %49 to i64
  %arrayidx = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %48, i64 %idxprom
  %50 = bitcast %struct.ethtool_pauseparam* %arrayidx to i8*
  %51 = load i8*, i8** %ulinfo, align 8
  %52 = load i32, i32* %ncopy, align 4
  %conv39 = zext i32 %52 to i64
  store i8* %50, i8** %to.addr.i, align 8
  store i8* %51, i8** %from.addr.i, align 8
  store i64 %conv39, i64* %n.addr.i, align 8
  %53 = load i8*, i8** %to.addr.i, align 8
  %54 = load i64, i64* %n.addr.i, align 8
  store i8* %53, i8** %addr.addr.i.i, align 8
  store i64 %54, i64* %bytes.addr.i.i, align 8
  store i8 0, i8* %is_source.addr.i.i, align 1
  store i32 -1, i32* %sz.i.i, align 4
  %55 = load i32, i32* %sz.i.i, align 4
  %cmp.i.i = icmp sge i32 %55, 0
  br i1 %cmp.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %if.end38
  %56 = load i32, i32* %sz.i.i, align 4
  %conv.i.i = sext i32 %56 to i64
  %57 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp1.i.i = icmp ult i64 %conv.i.i, %57
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %if.end38
  %58 = phi i1 [ false, %if.end38 ], [ %cmp1.i.i, %land.rhs.i.i ]
  %lnot.i.i = xor i1 %58, true
  %lnot.ext.i.i = zext i1 %58 to i32
  %conv4.i.i = sext i32 %lnot.ext.i.i to i64
  br i1 %58, label %if.then.i.i, label %if.end10.i.i

if.then.i.i:                                      ; preds = %land.end.i.i
  %59 = load i64, i64* %bytes.addr.i.i, align 8
  %60 = call i1 @llvm.is.constant.i64(i64 %59) #9
  br i1 %60, label %if.else.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.then.i.i
  %61 = load i32, i32* %sz.i.i, align 4
  %62 = load i64, i64* %bytes.addr.i.i, align 8
  call void @copy_overflow(i32 noundef %61, i64 noundef %62) #10
  br label %if.end9.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %63 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool6.i.i = trunc i8 %63 to i1
  br i1 %tobool6.i.i, label %if.then7.i.i, label %if.else8.i.i

if.then7.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_from() #10
  br label %if.end.i.i

if.else8.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_to() #10
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.else8.i.i, %if.then7.i.i
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.end.i.i, %if.then5.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end10.i.i:                                     ; preds = %land.end.i.i
  %64 = load i8*, i8** %addr.addr.i.i, align 8
  %65 = load i64, i64* %bytes.addr.i.i, align 8
  %66 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool11.i.i = trunc i8 %66 to i1
  call void @check_object_size(i8* noundef %64, i64 noundef %65, i1 noundef zeroext %tobool11.i.i) #10
  store i1 true, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

check_copy_size.exit.i:                           ; preds = %if.end10.i.i, %if.end9.i.i
  %67 = load i1, i1* %retval.i.i, align 1
  %lnot.i = xor i1 %67, true
  %lnot.ext.i = zext i1 %67 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %67, label %if.then.i, label %copy_from_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit.i
  %68 = load i8*, i8** %to.addr.i, align 8
  %69 = load i8*, i8** %from.addr.i, align 8
  %70 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_from_user(i8* noundef %68, i8* noundef %69, i64 noundef %70) #10
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.then.i, %check_copy_size.exit.i
  %71 = load i64, i64* %n.addr.i, align 8
  %tobool41 = icmp ne i64 %71, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %copy_from_user.exit
  store i32 -14, i32* %err, align 4
  br label %err_free

if.end43:                                         ; preds = %copy_from_user.exit
  %72 = load i32, i32* %i, align 4
  %tobool44 = icmp ne i32 %72, 0
  br i1 %tobool44, label %land.lhs.true, label %lor.lhs.false49

land.lhs.true:                                    ; preds = %if.end43
  %73 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %74 = load i32, i32* %i, align 4
  %idxprom45 = zext i32 %74 to i64
  %arrayidx46 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %73, i64 %idxprom45
  %insn_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx46, i32 0, i32 0
  %75 = load i32, i32* %insn_off, align 4
  %76 = load i32, i32* %prev_offset, align 4
  %cmp47 = icmp ule i32 %75, %76
  br i1 %cmp47, label %if.then55, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %land.lhs.true, %if.end43
  %77 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %78 = load i32, i32* %i, align 4
  %idxprom50 = zext i32 %78 to i64
  %arrayidx51 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %77, i64 %idxprom50
  %insn_off52 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx51, i32 0, i32 0
  %79 = load i32, i32* %insn_off52, align 4
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %80, i32 0, i32 4
  %81 = load i32, i32* %len, align 4
  %cmp53 = icmp uge i32 %79, %81
  br i1 %cmp53, label %if.then55, label %if.end60

if.then55:                                        ; preds = %lor.lhs.false49, %land.lhs.true
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = bitcast %struct.bpf_verifier_env* %82 to i8*
  %84 = load i32, i32* %i, align 4
  %85 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %86 = load i32, i32* %i, align 4
  %idxprom56 = zext i32 %86 to i64
  %arrayidx57 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %85, i64 %idxprom56
  %insn_off58 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx57, i32 0, i32 0
  %87 = load i32, i32* %insn_off58, align 4
  %88 = load i32, i32* %prev_offset, align 4
  %89 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len59 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %89, i32 0, i32 4
  %90 = load i32, i32* %len59, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %83, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.35, i64 0, i64 0), i32 noundef %84, i32 noundef %87, i32 noundef %88, i32 noundef %90) #8
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end60:                                         ; preds = %lor.lhs.false49
  %91 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %92 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %91, i32 0, i32 10
  %insnsi = bitcast %union.anon.146* %92 to [0 x %struct.bpf_insn]*
  %93 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %94 = load i32, i32* %i, align 4
  %idxprom61 = zext i32 %94 to i64
  %arrayidx62 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %93, i64 %idxprom61
  %insn_off63 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx62, i32 0, i32 0
  %95 = load i32, i32* %insn_off63, align 4
  %idxprom64 = zext i32 %95 to i64
  %arrayidx65 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom64
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx65, i32 0, i32 0
  %96 = load i8, i8* %code, align 8
  %tobool66 = icmp ne i8 %96, 0
  br i1 %tobool66, label %if.end68, label %if.then67

if.then67:                                        ; preds = %if.end60
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = bitcast %struct.bpf_verifier_env* %97 to i8*
  %99 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %98, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.36, i64 0, i64 0), i32 noundef %99) #8
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end68:                                         ; preds = %if.end60
  %100 = load %struct.btf*, %struct.btf** %btf, align 8
  %101 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %102 = load i32, i32* %i, align 4
  %idxprom69 = zext i32 %102 to i64
  %arrayidx70 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %101, i64 %idxprom69
  %line_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx70, i32 0, i32 2
  %103 = load i32, i32* %line_off, align 4
  %call71 = call i8* @btf_name_by_offset(%struct.btf* noundef %100, i32 noundef %103) #8
  %tobool72 = icmp ne i8* %call71, null
  br i1 %tobool72, label %lor.lhs.false73, label %if.then78

lor.lhs.false73:                                  ; preds = %if.end68
  %104 = load %struct.btf*, %struct.btf** %btf, align 8
  %105 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %106 = load i32, i32* %i, align 4
  %idxprom74 = zext i32 %106 to i64
  %arrayidx75 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %105, i64 %idxprom74
  %file_name_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx75, i32 0, i32 1
  %107 = load i32, i32* %file_name_off, align 4
  %call76 = call i8* @btf_name_by_offset(%struct.btf* noundef %104, i32 noundef %107) #8
  %tobool77 = icmp ne i8* %call76, null
  br i1 %tobool77, label %if.end79, label %if.then78

if.then78:                                        ; preds = %lor.lhs.false73, %if.end68
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %109 = bitcast %struct.bpf_verifier_env* %108 to i8*
  %110 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %109, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.37, i64 0, i64 0), i32 noundef %110) #8
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end79:                                         ; preds = %lor.lhs.false73
  %111 = load i32, i32* %s, align 4
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %112, i32 0, i32 21
  %113 = load i32, i32* %subprog_cnt, align 8
  %cmp80 = icmp ne i32 %111, %113
  br i1 %cmp80, label %if.then82, label %if.end104

if.then82:                                        ; preds = %if.end79
  %114 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %115 = load i32, i32* %i, align 4
  %idxprom83 = zext i32 %115 to i64
  %arrayidx84 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %114, i64 %idxprom83
  %insn_off85 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx84, i32 0, i32 0
  %116 = load i32, i32* %insn_off85, align 4
  %117 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %118 = load i32, i32* %s, align 4
  %idxprom86 = zext i32 %118 to i64
  %arrayidx87 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %117, i64 %idxprom86
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx87, i32 0, i32 0
  %119 = load i32, i32* %start, align 4
  %cmp88 = icmp eq i32 %116, %119
  br i1 %cmp88, label %if.then90, label %if.else

if.then90:                                        ; preds = %if.then82
  %120 = load i32, i32* %i, align 4
  %121 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %122 = load i32, i32* %s, align 4
  %idxprom91 = zext i32 %122 to i64
  %arrayidx92 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %121, i64 %idxprom91
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx92, i32 0, i32 1
  store i32 %120, i32* %linfo_idx, align 4
  %123 = load i32, i32* %s, align 4
  %inc = add i32 %123, 1
  store i32 %inc, i32* %s, align 4
  br label %if.end103

if.else:                                          ; preds = %if.then82
  %124 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %125 = load i32, i32* %s, align 4
  %idxprom93 = zext i32 %125 to i64
  %arrayidx94 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %124, i64 %idxprom93
  %start95 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx94, i32 0, i32 0
  %126 = load i32, i32* %start95, align 4
  %127 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %128 = load i32, i32* %i, align 4
  %idxprom96 = zext i32 %128 to i64
  %arrayidx97 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %127, i64 %idxprom96
  %insn_off98 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx97, i32 0, i32 0
  %129 = load i32, i32* %insn_off98, align 4
  %cmp99 = icmp ult i32 %126, %129
  br i1 %cmp99, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.else
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = bitcast %struct.bpf_verifier_env* %130 to i8*
  %132 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %131, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.38, i64 0, i64 0), i32 noundef %132) #8
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end102:                                        ; preds = %if.else
  br label %if.end103

if.end103:                                        ; preds = %if.end102, %if.then90
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.end79
  %133 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %134 = load i32, i32* %i, align 4
  %idxprom105 = zext i32 %134 to i64
  %arrayidx106 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %133, i64 %idxprom105
  %insn_off107 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx106, i32 0, i32 0
  %135 = load i32, i32* %insn_off107, align 4
  store i32 %135, i32* %prev_offset, align 4
  %136 = load i32, i32* %rec_size, align 4
  %137 = load i8*, i8** %ulinfo, align 8
  %idx.ext = zext i32 %136 to i64
  %add.ptr = getelementptr i8, i8* %137, i64 %idx.ext
  store i8* %add.ptr, i8** %ulinfo, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end104
  %138 = load i32, i32* %i, align 4
  %inc108 = add i32 %138, 1
  store i32 %inc108, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %139 = load i32, i32* %s, align 4
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt109 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %140, i32 0, i32 21
  %141 = load i32, i32* %subprog_cnt109, align 8
  %cmp110 = icmp ne i32 %139, %141
  br i1 %cmp110, label %if.then112, label %if.end115

if.then112:                                       ; preds = %for.end
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = bitcast %struct.bpf_verifier_env* %142 to i8*
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt113 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %144, i32 0, i32 21
  %145 = load i32, i32* %subprog_cnt113, align 8
  %146 = load i32, i32* %s, align 4
  %sub114 = sub i32 %145, %146
  %147 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %143, i8* noundef getelementptr inbounds ([58 x i8], [58 x i8]* @.str.39, i64 0, i64 0), i32 noundef %sub114, i32 noundef %147) #8
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end115:                                        ; preds = %for.end
  %148 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %149 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux116 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %149, i32 0, i32 7
  %150 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux116, align 8
  %linfo117 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %150, i32 0, i32 26
  store %struct.ethtool_pauseparam* %148, %struct.ethtool_pauseparam** %linfo117, align 8
  %151 = load i32, i32* %nr_linfo, align 4
  %152 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux118 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %152, i32 0, i32 7
  %153 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux118, align 8
  %nr_linfo119 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %153, i32 0, i32 29
  store i32 %151, i32* %nr_linfo119, align 4
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then112, %if.then101, %if.then78, %if.then67, %if.then55, %if.then42, %if.end37
  %154 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %155 = bitcast %struct.ethtool_pauseparam* %154 to i8*
  call void @kvfree(i8* noundef %155) #8
  %156 = load i32, i32* %err, align 4
  store i32 %156, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.end115, %if.then11, %if.then7, %if.then
  %157 = load i32, i32* %retval, align 4
  ret i32 %157
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_check_uarg_tail_zero(i8* noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @might_fault() #0 {
entry:
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_from_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_by_id(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  store i32 %2, i32* %insn_cnt, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp sge i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.25, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %8, i32 noundef %9) #8
  store i32 %call, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %cmp2 = icmp sge i32 %10, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 21
  %12 = load i32, i32* %subprog_cnt, align 8
  %cmp5 = icmp uge i32 %12, 256
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.26, i64 0, i64 0)) #8
  store i32 -7, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %15 = load i32, i32* %off.addr, align 4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 19
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 21
  %18 = load i32, i32* %subprog_cnt8, align 8
  %inc = add i32 %18, 1
  store i32 %inc, i32* %subprog_cnt8, align 8
  %idxprom = zext i32 %18 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  store i32 %15, i32* %start, align 4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 19
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info9, i64 0, i64 0
  %20 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 21
  %22 = load i32, i32* %subprog_cnt10, align 8
  %conv = zext i32 %22 to i64
  call void @sort(i8* noundef %20, i64 noundef %conv, i64 noundef 12, i32 (i8*, i8*)* noundef @cmp_subprogs, void (i8*, i8*, i32)* noundef null) #8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then3, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @sort(i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef, void (i8*, i8*, i32)* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %bytes, align 8
  %11 = load i32, i32* %flags.addr, align 4
  %call = call i8* @kvmalloc(i64 noundef %10, i32 noundef %11) #8
  store i8* %call, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i8*, i8** %retval, align 8
  ret i8* %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvmalloc(i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %call = call i8* @kvmalloc_node(i64 noundef %0, i32 noundef %1, i32 noundef -1) #8
  ret i8* %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @kvmalloc_node(i64 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @fdget(i32 noundef %fd) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %call = call i64 @__fdget(i32 noundef %0) #8
  %call1 = call { %struct.file*, i32 } @__to_fd(i64 noundef %call) #8
  %1 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 0
  %3 = extractvalue { %struct.file*, i32 } %call1, 0
  store %struct.file* %3, %struct.file** %2, align 8
  %4 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 1
  %5 = extractvalue { %struct.file*, i32 } %call1, 1
  store i32 %5, i32* %4, align 8
  %6 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %7 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %6, align 8
  ret { %struct.file*, i32 } %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_map* @__bpf_map_get(%struct.file*, i32) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 2
  %1 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %1, 7
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call = call i32 @check_map_prealloc(%struct.bpf_map* noundef %2) #8
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = bitcast %struct.bpf_verifier_env* %3 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %4, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.17, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %5, i32 0, i32 1
  %6 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool2 = icmp ne %struct.bpf_map* %6, null
  br i1 %tobool2, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %7 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %inner_map_meta3 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %7, i32 0, i32 1
  %8 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta3, align 8
  %call4 = call i32 @check_map_prealloc(%struct.bpf_map* noundef %8) #8
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.18, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %entry
  %11 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type9 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %11, i32 0, i32 2
  %12 = load i32, i32* %type9, align 4
  %call10 = call zeroext i1 @is_tracing_prog_type(i32 noundef %12) #8
  br i1 %call10, label %land.lhs.true13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type11 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 2
  %14 = load i32, i32* %type11, align 4
  %cmp12 = icmp eq i32 %14, 1
  br i1 %cmp12, label %land.lhs.true13, label %if.end16

land.lhs.true13:                                  ; preds = %lor.lhs.false, %if.end8
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call14 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %15) #8
  br i1 %call14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true13
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.19, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true13, %lor.lhs.false
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %18, i32 0, i32 7
  %19 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call17 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %19) #8
  br i1 %call17, label %land.lhs.true20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end16
  %20 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call19 = call zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %20) #8
  br i1 %call19, label %land.lhs.true20, label %if.end23

land.lhs.true20:                                  ; preds = %lor.lhs.false18, %if.end16
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %22 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call21 = call zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef %21, %struct.bpf_map* noundef %22) #8
  br i1 %call21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %land.lhs.true20
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.20, i64 0, i64 0)) #8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %land.lhs.true20, %lor.lhs.false18
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then22, %if.then15, %if.then6, %if.then1
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @fdput(%struct.file* %fd.coerce0, i32 %fd.coerce1) #0 {
entry:
  %fd = alloca %struct.fd, align 8
  %0 = bitcast %struct.fd* %fd to { %struct.file*, i32 }*
  %1 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 0
  store %struct.file* %fd.coerce0, %struct.file** %1, align 8
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 1
  store i32 %fd.coerce1, i32* %2, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 1
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %file = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 0
  %4 = load %struct.file*, %struct.file** %file, align 8
  call void @fput(%struct.file* noundef %4) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_map* @bpf_map_inc(%struct.bpf_map* noundef, i1 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp eq i32 %1, 19
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp eq i32 %3, 21
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_cgroup_storage_assign(%struct.bpf_prog* noundef %prog, %struct.bpf_map* noundef %map) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  ret i32 0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @fput(%struct.file* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prealloc(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp ne i32 %3, 5
  br i1 %cmp2, label %land.lhs.true3, label %lor.rhs

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type4 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %4, i32 0, i32 3
  %5 = load i32, i32* %map_type4, align 8
  %cmp5 = icmp ne i32 %5, 13
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %6, i32 0, i32 7
  %7 = load i32, i32* %map_flags, align 8
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true3
  %8 = phi i1 [ true, %land.lhs.true3 ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %8 to i32
  ret i32 %lor.ext
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_tracing_prog_type(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 5, label %sw.bb
    i32 7, label %sw.bb
    i32 17, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %cmp = icmp eq %struct.bpf_map_ops* %1, @bpf_map_offload_ops
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef, %struct.bpf_map* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__fdget(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @__to_fd(i64 noundef %v) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %v.addr = alloca i64, align 8
  store i64 %v, i64* %v.addr, align 8
  %file = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 0
  %0 = load i64, i64* %v.addr, align 8
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to %struct.file*
  store %struct.file* %1, %struct.file** %file, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 1
  %2 = load i64, i64* %v.addr, align 8
  %and1 = and i64 %2, 3
  %conv = trunc i64 %and1 to i32
  store i32 %conv, i32* %flags, align 8
  %3 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %4 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %3, align 8
  ret { %struct.file*, i32 } %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @ktime_get() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_to_ns(i64 noundef %kt) #0 {
entry:
  %kt.addr = alloca i64, align 8
  store i64 %kt, i64* %kt.addr, align 8
  %0 = load i64, i64* %kt.addr, align 8
  ret i64 %0
}

attributes #0 = { noinline noredzone nounwind null_pointer_is_valid sspstrong "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #1 = { noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #2 = { argmemonly nofree nounwind willreturn }
attributes #3 = { nofree nosync nounwind willreturn }
attributes #4 = { convergent nofree nosync nounwind readnone willreturn }
attributes #5 = { noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #6 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #7 = { argmemonly nofree nounwind willreturn writeonly }
attributes #8 = { noredzone }
attributes #9 = { nounwind }
attributes #10 = { noredzone nounwind }
attributes #11 = { noredzone nounwind readnone willreturn }
attributes #12 = { nounwind readnone }
attributes #13 = { nounwind readonly }

!llvm.ident = !{!0, !0}
!llvm.module.flags = !{!1, !2, !3, !4}

!0 = !{!"Ubuntu clang version 14.0.0-1ubuntu1.1"}
!1 = !{i32 1, !"wchar_size", i32 2}
!2 = !{i32 1, !"Code Model", i32 2}
!3 = !{i32 1, !"override-stack-alignment", i32 8}
!4 = !{i32 4, !"SkipRaxSetup", i32 1}
!5 = !{i64 2155315937, i64 2155315966, i64 2155316012, i64 2155316070, i64 2155316124, i64 2155316178, i64 2155316233, i64 2155316264}
!6 = !{i64 2155316687, i64 2155316694, i64 2155316746, i64 2155316777, i64 2155316807}
!7 = !{i64 2149199432, i64 2149199461, i64 2149199507, i64 2149199565, i64 2149199619, i64 2149199673, i64 2149199728, i64 2149199759}
!8 = !{i64 2149200188, i64 2149200195, i64 2149200247, i64 2149200278, i64 2149200308}
!9 = !{i64 2150361003, i64 2150361032, i64 2150361078, i64 2150361136, i64 2150361190, i64 2150361244, i64 2150361299, i64 2150361330}
!10 = !{i64 2150361782, i64 2150361789, i64 2150361843, i64 2150361874, i64 2150361904}
!11 = !{i64 2148494839}
!12 = !{i64 2155374490, i64 2155374519, i64 2155374565, i64 2155374623, i64 2155374677, i64 2155374731, i64 2155374786, i64 2155374817}
!13 = !{i64 2155375241, i64 2155375248, i64 2155375300, i64 2155375331, i64 2155375361}
!14 = !{i64 2155466605, i64 2155466634, i64 2155466680, i64 2155466738, i64 2155466792, i64 2155466846, i64 2155466901, i64 2155466932}
!15 = !{i64 2155467346, i64 2155467353, i64 2155467405, i64 2155467436, i64 2155467466}
!16 = !{i64 555201}
!17 = !{i64 2155469919, i64 2155469948, i64 2155469994, i64 2155470052, i64 2155470106, i64 2155470160, i64 2155470215, i64 2155470246}
!18 = !{i64 2155470671, i64 2155470678, i64 2155470730, i64 2155470761, i64 2155470791}
!19 = !{i64 2155380605, i64 2155380634, i64 2155380680, i64 2155380738, i64 2155380792, i64 2155380846, i64 2155380901, i64 2155380932}
!20 = !{i64 2155381356, i64 2155381363, i64 2155381415, i64 2155381446, i64 2155381476}
!21 = !{i64 2155321545, i64 2155321574, i64 2155321620, i64 2155321678, i64 2155321732, i64 2155321786, i64 2155321841, i64 2155321872}
!22 = !{i64 2155322295, i64 2155322302, i64 2155322354, i64 2155322385, i64 2155322415}
!23 = !{i64 2155323538, i64 2155323567, i64 2155323613, i64 2155323671, i64 2155323725, i64 2155323779, i64 2155323834, i64 2155323865}
!24 = !{i64 2155324288, i64 2155324295, i64 2155324347, i64 2155324378, i64 2155324408}
!25 = !{i64 2155458111, i64 2155458140, i64 2155458186, i64 2155458244, i64 2155458298, i64 2155458352, i64 2155458407, i64 2155458438}
!26 = !{i64 2155458862, i64 2155458869, i64 2155458921, i64 2155458952, i64 2155458982}
!27 = !{i64 2155460426, i64 2155460455, i64 2155460501, i64 2155460559, i64 2155460613, i64 2155460667, i64 2155460722, i64 2155460753}
!28 = !{i64 2155461177, i64 2155461184, i64 2155461236, i64 2155461267, i64 2155461297}
!29 = !{i64 2155329178, i64 2155329207, i64 2155329253, i64 2155329311, i64 2155329365, i64 2155329419, i64 2155329474, i64 2155329505}
!30 = !{i64 2155329928, i64 2155329935, i64 2155329987, i64 2155330018, i64 2155330048}
!31 = !{i64 2155330856, i64 2155330885, i64 2155330931, i64 2155330989, i64 2155331043, i64 2155331097, i64 2155331152, i64 2155331183}
!32 = !{i64 2155331595, i64 2155331602, i64 2155331654, i64 2155331685, i64 2155331715}
!33 = !{i64 2155354133, i64 2155354162, i64 2155354208, i64 2155354266, i64 2155354320, i64 2155354374, i64 2155354429, i64 2155354460}
!34 = !{i64 2155354873, i64 2155354880, i64 2155354932, i64 2155354963, i64 2155354993}
!35 = !{i64 2155352747, i64 2155352776, i64 2155352822, i64 2155352880, i64 2155352934, i64 2155352988, i64 2155353043, i64 2155353074}
!36 = !{i64 2155353487, i64 2155353494, i64 2155353546, i64 2155353577, i64 2155353607}
!37 = !{i64 2155433665, i64 2155433694, i64 2155433740, i64 2155433798, i64 2155433852, i64 2155433906, i64 2155433961, i64 2155433992}
!38 = !{i64 2155434416, i64 2155434423, i64 2155434475, i64 2155434506, i64 2155434536}
!39 = !{i64 2155431648, i64 2155431677, i64 2155431723, i64 2155431781, i64 2155431835, i64 2155431889, i64 2155431944, i64 2155431975}
!40 = !{i64 2155432399, i64 2155432406, i64 2155432458, i64 2155432489, i64 2155432519}
!41 = !{i64 2155363030, i64 2155363059, i64 2155363105, i64 2155363163, i64 2155363217, i64 2155363271, i64 2155363326, i64 2155363357}
!42 = !{i64 2155363781, i64 2155363788, i64 2155363840, i64 2155363871, i64 2155363901}
!43 = !{i64 2155365244, i64 2155365273, i64 2155365319, i64 2155365377, i64 2155365431, i64 2155365485, i64 2155365540, i64 2155365571}
!44 = !{i64 2155365995, i64 2155366002, i64 2155366054, i64 2155366085, i64 2155366115}
!45 = !{i64 2155357069, i64 2155357098, i64 2155357144, i64 2155357202, i64 2155357256, i64 2155357310, i64 2155357365, i64 2155357396}
!46 = !{i64 2155357820, i64 2155357827, i64 2155357879, i64 2155357910, i64 2155357940}
!47 = !{i64 2155359080, i64 2155359109, i64 2155359155, i64 2155359213, i64 2155359267, i64 2155359321, i64 2155359376, i64 2155359407}
!48 = !{i64 2155359831, i64 2155359838, i64 2155359890, i64 2155359921, i64 2155359951}
!49 = !{i64 2155361058, i64 2155361087, i64 2155361133, i64 2155361191, i64 2155361245, i64 2155361299, i64 2155361354, i64 2155361385}
!50 = !{i64 2155361809, i64 2155361816, i64 2155361868, i64 2155361899, i64 2155361929}
!51 = !{i64 2155392751, i64 2155392780, i64 2155392826, i64 2155392884, i64 2155392938, i64 2155392992, i64 2155393047, i64 2155393078}
!52 = !{i64 2155393502, i64 2155393509, i64 2155393561, i64 2155393592, i64 2155393622}
!53 = !{i64 2155394112, i64 2155394141, i64 2155394187, i64 2155394245, i64 2155394299, i64 2155394353, i64 2155394408, i64 2155394439}
!54 = !{i64 2155394852, i64 2155394859, i64 2155394911, i64 2155394942, i64 2155394972}
!55 = !{i64 2148055220, i64 2148055240}
!56 = !{i64 2155455320, i64 2155455349, i64 2155455395, i64 2155455453, i64 2155455507, i64 2155455561, i64 2155455616, i64 2155455647}
!57 = !{i64 2155456071, i64 2155456078, i64 2155456130, i64 2155456161, i64 2155456191}
!58 = !{i64 2155451659, i64 2155451688, i64 2155451734, i64 2155451792, i64 2155451846, i64 2155451900, i64 2155451955, i64 2155451986}
!59 = !{i64 2155452410, i64 2155452417, i64 2155452469, i64 2155452500, i64 2155452530}
!60 = !{i64 2155446140}
!61 = !{i64 2155450511}
