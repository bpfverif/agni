; ModuleID = 'kernel/bpf/verifier.c'
source_filename = "kernel/bpf/verifier.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_bpf_verifier_log_write:\09\09\09\09\09"
module asm "\09.asciz \09\22bpf_verifier_log_write\22\09\09\09\09\09"
module asm "__kstrtabns_bpf_verifier_log_write:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___ksymtab_gpl+bpf_verifier_log_write\22, \22a\22\09"
module asm "\09.balign\094\09\09\09\09\09"
module asm "__ksymtab_bpf_verifier_log_write:\09\09\09\09"
module asm "\09.long\09bpf_verifier_log_write- .\09\09\09\09"
module asm "\09.long\09__kstrtab_bpf_verifier_log_write- .\09\09\09"
module asm "\09.long\09__kstrtabns_bpf_verifier_log_write- .\09\09\09"
module asm "\09.previous\09\09\09\09\09"

%struct.bpf_insn = type { i8, i8, i16, i32 }
%struct.btf = type opaque
%struct.mutex = type { %struct.atomic64_t, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.atomic64_t = type { i64 }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %union.anon }
%union.anon = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.bpf_verifier_ops = type { %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*)*, i1 (i32)* }
%struct.bpf_func_proto = type { i64 (i64, i64, i64, i64, i64)*, i8, i8, i32, %union.anon.157, %union.anon.159, i32*, i1 (%struct.bpf_prog*)* }
%union.anon.157 = type { %struct.anon.158 }
%struct.anon.158 = type { i32, i32, i32, i32, i32 }
%union.anon.159 = type { %struct.anon.160 }
%struct.anon.160 = type { i32*, i32*, i32*, i32*, i32* }
%struct.bpf_prog = type { i16, i16, i32, i32, i32, i32, [8 x i8], %struct.bpf_prog_stats*, i32*, i32 (i8*, %struct.bpf_insn*)*, %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, [0 x %struct.sock_filter], [0 x %struct.bpf_insn] }
%struct.bpf_prog_stats = type { i64, i64, i64, %struct.u64_stats_sync, [8 x i8] }
%struct.u64_stats_sync = type {}
%struct.bpf_prog_aux = type { %struct.atomic64_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, %struct.bpf_ctx_arg_aux*, %struct.mutex, %struct.bpf_prog*, %struct.bpf_trampoline*, i32, i32, i8, i8, i8, i8, i8, i8, %struct.hlist_node, %struct.btf_type*, i8*, %struct.bpf_prog**, i8*, %struct.bpf_jit_poke_descriptor*, %struct.bpf_kfunc_desc_tab*, i32, %struct.bpf_ksym, %struct.bpf_prog_ops*, %struct.bpf_map**, %struct.mutex, %struct.btf_mod_pair*, %struct.bpf_prog*, %struct.user_struct*, i64, [2 x %struct.bpf_map*], [16 x i8], i8*, %struct.bpf_prog_offload*, %struct.btf*, %struct.bpf_func_info*, %struct.bpf_func_info_aux*, %struct.bpf_line_info*, i8**, i32, i32, i32, i32, %struct.exception_table_entry*, %union.anon.156 }
%struct.bpf_ctx_arg_aux = type { i32, i32, i32 }
%struct.bpf_trampoline = type { %struct.hlist_node, %struct.mutex, %struct.refcount_struct, i64, %struct.anon.1, %struct.bpf_prog*, [3 x %struct.hlist_head], [3 x i32], %struct.bpf_tramp_image*, i64, %struct.module* }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.anon.1 = type { %struct.btf_func_model, i8*, i8 }
%struct.btf_func_model = type { i8, i8, [12 x i8] }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.bpf_tramp_image = type { i8*, %struct.bpf_ksym, %struct.percpu_ref, i8*, i8*, %union.anon.2 }
%struct.percpu_ref = type { i64, %struct.percpu_ref_data* }
%struct.percpu_ref_data = type { %struct.atomic64_t, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head, %struct.percpu_ref* }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%union.anon.2 = type { %struct.work_struct }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, i32, %struct.exception_table_entry*, i32 ()*, %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i8*, i32, i32, i32*, i32, %struct.srcu_struct**, i32, %struct.bpf_raw_event_map*, %struct.jump_entry*, i32, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_eval_map**, i32, i8*, i32, i64*, i32, i32, %struct.static_call_site*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, %struct.error_injection_entry*, i32, [60 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.3 }
%union.anon.3 = type { %struct.raw_spinlock }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [64 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.attribute_group**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)*, void (%struct.kobject*, %struct.kuid_t*, %struct.kgid_t*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, %struct.address_space* ()*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.address_space = type { %struct.inode*, %struct.xarray, %struct.rw_semaphore, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i64, i64, %struct.address_space_operations*, i64, i32, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.191, i32, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.spinlock, i16, i8, i8, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.192, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.193, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.194, i32, i32, %struct.fsnotify_mark_connector*, i8* }
%struct.kuid_t = type { i32 }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.user_namespace*, %struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32, i1)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.user_namespace*, %struct.dentry*, %struct.iattr*)*, i32 (%struct.user_namespace*, %struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec64*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.posix_acl*, i32)*, i32 (%struct.user_namespace*, %struct.dentry*, %struct.fileattr*)*, i32 (%struct.dentry*, %struct.fileattr*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount_spinlock, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.109, %struct.list_head, %struct.list_head, %union.anon.110 }
%struct.seqcount_spinlock = type { %struct.seqcount }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.22, i8* }
%union.anon.22 = type { i64 }
%struct.lockref = type { %union.anon.24 }
%union.anon.24 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*)*, [24 x i8] }
%struct.vfsmount = type { %struct.dentry*, %struct.super_block*, i32, %struct.user_namespace* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.user_namespace*, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i64, i8, %struct.list_head, %struct.key*, %struct.rw_semaphore, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [14 x i64] }
%struct.uid_gid_map = type { i32, %union.anon.34 }
%union.anon.34 = type { %struct.anon.35, [48 x i8] }
%struct.anon.35 = type { %struct.uid_gid_extent*, %struct.uid_gid_extent* }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32, %struct.refcount_struct }
%struct.proc_ns_operations = type opaque
%struct.key = type { %struct.refcount_struct, i32, %union.anon.36, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.37, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i16, i64, %union.anon.38, %union.anon.42, %struct.key_restriction* }
%union.anon.36 = type { %struct.rb_node }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.key_user = type opaque
%union.anon.37 = type { i64 }
%union.anon.38 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { i64, %union.anon.39, %struct.key_type*, %struct.key_tag*, i8* }
%union.anon.39 = type { i64 }
%struct.key_type = type opaque
%struct.key_tag = type { %struct.callback_head, %struct.refcount_struct, i8 }
%union.anon.42 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.key_restriction = type { i32 (%struct.key*, %struct.key_type*, %union.key_payload*, %struct.key*)*, %struct.key*, %struct.key_type* }
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.44, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.hlist_head }
%union.anon.44 = type { %struct.anon.45 }
%struct.anon.45 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.wait_queue_head }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.kuid_t*, %struct.kgid_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.rb_root = type { %struct.rb_node* }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.kuid_t, %struct.atomic_t, [14 x %struct.atomic64_t] }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.109 = type { %struct.list_head }
%union.anon.110 = type { %struct.hlist_node }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.file* }
%struct.file = type { %union.anon.21, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.hlist_head*, %struct.address_space*, i32, i32 }
%union.anon.21 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.kiocb*, i1)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i64, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, i64, i32)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32, i16, i16, %union.anon.111 }
%union.anon.111 = type { %struct.wait_page_queue* }
%struct.wait_page_queue = type opaque
%struct.iov_iter = type { i8, i8, i64, i64, %union.anon.112, %union.anon.113 }
%union.anon.112 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%union.anon.113 = type { i64 }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.18, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.atomic64_t, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.mm_struct = type { %struct.anon.17, [0 x i64] }
%struct.anon.17 = type { %struct.vm_area_struct*, %struct.rb_root, i64, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, %struct.atomic64_t, i64, i64, i64, i64, %struct.seqcount, %struct.spinlock, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [48 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_subscriptions*, %struct.atomic_t, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct, i32 }
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i64, %struct.atomic64_t, %struct.rw_semaphore, %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.task_struct = type { %struct.thread_info, i32, i8*, %struct.refcount_struct, i32, i32, i32, %struct.__call_single_node, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [56 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.sched_dl_entity, %struct.task_group*, i32, i32, i32, %struct.cpumask*, %struct.cpumask*, %struct.cpumask, i8*, i16, i16, i32, i32, %union.rcu_special, i8, %struct.list_head, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.pid*, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i8*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.posix_cputimers, %struct.posix_cputimers_work, %struct.cred*, %struct.cred*, %struct.cred*, %struct.key*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.io_uring_task*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, %struct.syscall_user_dispatch, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, %struct.task_struct*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, %struct.capture_control*, i64, %struct.kernel_siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount_spinlock, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, %struct.mutex, i32, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.rseq*, i32, i64, %struct.tlbflush_unmap_batch, %union.anon.101, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.uprobe_task*, %struct.kmap_ctrl, i32, %struct.task_struct*, %struct.vm_struct*, %struct.refcount_struct, i8*, %struct.bpf_local_storage*, %struct.bpf_run_ctx*, i8*, i64, i64, i64, %struct.callback_head, i32, %struct.llist_head, %struct.callback_head, [32 x i8], %struct.thread_struct }
%struct.thread_info = type { i64, i64, i32 }
%struct.__call_single_node = type { %struct.llist_node, %union.anon.27, i16, i16 }
%struct.llist_node = type { %struct.llist_node* }
%union.anon.27 = type { i32 }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, i64, [24 x i8], %struct.sched_avg }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i64, i32, i32, i64, i64, i64, %struct.util_est }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, %struct.sched_dl_entity* }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.seqcount_raw_spinlock, %struct.hrtimer*, %struct.timerqueue_head, i64 ()*, i64 }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, i8, i32, i16, i16, i32, i64, %struct.hrtimer*, i64, %struct.hrtimer*, [8 x %struct.hrtimer_clock_base] }
%struct.seqcount_raw_spinlock = type { %struct.seqcount }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%union.rcu_special = type { i32 }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i64, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64, i64 (%struct.restart_block*)*, %union.anon.29 }
%union.anon.29 = type { %struct.anon.30 }
%struct.anon.30 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid = type { %struct.refcount_struct, i32, %struct.spinlock, [4 x %struct.hlist_head], %struct.hlist_head, %struct.wait_queue_head, %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace* }
%struct.pid_namespace = type { %struct.idr, %struct.callback_head, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.fs_pin*, %struct.user_namespace*, %struct.ucounts*, i32, %struct.ns_common }
%struct.idr = type { %struct.xarray, i32, i32 }
%struct.kmem_cache = type opaque
%struct.fs_pin = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.posix_cputimers_work = type { %struct.callback_head, i32 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.io_uring_task = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.time_namespace*, %struct.time_namespace*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type { %struct.refcount_struct, %struct.spinlock, i32, i32, i32, %struct.spinlock, %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.llist_node, %struct.key_tag*, %struct.user_namespace*, %struct.ucounts*, %struct.idr, %struct.ns_common, %struct.list_head, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.uevent_sock*, %struct.hlist_head*, %struct.hlist_head*, %struct.raw_notifier_head, i32, %struct.net_device*, %struct.list_head, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, %struct.netns_nexthop, [24 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_ct, %struct.net_generic*, %struct.netns_bpf, [56 x i8], %struct.netns_xfrm, i64, %struct.sock*, [48 x i8] }
%struct.proc_dir_entry = type opaque
%struct.uevent_sock = type opaque
%struct.raw_notifier_head = type { %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.net_device = type { [16 x i8], %struct.netdev_name_node*, %struct.dev_ifalias*, i64, i64, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.170, i32, i32, %struct.net_device_ops*, i32, i16, i16, i32, i16, i16, i64, i64, i64, i64, i64, i64, i64, i32, i32, i16, i8, i8, i32, %struct.net_device_stats, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.ethtool_ops*, %struct.ndisc_ops*, %struct.header_ops*, i8, i8, i8, i8, [32 x i8], i8, i8, i8, i8, i16, i16, i16, i16, %struct.spinlock, i32, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, i8, %struct.in_device*, %struct.inet6_dev*, %struct.wireless_dev*, %struct.wpan_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, %struct.bpf_prog*, i64, i32, i32 (%struct.sk_buff**)*, i8*, %struct.mini_Qdisc*, %struct.netdev_queue*, %struct.nf_hook_entries*, [32 x i8], %struct.cpu_rmap*, %struct.hlist_node, [8 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i32, %struct.spinlock, %struct.xdp_dev_bulk_queue*, [2 x %struct.xps_dev_maps*], %struct.mini_Qdisc*, [16 x %struct.hlist_head], %struct.timer_list, i32, i32, %struct.list_head, i32*, %struct.list_head, i8, i8, i16, i8, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.possible_net_t, i8*, i32, %union.anon.190, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, i16, [16 x %struct.netdev_tc_txq], [16 x i8], %struct.phy_device*, %struct.sfp_bus*, %struct.lock_class_key*, %struct.lock_class_key*, i8, i8, %struct.list_head, %struct.udp_tunnel_nic_info*, %struct.udp_tunnel_nic*, [3 x %struct.bpf_xdp_entity], [24 x i8] }
%struct.netdev_name_node = type { %struct.hlist_node, %struct.list_head, %struct.net_device*, i8* }
%struct.dev_ifalias = type { %struct.callback_head, [0 x i8] }
%struct.anon.170 = type { %struct.list_head, %struct.list_head }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, %struct.net_device*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.if_settings*)*, i32 (%struct.net_device*, %struct.ifreq*, i8*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_guid*, %struct.ifla_vf_guid*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.net_device*)*, %struct.net_device* (%struct.net_device*, %struct.sk_buff*, i1)*, %struct.net_device* (%struct.net_device*, %struct.sock*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16, %struct.netlink_ext_ack*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.sk_buff*, %struct.nlattr**, %struct.net_device*, i8*, i16, i32, i32, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_bpf*)*, i32 (%struct.net_device*, i32, %struct.xdp_frame**, i32)*, %struct.net_device* (%struct.net_device*, %struct.xdp_buff*)*, i32 (%struct.net_device*, i32, i32)*, %struct.devlink_port* (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ip_tunnel_parm*, i32)*, %struct.net_device* (%struct.net_device*)*, i32 (%struct.net_device_path_ctx*, %struct.net_device_path*)* }
%struct.sk_buff = type { %union.anon.49, %union.anon.52, %union.anon.53, [48 x i8], %union.anon.54, i64, i32, i32, i16, i16, i16, [0 x i8], i8, i8, [0 x i32], [0 x i8], i16, [0 x i8], i16, i16, %union.anon.56, i32, i32, i32, i16, i16, %union.anon.58, i32, %union.anon.59, %union.anon.60, i16, i16, i16, i16, i16, i16, i16, [0 x i32], i32, i32, i8*, i8*, i32, %struct.refcount_struct, %struct.skb_ext* }
%union.anon.49 = type { %struct.anon.50 }
%struct.anon.50 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.51 }
%union.anon.51 = type { %struct.net_device* }
%union.anon.52 = type { %struct.sock* }
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.anon.55 }
%struct.anon.55 = type { i64, void (%struct.sk_buff*)* }
%union.anon.56 = type { i32 }
%union.anon.58 = type { i32 }
%union.anon.59 = type { i32 }
%union.anon.60 = type { i16 }
%struct.skb_ext = type { %struct.refcount_struct, [1 x i8], i8, [2 x i8], [0 x i8] }
%struct.ifreq = type { %union.anon.171, %union.anon.172 }
%union.anon.171 = type { [16 x i8] }
%union.anon.172 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.if_settings = type { i32, i32, %union.anon.173 }
%union.anon.173 = type { %struct.raw_hdlc_proto* }
%struct.raw_hdlc_proto = type { i16, i16 }
%struct.neigh_parms = type opaque
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.nlattr = type { i16, i16 }
%struct.ifla_vf_guid = type { i32, i64 }
%struct.netlink_ext_ack = type { i8*, %struct.nlattr*, %struct.nla_policy*, [20 x i8], i8 }
%struct.nla_policy = type { i8, i8, i16, %union.anon.174 }
%union.anon.174 = type { i8* }
%struct.neighbour = type opaque
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, %struct.netlink_ext_ack*, i16, i16, i32, i32, i32, i8, %union.anon.176 }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%union.anon.176 = type { [6 x i64] }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.netdev_bpf = type { i32, %union.anon.177 }
%union.anon.177 = type { %struct.anon.178 }
%struct.anon.178 = type { i32, %struct.bpf_prog*, %struct.netlink_ext_ack* }
%struct.xdp_frame = type { i8*, i16, i16, i32, %struct.xdp_mem_info, %struct.net_device* }
%struct.xdp_mem_info = type { i32, i32 }
%struct.xdp_buff = type { i8*, i8*, i8*, i8*, %struct.xdp_rxq_info*, %struct.xdp_txq_info*, i32 }
%struct.xdp_rxq_info = type { %struct.net_device*, i32, i32, %struct.xdp_mem_info, i32, [36 x i8] }
%struct.xdp_txq_info = type { %struct.net_device* }
%struct.devlink_port = type opaque
%struct.ip_tunnel_parm = type opaque
%struct.net_device_path_ctx = type { %struct.net_device*, i8*, i32, [2 x %struct.anon.181] }
%struct.anon.181 = type { i16, i16 }
%struct.net_device_path = type { i32, %struct.net_device*, %union.anon.182 }
%union.anon.182 = type { %struct.anon.184, [4 x i8] }
%struct.anon.184 = type { i32, i16, i16 }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ethtool_ops = type opaque
%struct.ndisc_ops = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)*, i16 (%struct.sk_buff*)* }
%struct.hh_cache = type { i32, %struct.seqlock_t, [12 x i64] }
%struct.seqlock_t = type { %struct.seqcount_spinlock, %struct.spinlock }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32, %struct.rb_root }
%struct.in_device = type opaque
%struct.inet6_dev = type opaque
%struct.wireless_dev = type opaque
%struct.wpan_dev = type opaque
%struct.netdev_rx_queue = type { %struct.xdp_rxq_info, %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.nf_hook_entries = type opaque
%struct.cpu_rmap = type opaque
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, i64, i64, %struct.net_device*, [8 x i8], %struct.spinlock, i32, i64, i64, [40 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, i32, %struct.refcount_struct, [24 x i8], %struct.sk_buff_head, %struct.qdisc_skb_head, %struct.gnet_stats_basic_packed, %struct.seqcount, %struct.gnet_stats_queue, i64, %struct.Qdisc*, %struct.sk_buff_head, %struct.spinlock, %struct.spinlock, %struct.callback_head, [40 x i8], [0 x i64] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, void (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*)*, i32 (%struct.Qdisc*)*, %struct.module* }
%struct.Qdisc_class_ops = type { i32, %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**, %struct.netlink_ext_ack*)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*, %struct.netlink_ext_ack*)*, i32 (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_block* (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.tcf_block = type { %struct.mutex, %struct.list_head, i32, i32, %struct.refcount_struct, %struct.net*, %struct.Qdisc*, %struct.rw_semaphore, %struct.flow_block, %struct.list_head, i8, %struct.atomic_t, i32, i32, %struct.anon.189, %struct.callback_head, [128 x %struct.hlist_head], %struct.mutex }
%struct.flow_block = type { %struct.list_head }
%struct.anon.189 = type { %struct.tcf_chain*, %struct.list_head }
%struct.tcf_chain = type { %struct.mutex, %struct.tcf_proto*, %struct.list_head, %struct.tcf_block*, i32, i32, i32, i8, i8, %struct.tcf_proto_ops*, i8*, %struct.callback_head }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i16, i32, i8*, %struct.tcf_proto_ops*, %struct.tcf_chain*, %struct.spinlock, i8, %struct.refcount_struct, %struct.callback_head, %struct.hlist_node }
%struct.tcf_result = type { %union.anon.186 }
%union.anon.186 = type { %struct.anon.187 }
%struct.anon.187 = type { i64, i32 }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i32 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, i1, %struct.netlink_ext_ack*)*, i8* (%struct.tcf_proto*, i32)*, void (%struct.tcf_proto*, i8*)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i8**, i32, %struct.netlink_ext_ack*)*, i32 (%struct.tcf_proto*, i8*, i8*, i1, %struct.netlink_ext_ack*)*, i1 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, %struct.tcf_walker*, i1)*, i32 (%struct.tcf_proto*, i1, i32 (i32, i8*, i8*)*, i8*, %struct.netlink_ext_ack*)*, void (%struct.tcf_proto*, i8*)*, void (%struct.tcf_proto*, i8*)*, void (i8*, i32, i64, i8*, i64)*, i8* (%struct.net*, %struct.tcf_chain*, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (i8*)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.sk_buff*, %struct.net*, i8*)*, %struct.module*, i32 }
%struct.tcf_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.gnet_stats_basic_cpu = type { %struct.gnet_stats_basic_packed, %struct.u64_stats_sync }
%struct.qdisc_skb_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.gnet_stats_basic_packed = type { i64, i64 }
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.xdp_dev_bulk_queue = type opaque
%struct.xps_dev_maps = type { %struct.callback_head, i32, i16, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.mini_Qdisc = type { %struct.tcf_proto*, %struct.tcf_block*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, %struct.callback_head }
%struct.timer_list = type { %struct.hlist_node, i64, void (%struct.timer_list*)*, i32 }
%struct.netpoll_info = type opaque
%struct.possible_net_t = type { %struct.net* }
%union.anon.190 = type { %struct.pcpu_lstats* }
%struct.pcpu_lstats = type { %struct.u64_stats_t, %struct.u64_stats_t, %struct.u64_stats_sync }
%struct.u64_stats_t = type { %struct.local64_t }
%struct.local64_t = type { %struct.local_t }
%struct.local_t = type { %struct.atomic64_t }
%struct.device = type { %struct.kobject, %struct.device*, %struct.device_private*, i8*, %struct.device_type*, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.mutex, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.raw_spinlock, %struct.list_head, %struct.dma_map_ops*, i64*, i64, i64, %struct.bus_dma_region*, %struct.device_dma_parameters*, %struct.list_head, %struct.io_tlb_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, i32, %struct.spinlock, %struct.list_head, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.dev_iommu*, i32, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key, i8 }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.attribute_group**, %struct.dev_pm_ops*, void (%struct.device*)*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, i32, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.hrtimer, i64, %struct.work_struct, %struct.wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, i32, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.device*, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, i32, %struct.mutex, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, i32 (%struct.device*)*, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type opaque
%struct.bus_dma_region = type opaque
%struct.device_dma_parameters = type { i32, i32, i64 }
%struct.io_tlb_mem = type opaque
%struct.dev_archdata = type {}
%struct.device_node = type opaque
%struct.fwnode_handle = type { %struct.fwnode_handle*, %struct.fwnode_operations*, %struct.device*, %struct.list_head, %struct.list_head, i8 }
%struct.fwnode_operations = type { %struct.fwnode_handle* (%struct.fwnode_handle*)*, void (%struct.fwnode_handle*)*, i1 (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*, %struct.device*)*, i1 (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i32, i8*, i64)*, i32 (%struct.fwnode_handle*, i8*, i8**, i64)*, i8* (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i8*, i32, i32, %struct.fwnode_reference_args*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, i32 (%struct.fwnode_handle*, %struct.fwnode_endpoint*)*, i32 (%struct.fwnode_handle*)* }
%struct.fwnode_reference_args = type { %struct.fwnode_handle*, i32, [8 x i64] }
%struct.fwnode_endpoint = type { i32, i32, %struct.fwnode_handle* }
%struct.class = type { i8*, %struct.module*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, void (%struct.device*, %struct.kuid_t*, %struct.kgid_t*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.iommu_group = type opaque
%struct.dev_iommu = type opaque
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, %struct.net_device* (%struct.nlattr**, i8*, i8, i32, i32)*, void (%struct.net_device*)*, i8, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.netdev_tc_txq = type { i16, i16 }
%struct.phy_device = type opaque
%struct.sfp_bus = type opaque
%struct.udp_tunnel_nic_info = type opaque
%struct.udp_tunnel_nic = type opaque
%struct.bpf_xdp_entity = type { %struct.bpf_prog*, %struct.bpf_xdp_link* }
%struct.bpf_xdp_link = type opaque
%struct.netns_core = type { %struct.ctl_table_header*, i32, i32*, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.ipstats_mib*, %struct.ipstats_mib*, %struct.tcp_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.icmpv6_mib*, %struct.icmpv6msg_mib*, %struct.proc_dir_entry* }
%struct.ipstats_mib = type { [37 x i64], %struct.u64_stats_sync }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [126 x i64] }
%struct.udp_mib = type { [10 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.icmpv6msg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_nexthop = type { %struct.rb_root, %struct.hlist_head*, i32, i32, %struct.blocking_notifier_head }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.netns_ipv4 = type { %struct.inet_timewait_death_row, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.ip_ra_chain*, %struct.mutex, %struct.fib_rules_ops*, %struct.fib_table*, %struct.fib_table*, i32, i8, i8, i8, %struct.hlist_head*, %struct.sock*, %struct.sock**, %struct.sock*, %struct.inet_peer_base*, %struct.sock**, %struct.fqdir*, i8, i8, i8, i8, i8, i32, i32, %struct.local_ports, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i8, i32, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i8, i8, i8, i8, i32, i32, i32, [3 x i32], [3 x i32], i64, i64, i32, i32, %struct.tcp_congestion_ops*, %struct.tcp_fastopen_context*, i32, %struct.atomic_t, i64, i32, i32, i8, i8, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.mr_table*, i32, i8, i8, %struct.fib_notifier_ops*, i32, %struct.fib_notifier_ops*, i32, %struct.atomic_t, %struct.siphash_key_t, [8 x i8] }
%struct.inet_timewait_death_row = type { %struct.atomic_t, [60 x i8], %struct.inet_hashinfo*, i32 }
%struct.inet_hashinfo = type opaque
%struct.ipv4_devconf = type opaque
%struct.ip_ra_chain = type opaque
%struct.fib_rules_ops = type opaque
%struct.fib_table = type opaque
%struct.inet_peer_base = type opaque
%struct.fqdir = type { i64, i64, i32, i32, %struct.inet_frags*, %struct.net*, i8, [23 x i8], %struct.rhashtable, [56 x i8], %struct.atomic64_t, %struct.work_struct, %struct.llist_node, [16 x i8] }
%struct.inet_frags = type { i32, void (%struct.inet_frag_queue*, i8*)*, void (%struct.inet_frag_queue*)*, void (%struct.timer_list*)*, %struct.kmem_cache*, i8*, %struct.rhashtable_params, %struct.refcount_struct, %struct.completion }
%struct.inet_frag_queue = type { %struct.rhash_head, %union.anon.47, %struct.timer_list, %struct.spinlock, %struct.refcount_struct, %struct.rb_root, %struct.sk_buff*, %struct.sk_buff*, i64, i32, i32, i8, i16, %struct.fqdir*, %struct.callback_head }
%struct.rhash_head = type { %struct.rhash_head* }
%union.anon.47 = type { %struct.frag_v6_compare_key }
%struct.frag_v6_compare_key = type { %struct.in6_addr, %struct.in6_addr, i32, i32, i32 }
%struct.in6_addr = type { %union.anon.48 }
%union.anon.48 = type { [4 x i32] }
%struct.rhashtable_params = type { i16, i16, i16, i16, i32, i16, i8, i32 (i8*, i32, i32)*, i32 (i8*, i32, i32)*, i32 (%struct.rhashtable_compare_arg*, i8*)* }
%struct.rhashtable_compare_arg = type { %struct.rhashtable*, i8* }
%struct.rhashtable = type { %struct.bucket_table*, i32, i32, %struct.rhashtable_params, i8, %struct.work_struct, %struct.mutex, %struct.spinlock, %struct.atomic_t }
%struct.bucket_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.tcp_congestion_ops = type opaque
%struct.tcp_fastopen_context = type opaque
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.kgid_t] }
%struct.mr_table = type opaque
%struct.fib_notifier_ops = type opaque
%struct.siphash_key_t = type { [2 x i64] }
%struct.netns_ipv6 = type { %struct.dst_ops, %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, %struct.fqdir*, %struct.fib6_info*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, %struct.list_head, %struct.rwlock_t, %struct.spinlock, i32, i64, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.sock*, %struct.atomic_t, %struct.atomic_t, %struct.seg6_pernet_data*, %struct.fib_notifier_ops*, %struct.fib_notifier_ops*, i32, %struct.anon.63, %struct.ioam6_pernet_data*, [8 x i8] }
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32, i1)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [24 x i8] }
%struct.dst_entry = type opaque
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i32, i8, i8, i8, [4 x i64], i64*, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8, i8 }
%struct.ipv6_devconf = type opaque
%struct.fib6_info = type opaque
%struct.rt6_info = type opaque
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %union.anon.61, %struct.qspinlock }
%union.anon.61 = type { %struct.atomic_t }
%struct.seg6_pernet_data = type opaque
%struct.anon.63 = type { %struct.hlist_head, %struct.spinlock, i32 }
%struct.ioam6_pernet_data = type opaque
%struct.netns_nf = type { %struct.proc_dir_entry*, [13 x %struct.nf_logger*], %struct.ctl_table_header*, [5 x %struct.nf_hook_entries*], [5 x %struct.nf_hook_entries*], i32, i32 }
%struct.nf_logger = type opaque
%struct.netns_ct = type { i8, i8, i8, i8, i8, i8, %struct.ct_pcpu*, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_ip_net }
%struct.ct_pcpu = type { %struct.spinlock, %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ip_conntrack_stat = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.nf_ct_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_icmp_net, %struct.nf_icmp_net }
%struct.nf_generic_net = type { i32 }
%struct.nf_tcp_net = type { [14 x i32], i8, i8, i8, i8 }
%struct.nf_udp_net = type { [2 x i32] }
%struct.nf_icmp_net = type { i32 }
%struct.net_generic = type opaque
%struct.netns_bpf = type { [2 x %struct.bpf_prog_array*], [2 x %struct.bpf_prog*], [2 x %struct.list_head] }
%struct.bpf_prog_array = type { %struct.callback_head, [0 x %struct.bpf_prog_array_item] }
%struct.bpf_prog_array_item = type { %struct.bpf_prog*, %union.anon.64 }
%union.anon.64 = type { [2 x %struct.bpf_cgroup_storage*] }
%struct.bpf_cgroup_storage = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [3 x %struct.hlist_head], [3 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.xfrm_policy_hthresh, %struct.list_head, %struct.sock*, %struct.sock*, i32, i32, i32, i32, i8, %struct.ctl_table_header*, [24 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.seqcount_spinlock, %struct.seqcount_spinlock, %struct.spinlock, %struct.mutex, [16 x i8] }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32, i8, i8, i8, i8 }
%struct.xfrm_policy_hthresh = type { %struct.work_struct, %struct.seqlock_t, i8, i8, i8, i8 }
%struct.sock = type opaque
%struct.time_namespace = type opaque
%struct.cgroup_namespace = type { %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.signal_struct = type { %struct.refcount_struct, %struct.atomic_t, i32, %struct.list_head, %struct.wait_queue_head, %struct.task_struct*, %struct.sigpending, %struct.hlist_head, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x %struct.pid*], %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex, %struct.rw_semaphore }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.spinlock, %struct.refcount_struct, %struct.wait_queue_head, [64 x %struct.k_sigaction] }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.atomic_t, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.syscall_user_dispatch = type { i8*, i64, i64, i8 }
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type { %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, i16, %struct.xarray, %struct.io_cq*, %struct.hlist_head, %struct.work_struct }
%struct.io_cq = type { %struct.request_queue*, %struct.io_context*, %union.anon.66, %union.anon.67, i32 }
%struct.request_queue = type opaque
%union.anon.66 = type { %struct.list_head }
%union.anon.67 = type { %struct.hlist_node }
%struct.capture_control = type opaque
%struct.kernel_siginfo = type { %struct.anon.68 }
%struct.anon.68 = type { i32, i32, i32, %union.__sifields }
%union.__sifields = type { %struct.anon.72 }
%struct.anon.72 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type { [4 x %struct.cgroup_subsys_state*], %struct.refcount_struct, %struct.css_set*, %struct.cgroup*, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, [4 x %struct.list_head], %struct.list_head, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.cgroup*, %struct.css_set*, i8, %struct.callback_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.work_struct, %struct.rcu_work, %struct.cgroup_subsys_state* }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*, i32)*, i32 (%struct.seq_file*, %struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void ()*, i32 (%struct.task_struct*, %struct.css_set*)*, void (%struct.task_struct*, %struct.css_set*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i8, i32, i8*, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.cgroup_taskset = type opaque
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, i64, %struct.atomic_t, %struct.list_head, i32, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.idr, i32, i32, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.wait_queue_head }
%struct.kernfs_syscall_ops = type { i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_node*, %struct.kernfs_root*)* }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernfs_node*, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [4 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [4 x %struct.list_head], %struct.cgroup*, %struct.cgroup*, %struct.cgroup_rstat_cpu*, %struct.list_head, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.prev_cputime, %struct.list_head, %struct.mutex, %struct.wait_queue_head, %struct.work_struct, %struct.psi_group, %struct.cgroup_bpf, %struct.atomic_t, %struct.cgroup_freezer_state, [0 x i64] }
%struct.cgroup_file = type { %struct.kernfs_node*, i64, %struct.timer_list }
%struct.cgroup_rstat_cpu = type { %struct.u64_stats_sync, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.cgroup*, %struct.cgroup* }
%struct.cgroup_base_stat = type { %struct.task_cputime }
%struct.task_cputime = type { i64, i64, i64 }
%struct.psi_group = type {}
%struct.cgroup_bpf = type {}
%struct.cgroup_freezer_state = type { i8, i32, i32, i32 }
%struct.cftype = type { [64 x i8], i64, i64, i32, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.rcu_work = type { %struct.work_struct, %struct.callback_head, %struct.workqueue_struct* }
%struct.workqueue_struct = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type { %struct.pmu*, %struct.raw_spinlock, %struct.mutex, %struct.list_head, %struct.perf_event_groups, %struct.perf_event_groups, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i32, i32, i32, i32, i32, %struct.refcount_struct, %struct.task_struct*, i64, i64, %struct.perf_event_context*, i64, i64, i32, i8*, %struct.callback_head }
%struct.pmu = type { %struct.list_head, %struct.module*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, i8*, i32, i32, i32*, %struct.perf_cpu_context*, %struct.atomic_t, i32, i32, i32, void (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event*, %struct.mm_struct*)*, void (%struct.perf_event*, %struct.mm_struct*)*, i32 (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*)*, void (%struct.pmu*, i32)*, i32 (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event_context*, i1)*, %struct.kmem_cache*, void (%struct.perf_event_context*, %struct.perf_event_context*)*, i8* (%struct.perf_event*, i8**, i32, i1)*, void (i8*)*, i64 (%struct.perf_event*, %struct.perf_output_handle*, i64)*, i32 (%struct.list_head*)*, void (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*, i64)* }
%struct.perf_cpu_context = type { %struct.perf_event_context, %struct.perf_event_context*, i32, i32, %struct.raw_spinlock, %struct.hrtimer, i64, i32, %struct.list_head, i32, i32, i32, %struct.perf_event**, [2 x %struct.perf_event*] }
%struct.perf_event = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.rb_node, i64, %struct.list_head, %struct.hlist_node, %struct.list_head, i32, i32, i32, %struct.perf_event*, %struct.pmu*, i8*, i32, i32, %struct.local64_t, %struct.atomic64_t, i64, i64, i64, i64, %struct.perf_event_attr, i16, i16, i16, %struct.hw_perf_event, %struct.perf_event_context*, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.mutex, %struct.list_head, %struct.perf_event*, i32, i32, %struct.list_head, %struct.task_struct*, %struct.mutex, %struct.atomic_t, %struct.perf_buffer*, %struct.list_head, i64, i32, %struct.wait_queue_head, %struct.fasync_struct*, i32, i32, i32, i64, %struct.irq_work, %struct.atomic_t, %struct.perf_addr_filters_head, %struct.perf_addr_filter_range*, i64, %struct.perf_event*, void (%struct.perf_event*)*, %struct.callback_head, %struct.pid_namespace*, i64, i64 ()*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, i8*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, %struct.bpf_prog*, i64, %struct.trace_event_call*, %struct.event_filter*, i8*, %struct.list_head }
%struct.perf_event_attr = type { i32, i32, i64, %union.anon.80, i64, i64, i64, %union.anon.81, i32, %union.anon.82, %union.anon.83, i64, i64, i32, i32, i64, i32, i16, i16, i32, i32, i64 }
%union.anon.80 = type { i64 }
%union.anon.81 = type { i32 }
%union.anon.82 = type { i64 }
%union.anon.83 = type { i64 }
%struct.hw_perf_event = type { %union.anon.84, %struct.task_struct*, i8*, i64, i32, %struct.local64_t, i64, %union.anon.91, i64, i64, i64, i64 }
%union.anon.84 = type { %struct.anon.85 }
%struct.anon.85 = type { i64, i64, i64, i64, i32, i32, i32, i32, %struct.hw_perf_event_extra, %struct.hw_perf_event_extra }
%struct.hw_perf_event_extra = type { i64, i32, i32, i32 }
%union.anon.91 = type { %struct.anon.92 }
%struct.anon.92 = type { i64, %struct.local64_t }
%struct.perf_buffer = type opaque
%struct.fasync_struct = type { %struct.rwlock_t, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.irq_work = type { %struct.__call_single_node, void (%struct.irq_work*)* }
%struct.perf_addr_filters_head = type { %struct.list_head, %struct.raw_spinlock, i32 }
%struct.perf_addr_filter_range = type { i64, i64 }
%struct.perf_sample_data = type { i64, %struct.perf_raw_record*, %struct.perf_branch_stack*, i64, %union.perf_sample_weight, i64, %union.perf_mem_data_src, i64, i64, %struct.anon.97, i64, i64, i64, %struct.anon.98, %struct.perf_callchain_entry*, i64, %struct.perf_regs, %struct.perf_regs, i64, i64, i64, i64, i64, [56 x i8] }
%struct.perf_raw_record = type { %struct.perf_raw_frag, i32 }
%struct.perf_raw_frag = type <{ %union.anon.94, i64 (i8*, i8*, i64, i64)*, i8*, i32 }>
%union.anon.94 = type { %struct.perf_raw_frag* }
%struct.perf_branch_stack = type { i64, i64, [0 x %struct.perf_branch_entry] }
%struct.perf_branch_entry = type { i64, i64, i64 }
%union.perf_sample_weight = type { i64 }
%union.perf_mem_data_src = type { i64 }
%struct.anon.97 = type { i32, i32 }
%struct.anon.98 = type { i32, i32 }
%struct.perf_callchain_entry = type { i64, [0 x i64] }
%struct.perf_regs = type { i64, %struct.pt_regs* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.trace_event_call = type opaque
%struct.event_filter = type opaque
%struct.perf_output_handle = type { %struct.perf_event*, %struct.perf_buffer*, i64, i64, i64, %union.anon.99, i32 }
%union.anon.99 = type { i8* }
%struct.perf_event_groups = type { %struct.rb_root, i64 }
%struct.rseq = type { i32, i32, %union.anon.100, i32, [12 x i8] }
%union.anon.100 = type { i64 }
%struct.tlbflush_unmap_batch = type { %struct.arch_tlbflush_unmap_batch, i8, i8 }
%struct.arch_tlbflush_unmap_batch = type { %struct.cpumask }
%union.anon.101 = type { %struct.callback_head }
%struct.pipe_inode_info = type { %struct.mutex, %struct.wait_queue_head, %struct.wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.page = type { i64, %union.anon.4, %union.anon.119, %struct.atomic_t, [8 x i8] }
%union.anon.4 = type { %struct.anon.5 }
%struct.anon.5 = type { %struct.list_head, %struct.address_space*, i64, i64 }
%union.anon.119 = type { %struct.atomic_t }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.uprobe_task = type { i32, %union.anon.102, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.102 = type { %struct.anon.103 }
%struct.anon.103 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.kmap_ctrl = type {}
%struct.vm_struct = type { %struct.vm_struct*, i8*, i64, i64, %struct.page**, i32, i64, i8* }
%struct.bpf_local_storage = type opaque
%struct.bpf_run_ctx = type {}
%struct.llist_head = type { %struct.llist_node* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.io_bitmap*, i64, i8, i32, [40 x i8], %struct.fpu }
%struct.desc_struct = type { i16, i16, i32 }
%struct.io_bitmap = type opaque
%struct.fpu = type { i32, i64, [48 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.105, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.108 }
%union.anon.105 = type { %struct.anon.106 }
%struct.anon.106 = type { i64, i64 }
%union.anon.108 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.completion = type { i32, %struct.swait_queue_head }
%struct.swait_queue_head = type { %struct.raw_spinlock, %struct.list_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_subscriptions = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.pgprot = type { i64 }
%struct.anon.18 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, i32 (%struct.vm_fault*, i64, i64)*, i64 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.anon.19, i32, %struct.pmd_t*, %struct.pud_t*, %union.anon.20, %struct.page*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.anon.19 = type { %struct.vm_area_struct*, i32, i64, i64 }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%union.anon.20 = type { %struct.pte_t }
%struct.pte_t = type { i64 }
%struct.mempolicy = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, i8*, i32, i8, i32, i32, %struct.wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.115 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)*, i1 (%struct.file_lock*)* }
%union.anon.115 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.ucounts*, %struct.group_info*, %union.anon.46 }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%union.anon.46 = type { %struct.callback_head }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.timespec64, i64, i64 }
%struct.fiemap_extent_info = type opaque
%struct.fileattr = type opaque
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, i8*, i32, i64, i64, i32, %struct.fsnotify_mark_connector*, [32 x i8], %struct.uuid_t, i32, i32, %struct.mutex, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, %struct.atomic64_t, i32, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, i32 (%struct.fs_context*)*, %struct.fs_parameter_spec*, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.fs_context = type opaque
%struct.fs_parameter_spec = type opaque
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.spinlock, %struct.atomic_t, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.26, i32 }
%union.anon.26 = type { %struct.kuid_t }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.shrink_control = type { i32, i32, i64, i64, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.inode*, i64*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.rw_semaphore, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rcuwait, %struct.wait_queue_head, %struct.atomic_t }
%struct.rcu_sync = type { i32, i32, %struct.wait_queue_head, %struct.callback_head }
%struct.rcuwait = type { %struct.task_struct* }
%struct.uuid_t = type { [16 x i8] }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i64, i32, i32, %struct.list_head, %struct.atomic64_t* }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, i64, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%union.anon.191 = type { i32 }
%struct.timespec64 = type { i64, i64 }
%union.anon.192 = type { %struct.callback_head }
%union.anon.193 = type { %struct.file_operations* }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%union.anon.194 = type { %struct.pipe_inode_info* }
%struct.fsnotify_mark_connector = type opaque
%struct.xarray = type { %struct.spinlock, i32, i8* }
%struct.rb_root_cached = type { %struct.rb_root, %struct.rb_node* }
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.atomic64_t, %struct.optimistic_spin_queue, %struct.raw_spinlock, %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, void (%struct.readahead_control*)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.readahead_control = type opaque
%struct.swap_info_struct = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.65, i8*, i64, i16, i16, %struct.kernfs_iattrs* }
%union.anon.65 = type { %struct.kernfs_elem_dir }
%struct.kernfs_elem_dir = type { i64, %struct.rb_root, %struct.kernfs_root*, i64 }
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.120 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.120 = type { i8* }
%struct.kernel_symbol = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type { i32, i32*, %struct.orc_entry* }
%struct.orc_entry = type { i16, i16, i16 }
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8*, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.srcu_struct = type { [5 x %struct.srcu_node], [3 x %struct.srcu_node*], %struct.mutex, %struct.spinlock, %struct.mutex, i32, i64, i64, i64, i64, %struct.srcu_data*, i64, %struct.mutex, %struct.completion, %struct.atomic_t, %struct.delayed_work, %struct.lockdep_map }
%struct.srcu_node = type { %struct.spinlock, [4 x i64], [4 x i64], i64, %struct.srcu_node*, i32, i32 }
%struct.srcu_data = type { [2 x i64], [2 x i64], [32 x i8], %struct.spinlock, %struct.rcu_segcblist, i64, i64, i8, %struct.timer_list, %struct.work_struct, %struct.callback_head, %struct.srcu_node*, i64, i32, %struct.srcu_struct*, [48 x i8] }
%struct.rcu_segcblist = type { %struct.callback_head*, [4 x %struct.callback_head**], [4 x i64], i64, [4 x i64], i8 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.lockdep_map = type {}
%struct.bpf_raw_event_map = type { %struct.tracepoint*, i8*, i32, i32, [8 x i8] }
%struct.tracepoint = type { i8*, %struct.static_key, %struct.static_call_key*, i8*, i8*, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t, %union.anon.121 }
%union.anon.121 = type { i64 }
%struct.static_call_key = type { i8*, %union.anon.122 }
%union.anon.122 = type { i64 }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.jump_entry = type { i32, i32, i64 }
%struct.trace_eval_map = type opaque
%struct.static_call_site = type { i32, i32 }
%struct.error_injection_entry = type { i64, i32 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.btf_type = type { i32, i32, %union.anon.123 }
%union.anon.123 = type { i32 }
%struct.bpf_jit_poke_descriptor = type { i8*, i8*, i8*, i8*, %union.anon.124, i8, i8, i16, i32 }
%union.anon.124 = type { %struct.anon.125 }
%struct.anon.125 = type { %struct.bpf_map*, i32 }
%struct.bpf_map = type { %struct.bpf_map_ops*, %struct.bpf_map*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, [16 x i8], i32, i8, i8, [26 x i8], %struct.atomic64_t, %struct.atomic64_t, %struct.work_struct, %struct.mutex, i64, [40 x i8] }
%struct.bpf_map_ops = type { i32 (%union.bpf_attr*)*, %struct.bpf_map* (%union.bpf_attr*)*, void (%struct.bpf_map*, %struct.file*)*, void (%struct.bpf_map*)*, i32 (%struct.bpf_map*, i8*, i8*)*, void (%struct.bpf_map*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, %struct.file*, i32)*, void (i8*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (i8*)*, void (%struct.bpf_map*, i8*, %struct.seq_file*)*, i32 (%struct.bpf_map*, %struct.btf*, %struct.btf_type*, %struct.btf_type*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64, i32*)*, i32 (%struct.bpf_map*, %struct.vm_area_struct*)*, i32 (%struct.bpf_map*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.bpf_local_storage_map*, i8*, i32)*, void (%struct.bpf_local_storage_map*, i8*, i32)*, %struct.bpf_local_storage** (i8*)*, i32 (%struct.bpf_map*, i32, i64)*, i1 (%struct.bpf_map*, %struct.bpf_map*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i8*, i32*, %struct.bpf_iter_seq_info* }
%union.bpf_attr = type { %struct.anon.130 }
%struct.anon.130 = type { i32, i32, i64, i64, i32, i32, i64, i32, i32, [16 x i8], i32, i32, i32, i32, i64, i32, i32, i64, i32, i32, %union.anon.131, i32, i64 }
%union.anon.131 = type { i32 }
%struct.bpf_local_storage_map = type opaque
%struct.bpf_verifier_env = type { i32, i32, %struct.bpf_prog*, %struct.bpf_verifier_ops*, %struct.bpf_verifier_stack_elem*, i32, i8, i8, %struct.bpf_verifier_state*, %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*, [64 x %struct.bpf_map*], [64 x %struct.btf_mod_pair], i32, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, %struct.bpf_insn_aux_data*, %struct.bpf_line_info*, %struct.bpf_verifier_log, [257 x %struct.bpf_subprog_info], [75 x %struct.bpf_id_pair], %struct.anon.168, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, %struct.sockptr_t }
%struct.bpf_verifier_stack_elem = type { %struct.bpf_verifier_state, i32, i32, %struct.bpf_verifier_stack_elem*, i32 }
%struct.bpf_verifier_state = type { [8 x %struct.bpf_func_state*], %struct.bpf_verifier_state*, i32, i32, i32, i32, i8, i32, i32, %struct.bpf_idx_pair*, i32 }
%struct.bpf_idx_pair = type { i32, i32 }
%struct.bpf_verifier_state_list = type { %struct.bpf_verifier_state, %struct.bpf_verifier_state_list*, i32, i32 }
%struct.btf_mod_pair = type { %struct.btf*, %struct.module* }
%struct.bpf_insn_aux_data = type { %union.anon.163, i64, i32, i32, i8, i8, i8, i32, i8 }
%union.anon.163 = type { %struct.anon.165 }
%struct.anon.165 = type { i32, %union.anon.166 }
%union.anon.166 = type { %struct.anon.167 }
%struct.anon.167 = type { %struct.btf*, i32 }
%struct.bpf_verifier_log = type { i32, [1024 x i8], i8*, i32, i32 }
%struct.bpf_subprog_info = type { i32, i32, i16, i8, i8, i8, i8 }
%struct.bpf_id_pair = type { i32, i32 }
%struct.anon.168 = type { i32*, i32*, i32 }
%struct.sockptr_t = type { %union.anon.169, i8 }
%union.anon.169 = type { i8* }
%struct.bpf_func_state = type { [11 x %struct.bpf_reg_state], i32, i32, i32, i32, i8, i8, i32, %struct.bpf_reference_state*, i32, %struct.bpf_stack_state* }
%struct.bpf_reg_state = type { i32, i32, %union.anon.152, i32, i32, %struct.tnum, i64, i64, i64, i64, i32, i32, i32, i32, %struct.bpf_reg_state*, i32, i32, i32, i8 }
%union.anon.152 = type { %struct.anon.153 }
%struct.anon.153 = type { %struct.bpf_map*, i32 }
%struct.tnum = type { i64, i64 }
%struct.bpf_reference_state = type { i32, i32 }
%struct.bpf_stack_state = type { %struct.bpf_reg_state, [8 x i8] }
%struct.bpf_iter_seq_info = type { %struct.seq_operations*, i32 (i8*, %struct.bpf_iter_aux_info*)*, void (i8*)*, i32 }
%struct.bpf_iter_aux_info = type { %struct.bpf_map* }
%struct.bpf_kfunc_desc_tab = type { [256 x %struct.bpf_kfunc_desc], i32 }
%struct.bpf_kfunc_desc = type { %struct.btf_func_model, i32, i32 }
%struct.bpf_ksym = type { i64, i64, [128 x i8], %struct.list_head, %struct.latch_tree_node, i8 }
%struct.bpf_prog_ops = type { i32 (%struct.bpf_prog*, %union.bpf_attr*, %union.bpf_attr*)* }
%struct.user_struct = type { %struct.refcount_struct, %struct.percpu_counter, i64, %struct.atomic64_t, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t, %struct.ratelimit_state }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64, i64 }
%struct.bpf_prog_offload = type { %struct.bpf_prog*, %struct.net_device*, %struct.bpf_offload_dev*, i8*, %struct.list_head, i8, i8, i8*, i32 }
%struct.bpf_offload_dev = type opaque
%struct.bpf_func_info = type { i32, i32 }
%struct.bpf_func_info_aux = type { i16, i8 }
%struct.bpf_line_info = type { i32, i32, i32, i32 }
%struct.exception_table_entry = type { i32, i32, i32 }
%union.anon.156 = type { %struct.work_struct }
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.bpf_insn_access_aux = type { i32, %union.anon.161, %struct.bpf_verifier_log* }
%union.anon.161 = type { %struct.anon.162 }
%struct.anon.162 = type { %struct.btf*, i32 }
%struct.btf_id_set = type { i32, [0 x i32] }
%struct.bpf_reg_types = type { [10 x i32], i32* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.bpf_call_arg_meta = type { %struct.bpf_map*, i8, i8, i32, i32, i32, i64, i32, i32, i32, %struct.btf*, i32, %struct.btf*, i32, i32 }
%struct.bpf_attach_target_info = type { %struct.btf_func_model, i64, i8*, %struct.btf_type* }
%struct.fd = type { %struct.file*, i32 }
%struct.anon.164 = type { i32, i32 }
%struct.bpf_array = type { %struct.bpf_map, i32, i32, %struct.bpf_array_aux*, %union.anon.196, [48 x i8] }
%struct.bpf_array_aux = type { %struct.anon.195, %struct.list_head, %struct.bpf_map*, %struct.mutex, %struct.work_struct }
%struct.anon.195 = type { %struct.spinlock, i32, i8 }
%union.anon.196 = type { [0 x i8*] }
%struct.anon.154 = type { %struct.btf*, i32 }
%struct.bpf_struct_ops = type { %struct.bpf_verifier_ops*, i32 (%struct.btf*)*, i32 (%struct.btf_type*, %struct.btf_member*)*, i32 (%struct.btf_type*, %struct.btf_member*, i8*, i8*)*, i32 (i8*)*, void (i8*)*, %struct.btf_type*, %struct.btf_type*, i8*, [64 x %struct.btf_func_model], i32, i32 }
%struct.btf_member = type { i32, i32, i32 }
%struct.btf_var_secinfo = type { i32, i32, i32 }
%struct.bpf_insn_cbs = type { void (i8*, i8*, ...)*, i8* (i8*, %struct.bpf_insn*)*, i8* (i8*, %struct.bpf_insn*, i64)*, i8* }
%struct.btf_param = type { i32, i32 }
%struct.bpf_sanitize_info = type { %struct.bpf_insn_aux_data, i8 }
%struct.anon.155 = type { i64, i64 }

@bpf_verifier_vlog.__already_done = internal global i8 0, section ".data.once", align 1
@.str = private unnamed_addr constant [54 x i8] c"verifier log line truncated - local buffer too short\0A\00", align 1
@.str.1 = private unnamed_addr constant [22 x i8] c"kernel/bpf/verifier.c\00", align 1
@.str.2 = private unnamed_addr constant [10 x i8] c"\013BPF:%s\0A\00", align 1
@__UNIQUE_ID___addressable_bpf_verifier_log_write431 = internal global i8* bitcast (void (%struct.bpf_verifier_env*, i8*, ...)* @bpf_verifier_log_write to i8*), section ".discard.addressable", align 8
@.str.3 = private unnamed_addr constant [55 x i8] c"dereference of modified ctx ptr R%d off=%d disallowed\0A\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"variable ctx access var_off=%s disallowed\0A\00", align 1
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn = private unnamed_addr constant %struct.bpf_insn { i8 15, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn = private unnamed_addr constant %struct.bpf_insn { i8 31, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn = private unnamed_addr constant %struct.bpf_insn { i8 79, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn = private unnamed_addr constant %struct.bpf_insn { i8 95, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 111, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 127, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn = private unnamed_addr constant %struct.bpf_insn { i8 -81, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 -49, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 12, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 28, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 76, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 92, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 108, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 124, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -84, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -52, i8 33, i16 0, i32 0 }, align 4
@__const.bpf_check_attach_target.prefix = private unnamed_addr constant [11 x i8] c"btf_trace_\00", align 1
@.str.5 = private unnamed_addr constant [38 x i8] c"Tracing programs must provide btf_id\0A\00", align 1
@.str.6 = private unnamed_addr constant [81 x i8] c"FENTRY/FEXIT program can only be attached to another program annotated with BTF\0A\00", align 1
@.str.7 = private unnamed_addr constant [29 x i8] c"attach_btf_id %u is invalid\0A\00", align 1
@.str.8 = private unnamed_addr constant [38 x i8] c"attach_btf_id %u doesn't have a name\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Subprog %s doesn't exist\0A\00", align 1
@.str.10 = private unnamed_addr constant [33 x i8] c"Cannot replace static functions\0A\00", align 1
@.str.11 = private unnamed_addr constant [36 x i8] c"Extension programs should be JITed\0A\00", align 1
@.str.12 = private unnamed_addr constant [32 x i8] c"Can attach to only JITed progs\0A\00", align 1
@.str.13 = private unnamed_addr constant [27 x i8] c"Cannot recursively attach\0A\00", align 1
@.str.14 = private unnamed_addr constant [28 x i8] c"Cannot extend fentry/fexit\0A\00", align 1
@.str.15 = private unnamed_addr constant [33 x i8] c"Cannot replace kernel functions\0A\00", align 1
@.str.16 = private unnamed_addr constant [60 x i8] c"Only FENTRY/FEXIT progs are attachable to another BPF prog\0A\00", align 1
@.str.17 = private unnamed_addr constant [35 x i8] c"attach_btf_id %u is not a typedef\0A\00", align 1
@.str.18 = private unnamed_addr constant [47 x i8] c"attach_btf_id %u points to wrong type name %s\0A\00", align 1
@.str.19 = private unnamed_addr constant [36 x i8] c"attach_btf_id %u is not a function\0A\00", align 1
@.str.20 = private unnamed_addr constant [44 x i8] c"The address of function %s cannot be found\0A\00", align 1
@.str.21 = private unnamed_addr constant [21 x i8] c"%s is not sleepable\0A\00", align 1
@.str.22 = private unnamed_addr constant [43 x i8] c"can't modify return codes of BPF programs\0A\00", align 1
@.str.23 = private unnamed_addr constant [24 x i8] c"%s() is not modifiable\0A\00", align 1
@btf_vmlinux = dso_local global %struct.btf* null, align 8
@bpf_verifier_lock = internal global %struct.mutex { %struct.atomic64_t zeroinitializer, %struct.raw_spinlock zeroinitializer, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*) } }, align 8
@bpf_verifier_ops = internal constant [32 x %struct.bpf_verifier_ops*] [%struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_filter_verifier_ops, %struct.bpf_verifier_ops* @kprobe_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tracepoint_verifier_ops, %struct.bpf_verifier_ops* @xdp_verifier_ops, %struct.bpf_verifier_ops* @perf_event_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_in_verifier_ops, %struct.bpf_verifier_ops* @lwt_out_verifier_ops, %struct.bpf_verifier_ops* @lwt_xmit_verifier_ops, %struct.bpf_verifier_ops* @sock_ops_verifier_ops, %struct.bpf_verifier_ops* @sk_skb_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_msg_verifier_ops, %struct.bpf_verifier_ops* @raw_tracepoint_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_seg6local_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_reuseport_verifier_ops, %struct.bpf_verifier_ops* @flow_dissector_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @raw_tracepoint_writable_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @tracing_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_lookup_verifier_ops, %struct.bpf_verifier_ops* @bpf_syscall_verifier_ops], align 16
@.str.24 = private unnamed_addr constant [28 x i8] c"in-kernel BTF is malformed\0A\00", align 1
@.str.25 = private unnamed_addr constant [28 x i8] c"include/linux/thread_info.h\00", align 1
@.str.26 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@mark_ptr_not_null_reg.__already_done = internal global i8 0, section ".data.once", align 1
@.str.27 = private unnamed_addr constant [31 x i8] c"unknown nullable register type\00", align 1
@.str.28 = private unnamed_addr constant [7 x i8] c"rdonly\00", align 1
@.str.29 = private unnamed_addr constant [5 x i8] c"rdwr\00", align 1
@.str.30 = private unnamed_addr constant [25 x i8] c"R%d type=%s expected=%s\0A\00", align 1
@reg_type_str = internal constant [30 x i8*] [i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.92, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.93, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.94, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.95, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.96, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.97, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.98, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.99, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.100, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.103, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.105, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.106, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.107, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.108, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.110, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.113, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.114, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.115, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.116, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.117, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.118, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.119, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.120, i32 0, i32 0)], align 16
@.str.31 = private unnamed_addr constant [84 x i8] c"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\0A\00", align 1
@.str.32 = private unnamed_addr constant [37 x i8] c"R%d offset is outside of the packet\0A\00", align 1
@.str.33 = private unnamed_addr constant [55 x i8] c"invalid access to map key, key_size=%d off=%d size=%d\0A\00", align 1
@.str.34 = private unnamed_addr constant [59 x i8] c"invalid access to map value, value_size=%d off=%d size=%d\0A\00", align 1
@.str.35 = private unnamed_addr constant [66 x i8] c"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\0A\00", align 1
@.str.36 = private unnamed_addr constant [54 x i8] c"invalid access to memory, mem_size=%u off=%d size=%d\0A\00", align 1
@.str.37 = private unnamed_addr constant [54 x i8] c"R%d min value is outside of the allowed memory range\0A\00", align 1
@.str.38 = private unnamed_addr constant [72 x i8] c"R%d unbounded memory access, make sure to bounds check any such access\0A\00", align 1
@.str.39 = private unnamed_addr constant [54 x i8] c"R%d max value is outside of the allowed memory range\0A\00", align 1
@.str.40 = private unnamed_addr constant [10 x i8] c" frame%d:\00", align 1
@.str.41 = private unnamed_addr constant [5 x i8] c" R%d\00", align 1
@.str.42 = private unnamed_addr constant [4 x i8] c"=%s\00", align 1
@.str.43 = private unnamed_addr constant [2 x i8] c"P\00", align 1
@.str.44 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.45 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.46 = private unnamed_addr constant [7 x i8] c"(id=%d\00", align 1
@.str.47 = private unnamed_addr constant [15 x i8] c",ref_obj_id=%d\00", align 1
@.str.48 = private unnamed_addr constant [8 x i8] c",off=%d\00", align 1
@.str.49 = private unnamed_addr constant [6 x i8] c",r=%d\00", align 1
@.str.50 = private unnamed_addr constant [13 x i8] c",ks=%d,vs=%d\00", align 1
@.str.51 = private unnamed_addr constant [10 x i8] c",imm=%llx\00", align 1
@.str.52 = private unnamed_addr constant [17 x i8] c",smin_value=%lld\00", align 1
@.str.53 = private unnamed_addr constant [17 x i8] c",smax_value=%lld\00", align 1
@.str.54 = private unnamed_addr constant [17 x i8] c",umin_value=%llu\00", align 1
@.str.55 = private unnamed_addr constant [17 x i8] c",umax_value=%llu\00", align 1
@.str.56 = private unnamed_addr constant [12 x i8] c",var_off=%s\00", align 1
@.str.57 = private unnamed_addr constant [18 x i8] c",s32_min_value=%d\00", align 1
@.str.58 = private unnamed_addr constant [18 x i8] c",s32_max_value=%d\00", align 1
@.str.59 = private unnamed_addr constant [18 x i8] c",u32_min_value=%d\00", align 1
@.str.60 = private unnamed_addr constant [18 x i8] c",u32_max_value=%d\00", align 1
@.str.61 = private unnamed_addr constant [2 x i8] c")\00", align 1
@slot_type_char = internal global [4 x i8] c"?rm0", align 1
@.str.62 = private unnamed_addr constant [6 x i8] c" fp%d\00", align 1
@.str.63 = private unnamed_addr constant [9 x i8] c" refs=%d\00", align 1
@.str.64 = private unnamed_addr constant [4 x i8] c",%d\00", align 1
@.str.65 = private unnamed_addr constant [4 x i8] c" cb\00", align 1
@.str.66 = private unnamed_addr constant [10 x i8] c" async_cb\00", align 1
@.str.67 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.68 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.69 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.70 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.71 = private unnamed_addr constant [2 x i8] c"D\00", align 1
@.str.72 = private unnamed_addr constant [56 x i8] c"write into map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.73 = private unnamed_addr constant [55 x i8] c"read from map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.74 = private unnamed_addr constant [57 x i8] c"bpf_spin_lock cannot be accessed directly by load/store\0A\00", align 1
@.str.75 = private unnamed_addr constant [53 x i8] c"bpf_timer cannot be accessed directly by load/store\0A\00", align 1
@.str.76 = private unnamed_addr constant [47 x i8] c"R%d invalid %s buffer access: off=%d, size=%d\0A\00", align 1
@.str.77 = private unnamed_addr constant [56 x i8] c"R%d invalid variable buffer offset: off=%d, var_off=%s\0A\00", align 1
@.str.78 = private unnamed_addr constant [10 x i8] c" indirect\00", align 1
@.str.79 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.80 = private unnamed_addr constant [25 x i8] c"invalid zero-sized read\0A\00", align 1
@.str.81 = private unnamed_addr constant [69 x i8] c"R%d%s variable offset stack access prohibited for !root, var_off=%s\0A\00", align 1
@.str.82 = private unnamed_addr constant [49 x i8] c"invalid%s read from stack R%d off %d+%d size %d\0A\00", align 1
@.str.83 = private unnamed_addr constant [53 x i8] c"invalid%s read from stack R%d var_off %s+%d size %d\0A\00", align 1
@.str.84 = private unnamed_addr constant [20 x i8] c" indirect access to\00", align 1
@.str.85 = private unnamed_addr constant [11 x i8] c" read from\00", align 1
@.str.86 = private unnamed_addr constant [10 x i8] c" write to\00", align 1
@.str.87 = private unnamed_addr constant [47 x i8] c"invalid unbounded variable-offset%s stack R%d\0A\00", align 1
@.str.88 = private unnamed_addr constant [36 x i8] c"invalid%s stack R%d off=%d size=%d\0A\00", align 1
@.str.89 = private unnamed_addr constant [56 x i8] c"invalid variable-offset%s stack R%d var_off=%s size=%d\0A\00", align 1
@tnum_unknown = external dso_local constant %struct.tnum, align 8
@.str.90 = private unnamed_addr constant [42 x i8] c"verifier BUG type %s var_off %lld off %d\0A\00", align 1
@.str.91 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.92 = private unnamed_addr constant [4 x i8] c"inv\00", align 1
@.str.93 = private unnamed_addr constant [4 x i8] c"ctx\00", align 1
@.str.94 = private unnamed_addr constant [8 x i8] c"map_ptr\00", align 1
@.str.95 = private unnamed_addr constant [10 x i8] c"map_value\00", align 1
@.str.96 = private unnamed_addr constant [18 x i8] c"map_value_or_null\00", align 1
@.str.97 = private unnamed_addr constant [3 x i8] c"fp\00", align 1
@.str.98 = private unnamed_addr constant [9 x i8] c"pkt_meta\00", align 1
@.str.99 = private unnamed_addr constant [4 x i8] c"pkt\00", align 1
@.str.100 = private unnamed_addr constant [8 x i8] c"pkt_end\00", align 1
@.str.101 = private unnamed_addr constant [10 x i8] c"flow_keys\00", align 1
@.str.102 = private unnamed_addr constant [5 x i8] c"sock\00", align 1
@.str.103 = private unnamed_addr constant [13 x i8] c"sock_or_null\00", align 1
@.str.104 = private unnamed_addr constant [12 x i8] c"sock_common\00", align 1
@.str.105 = private unnamed_addr constant [20 x i8] c"sock_common_or_null\00", align 1
@.str.106 = private unnamed_addr constant [9 x i8] c"tcp_sock\00", align 1
@.str.107 = private unnamed_addr constant [17 x i8] c"tcp_sock_or_null\00", align 1
@.str.108 = private unnamed_addr constant [10 x i8] c"tp_buffer\00", align 1
@.str.109 = private unnamed_addr constant [9 x i8] c"xdp_sock\00", align 1
@.str.110 = private unnamed_addr constant [5 x i8] c"ptr_\00", align 1
@.str.111 = private unnamed_addr constant [13 x i8] c"ptr_or_null_\00", align 1
@.str.112 = private unnamed_addr constant [4 x i8] c"mem\00", align 1
@.str.113 = private unnamed_addr constant [12 x i8] c"mem_or_null\00", align 1
@.str.114 = private unnamed_addr constant [11 x i8] c"rdonly_buf\00", align 1
@.str.115 = private unnamed_addr constant [19 x i8] c"rdonly_buf_or_null\00", align 1
@.str.116 = private unnamed_addr constant [9 x i8] c"rdwr_buf\00", align 1
@.str.117 = private unnamed_addr constant [17 x i8] c"rdwr_buf_or_null\00", align 1
@.str.118 = private unnamed_addr constant [12 x i8] c"percpu_ptr_\00", align 1
@.str.119 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str.120 = private unnamed_addr constant [8 x i8] c"map_key\00", align 1
@sanitize_err.err = internal global i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.121, i32 0, i32 0), align 8
@.str.121 = private unnamed_addr constant [48 x i8] c"pointer arithmetic with it prohibited for !root\00", align 1
@.str.122 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@.str.123 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.124 = private unnamed_addr constant [53 x i8] c"R%d has unknown scalar with mixed signed bounds, %s\0A\00", align 1
@.str.125 = private unnamed_addr constant [52 x i8] c"R%d has pointer with unsupported alu operation, %s\0A\00", align 1
@.str.126 = private unnamed_addr constant [59 x i8] c"R%d tried to %s from different maps, paths or scalars, %s\0A\00", align 1
@.str.127 = private unnamed_addr constant [43 x i8] c"R%d tried to %s beyond pointer bounds, %s\0A\00", align 1
@.str.128 = private unnamed_addr constant [58 x i8] c"R%d could not be pushed for speculative verification, %s\0A\00", align 1
@.str.129 = private unnamed_addr constant [46 x i8] c"verifier internal error: unknown reason (%d)\0A\00", align 1
@flip_opcode.opcode_flip = internal constant [16 x i8] c"\00\10\A0\B0@P\C0\D0\00\00 0`p\00\00", align 16
@btf_non_sleepable_error_inject = internal global %struct.btf_id_set zeroinitializer, align 4
@.str.130 = private unnamed_addr constant [10 x i8] c"security_\00", align 1
@kmalloc_caches = external dso_local global [3 x [14 x %struct.kmem_cache*]], align 16
@.str.131 = private unnamed_addr constant [21 x i8] c"include/linux/slab.h\00", align 1
@sk_filter_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@kprobe_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tc_cls_act_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@xdp_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@perf_event_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_in_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_out_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_xmit_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sock_ops_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_skb_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_msg_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_seg6local_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_reuseport_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@flow_dissector_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_writable_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracing_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_lookup_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@bpf_syscall_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@.str.132 = private unnamed_addr constant [89 x i8] c"loading/calling other bpf or kernel functions are allowed for CAP_BPF and CAP_SYS_ADMIN\0A\00", align 1
@.str.133 = private unnamed_addr constant [13 x i8] c"func#%d @%d\0A\00", align 1
@.str.134 = private unnamed_addr constant [29 x i8] c"call to invalid destination\0A\00", align 1
@.str.135 = private unnamed_addr constant [22 x i8] c"too many subprograms\0A\00", align 1
@.str.136 = private unnamed_addr constant [72 x i8] c"calling kernel function is not supported without CONFIG_DEBUG_INFO_BTF\0A\00", align 1
@.str.137 = private unnamed_addr constant [45 x i8] c"JIT is required for calling kernel function\0A\00", align 1
@.str.138 = private unnamed_addr constant [46 x i8] c"JIT does not support calling kernel function\0A\00", align 1
@.str.139 = private unnamed_addr constant [61 x i8] c"cannot call kernel function from non-GPL compatible program\0A\00", align 1
@.str.140 = private unnamed_addr constant [42 x i8] c"too many different kernel function calls\0A\00", align 1
@.str.141 = private unnamed_addr constant [36 x i8] c"kernel btf_id %u is not a function\0A\00", align 1
@.str.142 = private unnamed_addr constant [60 x i8] c"kernel function btf_id %u does not have a valid func_proto\0A\00", align 1
@.str.143 = private unnamed_addr constant [44 x i8] c"cannot find address for kernel function %s\0A\00", align 1
@.str.144 = private unnamed_addr constant [38 x i8] c"jump out of range from insn %d to %d\0A\00", align 1
@.str.145 = private unnamed_addr constant [33 x i8] c"last insn is not an exit or jmp\0A\00", align 1
@.str.146 = private unnamed_addr constant [47 x i8] c"LD_ABS is not allowed in subprogs without BTF\0A\00", align 1
@.str.147 = private unnamed_addr constant [50 x i8] c"tail_call is not allowed in subprogs without BTF\0A\00", align 1
@.str.148 = private unnamed_addr constant [63 x i8] c"number of funcs in func_info doesn't match number of subprogs\0A\00", align 1
@.str.149 = private unnamed_addr constant [31 x i8] c"invalid func info rec size %u\0A\00", align 1
@.str.150 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in func info\00", align 1
@.str.151 = private unnamed_addr constant [51 x i8] c"nonzero insn_off %u for the first func info record\00", align 1
@.str.152 = private unnamed_addr constant [69 x i8] c"same or smaller insn offset (%u) than previous func info record (%u)\00", align 1
@.str.153 = private unnamed_addr constant [67 x i8] c"func_info BTF section doesn't match subprog layout in BPF program\0A\00", align 1
@.str.154 = private unnamed_addr constant [32 x i8] c"invalid type id %d in func info\00", align 1
@.str.155 = private unnamed_addr constant [56 x i8] c"LD_ABS is only allowed in functions that return 'int'.\0A\00", align 1
@.str.156 = private unnamed_addr constant [59 x i8] c"tail_call is only allowed in functions that return 'int'.\0A\00", align 1
@.str.157 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in line_info\00", align 1
@.str.158 = private unnamed_addr constant [65 x i8] c"Invalid line_info[%u].insn_off:%u (prev_offset:%u prog->len:%u)\0A\00", align 1
@.str.159 = private unnamed_addr constant [45 x i8] c"Invalid insn code at line_info[%u].insn_off\0A\00", align 1
@.str.160 = private unnamed_addr constant [50 x i8] c"Invalid line_info[%u].line_off or .file_name_off\0A\00", align 1
@.str.161 = private unnamed_addr constant [35 x i8] c"missing bpf_line_info for func#%u\0A\00", align 1
@.str.162 = private unnamed_addr constant [58 x i8] c"missing bpf_line_info for %u funcs starting from func#%u\0A\00", align 1
@.str.163 = private unnamed_addr constant [40 x i8] c"Syscall programs can only be sleepable\0A\00", align 1
@.str.164 = private unnamed_addr constant [62 x i8] c"Only fentry/fexit/fmod_ret and lsm programs can be sleepable\0A\00", align 1
@btf_id_deny = internal global %struct.btf_id_set zeroinitializer, align 4
@.str.165 = private unnamed_addr constant [56 x i8] c"struct ops programs must have a GPL compatible license\0A\00", align 1
@.str.166 = private unnamed_addr constant [44 x i8] c"attach_btf_id %u is not a supported struct\0A\00", align 1
@.str.167 = private unnamed_addr constant [46 x i8] c"attach to invalid member idx %u of struct %s\0A\00", align 1
@.str.168 = private unnamed_addr constant [51 x i8] c"attach to invalid member %s(@idx %u) of struct %s\0A\00", align 1
@.str.169 = private unnamed_addr constant [46 x i8] c"attach to unsupported member %s of struct %s\0A\00", align 1
@.str.170 = private unnamed_addr constant [30 x i8] c"BPF_LDX uses reserved fields\0A\00", align 1
@.str.171 = private unnamed_addr constant [27 x i8] c"invalid bpf_ld_imm64 insn\0A\00", align 1
@.str.172 = private unnamed_addr constant [32 x i8] c"unrecognized bpf_ld_imm64 insn\0A\00", align 1
@.str.173 = private unnamed_addr constant [36 x i8] c"fd_idx without fd_array is invalid\0A\00", align 1
@.str.174 = private unnamed_addr constant [40 x i8] c"fd %d is not pointing to valid bpf_map\0A\00", align 1
@.str.175 = private unnamed_addr constant [42 x i8] c"direct value offset of %u is not allowed\0A\00", align 1
@.str.176 = private unnamed_addr constant [50 x i8] c"no direct value access support for this map type\0A\00", align 1
@.str.177 = private unnamed_addr constant [59 x i8] c"invalid access to map value pointer, value_size=%u off=%u\0A\00", align 1
@.str.178 = private unnamed_addr constant [49 x i8] c"only one cgroup storage of each type is allowed\0A\00", align 1
@.str.179 = private unnamed_addr constant [21 x i8] c"unknown opcode %02x\0A\00", align 1
@.str.180 = private unnamed_addr constant [41 x i8] c"invalid module BTF object FD specified.\0A\00", align 1
@.str.181 = private unnamed_addr constant [83 x i8] c"kernel is missing BTF, make sure CONFIG_DEBUG_INFO_BTF=y is specified in Kconfig.\0A\00", align 1
@.str.182 = private unnamed_addr constant [43 x i8] c"ldimm64 insn specifies invalid btf_id %d.\0A\00", align 1
@.str.183 = private unnamed_addr constant [45 x i8] c"pseudo btf_id %d in ldimm64 isn't KIND_VAR.\0A\00", align 1
@.str.184 = private unnamed_addr constant [60 x i8] c"ldimm64 failed to find the address for kernel symbol '%s'.\0A\00", align 1
@.str.185 = private unnamed_addr constant [54 x i8] c"ldimm64 unable to resolve the size of type '%s': %ld\0A\00", align 1
@.str.186 = private unnamed_addr constant [14 x i8] c".data..percpu\00", align 1
@.str.187 = private unnamed_addr constant [56 x i8] c"perf_event programs can only use preallocated hash map\0A\00", align 1
@check_map_prog_compatibility.__already_done = internal global i8 0, section ".data.once", align 1
@.str.188 = private unnamed_addr constant [49 x i8] c"trace type BPF program uses run-time allocation\0A\00", align 1
@.str.189 = private unnamed_addr constant [101 x i8] c"trace type programs with run-time allocated hash maps are unsafe. Switch to preallocated hash maps.\0A\00", align 1
@.str.190 = private unnamed_addr constant [50 x i8] c"socket filter progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.191 = private unnamed_addr constant [44 x i8] c"tracing progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.192 = private unnamed_addr constant [46 x i8] c"sleepable progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.193 = private unnamed_addr constant [46 x i8] c"offload device mismatch between prog and map\0A\00", align 1
@.str.194 = private unnamed_addr constant [43 x i8] c"bpf_struct_ops map cannot be used in prog\0A\00", align 1
@.str.195 = private unnamed_addr constant [51 x i8] c"Sleepable programs can only use preallocated maps\0A\00", align 1
@.str.196 = private unnamed_addr constant [63 x i8] c"Sleepable programs can only use array, hash, and ringbuf maps\0A\00", align 1
@bpf_map_offload_ops = external dso_local constant %struct.bpf_map_ops, align 8
@.str.197 = private unnamed_addr constant [25 x i8] c"visit_insn internal bug\0A\00", align 1
@.str.198 = private unnamed_addr constant [24 x i8] c"pop stack internal bug\0A\00", align 1
@.str.199 = private unnamed_addr constant [21 x i8] c"unreachable insn %d\0A\00", align 1
@.str.200 = private unnamed_addr constant [5 x i8] c"%d: \00", align 1
@.str.201 = private unnamed_addr constant [30 x i8] c"back-edge from insn %d to %d\0A\00", align 1
@.str.202 = private unnamed_addr constant [25 x i8] c"insn state internal bug\0A\00", align 1
@.str.203 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@_ctype = external dso_local constant [0 x i8], align 1
@.str.204 = private unnamed_addr constant [55 x i8] c"Func#%d is safe for any args that match its prototype\0A\00", align 1
@.str.205 = private unnamed_addr constant [29 x i8] c"mark_reg_not_init(regs, %u)\0A\00", align 1
@.str.206 = private unnamed_addr constant [31 x i8] c"mark_reg_known_zero(regs, %u)\0A\00", align 1
@.str.207 = private unnamed_addr constant [28 x i8] c"mark_reg_unknown(regs, %u)\0A\00", align 1
@.str.208 = private unnamed_addr constant [33 x i8] c"invalid insn idx %d insn_cnt %d\0A\00", align 1
@.str.209 = private unnamed_addr constant [45 x i8] c"BPF program is too large. Processed %d insn\0A\00", align 1
@.str.210 = private unnamed_addr constant [24 x i8] c"\0Afrom %d to %d%s: safe\0A\00", align 1
@.str.211 = private unnamed_addr constant [25 x i8] c" (speculative execution)\00", align 1
@.str.212 = private unnamed_addr constant [10 x i8] c"%d: safe\0A\00", align 1
@.str.213 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.214 = private unnamed_addr constant [18 x i8] c"\0Afrom %d to %d%s:\00", align 1
@.str.215 = private unnamed_addr constant [3 x i8] c"; \00", align 1
@.str.216 = private unnamed_addr constant [50 x i8] c"same insn cannot be used with different pointers\0A\00", align 1
@.str.217 = private unnamed_addr constant [30 x i8] c"BPF_STX uses reserved fields\0A\00", align 1
@.str.218 = private unnamed_addr constant [29 x i8] c"BPF_ST uses reserved fields\0A\00", align 1
@.str.219 = private unnamed_addr constant [42 x i8] c"BPF_ST stores into R%d %s is not allowed\0A\00", align 1
@.str.220 = private unnamed_addr constant [31 x i8] c"BPF_CALL uses reserved fields\0A\00", align 1
@.str.221 = private unnamed_addr constant [53 x i8] c"function calls are not allowed while holding a lock\0A\00", align 1
@.str.222 = private unnamed_addr constant [29 x i8] c"BPF_JA uses reserved fields\0A\00", align 1
@.str.223 = private unnamed_addr constant [31 x i8] c"BPF_EXIT uses reserved fields\0A\00", align 1
@.str.224 = private unnamed_addr constant [28 x i8] c"bpf_spin_unlock is missing\0A\00", align 1
@.str.225 = private unnamed_addr constant [21 x i8] c"invalid BPF_LD mode\0A\00", align 1
@.str.226 = private unnamed_addr constant [23 x i8] c"unknown insn class %d\0A\00", align 1
@.str.227 = private unnamed_addr constant [35 x i8] c"infinite loop detected at insn %d\0A\00", align 1
@is_state_visited.__already_done = internal global i8 0, section ".data.once", align 1
@.str.228 = private unnamed_addr constant [42 x i8] c"BUG live_done but branches_to_explore %d\0A\00", align 1
@is_state_visited.__already_done.229 = internal global i8 0, section ".data.once", align 1
@.str.230 = private unnamed_addr constant [53 x i8] c"BUG is_state_visited:branches_to_explore=%d insn %d\0A\00", align 1
@.str.231 = private unnamed_addr constant [50 x i8] c"propagate_live: parent frame %d current frame %d\0A\00", align 1
@.str.232 = private unnamed_addr constant [17 x i8] c"propagating r%d\0A\00", align 1
@.str.233 = private unnamed_addr constant [18 x i8] c"propagating fp%d\0A\00", align 1
@__mark_chain_precision.__already_done = internal global i8 0, section ".data.once", align 1
@.str.234 = private unnamed_addr constant [19 x i8] c"backtracing misuse\00", align 1
@.str.235 = private unnamed_addr constant [26 x i8] c"last_idx %d first_idx %d\0A\00", align 1
@.str.236 = private unnamed_addr constant [25 x i8] c"BUG backtracking idx %d\0A\00", align 1
@__mark_chain_precision.__already_done.237 = internal global i8 0, section ".data.once", align 1
@.str.238 = private unnamed_addr constant [26 x i8] c"verifier backtracking bug\00", align 1
@.str.239 = private unnamed_addr constant [36 x i8] c"parent %s regs=%x stack=%llx marks\0A\00", align 1
@.str.240 = private unnamed_addr constant [12 x i8] c"didn't have\00", align 1
@.str.241 = private unnamed_addr constant [12 x i8] c"already had\00", align 1
@.str.242 = private unnamed_addr constant [27 x i8] c"regs=%x stack=%llx before \00", align 1
@.str.243 = private unnamed_addr constant [12 x i8] c"BUG spi %d\0A\00", align 1
@backtrack_insn.__already_done = internal global i8 0, section ".data.once", align 1
@backtrack_insn.__already_done.244 = internal global i8 0, section ".data.once", align 1
@.str.245 = private unnamed_addr constant [13 x i8] c"BUG regs %x\0A\00", align 1
@backtrack_insn.__already_done.246 = internal global i8 0, section ".data.once", align 1
@current_task = external dso_local global %struct.task_struct*, section ".data..percpu", align 8
@.str.247 = private unnamed_addr constant [30 x i8] c"BPF_NEG uses reserved fields\0A\00", align 1
@.str.248 = private unnamed_addr constant [30 x i8] c"BPF_END uses reserved fields\0A\00", align 1
@.str.249 = private unnamed_addr constant [35 x i8] c"R%d pointer arithmetic prohibited\0A\00", align 1
@.str.250 = private unnamed_addr constant [30 x i8] c"BPF_MOV uses reserved fields\0A\00", align 1
@.str.251 = private unnamed_addr constant [29 x i8] c"R%d partial copy of pointer\0A\00", align 1
@.str.252 = private unnamed_addr constant [27 x i8] c"invalid BPF_ALU opcode %x\0A\00", align 1
@.str.253 = private unnamed_addr constant [30 x i8] c"BPF_ALU uses reserved fields\0A\00", align 1
@.str.254 = private unnamed_addr constant [13 x i8] c"div by zero\0A\00", align 1
@.str.255 = private unnamed_addr constant [18 x i8] c"invalid shift %d\0A\00", align 1
@.str.256 = private unnamed_addr constant [35 x i8] c"R%d pointer %s pointer prohibited\0A\00", align 1
@bpf_alu_string = external dso_local constant [16 x i8*], align 16
@.str.257 = private unnamed_addr constant [45 x i8] c"verifier internal error: unexpected ptr_reg\0A\00", align 1
@.str.258 = private unnamed_addr constant [37 x i8] c"verifier internal error: no src_reg\0A\00", align 1
@.str.259 = private unnamed_addr constant [42 x i8] c"R%d 32-bit pointer arithmetic prohibited\0A\00", align 1
@.str.260 = private unnamed_addr constant [62 x i8] c"R%d pointer arithmetic on %s prohibited, null-check it first\0A\00", align 1
@.str.261 = private unnamed_addr constant [41 x i8] c"R%d pointer arithmetic on %s prohibited\0A\00", align 1
@.str.262 = private unnamed_addr constant [43 x i8] c"R%d tried to subtract pointer from scalar\0A\00", align 1
@.str.263 = private unnamed_addr constant [47 x i8] c"R%d subtraction from stack pointer prohibited\0A\00", align 1
@.str.264 = private unnamed_addr constant [47 x i8] c"R%d bitwise operator %s on pointer prohibited\0A\00", align 1
@.str.265 = private unnamed_addr constant [52 x i8] c"R%d pointer arithmetic with %s operator prohibited\0A\00", align 1
@.str.266 = private unnamed_addr constant [49 x i8] c"math between %s pointer and %lld is not allowed\0A\00", align 1
@.str.267 = private unnamed_addr constant [37 x i8] c"%s pointer offset %d is not allowed\0A\00", align 1
@.str.268 = private unnamed_addr constant [78 x i8] c"math between %s pointer and register with unbounded min value is not allowed\0A\00", align 1
@.str.269 = private unnamed_addr constant [46 x i8] c"value %lld makes %s pointer be out of bounds\0A\00", align 1
@.str.270 = private unnamed_addr constant [42 x i8] c"The sequence of %d jumps is too complex.\0A\00", align 1
@.str.271 = private unnamed_addr constant [77 x i8] c"R%d pointer arithmetic of map value goes out of range, prohibited for !root\0A\00", align 1
@.str.272 = private unnamed_addr constant [67 x i8] c"R%d variable stack access prohibited for !root, var_off=%s off=%d\0A\00", align 1
@.str.273 = private unnamed_addr constant [78 x i8] c"R%d stack pointer arithmetic goes out of range, prohibited for !root; off=%d\0A\00", align 1
@.str.274 = private unnamed_addr constant [16 x i8] c"R%d is invalid\0A\00", align 1
@.str.275 = private unnamed_addr constant [14 x i8] c"R%d !read_ok\0A\00", align 1
@.str.276 = private unnamed_addr constant [28 x i8] c"frame pointer is read only\0A\00", align 1
@.str.277 = private unnamed_addr constant [37 x i8] c"write to change key R%d not allowed\0A\00", align 1
@.str.278 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into map\0A\00", align 1
@.str.279 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into mem\0A\00", align 1
@.str.280 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into ctx\0A\00", align 1
@.str.281 = private unnamed_addr constant [26 x i8] c"cannot write into packet\0A\00", align 1
@.str.282 = private unnamed_addr constant [28 x i8] c"R%d leaks addr into packet\0A\00", align 1
@.str.283 = private unnamed_addr constant [31 x i8] c"R%d leaks addr into flow keys\0A\00", align 1
@.str.284 = private unnamed_addr constant [26 x i8] c"R%d cannot write into %s\0A\00", align 1
@.str.285 = private unnamed_addr constant [29 x i8] c"R%d invalid mem access '%s'\0A\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"flow keys \00", align 1
@.str.287 = private unnamed_addr constant [5 x i8] c"key \00", align 1
@.str.288 = private unnamed_addr constant [7 x i8] c"value \00", align 1
@.str.289 = private unnamed_addr constant [9 x i8] c"context \00", align 1
@.str.290 = private unnamed_addr constant [7 x i8] c"stack \00", align 1
@.str.291 = private unnamed_addr constant [6 x i8] c"sock \00", align 1
@.str.292 = private unnamed_addr constant [13 x i8] c"sock_common \00", align 1
@.str.293 = private unnamed_addr constant [10 x i8] c"tcp_sock \00", align 1
@.str.294 = private unnamed_addr constant [10 x i8] c"xdp_sock \00", align 1
@.str.295 = private unnamed_addr constant [50 x i8] c"misaligned packet access off %d+%s+%d+%d size %d\0A\00", align 1
@.str.296 = private unnamed_addr constant [42 x i8] c"misaligned %saccess off %s+%d+%d size %d\0A\00", align 1
@.str.297 = private unnamed_addr constant [43 x i8] c"invalid bpf_context access off=%d size=%d\0A\00", align 1
@.str.298 = private unnamed_addr constant [96 x i8] c"variable offset stack pointer cannot be passed into helper function; var_off=%s off=%d size=%d\0A\00", align 1
@.str.299 = private unnamed_addr constant [67 x i8] c"R%d variable offset stack access prohibited for !root, var_off=%s\0A\00", align 1
@.str.300 = private unnamed_addr constant [31 x i8] c"invalid size of register fill\0A\00", align 1
@.str.301 = private unnamed_addr constant [24 x i8] c"corrupted spill memory\0A\00", align 1
@.str.302 = private unnamed_addr constant [35 x i8] c"leaking pointer from stack off %d\0A\00", align 1
@.str.303 = private unnamed_addr constant [43 x i8] c"invalid read from stack off %d+%d size %d\0A\00", align 1
@.str.304 = private unnamed_addr constant [45 x i8] c"attempt to corrupt spilled pointer on stack\0A\00", align 1
@.str.305 = private unnamed_addr constant [32 x i8] c"invalid size of register spill\0A\00", align 1
@.str.306 = private unnamed_addr constant [63 x i8] c"cannot spill pointers to stack into stack frame of the caller\0A\00", align 1
@.str.307 = private unnamed_addr constant [69 x i8] c"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\00", align 1
@.str.308 = private unnamed_addr constant [81 x i8] c"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\00", align 1
@.str.309 = private unnamed_addr constant [44 x i8] c"invalid access to flow keys off=%d size=%d\0A\00", align 1
@.str.310 = private unnamed_addr constant [38 x i8] c"R%d invalid %s access off=%d size=%d\0A\00", align 1
@.str.311 = private unnamed_addr constant [11 x i8] c"tracepoint\00", align 1
@.str.312 = private unnamed_addr constant [47 x i8] c"R%d is ptr_%s invalid negative access: off=%d\0A\00", align 1
@.str.313 = private unnamed_addr constant [59 x i8] c"R%d is ptr_%s invalid variable offset: off=%d, var_off=%s\0A\00", align 1
@.str.314 = private unnamed_addr constant [24 x i8] c"only read is supported\0A\00", align 1
@.str.315 = private unnamed_addr constant [60 x i8] c"map_ptr access not supported without CONFIG_DEBUG_INFO_BTF\0A\00", align 1
@.str.316 = private unnamed_addr constant [46 x i8] c"map_ptr access not supported for map type %d\0A\00", align 1
@.str.317 = private unnamed_addr constant [60 x i8] c"%s access is allowed only to CAP_PERFMON and CAP_SYS_ADMIN\0A\00", align 1
@.str.318 = private unnamed_addr constant [43 x i8] c"R%d is %s invalid negative access: off=%d\0A\00", align 1
@.str.319 = private unnamed_addr constant [32 x i8] c"only read from %s is supported\0A\00", align 1
@.str.320 = private unnamed_addr constant [44 x i8] c"BPF_ATOMIC uses invalid atomic opcode %02x\0A\00", align 1
@.str.321 = private unnamed_addr constant [29 x i8] c"invalid atomic operand size\0A\00", align 1
@.str.322 = private unnamed_addr constant [46 x i8] c"BPF_ATOMIC stores into R%d %s is not allowed\0A\00", align 1
@.str.323 = private unnamed_addr constant [44 x i8] c"verifier bug. No program starts at insn %d\0A\00", align 1
@.str.324 = private unnamed_addr constant [41 x i8] c"the call stack of %d frames is too deep\0A\00", align 1
@.str.325 = private unnamed_addr constant [42 x i8] c"verifier bug. Frame %d already allocated\0A\00", align 1
@.str.326 = private unnamed_addr constant [41 x i8] c"Caller passes invalid args into func#%d\0A\00", align 1
@.str.327 = private unnamed_addr constant [40 x i8] c"Func#%d is global and valid. Skipping.\0A\00", align 1
@.str.328 = private unnamed_addr constant [9 x i8] c"caller:\0A\00", align 1
@.str.329 = private unnamed_addr constant [9 x i8] c"callee:\0A\00", align 1
@caller_saved = internal constant [6 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5], align 16
@.str.330 = private unnamed_addr constant [55 x i8] c"The sequence of %d jumps is too complex for async cb.\0A\00", align 1
@.str.331 = private unnamed_addr constant [43 x i8] c"calling kernel function %s is not allowed\0A\00", align 1
@.str.332 = private unnamed_addr constant [64 x i8] c"kernel function %s returns pointer type %s %s is not supported\0A\00", align 1
@.str.333 = private unnamed_addr constant [20 x i8] c"invalid func %s#%d\0A\00", align 1
@.str.334 = private unnamed_addr constant [20 x i8] c"unknown func %s#%d\0A\00", align 1
@.str.335 = private unnamed_addr constant [69 x i8] c"cannot call GPL-restricted function from non-GPL compatible program\0A\00", align 1
@.str.336 = private unnamed_addr constant [37 x i8] c"helper call is not allowed in probe\0A\00", align 1
@.str.337 = private unnamed_addr constant [54 x i8] c"kernel subsystem misconfigured func %s#%d: r1 != ctx\0A\00", align 1
@.str.338 = private unnamed_addr constant [43 x i8] c"kernel subsystem misconfigured func %s#%d\0A\00", align 1
@.str.339 = private unnamed_addr constant [40 x i8] c"tail_call would lead to reference leak\0A\00", align 1
@.str.340 = private unnamed_addr constant [51 x i8] c"func %s#%d reference has not been acquired before\0A\00", align 1
@.str.341 = private unnamed_addr constant [52 x i8] c"get_local_storage() doesn't support non-zero flags\0A\00", align 1
@.str.342 = private unnamed_addr constant [41 x i8] c"kernel subsystem misconfigured verifier\0A\00", align 1
@.str.343 = private unnamed_addr constant [46 x i8] c"unable to resolve the size of type '%s': %ld\0A\00", align 1
@.str.344 = private unnamed_addr constant [38 x i8] c"invalid return type %d of func %s#%d\0A\00", align 1
@.str.345 = private unnamed_addr constant [38 x i8] c"unknown return type %d of func %s#%d\0A\00", align 1
@sysctl_perf_event_max_stack = external dso_local global i32, align 4
@.str.346 = private unnamed_addr constant [44 x i8] c"cannot get callchain buffer for func %s#%d\0A\00", align 1
@.str.347 = private unnamed_addr constant [37 x i8] c"R%d leaks addr into helper function\0A\00", align 1
@.str.348 = private unnamed_addr constant [44 x i8] c"helper access to the packet is not allowed\0A\00", align 1
@.str.349 = private unnamed_addr constant [70 x i8] c"verifier internal error: more than one arg with ref_obj_id R%d %u %u\0A\00", align 1
@.str.350 = private unnamed_addr constant [75 x i8] c"timer pointer in R1 map_uid=%d doesn't match map pointer in R2 map_uid=%d\0A\00", align 1
@.str.351 = private unnamed_addr constant [36 x i8] c"invalid map_ptr to access map->key\0A\00", align 1
@.str.352 = private unnamed_addr constant [38 x i8] c"invalid map_ptr to access map->value\0A\00", align 1
@.str.353 = private unnamed_addr constant [34 x i8] c"Helper has invalid btf_id in R%d\0A\00", align 1
@.str.354 = private unnamed_addr constant [25 x i8] c"verifier internal error\0A\00", align 1
@.str.355 = private unnamed_addr constant [66 x i8] c"R%d min value is negative, either use unsigned or 'var &= const'\0A\00", align 1
@.str.356 = private unnamed_addr constant [71 x i8] c"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\0A\00", align 1
@.str.357 = private unnamed_addr constant [30 x i8] c"R%d is not a known constant'\0A\00", align 1
@.str.358 = private unnamed_addr constant [39 x i8] c"R%d does not point to a readonly map'\0A\00", align 1
@.str.359 = private unnamed_addr constant [32 x i8] c"R%d is not a constant address'\0A\00", align 1
@.str.360 = private unnamed_addr constant [38 x i8] c"direct value access on string failed\0A\00", align 1
@.str.361 = private unnamed_addr constant [31 x i8] c"string is not zero-terminated\0A\00", align 1
@.str.362 = private unnamed_addr constant [37 x i8] c"invalid map_ptr to access map->type\0A\00", align 1
@.str.363 = private unnamed_addr constant [39 x i8] c"invalid arg_type for sockmap/sockhash\0A\00", align 1
@compatible_reg_types = internal global [30 x %struct.bpf_reg_types*] [%struct.bpf_reg_types* null, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @const_map_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @context_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @context_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* null, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @spin_lock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @sock_types, %struct.bpf_reg_types* @int_ptr_types, %struct.bpf_reg_types* @int_ptr_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @fullsock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @fullsock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @btf_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @alloc_mem_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @alloc_mem_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @btf_id_sock_common_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @percpu_btf_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @func_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @stack_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @const_str_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @timer_types to %struct.bpf_reg_types*)], align 16
@.str.364 = private unnamed_addr constant [50 x i8] c"verifier internal error: unsupported arg type %d\0A\00", align 1
@.str.365 = private unnamed_addr constant [22 x i8] c"R%d type=%s expected=\00", align 1
@.str.366 = private unnamed_addr constant [5 x i8] c"%s, \00", align 1
@.str.367 = private unnamed_addr constant [56 x i8] c"verifier internal error: missing arg compatible BTF ID\0A\00", align 1
@.str.368 = private unnamed_addr constant [38 x i8] c"R%d is of type %s but %s is expected\0A\00", align 1
@.str.369 = private unnamed_addr constant [59 x i8] c"R%d is a pointer to in-kernel struct with non-zero offset\0A\00", align 1
@map_key_value_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 29, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@mem_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 29, i32 4, i32 21, i32 23, i32 25, i32 0, i32 0], i32* null }, align 8
@sock_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 13, i32 11, i32 15, i32 18, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@int_ptr_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 29, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@btf_id_sock_common_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 13, i32 11, i32 15, i32 18, i32 19, i32 0, i32 0, i32 0, i32 0, i32 0], i32* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x i32]* @btf_sock_ids to i8*), i64 24) to i32*) }, align 8
@const_map_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 3, [9 x i32] zeroinitializer }>, i32* null }, align 8
@scalar_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 1, [9 x i32] zeroinitializer }>, i32* null }, align 8
@context_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 2, [9 x i32] zeroinitializer }>, i32* null }, align 8
@spin_lock_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@fullsock_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 11, [9 x i32] zeroinitializer }>, i32* null }, align 8
@btf_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 19, [9 x i32] zeroinitializer }>, i32* null }, align 8
@alloc_mem_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 21, [9 x i32] zeroinitializer }>, i32* null }, align 8
@btf_sock_ids = external dso_local global [0 x i32], align 4
@percpu_btf_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 27, [9 x i32] zeroinitializer }>, i32* null }, align 8
@func_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 28, [9 x i32] zeroinitializer }>, i32* null }, align 8
@stack_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 6, [9 x i32] zeroinitializer }>, i32* null }, align 8
@const_str_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@timer_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@.str.382 = private unnamed_addr constant [82 x i8] c"R%d doesn't have constant offset. bpf_spin_lock has to be at the constant offset\0A\00", align 1
@.str.383 = private unnamed_addr constant [56 x i8] c"map '%s' has to have BTF in order to use bpf_spin_lock\0A\00", align 1
@.str.384 = private unnamed_addr constant [51 x i8] c"map '%s' has more than one 'struct bpf_spin_lock'\0A\00", align 1
@.str.385 = private unnamed_addr constant [46 x i8] c"map '%s' doesn't have 'struct bpf_spin_lock'\0A\00", align 1
@.str.386 = private unnamed_addr constant [59 x i8] c"map '%s' is not a struct type or bpf_spin_lock is mangled\0A\00", align 1
@.str.387 = private unnamed_addr constant [50 x i8] c"off %lld doesn't point to 'struct bpf_spin_lock'\0A\00", align 1
@.str.388 = private unnamed_addr constant [44 x i8] c"Locking two bpf_spin_locks are not allowed\0A\00", align 1
@.str.389 = private unnamed_addr constant [39 x i8] c"bpf_spin_unlock without taking a lock\0A\00", align 1
@.str.390 = private unnamed_addr constant [35 x i8] c"bpf_spin_unlock of different lock\0A\00", align 1
@.str.391 = private unnamed_addr constant [78 x i8] c"R%d doesn't have constant offset. bpf_timer has to be at the constant offset\0A\00", align 1
@.str.392 = private unnamed_addr constant [52 x i8] c"map '%s' has to have BTF in order to use bpf_timer\0A\00", align 1
@.str.393 = private unnamed_addr constant [47 x i8] c"map '%s' has more than one 'struct bpf_timer'\0A\00", align 1
@.str.394 = private unnamed_addr constant [42 x i8] c"map '%s' doesn't have 'struct bpf_timer'\0A\00", align 1
@.str.395 = private unnamed_addr constant [55 x i8] c"map '%s' is not a struct type or bpf_timer is mangled\0A\00", align 1
@.str.396 = private unnamed_addr constant [60 x i8] c"off %lld doesn't point to 'struct bpf_timer' that is at %d\0A\00", align 1
@.str.397 = private unnamed_addr constant [50 x i8] c"verifier bug. Two map pointers in a timer helper\0A\00", align 1
@.str.398 = private unnamed_addr constant [26 x i8] c"write into map forbidden\0A\00", align 1
@.str.399 = private unnamed_addr constant [27 x i8] c"tail_call abusing map_ptr\0A\00", align 1
@.str.400 = private unnamed_addr constant [39 x i8] c"callback function not allowed for map\0A\00", align 1
@.str.401 = private unnamed_addr constant [14 x i8] c"verifier bug\0A\00", align 1
@.str.402 = private unnamed_addr constant [23 x i8] c"Invalid format string\0A\00", align 1
@.str.403 = private unnamed_addr constant [72 x i8] c"tail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\0A\00", align 1
@.str.404 = private unnamed_addr constant [41 x i8] c"cannot pass map_type %d into func %s#%d\0A\00", align 1
@.str.405 = private unnamed_addr constant [39 x i8] c"cannot update sockmap in this context\0A\00", align 1
@.str.406 = private unnamed_addr constant [62 x i8] c"func %s#%d supported only for fentry/fexit/fmod_ret programs\0A\00", align 1
@.str.407 = private unnamed_addr constant [46 x i8] c"func %s#%d not supported for program type %d\0A\00", align 1
@.str.408 = private unnamed_addr constant [43 x i8] c"cannot return stack pointer to the caller\0A\00", align 1
@.str.409 = private unnamed_addr constant [23 x i8] c"R0 not a scalar value\0A\00", align 1
@.str.410 = private unnamed_addr constant [16 x i8] c"callback return\00", align 1
@.str.411 = private unnamed_addr constant [3 x i8] c"R0\00", align 1
@.str.412 = private unnamed_addr constant [24 x i8] c"returning from callee:\0A\00", align 1
@.str.413 = private unnamed_addr constant [18 x i8] c"to caller at %d:\0A\00", align 1
@.str.414 = private unnamed_addr constant [23 x i8] c"At %s the register %s \00", align 1
@.str.415 = private unnamed_addr constant [13 x i8] c"has value %s\00", align 1
@.str.416 = private unnamed_addr constant [25 x i8] c"has unknown scalar value\00", align 1
@.str.417 = private unnamed_addr constant [25 x i8] c" should have been in %s\0A\00", align 1
@.str.418 = private unnamed_addr constant [42 x i8] c"Unreleased reference id=%d alloc_insn=%d\0A\00", align 1
@.str.419 = private unnamed_addr constant [31 x i8] c"R0 leaks addr as return value\0A\00", align 1
@.str.420 = private unnamed_addr constant [61 x i8] c"In async callback the register R0 is not a known value (%s)\0A\00", align 1
@.str.421 = private unnamed_addr constant [15 x i8] c"async callback\00", align 1
@.str.422 = private unnamed_addr constant [63 x i8] c"At subprogram exit the register R0 is not a scalar value (%s)\0A\00", align 1
@.str.423 = private unnamed_addr constant [59 x i8] c"At program exit the register R0 is not a known value (%s)\0A\00", align 1
@.str.424 = private unnamed_addr constant [13 x i8] c"program exit\00", align 1
@update_branch_counts.__already_done = internal global i8 0, section ".data.once", align 1
@.str.425 = private unnamed_addr constant [49 x i8] c"BUG update_branch_counts:branches_to_explore=%d\0A\00", align 1
@.str.426 = private unnamed_addr constant [33 x i8] c"invalid BPF_JMP/JMP32 opcode %x\0A\00", align 1
@.str.427 = private unnamed_addr constant [36 x i8] c"BPF_JMP/JMP32 uses reserved fields\0A\00", align 1
@.str.428 = private unnamed_addr constant [35 x i8] c"R%d pointer comparison prohibited\0A\00", align 1
@check_ld_abs.ctx_reg = internal constant i32 6, align 4
@.str.429 = private unnamed_addr constant [65 x i8] c"BPF_LD_[ABS|IND] instructions not allowed for this program type\0A\00", align 1
@.str.430 = private unnamed_addr constant [31 x i8] c"bpf verifier is misconfigured\0A\00", align 1
@.str.431 = private unnamed_addr constant [39 x i8] c"BPF_LD_[ABS|IND] uses reserved fields\0A\00", align 1
@.str.432 = private unnamed_addr constant [57 x i8] c"BPF_LD_[ABS|IND] cannot be mixed with socket references\0A\00", align 1
@.str.433 = private unnamed_addr constant [64 x i8] c"BPF_LD_[ABS|IND] cannot be used inside bpf_spin_lock-ed region\0A\00", align 1
@.str.434 = private unnamed_addr constant [52 x i8] c"at the time of BPF_LD_ABS|IND R6 != pointer to skb\0A\00", align 1
@.str.435 = private unnamed_addr constant [25 x i8] c"invalid BPF_LD_IMM insn\0A\00", align 1
@.str.436 = private unnamed_addr constant [35 x i8] c"BPF_LD_IMM64 uses reserved fields\0A\00", align 1
@.str.437 = private unnamed_addr constant [23 x i8] c"missing btf func_info\0A\00", align 1
@.str.438 = private unnamed_addr constant [30 x i8] c"callback function not static\0A\00", align 1
@.str.439 = private unnamed_addr constant [86 x i8] c"tail_calls are not allowed when call stack of previous frames is %d bytes. Too large\0A\00", align 1
@.str.440 = private unnamed_addr constant [50 x i8] c"combined stack size of %d calls is %d. Too large\0A\00", align 1
@check_max_stack_depth.__already_done = internal global i8 0, section ".data.once", align 1
@.str.441 = private unnamed_addr constant [50 x i8] c"verifier bug. subprog has tail_call and async cb\0A\00", align 1
@.str.442 = private unnamed_addr constant [43 x i8] c"the call stack of %d frames is too deep !\0A\00", align 1
@__const.opt_hard_wire_dead_code_branches.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.opt_remove_nops.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.sanitize_dead_code.trap = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 -1, i32 0 }, align 4
@.str.443 = private unnamed_addr constant [45 x i8] c"Writes through BTF pointers are not allowed\0A\00", align 1
@.str.444 = private unnamed_addr constant [46 x i8] c"bpf verifier narrow ctx access misconfigured\0A\00", align 1
@.str.445 = private unnamed_addr constant [44 x i8] c"bpf verifier narrow ctx load misconfigured\0A\00", align 1
@.str.446 = private unnamed_addr constant [47 x i8] c"insn %d cannot be patched due to 16-bit range\0A\00", align 1
@.str.447 = private unnamed_addr constant [41 x i8] c"adding tail call poke descriptor failed\0A\00", align 1
@jiffies = external dso_local global i64, section ".data..cacheline_aligned", align 64
@.str.448 = private unnamed_addr constant [32 x i8] c"tracking tail call prog failed\0A\00", align 1
@.str.449 = private unnamed_addr constant [78 x i8] c"verifier internal error: kernel function descriptor not found for func_id %u\0A\00", align 1
@.str.450 = private unnamed_addr constant [54 x i8] c"verifier bug. zext_dst is set, but no reg is defined\0A\00", align 1
@.str.451 = private unnamed_addr constant [64 x i8] c"calling kernel functions are not allowed in non-JITed programs\0A\00", align 1
@.str.452 = private unnamed_addr constant [49 x i8] c"callbacks are not allowed in non-JITed programs\0A\00", align 1
@jit_subprogs.__already_done = internal global i8 0, section ".data.once", align 1
@.str.453 = private unnamed_addr constant [38 x i8] c"JIT doesn't support bpf-to-bpf calls\0A\00", align 1
@get_callee_stack_depth.__already_done = internal global i8 0, section ".data.once", align 1
@.str.454 = private unnamed_addr constant [29 x i8] c"verification time %lld usec\0A\00", align 1
@.str.455 = private unnamed_addr constant [13 x i8] c"stack depth \00", align 1
@.str.456 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.457 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.458 = private unnamed_addr constant [98 x i8] c"processed %d insns (limit %d) max_states_per_insn %d total_states %d peak_states %d mark_read %d\0A\00", align 1
@llvm.compiler.used = appending global [1 x i8*] [i8* bitcast (i8** @__UNIQUE_ID___addressable_bpf_verifier_log_write431 to i8*)], section "llvm.metadata"

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, %struct.__va_list_tag* noundef %args) #0 {
entry:
  %retval.i = alloca i1, align 1
  %addr.addr.i = alloca i8*, align 8
  %bytes.addr.i = alloca i64, align 8
  %is_source.addr.i = alloca i8, align 1
  %sz.i = alloca i32, align 4
  %__ret_warn_on.i = alloca i32, align 4
  %tmp.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args.addr = alloca %struct.__va_list_tag*, align 8
  %n = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp34 = alloca i64, align 8
  %__UNIQUE_ID___x429 = alloca i32, align 4
  %__UNIQUE_ID___y430 = alloca i32, align 4
  %tmp42 = alloca i32, align 4
  %tmp51 = alloca i32, align 4
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  store %struct.__va_list_tag* %args, %struct.__va_list_tag** %args.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf, i64 0, i64 0
  %1 = load i8*, i8** %fmt.addr, align 8
  %2 = load %struct.__va_list_tag*, %struct.__va_list_tag** %args.addr, align 8
  %call = call i32 @vscnprintf(i8* noundef %arraydecay, i64 noundef 1024, i8* noundef %1, %struct.__va_list_tag* noundef %2) #14
  store i32 %call, i32* %n, align 4
  %3 = load i32, i32* %n, align 4
  %cmp = icmp uge i32 %3, 1023
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %frombool = zext i1 %lnot1 to i8
  store i8 %frombool, i8* %__ret_do_once, align 1
  %4 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %5 = load i8, i8* @bpf_verifier_vlog.__already_done, align 1
  %tobool2 = trunc i8 %5 to i1
  %lnot3 = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  %lnot4 = xor i1 %6, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %land.end
  store i8 1, i8* @bpf_verifier_vlog.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %7, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then14
  br label %do.body15

do.body15:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body15
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str, i64 0, i64 0)) #14
  br label %do.body16

do.body16:                                        ; preds = %do.end
  br label %do.body17

do.body17:                                        ; preds = %do.body16
  br label %do.end18

do.end18:                                         ; preds = %do.body17
  br label %do.body19

do.body19:                                        ; preds = %do.end18
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 386, i32 2313, i64 12) #13, !srcloc !6
  br label %do.end20

do.end20:                                         ; preds = %do.body19
  call void asm sideeffect "428:\0A\09.pushsection .discard.reachable\0A\09.long 428b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !7
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  br label %do.end23

do.end23:                                         ; preds = %do.end22
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  br label %do.end25

do.end25:                                         ; preds = %do.body24
  br label %do.end26

do.end26:                                         ; preds = %do.end25
  br label %if.end

if.end:                                           ; preds = %do.end26, %if.then
  %8 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %8, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end, %land.end
  %10 = load i8, i8* %__ret_do_once, align 1
  %tobool35 = trunc i8 %10 to i1
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  store i64 %conv40, i64* %tmp34, align 8
  %11 = load i64, i64* %tmp34, align 8
  %12 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %12, i32 0, i32 4
  %13 = load i32, i32* %len_total, align 4
  %14 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %14, i32 0, i32 3
  %15 = load i32, i32* %len_used, align 8
  %sub = sub i32 %13, %15
  %sub41 = sub i32 %sub, 1
  store i32 %sub41, i32* %__UNIQUE_ID___x429, align 4
  %16 = load i32, i32* %n, align 4
  store i32 %16, i32* %__UNIQUE_ID___y430, align 4
  %17 = load i32, i32* %__UNIQUE_ID___x429, align 4
  %18 = load i32, i32* %__UNIQUE_ID___y430, align 4
  %cmp43 = icmp ult i32 %17, %18
  br i1 %cmp43, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end33
  %19 = load i32, i32* %__UNIQUE_ID___x429, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end33
  %20 = load i32, i32* %__UNIQUE_ID___y430, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, i32* %tmp42, align 4
  %21 = load i32, i32* %tmp42, align 4
  store i32 %21, i32* %n, align 4
  %22 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf45 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %22, i32 0, i32 1
  %23 = load i32, i32* %n, align 4
  %idxprom = zext i32 %23 to i64
  %arrayidx = getelementptr [1024 x i8], [1024 x i8]* %kbuf45, i64 0, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  %24 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %24, i32 0, i32 0
  %25 = load i32, i32* %level, align 8
  %cmp46 = icmp eq i32 %25, 8
  br i1 %cmp46, label %if.then48, label %if.end55

if.then48:                                        ; preds = %cond.end
  br label %do.body49

do.body49:                                        ; preds = %if.then48
  br label %do.end50

do.end50:                                         ; preds = %do.body49
  %26 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf52 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %26, i32 0, i32 1
  %arraydecay53 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf52, i64 0, i64 0
  %call54 = call i32 (i8*, ...) @_printk(i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i64 0, i64 0), i8* noundef %arraydecay53) #15
  store i32 %call54, i32* %tmp51, align 4
  %27 = load i32, i32* %tmp51, align 4
  br label %if.end66

if.end55:                                         ; preds = %cond.end
  %28 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %28, i32 0, i32 2
  %29 = load i8*, i8** %ubuf, align 8
  %30 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used56 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %30, i32 0, i32 3
  %31 = load i32, i32* %len_used56, align 8
  %idx.ext = zext i32 %31 to i64
  %add.ptr = getelementptr i8, i8* %29, i64 %idx.ext
  %32 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf57 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %32, i32 0, i32 1
  %arraydecay58 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf57, i64 0, i64 0
  %33 = load i32, i32* %n, align 4
  %add = add i32 %33, 1
  %conv59 = zext i32 %add to i64
  store i8* %add.ptr, i8** %to.addr.i, align 8
  store i8* %arraydecay58, i8** %from.addr.i, align 8
  store i64 %conv59, i64* %n.addr.i, align 8
  %34 = load i8*, i8** %from.addr.i, align 8
  %35 = load i64, i64* %n.addr.i, align 8
  store i8* %34, i8** %addr.addr.i, align 8
  store i64 %35, i64* %bytes.addr.i, align 8
  store i8 1, i8* %is_source.addr.i, align 1
  store i32 -1, i32* %sz.i, align 4
  %36 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp sge i32 %36, 0
  br i1 %cmp.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %if.end55
  %37 = load i32, i32* %sz.i, align 4
  %conv.i67 = sext i32 %37 to i64
  %38 = load i64, i64* %bytes.addr.i, align 8
  %cmp1.i = icmp ult i64 %conv.i67, %38
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %if.end55
  %39 = phi i1 [ false, %if.end55 ], [ %cmp1.i, %land.rhs.i ]
  %lnot.i68 = xor i1 %39, true
  %lnot.ext.i69 = zext i1 %39 to i32
  %conv4.i = sext i32 %lnot.ext.i69 to i64
  br i1 %39, label %if.then.i70, label %if.end10.i

if.then.i70:                                      ; preds = %land.end.i
  %40 = load i64, i64* %bytes.addr.i, align 8
  %41 = call i1 @llvm.is.constant.i64(i64 %40) #13
  br i1 %41, label %if.else.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.then.i70
  %42 = load i32, i32* %sz.i, align 4
  %43 = load i64, i64* %bytes.addr.i, align 8
  call void @copy_overflow(i32 noundef %42, i64 noundef %43) #16
  br label %if.end9.i

if.else.i:                                        ; preds = %if.then.i70
  %44 = load i8, i8* %is_source.addr.i, align 1
  %tobool6.i = trunc i8 %44 to i1
  br i1 %tobool6.i, label %if.then7.i, label %if.else8.i

if.then7.i:                                       ; preds = %if.else.i
  call void @__bad_copy_from() #16, !srcloc !8
  br label %if.end.i

if.else8.i:                                       ; preds = %if.else.i
  call void @__bad_copy_to() #16, !srcloc !9
  br label %if.end.i

if.end.i:                                         ; preds = %if.else8.i, %if.then7.i
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.end.i, %if.then5.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end10.i:                                       ; preds = %land.end.i
  %45 = load i64, i64* %bytes.addr.i, align 8
  %cmp11.i = icmp ugt i64 %45, 2147483647
  %lnot13.i = xor i1 %cmp11.i, true
  %lnot.ext16.i = zext i1 %cmp11.i to i32
  store i32 %lnot.ext16.i, i32* %__ret_warn_on.i, align 4
  %46 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool17.i = icmp ne i32 %46, 0
  %lnot18.i = xor i1 %tobool17.i, true
  %lnot.ext21.i = zext i1 %tobool17.i to i32
  %conv22.i = sext i32 %lnot.ext21.i to i64
  br i1 %tobool17.i, label %if.then24.i, label %if.end31.i

if.then24.i:                                      ; preds = %if.end10.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 216, i32 2307, i64 12) #13, !srcloc !10
  call void asm sideeffect "33:\0A\09.pushsection .discard.reachable\0A\09.long 33b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !11
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then24.i, %if.end10.i
  %47 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool32.i = icmp ne i32 %47, 0
  %lnot33.i = xor i1 %tobool32.i, true
  %lnot.ext36.i = zext i1 %tobool32.i to i32
  %conv37.i = sext i32 %lnot.ext36.i to i64
  store i64 %conv37.i, i64* %tmp.i, align 8
  %48 = load i64, i64* %tmp.i, align 8
  %tobool38.i = icmp ne i64 %48, 0
  br i1 %tobool38.i, label %if.then39.i, label %if.end40.i

if.then39.i:                                      ; preds = %if.end31.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end40.i:                                       ; preds = %if.end31.i
  %49 = load i8*, i8** %addr.addr.i, align 8
  %50 = load i64, i64* %bytes.addr.i, align 8
  %51 = load i8, i8* %is_source.addr.i, align 1
  %tobool41.i = trunc i8 %51 to i1
  call void @check_object_size(i8* noundef %49, i64 noundef %50, i1 noundef zeroext %tobool41.i) #16
  store i1 true, i1* %retval.i, align 1
  br label %check_copy_size.exit

check_copy_size.exit:                             ; preds = %if.end9.i, %if.then39.i, %if.end40.i
  %52 = load i1, i1* %retval.i, align 1
  %lnot.i = xor i1 %52, true
  %lnot.ext.i = zext i1 %52 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %52, label %if.then.i, label %copy_to_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit
  %53 = load i8*, i8** %to.addr.i, align 8
  %54 = load i8*, i8** %from.addr.i, align 8
  %55 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_to_user(i8* noundef %53, i8* noundef %54, i64 noundef %55) #16
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %check_copy_size.exit, %if.then.i
  %56 = load i64, i64* %n.addr.i, align 8
  %tobool61 = icmp ne i64 %56, 0
  br i1 %tobool61, label %if.else, label %if.then62

if.then62:                                        ; preds = %copy_to_user.exit
  %57 = load i32, i32* %n, align 4
  %58 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used63 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %58, i32 0, i32 3
  %59 = load i32, i32* %len_used63, align 8
  %add64 = add i32 %59, %57
  store i32 %add64, i32* %len_used63, align 8
  br label %if.end66

if.else:                                          ; preds = %copy_to_user.exit
  %60 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf65 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %60, i32 0, i32 2
  store i8* null, i8** %ubuf65, align 8
  br label %if.end66

if.end66:                                         ; preds = %do.end50, %if.else, %if.then62
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @vscnprintf(i8* noundef, i64 noundef, i8* noundef, %struct.__va_list_tag* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__warn_printk(i8* noundef, ...) #1

; Function Attrs: cold noredzone null_pointer_is_valid
declare dso_local i32 @_printk(i8* noundef, ...) #2

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_log_write(%struct.bpf_verifier_env* noundef %env, i8* noundef %fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 26
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay3) #14
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_log* %0, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %1, i32 0, i32 0
  %2 = load i32, i32* %level, align 8
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %land.rhs
  %3 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %3, i32 0, i32 2
  %4 = load i8*, i8** %ubuf, align 8
  %tobool2 = icmp ne i8* %4, null
  br i1 %tobool2, label %land.lhs.true3, label %lor.rhs

land.lhs.true3:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %5) #14
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true3, %land.lhs.true, %land.rhs
  %6 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level4 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %6, i32 0, i32 0
  %7 = load i32, i32* %level4, align 8
  %cmp = icmp eq i32 %7, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true3
  %8 = phi i1 [ true, %land.lhs.true3 ], [ %cmp, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %9 = phi i1 [ false, %entry ], [ %8, %lor.end ]
  ret i1 %9
}

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_start(i8*) #3

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_end(i8*) #3

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_log(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, ...) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %0) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %1, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay2) #14
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @bpf_prog_has_kfunc_call(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 33
  %2 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc_tab* %2, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  ret i1 %lnot1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local %struct.btf_func_model* @bpf_jit_find_kfunc_model(%struct.bpf_prog* noundef %prog, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %desc = alloca %struct.bpf_kfunc_desc, align 4
  %res = alloca %struct.bpf_kfunc_desc*, align 8
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %0, i8 0, i64 24, i1 false)
  %imm = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %desc, i32 0, i32 2
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm1, align 4
  store i32 %2, i32* %imm, align 4
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 33
  %5 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %5, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %6 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  %7 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %7, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 0
  %8 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %9 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %9, i32 0, i32 1
  %10 = load i32, i32* %nr_descs, align 4
  %conv = zext i32 %10 to i64
  %call = call i8* @bsearch(i8* noundef %6, i8* noundef %8, i64 noundef %conv, i64 noundef 24, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_imm) #14
  %11 = bitcast i8* %call to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %11, %struct.bpf_kfunc_desc** %res, align 8
  %12 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %res, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc* %12, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %13 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %res, align 8
  %func_model = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %13, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.btf_func_model* [ %func_model, %cond.true ], [ null, %cond.false ]
  ret %struct.btf_func_model* %cond
}

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #4

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @bsearch(i8* noundef, i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @kfunc_desc_cmp_by_imm(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %d0 = alloca %struct.bpf_kfunc_desc*, align 8
  %d1 = alloca %struct.bpf_kfunc_desc*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %1, %struct.bpf_kfunc_desc** %d0, align 8
  %2 = load i8*, i8** %b.addr, align 8
  %3 = bitcast i8* %2 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %3, %struct.bpf_kfunc_desc** %d1, align 8
  %4 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %imm = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %4, i32 0, i32 2
  %5 = load i32, i32* %imm, align 4
  %6 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %imm1 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %6, i32 0, i32 2
  %7 = load i32, i32* %imm1, align 4
  %cmp = icmp sgt i32 %5, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %8 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %imm2 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %8, i32 0, i32 2
  %9 = load i32, i32* %imm2, align 4
  %10 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %imm3 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %10, i32 0, i32 2
  %11 = load i32, i32* %imm3, align 4
  %cmp4 = icmp slt i32 %9, %11
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 1
  %1 = load i32, i32* %off, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load i32, i32* %regno.addr, align 4
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 1
  %6 = load i32, i32* %off1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.3, i64 0, i64 0), i32 noundef %4, i32 noundef %6) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #14
  br i1 %call, label %lor.lhs.false, label %if.then4

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %tobool3 = icmp ne i64 %14, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call6 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %18, i64 %20) #14
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %arraydecay7 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i64 0, i64 0), i8* noundef %arraydecay7) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then4, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose(i8* noundef %private_data, i8* noundef %fmt, ...) #0 {
entry:
  %private_data.addr = alloca i8*, align 8
  %fmt.addr = alloca i8*, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store i8* %private_data, i8** %private_data.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load i8*, i8** %private_data.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %1, %struct.bpf_verifier_env** %env, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 26
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 26
  %4 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %4, %struct.__va_list_tag* noundef %arraydecay3) #14
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %3, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @tnum_strn(i8* noundef, i64 noundef, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_mem_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %mem_size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %saved_reg = alloca %struct.bpf_reg_state, align 8
  %rv = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %0) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @reg_type_may_be_null(i32 noundef %2) #14
  br i1 %call1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %4 = bitcast %struct.bpf_reg_state* %saved_reg to i8*
  %5 = bitcast %struct.bpf_reg_state* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 120, i1 false)
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = load i32, i32* %regno.addr, align 4
  %9 = load i32, i32* %mem_size.addr, align 4
  %call3 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %7, i32 noundef %8, i32 noundef %9, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef null) #14
  store i32 %call3, i32* %rv, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %11 = bitcast %struct.bpf_reg_state* %10 to i8*
  %12 = bitcast %struct.bpf_reg_state* %saved_reg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %12, i64 120, i1 false)
  %13 = load i32, i32* %rv, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = load i32, i32* %regno.addr, align 4
  %16 = load i32, i32* %mem_size.addr, align 4
  %call5 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %14, i32 noundef %15, i32 noundef %16, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef null) #14
  store i32 %call5, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %5, i64 %7, i64 noundef 0) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 14
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 16
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp7 = icmp eq i32 %4, 20
  br i1 %cmp7, label %lor.end, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %5 = load i32, i32* %type.addr, align 4
  %cmp9 = icmp eq i32 %5, 22
  br i1 %cmp9, label %lor.end, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %6 = load i32, i32* %type.addr, align 4
  %cmp11 = icmp eq i32 %6, 24
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false10
  %7 = load i32, i32* %type.addr, align 4
  %cmp12 = icmp eq i32 %7, 26
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false10, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %8 = phi i1 [ true, %lor.lhs.false10 ], [ true, %lor.lhs.false8 ], [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp12, %lor.rhs ]
  ret i1 %8
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #5

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp65 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  switch i32 %1, label %sw.default [
    i32 5, label %sw.bb
    i32 12, label %sw.bb17
    i32 14, label %sw.bb19
    i32 16, label %sw.bb21
    i32 20, label %sw.bb23
    i32 22, label %sw.bb25
    i32 24, label %sw.bb27
    i32 26, label %sw.bb29
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.152* %3 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %6, i32 0, i32 1
  %7 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool = icmp ne %struct.bpf_map* %7, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  store i32 3, i32* %type1, align 8
  %9 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta2 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %9, i32 0, i32 1
  %10 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta2, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %13 = bitcast %union.anon.152* %12 to %struct.anon.153*
  %map_ptr3 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %13, i32 0, i32 0
  store %struct.bpf_map* %10, %struct.bpf_map** %map_ptr3, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 3
  %15 = load i32, i32* %id, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 2
  %18 = bitcast %union.anon.152* %17 to %struct.anon.153*
  %map_uid = getelementptr inbounds %struct.anon.153, %struct.anon.153* %18, i32 0, i32 1
  store i32 %15, i32* %map_uid, align 8
  br label %if.end16

if.else:                                          ; preds = %sw.bb
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %19, i32 0, i32 3
  %20 = load i32, i32* %map_type, align 8
  %cmp = icmp eq i32 %20, 17
  br i1 %cmp, label %if.then4, label %if.else6

if.then4:                                         ; preds = %if.else
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  store i32 18, i32* %type5, align 8
  br label %if.end15

if.else6:                                         ; preds = %if.else
  %22 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type7 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %22, i32 0, i32 3
  %23 = load i32, i32* %map_type7, align 8
  %cmp8 = icmp eq i32 %23, 15
  br i1 %cmp8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else6
  %24 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %24, i32 0, i32 3
  %25 = load i32, i32* %map_type9, align 8
  %cmp10 = icmp eq i32 %25, 18
  br i1 %cmp10, label %if.then11, label %if.else13

if.then11:                                        ; preds = %lor.lhs.false, %if.else6
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 0
  store i32 11, i32* %type12, align 8
  br label %if.end

if.else13:                                        ; preds = %lor.lhs.false
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 0
  store i32 4, i32* %type14, align 8
  br label %if.end

if.end:                                           ; preds = %if.else13, %if.then11
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then4
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.then
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 0
  store i32 11, i32* %type18, align 8
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 0
  store i32 13, i32* %type20, align 8
  br label %sw.epilog

sw.bb21:                                          ; preds = %entry
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  store i32 15, i32* %type22, align 8
  br label %sw.epilog

sw.bb23:                                          ; preds = %entry
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 0
  store i32 19, i32* %type24, align 8
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  store i32 21, i32* %type26, align 8
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 0
  store i32 23, i32* %type28, align 8
  br label %sw.epilog

sw.bb29:                                          ; preds = %entry
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 0
  store i32 25, i32* %type30, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i8 1, i8* %__ret_do_once, align 1
  %35 = load i8, i8* %__ret_do_once, align 1
  %tobool31 = trunc i8 %35 to i1
  br i1 %tobool31, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.default
  %36 = load i8, i8* @mark_ptr_not_null_reg.__already_done, align 1
  %tobool32 = trunc i8 %36 to i1
  %lnot = xor i1 %tobool32, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.default
  %37 = phi i1 [ false, %sw.default ], [ %lnot, %land.rhs ]
  %lnot33 = xor i1 %37, true
  %lnot34 = xor i1 %lnot33, true
  %lnot.ext = zext i1 %lnot34 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool35 = icmp ne i64 %conv, 0
  br i1 %tobool35, label %if.then36, label %if.end64

if.then36:                                        ; preds = %land.end
  store i8 1, i8* @mark_ptr_not_null_reg.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %38 = load i32, i32* %__ret_warn_on, align 4
  %tobool37 = icmp ne i32 %38, 0
  %lnot38 = xor i1 %tobool37, true
  %lnot40 = xor i1 %lnot38, true
  %lnot.ext41 = zext i1 %lnot40 to i32
  %conv42 = sext i32 %lnot.ext41 to i64
  %tobool43 = icmp ne i64 %conv42, 0
  br i1 %tobool43, label %if.then44, label %if.end57

if.then44:                                        ; preds = %if.then36
  br label %do.body

do.body:                                          ; preds = %if.then44
  br label %do.body45

do.body45:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body45
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.27, i64 0, i64 0)) #14
  br label %do.body46

do.body46:                                        ; preds = %do.end
  br label %do.body47

do.body47:                                        ; preds = %do.body46
  br label %do.end48

do.end48:                                         ; preds = %do.body47
  br label %do.body49

do.body49:                                        ; preds = %do.end48
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1263, i32 2313, i64 12) #13, !srcloc !12
  br label %do.end50

do.end50:                                         ; preds = %do.body49
  call void asm sideeffect "434:\0A\09.pushsection .discard.reachable\0A\09.long 434b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !13
  br label %do.body51

do.body51:                                        ; preds = %do.end50
  br label %do.end52

do.end52:                                         ; preds = %do.body51
  br label %do.end53

do.end53:                                         ; preds = %do.end52
  br label %do.body54

do.body54:                                        ; preds = %do.end53
  br label %do.end55

do.end55:                                         ; preds = %do.body54
  br label %do.end56

do.end56:                                         ; preds = %do.end55
  br label %if.end57

if.end57:                                         ; preds = %do.end56, %if.then36
  %39 = load i32, i32* %__ret_warn_on, align 4
  %tobool58 = icmp ne i32 %39, 0
  %lnot59 = xor i1 %tobool58, true
  %lnot61 = xor i1 %lnot59, true
  %lnot.ext62 = zext i1 %lnot61 to i32
  %conv63 = sext i32 %lnot.ext62 to i64
  store i64 %conv63, i64* %tmp, align 8
  %40 = load i64, i64* %tmp, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.end57, %land.end
  %41 = load i8, i8* %__ret_do_once, align 1
  %tobool66 = trunc i8 %41 to i1
  %lnot67 = xor i1 %tobool66, true
  %lnot69 = xor i1 %lnot67, true
  %lnot.ext70 = zext i1 %lnot69 to i32
  %conv71 = sext i32 %lnot.ext70 to i64
  store i64 %conv71, i64* %tmp65, align 8
  %42 = load i64, i64* %tmp65, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end64, %sw.bb29, %sw.bb27, %sw.bb25, %sw.bb23, %sw.bb21, %sw.bb19, %sw.bb17, %if.end16
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 8
  switch i32 %4, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 29, label %sw.bb2
    i32 4, label %sw.bb5
    i32 21, label %sw.bb14
    i32 23, label %sw.bb18
    i32 25, label %sw.bb27
    i32 6, label %sw.bb33
  ]

sw.bb:                                            ; preds = %entry, %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 1
  %8 = load i32, i32* %off, align 4
  %9 = load i32, i32* %access_size.addr, align 4
  %10 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %10 to i1
  %call1 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %5, i32 noundef %6, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool) #14
  store i32 %call1, i32* %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 1
  %14 = load i32, i32* %off3, align 4
  %15 = load i32, i32* %access_size.addr, align 4
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 2
  %18 = bitcast %union.anon.152* %17 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %18, i32 0, i32 0
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %19, i32 0, i32 4
  %20 = load i32, i32* %key_size, align 4
  %call4 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %14, i32 noundef %15, i32 noundef %20, i1 noundef zeroext false) #14
  store i32 %call4, i32* %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %entry
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load i32, i32* %regno.addr, align 4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 1
  %24 = load i32, i32* %off6, align 4
  %25 = load i32, i32* %access_size.addr, align 4
  %26 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool7 = icmp ne %struct.bpf_call_arg_meta* %26, null
  br i1 %tobool7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb5
  %27 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %27, i32 0, i32 1
  %28 = load i8, i8* %raw_mode, align 8
  %tobool8 = trunc i8 %28 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb5
  %29 = phi i1 [ false, %sw.bb5 ], [ %tobool8, %land.rhs ]
  %30 = zext i1 %29 to i64
  %cond = select i1 %29, i32 2, i32 1
  %call9 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %21, i32 noundef %22, i32 noundef %24, i32 noundef %25, i32 noundef %cond) #14
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.end
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load i32, i32* %regno.addr, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 1
  %34 = load i32, i32* %off11, align 4
  %35 = load i32, i32* %access_size.addr, align 4
  %36 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool12 = trunc i8 %36 to i1
  %call13 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %31, i32 noundef %32, i32 noundef %34, i32 noundef %35, i1 noundef zeroext %tobool12) #14
  store i32 %call13, i32* %retval, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 1
  %40 = load i32, i32* %off15, align 4
  %41 = load i32, i32* %access_size.addr, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 2
  %mem_size = bitcast %union.anon.152* %43 to i32*
  %44 = load i32, i32* %mem_size, align 8
  %45 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool16 = trunc i8 %45 to i1
  %call17 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %37, i32 noundef %38, i32 noundef %40, i32 noundef %41, i32 noundef %44, i1 noundef zeroext %tobool16) #14
  store i32 %call17, i32* %retval, align 4
  br label %return

sw.bb18:                                          ; preds = %entry
  %46 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool19 = icmp ne %struct.bpf_call_arg_meta* %46, null
  br i1 %tobool19, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %sw.bb18
  %47 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode20 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %47, i32 0, i32 1
  %48 = load i8, i8* %raw_mode20, align 8
  %tobool21 = trunc i8 %48 to i1
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  store i32 -13, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %land.lhs.true, %sw.bb18
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %51 = load i32, i32* %regno.addr, align 4
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 1
  %53 = load i32, i32* %off24, align 4
  %54 = load i32, i32* %access_size.addr, align 4
  %55 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool25 = trunc i8 %55 to i1
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %56, i32 0, i32 2
  %57 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %57, i32 0, i32 10
  %58 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_rdonly_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %58, i32 0, i32 12
  %call26 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %49, %struct.bpf_reg_state* noundef %50, i32 noundef %51, i32 noundef %53, i32 noundef %54, i1 noundef zeroext %tobool25, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.28, i64 0, i64 0), i32* noundef %max_rdonly_access) #14
  store i32 %call26, i32* %retval, align 4
  br label %return

sw.bb27:                                          ; preds = %entry
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %61 = load i32, i32* %regno.addr, align 4
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 1
  %63 = load i32, i32* %off28, align 4
  %64 = load i32, i32* %access_size.addr, align 4
  %65 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool29 = trunc i8 %65 to i1
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %66, i32 0, i32 2
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog30, align 8
  %aux31 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 10
  %68 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux31, align 8
  %max_rdwr_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %68, i32 0, i32 13
  %call32 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %59, %struct.bpf_reg_state* noundef %60, i32 noundef %61, i32 noundef %63, i32 noundef %64, i1 noundef zeroext %tobool29, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i64 0, i64 0), i32* noundef %max_rdwr_access) #14
  store i32 %call32, i32* %retval, align 4
  br label %return

sw.bb33:                                          ; preds = %entry
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load i32, i32* %regno.addr, align 4
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 1
  %72 = load i32, i32* %off34, align 4
  %73 = load i32, i32* %access_size.addr, align 4
  %74 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool35 = trunc i8 %74 to i1
  %75 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call36 = call i32 @check_stack_range_initialized(%struct.bpf_verifier_env* noundef %69, i32 noundef %70, i32 noundef %72, i32 noundef %73, i1 noundef zeroext %tobool35, i32 noundef 2, %struct.bpf_call_arg_meta* noundef %75) #14
  store i32 %call36, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %76 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool37 = trunc i8 %76 to i1
  br i1 %tobool37, label %land.lhs.true38, label %if.end42

land.lhs.true38:                                  ; preds = %sw.default
  %77 = load i32, i32* %access_size.addr, align 4
  %cmp = icmp eq i32 %77, 0
  br i1 %cmp, label %land.lhs.true39, label %if.end42

land.lhs.true39:                                  ; preds = %land.lhs.true38
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call40 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %78) #14
  br i1 %call40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %land.lhs.true39
  store i32 0, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %land.lhs.true39, %land.lhs.true38, %sw.default
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %80 = bitcast %struct.bpf_verifier_env* %79 to i8*
  %81 = load i32, i32* %regno.addr, align 4
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 0
  %83 = load i32, i32* %type43, align 8
  %idxprom44 = zext i32 %83 to i64
  %arrayidx45 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom44
  %84 = load i8*, i8** %arrayidx45, align 8
  %85 = load i8*, i8** getelementptr inbounds ([30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 6), align 16
  call void (i8*, i8*, ...) @verbose(i8* noundef %80, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.30, i64 0, i64 0), i32 noundef %81, i8* noundef %84, i8* noundef %85) #14
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end42, %if.then41, %sw.bb33, %sw.bb27, %if.end23, %if.then22, %sw.bb14, %if.end, %if.then, %sw.bb2, %sw.bb
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @map_set_for_each_callback_args(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 1
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 1
  %2 = bitcast %struct.bpf_reg_state* %arrayidx to i8*
  %3 = bitcast %struct.bpf_reg_state* %arrayidx2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 %3, i64 120, i1 false)
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs3, i64 0, i64 2
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 0
  store i32 29, i32* %type, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arrayidx6 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs5, i64 0, i64 2
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx6) #14
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 1
  %7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx8, i32 0, i32 2
  %8 = bitcast %union.anon.152* %7 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %8, i32 0, i32 0
  %9 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 2
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx10, i32 0, i32 2
  %12 = bitcast %union.anon.152* %11 to %struct.anon.153*
  %map_ptr11 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %12, i32 0, i32 0
  store %struct.bpf_map* %9, %struct.bpf_map** %map_ptr11, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 0
  %arrayidx13 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs12, i64 0, i64 3
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx13, i32 0, i32 0
  store i32 4, i32* %type14, align 8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 0
  %arrayidx16 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs15, i64 0, i64 3
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx16) #14
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs17 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %arrayidx18 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs17, i64 0, i64 1
  %16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx18, i32 0, i32 2
  %17 = bitcast %union.anon.152* %16 to %struct.anon.153*
  %map_ptr19 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %17, i32 0, i32 0
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr19, align 8
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 0
  %arrayidx21 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs20, i64 0, i64 3
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx21, i32 0, i32 2
  %21 = bitcast %union.anon.152* %20 to %struct.anon.153*
  %map_ptr22 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %21, i32 0, i32 0
  store %struct.bpf_map* %18, %struct.bpf_map** %map_ptr22, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs23 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 0
  %arrayidx24 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs23, i64 0, i64 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 0
  %arrayidx26 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs25, i64 0, i64 3
  %24 = bitcast %struct.bpf_reg_state* %arrayidx24 to i8*
  %25 = bitcast %struct.bpf_reg_state* %arrayidx26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %25, i64 120, i1 false)
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 0
  %arrayidx28 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs27, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %arrayidx28) #14
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #14
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 0, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @reg_bounds_sync___(%struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %0) #14
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %1) #14
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %2) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %0) #14
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg64_bounds(%struct.bpf_reg_state* noundef %1) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg32_deduce_bounds(%struct.bpf_reg_state* noundef %0) #14
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg64_deduce_bounds(%struct.bpf_reg_state* noundef %1) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_bound_offset(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %var64_off = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %var32_off = alloca %struct.tnum, align 8
  %agg.tmp2 = alloca %struct.tnum, align 8
  %agg.tmp5 = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp10 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 8
  %2 = load i64, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  %4 = load i64, i64* %umax_value, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef %2, i64 noundef %4) #14
  %5 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %15 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call1 = call { i64, i64 } @tnum_intersect(i64 %12, i64 %14, i64 %17, i64 %19) #14
  %20 = bitcast %struct.tnum* %var64_off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call1, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call1, 1
  store i64 %24, i64* %23, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call4 = call { i64, i64 } @tnum_subreg(i64 %28, i64 %30) #14
  %31 = bitcast %struct.tnum* %agg.tmp2 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call4, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call4, 1
  store i64 %35, i64* %34, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 12
  %37 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %37 to i64
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 13
  %39 = load i32, i32* %u32_max_value, align 4
  %conv6 = zext i32 %39 to i64
  %call7 = call { i64, i64 } @tnum_range(i64 noundef %conv, i64 noundef %conv6) #14
  %40 = bitcast %struct.tnum* %agg.tmp5 to { i64, i64 }*
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 0
  %42 = extractvalue { i64, i64 } %call7, 0
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 1
  %44 = extractvalue { i64, i64 } %call7, 1
  store i64 %44, i64* %43, align 8
  %45 = bitcast %struct.tnum* %agg.tmp2 to { i64, i64 }*
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 0
  %47 = load i64, i64* %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %50 = bitcast %struct.tnum* %agg.tmp5 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %call8 = call { i64, i64 } @tnum_intersect(i64 %47, i64 %49, i64 %52, i64 %54) #14
  %55 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = extractvalue { i64, i64 } %call8, 0
  store i64 %57, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = extractvalue { i64, i64 } %call8, 1
  store i64 %59, i64* %58, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 5
  %61 = bitcast %struct.tnum* %var64_off to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %call11 = call { i64, i64 } @tnum_clear_subreg(i64 %63, i64 %65) #14
  %66 = bitcast %struct.tnum* %agg.tmp10 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call11, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call11, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.tnum* %agg.tmp10 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %76 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call12 = call { i64, i64 } @tnum_or(i64 %73, i64 %75, i64 %78, i64 %80) #14
  %81 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = extractvalue { i64, i64 } %call12, 0
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = extractvalue { i64, i64 } %call12, 1
  store i64 %85, i64* %84, align 8
  %86 = bitcast %struct.tnum* %var_off9 to i8*
  %87 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %86, i8* align 8 %87, i64 16, i1 false)
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %src_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %src_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %s32_min_val = alloca i32, align 4
  %s32_max_val = alloca i32, align 4
  %u32_min_val = alloca i32, align 4
  %u32_max_val = alloca i32, align 4
  %insn_bitness = alloca i64, align 8
  %alu32 = alloca i8, align 1
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp78 = alloca %struct.tnum, align 8
  %tmp84 = alloca %struct.tnum, align 8
  %tmp90 = alloca %struct.tnum, align 8
  %tmp96 = alloca %struct.tnum, align 8
  %tmp102 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 0
  %4 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %4 to i32
  %and4 = and i32 %conv3, 7
  %cmp = icmp eq i32 %and4, 7
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 64, i32 32
  %conv6 = sext i32 %cond to i64
  store i64 %conv6, i64* %insn_bitness, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code7, align 4
  %conv8 = zext i8 %7 to i32
  %and9 = and i32 %conv8, 7
  %cmp10 = icmp ne i32 %and9, 7
  %frombool = zext i1 %cmp10 to i8
  store i8 %frombool, i8* %alu32, align 1
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 6
  %8 = load i64, i64* %smin_value, align 8
  store i64 %8, i64* %smin_val, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 7
  %9 = load i64, i64* %smax_value, align 8
  store i64 %9, i64* %smax_val, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 8
  %10 = load i64, i64* %umin_value, align 8
  store i64 %10, i64* %umin_val, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 9
  %11 = load i64, i64* %umax_value, align 8
  store i64 %11, i64* %umax_val, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 10
  %12 = load i32, i32* %s32_min_value, align 8
  store i32 %12, i32* %s32_min_val, align 4
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 11
  %13 = load i32, i32* %s32_max_value, align 4
  store i32 %13, i32* %s32_max_val, align 4
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 12
  %14 = load i32, i32* %u32_min_value, align 8
  store i32 %14, i32* %u32_min_val, align 4
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 13
  %15 = load i32, i32* %u32_max_value, align 4
  store i32 %15, i32* %u32_max_val, align 4
  %16 = load i8, i8* %alu32, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %17 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call12 = call zeroext i1 @tnum_subreg_is_const(i64 %19, i64 %21) #14
  %frombool13 = zext i1 %call12 to i8
  store i8 %frombool13, i8* %src_known, align 1
  %22 = load i8, i8* %src_known, align 1
  %tobool14 = trunc i8 %22 to i1
  br i1 %tobool14, label %land.lhs.true, label %lor.lhs.false20

land.lhs.true:                                    ; preds = %if.then
  %23 = load i32, i32* %s32_min_val, align 4
  %24 = load i32, i32* %s32_max_val, align 4
  %cmp16 = icmp ne i32 %23, %24
  br i1 %cmp16, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %25 = load i32, i32* %u32_min_val, align 4
  %26 = load i32, i32* %u32_max_val, align 4
  %cmp18 = icmp ne i32 %25, %26
  br i1 %cmp18, label %if.then26, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false, %if.then
  %27 = load i32, i32* %s32_min_val, align 4
  %28 = load i32, i32* %s32_max_val, align 4
  %cmp21 = icmp sgt i32 %27, %28
  br i1 %cmp21, label %if.then26, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false20
  %29 = load i32, i32* %u32_min_val, align 4
  %30 = load i32, i32* %u32_max_val, align 4
  %cmp24 = icmp ugt i32 %29, %30
  br i1 %cmp24, label %if.then26, label %if.end

if.then26:                                        ; preds = %lor.lhs.false23, %lor.lhs.false20, %lor.lhs.false, %land.lhs.true
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %31, %struct.bpf_reg_state* noundef %32) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false23
  br label %if.end46

if.else:                                          ; preds = %entry
  %var_off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %33 = bitcast %struct.tnum* %var_off27 to { i64, i64 }*
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 0
  %35 = load i64, i64* %34, align 8
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 1
  %37 = load i64, i64* %36, align 8
  %call28 = call zeroext i1 @tnum_is_const(i64 %35, i64 %37) #14
  %frombool29 = zext i1 %call28 to i8
  store i8 %frombool29, i8* %src_known, align 1
  %38 = load i8, i8* %src_known, align 1
  %tobool30 = trunc i8 %38 to i1
  br i1 %tobool30, label %land.lhs.true32, label %lor.lhs.false38

land.lhs.true32:                                  ; preds = %if.else
  %39 = load i64, i64* %smin_val, align 8
  %40 = load i64, i64* %smax_val, align 8
  %cmp33 = icmp ne i64 %39, %40
  br i1 %cmp33, label %if.then44, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %land.lhs.true32
  %41 = load i64, i64* %umin_val, align 8
  %42 = load i64, i64* %umax_val, align 8
  %cmp36 = icmp ne i64 %41, %42
  br i1 %cmp36, label %if.then44, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %lor.lhs.false35, %if.else
  %43 = load i64, i64* %smin_val, align 8
  %44 = load i64, i64* %smax_val, align 8
  %cmp39 = icmp sgt i64 %43, %44
  br i1 %cmp39, label %if.then44, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false38
  %45 = load i64, i64* %umin_val, align 8
  %46 = load i64, i64* %umax_val, align 8
  %cmp42 = icmp ugt i64 %45, %46
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %lor.lhs.false41, %lor.lhs.false38, %lor.lhs.false35, %land.lhs.true32
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %47, %struct.bpf_reg_state* noundef %48) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %lor.lhs.false41
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.end
  %49 = load i8, i8* %src_known, align 1
  %tobool47 = trunc i8 %49 to i1
  br i1 %tobool47, label %if.end61, label %land.lhs.true48

land.lhs.true48:                                  ; preds = %if.end46
  %50 = load i8, i8* %opcode, align 1
  %conv49 = zext i8 %50 to i32
  %cmp50 = icmp ne i32 %conv49, 0
  br i1 %cmp50, label %land.lhs.true52, label %if.end61

land.lhs.true52:                                  ; preds = %land.lhs.true48
  %51 = load i8, i8* %opcode, align 1
  %conv53 = zext i8 %51 to i32
  %cmp54 = icmp ne i32 %conv53, 16
  br i1 %cmp54, label %land.lhs.true56, label %if.end61

land.lhs.true56:                                  ; preds = %land.lhs.true52
  %52 = load i8, i8* %opcode, align 1
  %conv57 = zext i8 %52 to i32
  %cmp58 = icmp ne i32 %conv57, 80
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %land.lhs.true56
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %53, %struct.bpf_reg_state* noundef %54) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %land.lhs.true56, %land.lhs.true52, %land.lhs.true48, %if.end46
  %55 = load i8, i8* %opcode, align 1
  %call62 = call zeroext i1 @sanitize_needed(i8 noundef zeroext %55) #14
  br i1 %call62, label %if.then63, label %if.end70

if.then63:                                        ; preds = %if.end61
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call64 = call i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %56, %struct.bpf_insn* noundef %57) #14
  store i32 %call64, i32* %ret, align 4
  %58 = load i32, i32* %ret, align 4
  %cmp65 = icmp slt i32 %58, 0
  br i1 %cmp65, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.then63
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %61 = load i32, i32* %ret, align 4
  %call68 = call i32 @sanitize_err(%struct.bpf_verifier_env* noundef %59, %struct.bpf_insn* noundef %60, i32 noundef %61, %struct.bpf_reg_state* noundef null, %struct.bpf_reg_state* noundef null) #14
  store i32 %call68, i32* %retval, align 4
  br label %return

if.end69:                                         ; preds = %if.then63
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.end61
  %62 = load i8, i8* %opcode, align 1
  %conv71 = zext i8 %62 to i32
  switch i32 %conv71, label %sw.default [
    i32 0, label %sw.bb
    i32 16, label %sw.bb76
    i32 32, label %sw.bb82
    i32 80, label %sw.bb88
    i32 64, label %sw.bb94
    i32 160, label %sw.bb100
    i32 96, label %sw.bb106
    i32 112, label %sw.bb115
    i32 192, label %sw.bb124
  ]

sw.bb:                                            ; preds = %if.end70
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_add(%struct.bpf_reg_state* noundef %63, %struct.bpf_reg_state* noundef %src_reg) #14
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_add(%struct.bpf_reg_state* noundef %64, %struct.bpf_reg_state* noundef %src_reg) #14
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 5
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %67 = bitcast %struct.tnum* %var_off73 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = load i64, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = load i64, i64* %70, align 8
  %72 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %73 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %72, i32 0, i32 0
  %74 = load i64, i64* %73, align 8
  %75 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %72, i32 0, i32 1
  %76 = load i64, i64* %75, align 8
  %call75 = call { i64, i64 } @tnum_add(i64 %69, i64 %71, i64 %74, i64 %76) #14
  %77 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %78 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %77, i32 0, i32 0
  %79 = extractvalue { i64, i64 } %call75, 0
  store i64 %79, i64* %78, align 8
  %80 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %77, i32 0, i32 1
  %81 = extractvalue { i64, i64 } %call75, 1
  store i64 %81, i64* %80, align 8
  %82 = bitcast %struct.tnum* %var_off72 to i8*
  %83 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %82, i8* align 8 %83, i64 16, i1 false)
  br label %sw.epilog

sw.bb76:                                          ; preds = %if.end70
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_sub(%struct.bpf_reg_state* noundef %84, %struct.bpf_reg_state* noundef %src_reg) #14
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_sub(%struct.bpf_reg_state* noundef %85, %struct.bpf_reg_state* noundef %src_reg) #14
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 5
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i32 0, i32 5
  %var_off80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %88 = bitcast %struct.tnum* %var_off79 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %93 = bitcast %struct.tnum* %var_off80 to { i64, i64 }*
  %94 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %93, i32 0, i32 0
  %95 = load i64, i64* %94, align 8
  %96 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %93, i32 0, i32 1
  %97 = load i64, i64* %96, align 8
  %call81 = call { i64, i64 } @tnum_sub(i64 %90, i64 %92, i64 %95, i64 %97) #14
  %98 = bitcast %struct.tnum* %tmp78 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = extractvalue { i64, i64 } %call81, 0
  store i64 %100, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = extractvalue { i64, i64 } %call81, 1
  store i64 %102, i64* %101, align 8
  %103 = bitcast %struct.tnum* %var_off77 to i8*
  %104 = bitcast %struct.tnum* %tmp78 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %103, i8* align 8 %104, i64 16, i1 false)
  br label %sw.epilog

sw.bb82:                                          ; preds = %if.end70
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i32 0, i32 5
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 5
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %107 = bitcast %struct.tnum* %var_off85 to { i64, i64 }*
  %108 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 0
  %109 = load i64, i64* %108, align 8
  %110 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 1
  %111 = load i64, i64* %110, align 8
  %112 = bitcast %struct.tnum* %var_off86 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call87 = call { i64, i64 } @tnum_mul(i64 %109, i64 %111, i64 %114, i64 %116) #14
  %117 = bitcast %struct.tnum* %tmp84 to { i64, i64 }*
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 0
  %119 = extractvalue { i64, i64 } %call87, 0
  store i64 %119, i64* %118, align 8
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 1
  %121 = extractvalue { i64, i64 } %call87, 1
  store i64 %121, i64* %120, align 8
  %122 = bitcast %struct.tnum* %var_off83 to i8*
  %123 = bitcast %struct.tnum* %tmp84 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %122, i8* align 8 %123, i64 16, i1 false)
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_mul(%struct.bpf_reg_state* noundef %124, %struct.bpf_reg_state* noundef %src_reg) #14
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_mul(%struct.bpf_reg_state* noundef %125, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %sw.epilog

sw.bb88:                                          ; preds = %if.end70
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 5
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off91 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i32 0, i32 5
  %var_off92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %128 = bitcast %struct.tnum* %var_off91 to { i64, i64 }*
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 0
  %130 = load i64, i64* %129, align 8
  %131 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 1
  %132 = load i64, i64* %131, align 8
  %133 = bitcast %struct.tnum* %var_off92 to { i64, i64 }*
  %134 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 0
  %135 = load i64, i64* %134, align 8
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 1
  %137 = load i64, i64* %136, align 8
  %call93 = call { i64, i64 } @tnum_and(i64 %130, i64 %132, i64 %135, i64 %137) #14
  %138 = bitcast %struct.tnum* %tmp90 to { i64, i64 }*
  %139 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %138, i32 0, i32 0
  %140 = extractvalue { i64, i64 } %call93, 0
  store i64 %140, i64* %139, align 8
  %141 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %138, i32 0, i32 1
  %142 = extractvalue { i64, i64 } %call93, 1
  store i64 %142, i64* %141, align 8
  %143 = bitcast %struct.tnum* %var_off89 to i8*
  %144 = bitcast %struct.tnum* %tmp90 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %143, i8* align 8 %144, i64 16, i1 false)
  %145 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_and(%struct.bpf_reg_state* noundef %145, %struct.bpf_reg_state* noundef %src_reg) #14
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_and(%struct.bpf_reg_state* noundef %146, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %sw.epilog

sw.bb94:                                          ; preds = %if.end70
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 5
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 5
  %var_off98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %149 = bitcast %struct.tnum* %var_off97 to { i64, i64 }*
  %150 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %149, i32 0, i32 0
  %151 = load i64, i64* %150, align 8
  %152 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %149, i32 0, i32 1
  %153 = load i64, i64* %152, align 8
  %154 = bitcast %struct.tnum* %var_off98 to { i64, i64 }*
  %155 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %154, i32 0, i32 0
  %156 = load i64, i64* %155, align 8
  %157 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %154, i32 0, i32 1
  %158 = load i64, i64* %157, align 8
  %call99 = call { i64, i64 } @tnum_or(i64 %151, i64 %153, i64 %156, i64 %158) #14
  %159 = bitcast %struct.tnum* %tmp96 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = extractvalue { i64, i64 } %call99, 0
  store i64 %161, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = extractvalue { i64, i64 } %call99, 1
  store i64 %163, i64* %162, align 8
  %164 = bitcast %struct.tnum* %var_off95 to i8*
  %165 = bitcast %struct.tnum* %tmp96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %164, i8* align 8 %165, i64 16, i1 false)
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_or(%struct.bpf_reg_state* noundef %166, %struct.bpf_reg_state* noundef %src_reg) #14
  %167 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_or(%struct.bpf_reg_state* noundef %167, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %sw.epilog

sw.bb100:                                         ; preds = %if.end70
  %168 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off101 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %168, i32 0, i32 5
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %169, i32 0, i32 5
  %var_off104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %170 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %171 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %170, i32 0, i32 0
  %172 = load i64, i64* %171, align 8
  %173 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %170, i32 0, i32 1
  %174 = load i64, i64* %173, align 8
  %175 = bitcast %struct.tnum* %var_off104 to { i64, i64 }*
  %176 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %175, i32 0, i32 0
  %177 = load i64, i64* %176, align 8
  %178 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %175, i32 0, i32 1
  %179 = load i64, i64* %178, align 8
  %call105 = call { i64, i64 } @tnum_xor(i64 %172, i64 %174, i64 %177, i64 %179) #14
  %180 = bitcast %struct.tnum* %tmp102 to { i64, i64 }*
  %181 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %180, i32 0, i32 0
  %182 = extractvalue { i64, i64 } %call105, 0
  store i64 %182, i64* %181, align 8
  %183 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %180, i32 0, i32 1
  %184 = extractvalue { i64, i64 } %call105, 1
  store i64 %184, i64* %183, align 8
  %185 = bitcast %struct.tnum* %var_off101 to i8*
  %186 = bitcast %struct.tnum* %tmp102 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %185, i8* align 8 %186, i64 16, i1 false)
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_xor(%struct.bpf_reg_state* noundef %187, %struct.bpf_reg_state* noundef %src_reg) #14
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_xor(%struct.bpf_reg_state* noundef %188, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %sw.epilog

sw.bb106:                                         ; preds = %if.end70
  %189 = load i64, i64* %umax_val, align 8
  %190 = load i64, i64* %insn_bitness, align 8
  %cmp107 = icmp uge i64 %189, %190
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %sw.bb106
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %191) #14
  br label %sw.epilog

if.end110:                                        ; preds = %sw.bb106
  %192 = load i8, i8* %alu32, align 1
  %tobool111 = trunc i8 %192 to i1
  br i1 %tobool111, label %if.then112, label %if.else113

if.then112:                                       ; preds = %if.end110
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %193, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %if.end114

if.else113:                                       ; preds = %if.end110
  %194 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_lsh(%struct.bpf_reg_state* noundef %194, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %if.end114

if.end114:                                        ; preds = %if.else113, %if.then112
  br label %sw.epilog

sw.bb115:                                         ; preds = %if.end70
  %195 = load i64, i64* %umax_val, align 8
  %196 = load i64, i64* %insn_bitness, align 8
  %cmp116 = icmp uge i64 %195, %196
  br i1 %cmp116, label %if.then118, label %if.end119

if.then118:                                       ; preds = %sw.bb115
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %197) #14
  br label %sw.epilog

if.end119:                                        ; preds = %sw.bb115
  %198 = load i8, i8* %alu32, align 1
  %tobool120 = trunc i8 %198 to i1
  br i1 %tobool120, label %if.then121, label %if.else122

if.then121:                                       ; preds = %if.end119
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_rsh(%struct.bpf_reg_state* noundef %199, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %if.end123

if.else122:                                       ; preds = %if.end119
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_rsh(%struct.bpf_reg_state* noundef %200, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %if.end123

if.end123:                                        ; preds = %if.else122, %if.then121
  br label %sw.epilog

sw.bb124:                                         ; preds = %if.end70
  %201 = load i64, i64* %umax_val, align 8
  %202 = load i64, i64* %insn_bitness, align 8
  %cmp125 = icmp uge i64 %201, %202
  br i1 %cmp125, label %if.then127, label %if.end128

if.then127:                                       ; preds = %sw.bb124
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %203) #14
  br label %sw.epilog

if.end128:                                        ; preds = %sw.bb124
  %204 = load i8, i8* %alu32, align 1
  %tobool129 = trunc i8 %204 to i1
  br i1 %tobool129, label %if.then130, label %if.else131

if.then130:                                       ; preds = %if.end128
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_arsh(%struct.bpf_reg_state* noundef %205, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %if.end132

if.else131:                                       ; preds = %if.end128
  %206 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_arsh(%struct.bpf_reg_state* noundef %206, %struct.bpf_reg_state* noundef %src_reg) #14
  br label %if.end132

if.end132:                                        ; preds = %if.else131, %if.then130
  br label %sw.epilog

sw.default:                                       ; preds = %if.end70
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %207) #14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end132, %if.then127, %if.end123, %if.then118, %if.end114, %if.then109, %sw.bb100, %sw.bb94, %sw.bb88, %sw.bb82, %sw.bb76, %sw.bb
  %208 = load i8, i8* %alu32, align 1
  %tobool133 = trunc i8 %208 to i1
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %sw.epilog
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @zext_32_to_64(%struct.bpf_reg_state* noundef %209) #14
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %sw.epilog
  %210 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %210) #14
  %211 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %211) #14
  %212 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %212) #14
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end135, %if.then67, %if.then60, %if.then44, %if.then26
  %213 = load i32, i32* %retval, align 4
  ret i32 %213
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 29, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @push_stack___(%struct.bpf_reg_state* noundef %to, %struct.bpf_reg_state* noundef %from) #0 {
entry:
  %to.addr = alloca %struct.bpf_reg_state*, align 8
  %from.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %to, %struct.bpf_reg_state** %to.addr, align 8
  store %struct.bpf_reg_state* %from, %struct.bpf_reg_state** %from.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 %1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  store i64 %4, i64* %value3, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off4, i32 0, i32 1
  %7 = load i64, i64* %mask, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  store i64 %7, i64* %mask6, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 6
  %10 = load i64, i64* %smin_value, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value7, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  store i64 %13, i64* %smax_value8, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 8
  store i64 %16, i64* %umin_value9, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value10, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 10
  %22 = load i32, i32* %s32_min_value, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %s32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  store i32 %22, i32* %s32_min_value11, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 11
  %25 = load i32, i32* %s32_max_value, align 4
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %s32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 11
  store i32 %25, i32* %s32_max_value12, align 4
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 12
  %28 = load i32, i32* %u32_min_value, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %u32_min_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 12
  store i32 %28, i32* %u32_min_value13, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 13
  %31 = load i32, i32* %u32_max_value, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %u32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 13
  store i32 %31, i32* %u32_max_value14, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %0) #14
  br i1 %call, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @reg_type_not_null(i32 noundef %2) #14
  br i1 %call1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %3 = load i64, i64* %val.addr, align 8
  %cmp = icmp ne i64 %3, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %4 to i32
  switch i32 %conv, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end4
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %if.end4
  store i32 1, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end4
  store i32 -1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %5 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end6
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %7 = load i64, i64* %val.addr, align 8
  %conv8 = trunc i64 %7 to i32
  %8 = load i8, i8* %opcode.addr, align 1
  %call9 = call i32 @is_branch32_taken(%struct.bpf_reg_state* noundef %6, i32 noundef %conv8, i8 noundef zeroext %8) #14
  store i32 %call9, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load i64, i64* %val.addr, align 8
  %11 = load i8, i8* %opcode.addr, align 1
  %call11 = call i32 @is_branch64_taken(%struct.bpf_reg_state* noundef %9, i64 noundef %10, i8 noundef zeroext %11) #14
  store i32 %call11, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then7, %sw.default, %sw.bb5, %sw.bb, %if.then3, %if.then2
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_subreg(i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i32 noundef %val32, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %val32.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  %false_32off = alloca %struct.tnum, align 8
  %false_64off = alloca %struct.tnum, align 8
  %true_32off = alloca %struct.tnum, align 8
  %true_64off = alloca %struct.tnum, align 8
  %sval = alloca i64, align 8
  %sval32 = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp20 = alloca %struct.tnum, align 8
  %agg.tmp21 = alloca %struct.tnum, align 8
  %tmp27 = alloca %struct.tnum, align 8
  %agg.tmp28 = alloca %struct.tnum, align 8
  %tmp34 = alloca %struct.tnum, align 8
  %agg.tmp35 = alloca %struct.tnum, align 8
  %false_umax = alloca i32, align 4
  %true_umin = alloca i32, align 4
  %__UNIQUE_ID___x496 = alloca i32, align 4
  %__UNIQUE_ID___y497 = alloca i32, align 4
  %tmp57 = alloca i32, align 4
  %__UNIQUE_ID___x498 = alloca i32, align 4
  %__UNIQUE_ID___y499 = alloca i32, align 4
  %tmp65 = alloca i32, align 4
  %false_umax74 = alloca i64, align 8
  %true_umin83 = alloca i64, align 8
  %__UNIQUE_ID___x500 = alloca i64, align 8
  %__UNIQUE_ID___y501 = alloca i64, align 8
  %tmp92 = alloca i64, align 8
  %__UNIQUE_ID___x502 = alloca i64, align 8
  %__UNIQUE_ID___y503 = alloca i64, align 8
  %tmp100 = alloca i64, align 8
  %false_smax = alloca i32, align 4
  %true_smin = alloca i32, align 4
  %__UNIQUE_ID___x504 = alloca i32, align 4
  %__UNIQUE_ID___y505 = alloca i32, align 4
  %tmp128 = alloca i32, align 4
  %__UNIQUE_ID___x506 = alloca i32, align 4
  %__UNIQUE_ID___y507 = alloca i32, align 4
  %tmp136 = alloca i32, align 4
  %false_smax145 = alloca i64, align 8
  %true_smin154 = alloca i64, align 8
  %__UNIQUE_ID___x508 = alloca i64, align 8
  %__UNIQUE_ID___y509 = alloca i64, align 8
  %tmp163 = alloca i64, align 8
  %__UNIQUE_ID___x510 = alloca i64, align 8
  %__UNIQUE_ID___y511 = alloca i64, align 8
  %tmp171 = alloca i64, align 8
  %false_umin = alloca i32, align 4
  %true_umax = alloca i32, align 4
  %__UNIQUE_ID___x512 = alloca i32, align 4
  %__UNIQUE_ID___y513 = alloca i32, align 4
  %tmp200 = alloca i32, align 4
  %__UNIQUE_ID___x514 = alloca i32, align 4
  %__UNIQUE_ID___y515 = alloca i32, align 4
  %tmp209 = alloca i32, align 4
  %false_umin218 = alloca i64, align 8
  %true_umax227 = alloca i64, align 8
  %__UNIQUE_ID___x516 = alloca i64, align 8
  %__UNIQUE_ID___y517 = alloca i64, align 8
  %tmp237 = alloca i64, align 8
  %__UNIQUE_ID___x518 = alloca i64, align 8
  %__UNIQUE_ID___y519 = alloca i64, align 8
  %tmp246 = alloca i64, align 8
  %false_smin = alloca i32, align 4
  %true_smax = alloca i32, align 4
  %__UNIQUE_ID___x520 = alloca i32, align 4
  %__UNIQUE_ID___y521 = alloca i32, align 4
  %tmp275 = alloca i32, align 4
  %__UNIQUE_ID___x522 = alloca i32, align 4
  %__UNIQUE_ID___y523 = alloca i32, align 4
  %tmp284 = alloca i32, align 4
  %false_smin293 = alloca i64, align 8
  %true_smax302 = alloca i64, align 8
  %__UNIQUE_ID___x524 = alloca i64, align 8
  %__UNIQUE_ID___y525 = alloca i64, align 8
  %tmp312 = alloca i64, align 8
  %__UNIQUE_ID___x526 = alloca i64, align 8
  %__UNIQUE_ID___y527 = alloca i64, align 8
  %tmp321 = alloca i64, align 8
  %tmp333 = alloca %struct.tnum, align 8
  %agg.tmp334 = alloca %struct.tnum, align 8
  %agg.tmp336 = alloca %struct.tnum, align 8
  %tmp340 = alloca %struct.tnum, align 8
  %agg.tmp341 = alloca %struct.tnum, align 8
  %agg.tmp343 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 %val32, i32* %val32.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #14
  %6 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = bitcast %struct.tnum* %false_64off to i8*
  %13 = bitcast %struct.tnum* %var_off1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %15 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call3 = call { i64, i64 } @tnum_subreg(i64 %17, i64 %19) #14
  %20 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call3, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call3, 1
  store i64 %24, i64* %23, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %true_64off to i8*
  %27 = bitcast %struct.tnum* %var_off4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i64, i64* %val.addr, align 8
  store i64 %28, i64* %sval, align 8
  %29 = load i32, i32* %val32.addr, align 4
  store i32 %29, i32* %sval32, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call5 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %30) #14
  br i1 %call5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end349

if.end:                                           ; preds = %entry
  %31 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %31 to i32
  switch i32 %conv, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb
    i32 64, label %sw.bb11
    i32 48, label %sw.bb40
    i32 32, label %sw.bb40
    i32 112, label %sw.bb109
    i32 96, label %sw.bb109
    i32 176, label %sw.bb180
    i32 160, label %sw.bb180
    i32 208, label %sw.bb255
    i32 192, label %sw.bb255
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %32 = load i8, i8* %opcode.addr, align 1
  %conv6 = zext i8 %32 to i32
  %cmp = icmp eq i32 %conv6, 16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %33, %cond.true ], [ %34, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  %35 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %35 to i1
  br i1 %tobool, label %if.then8, label %if.else

if.then8:                                         ; preds = %cond.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %37 = load i32, i32* %val32.addr, align 4
  %conv9 = zext i32 %37 to i64
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %36, i64 noundef %conv9) #14
  br label %if.end10

if.else:                                          ; preds = %cond.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %39 = load i64, i64* %val.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %38, i64 noundef %39) #14
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then8
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end
  %40 = load i8, i8* %is_jmp32.addr, align 1
  %tobool12 = trunc i8 %40 to i1
  br i1 %tobool12, label %if.then13, label %if.else26

if.then13:                                        ; preds = %sw.bb11
  %41 = load i32, i32* %val32.addr, align 4
  %neg = xor i32 %41, -1
  %conv14 = zext i32 %neg to i64
  %call15 = call { i64, i64 } @tnum_const(i64 noundef %conv14) #14
  %42 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %call15, 0
  store i64 %44, i64* %43, align 8
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %call15, 1
  store i64 %46, i64* %45, align 8
  %47 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %47, i32 0, i32 0
  %49 = load i64, i64* %48, align 8
  %50 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %47, i32 0, i32 1
  %51 = load i64, i64* %50, align 8
  %52 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = load i64, i64* %55, align 8
  %call16 = call { i64, i64 } @tnum_and(i64 %49, i64 %51, i64 %54, i64 %56) #14
  %57 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call16, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call16, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.tnum* %false_32off to i8*
  %63 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %62, i8* align 8 %63, i64 16, i1 false)
  %64 = load i32, i32* %val32.addr, align 4
  %conv17 = zext i32 %64 to i64
  %call18 = call zeroext i1 @is_power_of_2(i64 noundef %conv17) #17
  br i1 %call18, label %if.then19, label %if.end25

if.then19:                                        ; preds = %if.then13
  %65 = load i32, i32* %val32.addr, align 4
  %conv22 = zext i32 %65 to i64
  %call23 = call { i64, i64 } @tnum_const(i64 noundef %conv22) #14
  %66 = bitcast %struct.tnum* %agg.tmp21 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call23, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call23, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %76 = bitcast %struct.tnum* %agg.tmp21 to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call24 = call { i64, i64 } @tnum_or(i64 %73, i64 %75, i64 %78, i64 %80) #14
  %81 = bitcast %struct.tnum* %tmp20 to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = extractvalue { i64, i64 } %call24, 0
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = extractvalue { i64, i64 } %call24, 1
  store i64 %85, i64* %84, align 8
  %86 = bitcast %struct.tnum* %true_32off to i8*
  %87 = bitcast %struct.tnum* %tmp20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %86, i8* align 8 %87, i64 16, i1 false)
  br label %if.end25

if.end25:                                         ; preds = %if.then19, %if.then13
  br label %if.end39

if.else26:                                        ; preds = %sw.bb11
  %88 = load i64, i64* %val.addr, align 8
  %neg29 = xor i64 %88, -1
  %call30 = call { i64, i64 } @tnum_const(i64 noundef %neg29) #14
  %89 = bitcast %struct.tnum* %agg.tmp28 to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = extractvalue { i64, i64 } %call30, 0
  store i64 %91, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = extractvalue { i64, i64 } %call30, 1
  store i64 %93, i64* %92, align 8
  %94 = bitcast %struct.tnum* %false_64off to { i64, i64 }*
  %95 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 0
  %96 = load i64, i64* %95, align 8
  %97 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 1
  %98 = load i64, i64* %97, align 8
  %99 = bitcast %struct.tnum* %agg.tmp28 to { i64, i64 }*
  %100 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %99, i32 0, i32 0
  %101 = load i64, i64* %100, align 8
  %102 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %99, i32 0, i32 1
  %103 = load i64, i64* %102, align 8
  %call31 = call { i64, i64 } @tnum_and(i64 %96, i64 %98, i64 %101, i64 %103) #14
  %104 = bitcast %struct.tnum* %tmp27 to { i64, i64 }*
  %105 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %104, i32 0, i32 0
  %106 = extractvalue { i64, i64 } %call31, 0
  store i64 %106, i64* %105, align 8
  %107 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %104, i32 0, i32 1
  %108 = extractvalue { i64, i64 } %call31, 1
  store i64 %108, i64* %107, align 8
  %109 = bitcast %struct.tnum* %false_64off to i8*
  %110 = bitcast %struct.tnum* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %109, i8* align 8 %110, i64 16, i1 false)
  %111 = load i64, i64* %val.addr, align 8
  %call32 = call zeroext i1 @is_power_of_2(i64 noundef %111) #17
  br i1 %call32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else26
  %112 = load i64, i64* %val.addr, align 8
  %call36 = call { i64, i64 } @tnum_const(i64 noundef %112) #14
  %113 = bitcast %struct.tnum* %agg.tmp35 to { i64, i64 }*
  %114 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 0
  %115 = extractvalue { i64, i64 } %call36, 0
  store i64 %115, i64* %114, align 8
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 1
  %117 = extractvalue { i64, i64 } %call36, 1
  store i64 %117, i64* %116, align 8
  %118 = bitcast %struct.tnum* %true_64off to { i64, i64 }*
  %119 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %118, i32 0, i32 0
  %120 = load i64, i64* %119, align 8
  %121 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %118, i32 0, i32 1
  %122 = load i64, i64* %121, align 8
  %123 = bitcast %struct.tnum* %agg.tmp35 to { i64, i64 }*
  %124 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 0
  %125 = load i64, i64* %124, align 8
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 1
  %127 = load i64, i64* %126, align 8
  %call37 = call { i64, i64 } @tnum_or(i64 %120, i64 %122, i64 %125, i64 %127) #14
  %128 = bitcast %struct.tnum* %tmp34 to { i64, i64 }*
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 0
  %130 = extractvalue { i64, i64 } %call37, 0
  store i64 %130, i64* %129, align 8
  %131 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 1
  %132 = extractvalue { i64, i64 } %call37, 1
  store i64 %132, i64* %131, align 8
  %133 = bitcast %struct.tnum* %true_64off to i8*
  %134 = bitcast %struct.tnum* %tmp34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %133, i8* align 8 %134, i64 16, i1 false)
  br label %if.end38

if.end38:                                         ; preds = %if.then33, %if.else26
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end25
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end, %if.end
  %135 = load i8, i8* %is_jmp32.addr, align 1
  %tobool41 = trunc i8 %135 to i1
  br i1 %tobool41, label %if.then42, label %if.else73

if.then42:                                        ; preds = %sw.bb40
  %136 = load i8, i8* %opcode.addr, align 1
  %conv43 = zext i8 %136 to i32
  %cmp44 = icmp eq i32 %conv43, 32
  br i1 %cmp44, label %cond.true46, label %cond.false47

cond.true46:                                      ; preds = %if.then42
  %137 = load i32, i32* %val32.addr, align 4
  br label %cond.end48

cond.false47:                                     ; preds = %if.then42
  %138 = load i32, i32* %val32.addr, align 4
  %sub = sub i32 %138, 1
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false47, %cond.true46
  %cond49 = phi i32 [ %137, %cond.true46 ], [ %sub, %cond.false47 ]
  store i32 %cond49, i32* %false_umax, align 4
  %139 = load i8, i8* %opcode.addr, align 1
  %conv50 = zext i8 %139 to i32
  %cmp51 = icmp eq i32 %conv50, 32
  br i1 %cmp51, label %cond.true53, label %cond.false54

cond.true53:                                      ; preds = %cond.end48
  %140 = load i32, i32* %val32.addr, align 4
  %add = add i32 %140, 1
  br label %cond.end55

cond.false54:                                     ; preds = %cond.end48
  %141 = load i32, i32* %val32.addr, align 4
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false54, %cond.true53
  %cond56 = phi i32 [ %add, %cond.true53 ], [ %141, %cond.false54 ]
  store i32 %cond56, i32* %true_umin, align 4
  %142 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %142, i32 0, i32 13
  %143 = load i32, i32* %u32_max_value, align 4
  store i32 %143, i32* %__UNIQUE_ID___x496, align 4
  %144 = load i32, i32* %false_umax, align 4
  store i32 %144, i32* %__UNIQUE_ID___y497, align 4
  %145 = load i32, i32* %__UNIQUE_ID___x496, align 4
  %146 = load i32, i32* %__UNIQUE_ID___y497, align 4
  %cmp58 = icmp ult i32 %145, %146
  br i1 %cmp58, label %cond.true60, label %cond.false61

cond.true60:                                      ; preds = %cond.end55
  %147 = load i32, i32* %__UNIQUE_ID___x496, align 4
  br label %cond.end62

cond.false61:                                     ; preds = %cond.end55
  %148 = load i32, i32* %__UNIQUE_ID___y497, align 4
  br label %cond.end62

cond.end62:                                       ; preds = %cond.false61, %cond.true60
  %cond63 = phi i32 [ %147, %cond.true60 ], [ %148, %cond.false61 ]
  store i32 %cond63, i32* %tmp57, align 4
  %149 = load i32, i32* %tmp57, align 4
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_max_value64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i32 0, i32 13
  store i32 %149, i32* %u32_max_value64, align 4
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %151, i32 0, i32 12
  %152 = load i32, i32* %u32_min_value, align 8
  store i32 %152, i32* %__UNIQUE_ID___x498, align 4
  %153 = load i32, i32* %true_umin, align 4
  store i32 %153, i32* %__UNIQUE_ID___y499, align 4
  %154 = load i32, i32* %__UNIQUE_ID___x498, align 4
  %155 = load i32, i32* %__UNIQUE_ID___y499, align 4
  %cmp66 = icmp ugt i32 %154, %155
  br i1 %cmp66, label %cond.true68, label %cond.false69

cond.true68:                                      ; preds = %cond.end62
  %156 = load i32, i32* %__UNIQUE_ID___x498, align 4
  br label %cond.end70

cond.false69:                                     ; preds = %cond.end62
  %157 = load i32, i32* %__UNIQUE_ID___y499, align 4
  br label %cond.end70

cond.end70:                                       ; preds = %cond.false69, %cond.true68
  %cond71 = phi i32 [ %156, %cond.true68 ], [ %157, %cond.false69 ]
  store i32 %cond71, i32* %tmp65, align 4
  %158 = load i32, i32* %tmp65, align 4
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_min_value72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i32 0, i32 12
  store i32 %158, i32* %u32_min_value72, align 8
  br label %if.end108

if.else73:                                        ; preds = %sw.bb40
  %160 = load i8, i8* %opcode.addr, align 1
  %conv75 = zext i8 %160 to i32
  %cmp76 = icmp eq i32 %conv75, 32
  br i1 %cmp76, label %cond.true78, label %cond.false79

cond.true78:                                      ; preds = %if.else73
  %161 = load i64, i64* %val.addr, align 8
  br label %cond.end81

cond.false79:                                     ; preds = %if.else73
  %162 = load i64, i64* %val.addr, align 8
  %sub80 = sub i64 %162, 1
  br label %cond.end81

cond.end81:                                       ; preds = %cond.false79, %cond.true78
  %cond82 = phi i64 [ %161, %cond.true78 ], [ %sub80, %cond.false79 ]
  store i64 %cond82, i64* %false_umax74, align 8
  %163 = load i8, i8* %opcode.addr, align 1
  %conv84 = zext i8 %163 to i32
  %cmp85 = icmp eq i32 %conv84, 32
  br i1 %cmp85, label %cond.true87, label %cond.false89

cond.true87:                                      ; preds = %cond.end81
  %164 = load i64, i64* %val.addr, align 8
  %add88 = add i64 %164, 1
  br label %cond.end90

cond.false89:                                     ; preds = %cond.end81
  %165 = load i64, i64* %val.addr, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false89, %cond.true87
  %cond91 = phi i64 [ %add88, %cond.true87 ], [ %165, %cond.false89 ]
  store i64 %cond91, i64* %true_umin83, align 8
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 9
  %167 = load i64, i64* %umax_value, align 8
  store i64 %167, i64* %__UNIQUE_ID___x500, align 8
  %168 = load i64, i64* %false_umax74, align 8
  store i64 %168, i64* %__UNIQUE_ID___y501, align 8
  %169 = load i64, i64* %__UNIQUE_ID___x500, align 8
  %170 = load i64, i64* %__UNIQUE_ID___y501, align 8
  %cmp93 = icmp ult i64 %169, %170
  br i1 %cmp93, label %cond.true95, label %cond.false96

cond.true95:                                      ; preds = %cond.end90
  %171 = load i64, i64* %__UNIQUE_ID___x500, align 8
  br label %cond.end97

cond.false96:                                     ; preds = %cond.end90
  %172 = load i64, i64* %__UNIQUE_ID___y501, align 8
  br label %cond.end97

cond.end97:                                       ; preds = %cond.false96, %cond.true95
  %cond98 = phi i64 [ %171, %cond.true95 ], [ %172, %cond.false96 ]
  store i64 %cond98, i64* %tmp92, align 8
  %173 = load i64, i64* %tmp92, align 8
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %174, i32 0, i32 9
  store i64 %173, i64* %umax_value99, align 8
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %175, i32 0, i32 8
  %176 = load i64, i64* %umin_value, align 8
  store i64 %176, i64* %__UNIQUE_ID___x502, align 8
  %177 = load i64, i64* %true_umin83, align 8
  store i64 %177, i64* %__UNIQUE_ID___y503, align 8
  %178 = load i64, i64* %__UNIQUE_ID___x502, align 8
  %179 = load i64, i64* %__UNIQUE_ID___y503, align 8
  %cmp101 = icmp ugt i64 %178, %179
  br i1 %cmp101, label %cond.true103, label %cond.false104

cond.true103:                                     ; preds = %cond.end97
  %180 = load i64, i64* %__UNIQUE_ID___x502, align 8
  br label %cond.end105

cond.false104:                                    ; preds = %cond.end97
  %181 = load i64, i64* %__UNIQUE_ID___y503, align 8
  br label %cond.end105

cond.end105:                                      ; preds = %cond.false104, %cond.true103
  %cond106 = phi i64 [ %180, %cond.true103 ], [ %181, %cond.false104 ]
  store i64 %cond106, i64* %tmp100, align 8
  %182 = load i64, i64* %tmp100, align 8
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %183, i32 0, i32 8
  store i64 %182, i64* %umin_value107, align 8
  br label %if.end108

if.end108:                                        ; preds = %cond.end105, %cond.end70
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end, %if.end
  %184 = load i8, i8* %is_jmp32.addr, align 1
  %tobool110 = trunc i8 %184 to i1
  br i1 %tobool110, label %if.then111, label %if.else144

if.then111:                                       ; preds = %sw.bb109
  %185 = load i8, i8* %opcode.addr, align 1
  %conv112 = zext i8 %185 to i32
  %cmp113 = icmp eq i32 %conv112, 96
  br i1 %cmp113, label %cond.true115, label %cond.false116

cond.true115:                                     ; preds = %if.then111
  %186 = load i32, i32* %sval32, align 4
  br label %cond.end118

cond.false116:                                    ; preds = %if.then111
  %187 = load i32, i32* %sval32, align 4
  %sub117 = sub i32 %187, 1
  br label %cond.end118

cond.end118:                                      ; preds = %cond.false116, %cond.true115
  %cond119 = phi i32 [ %186, %cond.true115 ], [ %sub117, %cond.false116 ]
  store i32 %cond119, i32* %false_smax, align 4
  %188 = load i8, i8* %opcode.addr, align 1
  %conv120 = zext i8 %188 to i32
  %cmp121 = icmp eq i32 %conv120, 96
  br i1 %cmp121, label %cond.true123, label %cond.false125

cond.true123:                                     ; preds = %cond.end118
  %189 = load i32, i32* %sval32, align 4
  %add124 = add i32 %189, 1
  br label %cond.end126

cond.false125:                                    ; preds = %cond.end118
  %190 = load i32, i32* %sval32, align 4
  br label %cond.end126

cond.end126:                                      ; preds = %cond.false125, %cond.true123
  %cond127 = phi i32 [ %add124, %cond.true123 ], [ %190, %cond.false125 ]
  store i32 %cond127, i32* %true_smin, align 4
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %191, i32 0, i32 11
  %192 = load i32, i32* %s32_max_value, align 4
  store i32 %192, i32* %__UNIQUE_ID___x504, align 4
  %193 = load i32, i32* %false_smax, align 4
  store i32 %193, i32* %__UNIQUE_ID___y505, align 4
  %194 = load i32, i32* %__UNIQUE_ID___x504, align 4
  %195 = load i32, i32* %__UNIQUE_ID___y505, align 4
  %cmp129 = icmp slt i32 %194, %195
  br i1 %cmp129, label %cond.true131, label %cond.false132

cond.true131:                                     ; preds = %cond.end126
  %196 = load i32, i32* %__UNIQUE_ID___x504, align 4
  br label %cond.end133

cond.false132:                                    ; preds = %cond.end126
  %197 = load i32, i32* %__UNIQUE_ID___y505, align 4
  br label %cond.end133

cond.end133:                                      ; preds = %cond.false132, %cond.true131
  %cond134 = phi i32 [ %196, %cond.true131 ], [ %197, %cond.false132 ]
  store i32 %cond134, i32* %tmp128, align 4
  %198 = load i32, i32* %tmp128, align 4
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_max_value135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %199, i32 0, i32 11
  store i32 %198, i32* %s32_max_value135, align 4
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i32 0, i32 10
  %201 = load i32, i32* %s32_min_value, align 8
  store i32 %201, i32* %__UNIQUE_ID___x506, align 4
  %202 = load i32, i32* %true_smin, align 4
  store i32 %202, i32* %__UNIQUE_ID___y507, align 4
  %203 = load i32, i32* %__UNIQUE_ID___x506, align 4
  %204 = load i32, i32* %__UNIQUE_ID___y507, align 4
  %cmp137 = icmp sgt i32 %203, %204
  br i1 %cmp137, label %cond.true139, label %cond.false140

cond.true139:                                     ; preds = %cond.end133
  %205 = load i32, i32* %__UNIQUE_ID___x506, align 4
  br label %cond.end141

cond.false140:                                    ; preds = %cond.end133
  %206 = load i32, i32* %__UNIQUE_ID___y507, align 4
  br label %cond.end141

cond.end141:                                      ; preds = %cond.false140, %cond.true139
  %cond142 = phi i32 [ %205, %cond.true139 ], [ %206, %cond.false140 ]
  store i32 %cond142, i32* %tmp136, align 4
  %207 = load i32, i32* %tmp136, align 4
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_min_value143 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %208, i32 0, i32 10
  store i32 %207, i32* %s32_min_value143, align 8
  br label %if.end179

if.else144:                                       ; preds = %sw.bb109
  %209 = load i8, i8* %opcode.addr, align 1
  %conv146 = zext i8 %209 to i32
  %cmp147 = icmp eq i32 %conv146, 96
  br i1 %cmp147, label %cond.true149, label %cond.false150

cond.true149:                                     ; preds = %if.else144
  %210 = load i64, i64* %sval, align 8
  br label %cond.end152

cond.false150:                                    ; preds = %if.else144
  %211 = load i64, i64* %sval, align 8
  %sub151 = sub i64 %211, 1
  br label %cond.end152

cond.end152:                                      ; preds = %cond.false150, %cond.true149
  %cond153 = phi i64 [ %210, %cond.true149 ], [ %sub151, %cond.false150 ]
  store i64 %cond153, i64* %false_smax145, align 8
  %212 = load i8, i8* %opcode.addr, align 1
  %conv155 = zext i8 %212 to i32
  %cmp156 = icmp eq i32 %conv155, 96
  br i1 %cmp156, label %cond.true158, label %cond.false160

cond.true158:                                     ; preds = %cond.end152
  %213 = load i64, i64* %sval, align 8
  %add159 = add i64 %213, 1
  br label %cond.end161

cond.false160:                                    ; preds = %cond.end152
  %214 = load i64, i64* %sval, align 8
  br label %cond.end161

cond.end161:                                      ; preds = %cond.false160, %cond.true158
  %cond162 = phi i64 [ %add159, %cond.true158 ], [ %214, %cond.false160 ]
  store i64 %cond162, i64* %true_smin154, align 8
  %215 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %215, i32 0, i32 7
  %216 = load i64, i64* %smax_value, align 8
  store i64 %216, i64* %__UNIQUE_ID___x508, align 8
  %217 = load i64, i64* %false_smax145, align 8
  store i64 %217, i64* %__UNIQUE_ID___y509, align 8
  %218 = load i64, i64* %__UNIQUE_ID___x508, align 8
  %219 = load i64, i64* %__UNIQUE_ID___y509, align 8
  %cmp164 = icmp slt i64 %218, %219
  br i1 %cmp164, label %cond.true166, label %cond.false167

cond.true166:                                     ; preds = %cond.end161
  %220 = load i64, i64* %__UNIQUE_ID___x508, align 8
  br label %cond.end168

cond.false167:                                    ; preds = %cond.end161
  %221 = load i64, i64* %__UNIQUE_ID___y509, align 8
  br label %cond.end168

cond.end168:                                      ; preds = %cond.false167, %cond.true166
  %cond169 = phi i64 [ %220, %cond.true166 ], [ %221, %cond.false167 ]
  store i64 %cond169, i64* %tmp163, align 8
  %222 = load i64, i64* %tmp163, align 8
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i32 0, i32 7
  store i64 %222, i64* %smax_value170, align 8
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %224, i32 0, i32 6
  %225 = load i64, i64* %smin_value, align 8
  store i64 %225, i64* %__UNIQUE_ID___x510, align 8
  %226 = load i64, i64* %true_smin154, align 8
  store i64 %226, i64* %__UNIQUE_ID___y511, align 8
  %227 = load i64, i64* %__UNIQUE_ID___x510, align 8
  %228 = load i64, i64* %__UNIQUE_ID___y511, align 8
  %cmp172 = icmp sgt i64 %227, %228
  br i1 %cmp172, label %cond.true174, label %cond.false175

cond.true174:                                     ; preds = %cond.end168
  %229 = load i64, i64* %__UNIQUE_ID___x510, align 8
  br label %cond.end176

cond.false175:                                    ; preds = %cond.end168
  %230 = load i64, i64* %__UNIQUE_ID___y511, align 8
  br label %cond.end176

cond.end176:                                      ; preds = %cond.false175, %cond.true174
  %cond177 = phi i64 [ %229, %cond.true174 ], [ %230, %cond.false175 ]
  store i64 %cond177, i64* %tmp171, align 8
  %231 = load i64, i64* %tmp171, align 8
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %232, i32 0, i32 6
  store i64 %231, i64* %smin_value178, align 8
  br label %if.end179

if.end179:                                        ; preds = %cond.end176, %cond.end141
  br label %sw.epilog

sw.bb180:                                         ; preds = %if.end, %if.end
  %233 = load i8, i8* %is_jmp32.addr, align 1
  %tobool181 = trunc i8 %233 to i1
  br i1 %tobool181, label %if.then182, label %if.else217

if.then182:                                       ; preds = %sw.bb180
  %234 = load i8, i8* %opcode.addr, align 1
  %conv183 = zext i8 %234 to i32
  %cmp184 = icmp eq i32 %conv183, 160
  br i1 %cmp184, label %cond.true186, label %cond.false187

cond.true186:                                     ; preds = %if.then182
  %235 = load i32, i32* %val32.addr, align 4
  br label %cond.end189

cond.false187:                                    ; preds = %if.then182
  %236 = load i32, i32* %val32.addr, align 4
  %add188 = add i32 %236, 1
  br label %cond.end189

cond.end189:                                      ; preds = %cond.false187, %cond.true186
  %cond190 = phi i32 [ %235, %cond.true186 ], [ %add188, %cond.false187 ]
  store i32 %cond190, i32* %false_umin, align 4
  %237 = load i8, i8* %opcode.addr, align 1
  %conv191 = zext i8 %237 to i32
  %cmp192 = icmp eq i32 %conv191, 160
  br i1 %cmp192, label %cond.true194, label %cond.false196

cond.true194:                                     ; preds = %cond.end189
  %238 = load i32, i32* %val32.addr, align 4
  %sub195 = sub i32 %238, 1
  br label %cond.end197

cond.false196:                                    ; preds = %cond.end189
  %239 = load i32, i32* %val32.addr, align 4
  br label %cond.end197

cond.end197:                                      ; preds = %cond.false196, %cond.true194
  %cond198 = phi i32 [ %sub195, %cond.true194 ], [ %239, %cond.false196 ]
  store i32 %cond198, i32* %true_umax, align 4
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_min_value199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i32 0, i32 12
  %241 = load i32, i32* %u32_min_value199, align 8
  store i32 %241, i32* %__UNIQUE_ID___x512, align 4
  %242 = load i32, i32* %false_umin, align 4
  store i32 %242, i32* %__UNIQUE_ID___y513, align 4
  %243 = load i32, i32* %__UNIQUE_ID___x512, align 4
  %244 = load i32, i32* %__UNIQUE_ID___y513, align 4
  %cmp201 = icmp ugt i32 %243, %244
  br i1 %cmp201, label %cond.true203, label %cond.false204

cond.true203:                                     ; preds = %cond.end197
  %245 = load i32, i32* %__UNIQUE_ID___x512, align 4
  br label %cond.end205

cond.false204:                                    ; preds = %cond.end197
  %246 = load i32, i32* %__UNIQUE_ID___y513, align 4
  br label %cond.end205

cond.end205:                                      ; preds = %cond.false204, %cond.true203
  %cond206 = phi i32 [ %245, %cond.true203 ], [ %246, %cond.false204 ]
  store i32 %cond206, i32* %tmp200, align 4
  %247 = load i32, i32* %tmp200, align 4
  %248 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_min_value207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %248, i32 0, i32 12
  store i32 %247, i32* %u32_min_value207, align 8
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_max_value208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %249, i32 0, i32 13
  %250 = load i32, i32* %u32_max_value208, align 4
  store i32 %250, i32* %__UNIQUE_ID___x514, align 4
  %251 = load i32, i32* %true_umax, align 4
  store i32 %251, i32* %__UNIQUE_ID___y515, align 4
  %252 = load i32, i32* %__UNIQUE_ID___x514, align 4
  %253 = load i32, i32* %__UNIQUE_ID___y515, align 4
  %cmp210 = icmp ult i32 %252, %253
  br i1 %cmp210, label %cond.true212, label %cond.false213

cond.true212:                                     ; preds = %cond.end205
  %254 = load i32, i32* %__UNIQUE_ID___x514, align 4
  br label %cond.end214

cond.false213:                                    ; preds = %cond.end205
  %255 = load i32, i32* %__UNIQUE_ID___y515, align 4
  br label %cond.end214

cond.end214:                                      ; preds = %cond.false213, %cond.true212
  %cond215 = phi i32 [ %254, %cond.true212 ], [ %255, %cond.false213 ]
  store i32 %cond215, i32* %tmp209, align 4
  %256 = load i32, i32* %tmp209, align 4
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_max_value216 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 13
  store i32 %256, i32* %u32_max_value216, align 4
  br label %if.end254

if.else217:                                       ; preds = %sw.bb180
  %258 = load i8, i8* %opcode.addr, align 1
  %conv219 = zext i8 %258 to i32
  %cmp220 = icmp eq i32 %conv219, 160
  br i1 %cmp220, label %cond.true222, label %cond.false223

cond.true222:                                     ; preds = %if.else217
  %259 = load i64, i64* %val.addr, align 8
  br label %cond.end225

cond.false223:                                    ; preds = %if.else217
  %260 = load i64, i64* %val.addr, align 8
  %add224 = add i64 %260, 1
  br label %cond.end225

cond.end225:                                      ; preds = %cond.false223, %cond.true222
  %cond226 = phi i64 [ %259, %cond.true222 ], [ %add224, %cond.false223 ]
  store i64 %cond226, i64* %false_umin218, align 8
  %261 = load i8, i8* %opcode.addr, align 1
  %conv228 = zext i8 %261 to i32
  %cmp229 = icmp eq i32 %conv228, 160
  br i1 %cmp229, label %cond.true231, label %cond.false233

cond.true231:                                     ; preds = %cond.end225
  %262 = load i64, i64* %val.addr, align 8
  %sub232 = sub i64 %262, 1
  br label %cond.end234

cond.false233:                                    ; preds = %cond.end225
  %263 = load i64, i64* %val.addr, align 8
  br label %cond.end234

cond.end234:                                      ; preds = %cond.false233, %cond.true231
  %cond235 = phi i64 [ %sub232, %cond.true231 ], [ %263, %cond.false233 ]
  store i64 %cond235, i64* %true_umax227, align 8
  %264 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value236 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %264, i32 0, i32 8
  %265 = load i64, i64* %umin_value236, align 8
  store i64 %265, i64* %__UNIQUE_ID___x516, align 8
  %266 = load i64, i64* %false_umin218, align 8
  store i64 %266, i64* %__UNIQUE_ID___y517, align 8
  %267 = load i64, i64* %__UNIQUE_ID___x516, align 8
  %268 = load i64, i64* %__UNIQUE_ID___y517, align 8
  %cmp238 = icmp ugt i64 %267, %268
  br i1 %cmp238, label %cond.true240, label %cond.false241

cond.true240:                                     ; preds = %cond.end234
  %269 = load i64, i64* %__UNIQUE_ID___x516, align 8
  br label %cond.end242

cond.false241:                                    ; preds = %cond.end234
  %270 = load i64, i64* %__UNIQUE_ID___y517, align 8
  br label %cond.end242

cond.end242:                                      ; preds = %cond.false241, %cond.true240
  %cond243 = phi i64 [ %269, %cond.true240 ], [ %270, %cond.false241 ]
  store i64 %cond243, i64* %tmp237, align 8
  %271 = load i64, i64* %tmp237, align 8
  %272 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value244 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %272, i32 0, i32 8
  store i64 %271, i64* %umin_value244, align 8
  %273 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value245 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %273, i32 0, i32 9
  %274 = load i64, i64* %umax_value245, align 8
  store i64 %274, i64* %__UNIQUE_ID___x518, align 8
  %275 = load i64, i64* %true_umax227, align 8
  store i64 %275, i64* %__UNIQUE_ID___y519, align 8
  %276 = load i64, i64* %__UNIQUE_ID___x518, align 8
  %277 = load i64, i64* %__UNIQUE_ID___y519, align 8
  %cmp247 = icmp ult i64 %276, %277
  br i1 %cmp247, label %cond.true249, label %cond.false250

cond.true249:                                     ; preds = %cond.end242
  %278 = load i64, i64* %__UNIQUE_ID___x518, align 8
  br label %cond.end251

cond.false250:                                    ; preds = %cond.end242
  %279 = load i64, i64* %__UNIQUE_ID___y519, align 8
  br label %cond.end251

cond.end251:                                      ; preds = %cond.false250, %cond.true249
  %cond252 = phi i64 [ %278, %cond.true249 ], [ %279, %cond.false250 ]
  store i64 %cond252, i64* %tmp246, align 8
  %280 = load i64, i64* %tmp246, align 8
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value253 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i32 0, i32 9
  store i64 %280, i64* %umax_value253, align 8
  br label %if.end254

if.end254:                                        ; preds = %cond.end251, %cond.end214
  br label %sw.epilog

sw.bb255:                                         ; preds = %if.end, %if.end
  %282 = load i8, i8* %is_jmp32.addr, align 1
  %tobool256 = trunc i8 %282 to i1
  br i1 %tobool256, label %if.then257, label %if.else292

if.then257:                                       ; preds = %sw.bb255
  %283 = load i8, i8* %opcode.addr, align 1
  %conv258 = zext i8 %283 to i32
  %cmp259 = icmp eq i32 %conv258, 192
  br i1 %cmp259, label %cond.true261, label %cond.false262

cond.true261:                                     ; preds = %if.then257
  %284 = load i32, i32* %sval32, align 4
  br label %cond.end264

cond.false262:                                    ; preds = %if.then257
  %285 = load i32, i32* %sval32, align 4
  %add263 = add i32 %285, 1
  br label %cond.end264

cond.end264:                                      ; preds = %cond.false262, %cond.true261
  %cond265 = phi i32 [ %284, %cond.true261 ], [ %add263, %cond.false262 ]
  store i32 %cond265, i32* %false_smin, align 4
  %286 = load i8, i8* %opcode.addr, align 1
  %conv266 = zext i8 %286 to i32
  %cmp267 = icmp eq i32 %conv266, 192
  br i1 %cmp267, label %cond.true269, label %cond.false271

cond.true269:                                     ; preds = %cond.end264
  %287 = load i32, i32* %sval32, align 4
  %sub270 = sub i32 %287, 1
  br label %cond.end272

cond.false271:                                    ; preds = %cond.end264
  %288 = load i32, i32* %sval32, align 4
  br label %cond.end272

cond.end272:                                      ; preds = %cond.false271, %cond.true269
  %cond273 = phi i32 [ %sub270, %cond.true269 ], [ %288, %cond.false271 ]
  store i32 %cond273, i32* %true_smax, align 4
  %289 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_min_value274 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %289, i32 0, i32 10
  %290 = load i32, i32* %s32_min_value274, align 8
  store i32 %290, i32* %__UNIQUE_ID___x520, align 4
  %291 = load i32, i32* %false_smin, align 4
  store i32 %291, i32* %__UNIQUE_ID___y521, align 4
  %292 = load i32, i32* %__UNIQUE_ID___x520, align 4
  %293 = load i32, i32* %__UNIQUE_ID___y521, align 4
  %cmp276 = icmp sgt i32 %292, %293
  br i1 %cmp276, label %cond.true278, label %cond.false279

cond.true278:                                     ; preds = %cond.end272
  %294 = load i32, i32* %__UNIQUE_ID___x520, align 4
  br label %cond.end280

cond.false279:                                    ; preds = %cond.end272
  %295 = load i32, i32* %__UNIQUE_ID___y521, align 4
  br label %cond.end280

cond.end280:                                      ; preds = %cond.false279, %cond.true278
  %cond281 = phi i32 [ %294, %cond.true278 ], [ %295, %cond.false279 ]
  store i32 %cond281, i32* %tmp275, align 4
  %296 = load i32, i32* %tmp275, align 4
  %297 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_min_value282 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %297, i32 0, i32 10
  store i32 %296, i32* %s32_min_value282, align 8
  %298 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_max_value283 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %298, i32 0, i32 11
  %299 = load i32, i32* %s32_max_value283, align 4
  store i32 %299, i32* %__UNIQUE_ID___x522, align 4
  %300 = load i32, i32* %true_smax, align 4
  store i32 %300, i32* %__UNIQUE_ID___y523, align 4
  %301 = load i32, i32* %__UNIQUE_ID___x522, align 4
  %302 = load i32, i32* %__UNIQUE_ID___y523, align 4
  %cmp285 = icmp slt i32 %301, %302
  br i1 %cmp285, label %cond.true287, label %cond.false288

cond.true287:                                     ; preds = %cond.end280
  %303 = load i32, i32* %__UNIQUE_ID___x522, align 4
  br label %cond.end289

cond.false288:                                    ; preds = %cond.end280
  %304 = load i32, i32* %__UNIQUE_ID___y523, align 4
  br label %cond.end289

cond.end289:                                      ; preds = %cond.false288, %cond.true287
  %cond290 = phi i32 [ %303, %cond.true287 ], [ %304, %cond.false288 ]
  store i32 %cond290, i32* %tmp284, align 4
  %305 = load i32, i32* %tmp284, align 4
  %306 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_max_value291 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %306, i32 0, i32 11
  store i32 %305, i32* %s32_max_value291, align 4
  br label %if.end329

if.else292:                                       ; preds = %sw.bb255
  %307 = load i8, i8* %opcode.addr, align 1
  %conv294 = zext i8 %307 to i32
  %cmp295 = icmp eq i32 %conv294, 192
  br i1 %cmp295, label %cond.true297, label %cond.false298

cond.true297:                                     ; preds = %if.else292
  %308 = load i64, i64* %sval, align 8
  br label %cond.end300

cond.false298:                                    ; preds = %if.else292
  %309 = load i64, i64* %sval, align 8
  %add299 = add i64 %309, 1
  br label %cond.end300

cond.end300:                                      ; preds = %cond.false298, %cond.true297
  %cond301 = phi i64 [ %308, %cond.true297 ], [ %add299, %cond.false298 ]
  store i64 %cond301, i64* %false_smin293, align 8
  %310 = load i8, i8* %opcode.addr, align 1
  %conv303 = zext i8 %310 to i32
  %cmp304 = icmp eq i32 %conv303, 192
  br i1 %cmp304, label %cond.true306, label %cond.false308

cond.true306:                                     ; preds = %cond.end300
  %311 = load i64, i64* %sval, align 8
  %sub307 = sub i64 %311, 1
  br label %cond.end309

cond.false308:                                    ; preds = %cond.end300
  %312 = load i64, i64* %sval, align 8
  br label %cond.end309

cond.end309:                                      ; preds = %cond.false308, %cond.true306
  %cond310 = phi i64 [ %sub307, %cond.true306 ], [ %312, %cond.false308 ]
  store i64 %cond310, i64* %true_smax302, align 8
  %313 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value311 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %313, i32 0, i32 6
  %314 = load i64, i64* %smin_value311, align 8
  store i64 %314, i64* %__UNIQUE_ID___x524, align 8
  %315 = load i64, i64* %false_smin293, align 8
  store i64 %315, i64* %__UNIQUE_ID___y525, align 8
  %316 = load i64, i64* %__UNIQUE_ID___x524, align 8
  %317 = load i64, i64* %__UNIQUE_ID___y525, align 8
  %cmp313 = icmp sgt i64 %316, %317
  br i1 %cmp313, label %cond.true315, label %cond.false316

cond.true315:                                     ; preds = %cond.end309
  %318 = load i64, i64* %__UNIQUE_ID___x524, align 8
  br label %cond.end317

cond.false316:                                    ; preds = %cond.end309
  %319 = load i64, i64* %__UNIQUE_ID___y525, align 8
  br label %cond.end317

cond.end317:                                      ; preds = %cond.false316, %cond.true315
  %cond318 = phi i64 [ %318, %cond.true315 ], [ %319, %cond.false316 ]
  store i64 %cond318, i64* %tmp312, align 8
  %320 = load i64, i64* %tmp312, align 8
  %321 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value319 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %321, i32 0, i32 6
  store i64 %320, i64* %smin_value319, align 8
  %322 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value320 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %322, i32 0, i32 7
  %323 = load i64, i64* %smax_value320, align 8
  store i64 %323, i64* %__UNIQUE_ID___x526, align 8
  %324 = load i64, i64* %true_smax302, align 8
  store i64 %324, i64* %__UNIQUE_ID___y527, align 8
  %325 = load i64, i64* %__UNIQUE_ID___x526, align 8
  %326 = load i64, i64* %__UNIQUE_ID___y527, align 8
  %cmp322 = icmp slt i64 %325, %326
  br i1 %cmp322, label %cond.true324, label %cond.false325

cond.true324:                                     ; preds = %cond.end317
  %327 = load i64, i64* %__UNIQUE_ID___x526, align 8
  br label %cond.end326

cond.false325:                                    ; preds = %cond.end317
  %328 = load i64, i64* %__UNIQUE_ID___y527, align 8
  br label %cond.end326

cond.end326:                                      ; preds = %cond.false325, %cond.true324
  %cond327 = phi i64 [ %327, %cond.true324 ], [ %328, %cond.false325 ]
  store i64 %cond327, i64* %tmp321, align 8
  %329 = load i64, i64* %tmp321, align 8
  %330 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value328 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %330, i32 0, i32 7
  store i64 %329, i64* %smax_value328, align 8
  br label %if.end329

if.end329:                                        ; preds = %cond.end326, %cond.end289
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %if.end349

sw.epilog:                                        ; preds = %if.end329, %if.end254, %if.end179, %if.end108, %if.end39, %if.end10
  %331 = load i8, i8* %is_jmp32.addr, align 1
  %tobool330 = trunc i8 %331 to i1
  br i1 %tobool330, label %if.then331, label %if.else346

if.then331:                                       ; preds = %sw.epilog
  %332 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off332 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %332, i32 0, i32 5
  %333 = bitcast %struct.tnum* %false_64off to { i64, i64 }*
  %334 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %333, i32 0, i32 0
  %335 = load i64, i64* %334, align 8
  %336 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %333, i32 0, i32 1
  %337 = load i64, i64* %336, align 8
  %call335 = call { i64, i64 } @tnum_clear_subreg(i64 %335, i64 %337) #14
  %338 = bitcast %struct.tnum* %agg.tmp334 to { i64, i64 }*
  %339 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %338, i32 0, i32 0
  %340 = extractvalue { i64, i64 } %call335, 0
  store i64 %340, i64* %339, align 8
  %341 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %338, i32 0, i32 1
  %342 = extractvalue { i64, i64 } %call335, 1
  store i64 %342, i64* %341, align 8
  %343 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %344 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %343, i32 0, i32 0
  %345 = load i64, i64* %344, align 8
  %346 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %343, i32 0, i32 1
  %347 = load i64, i64* %346, align 8
  %call337 = call { i64, i64 } @tnum_subreg(i64 %345, i64 %347) #14
  %348 = bitcast %struct.tnum* %agg.tmp336 to { i64, i64 }*
  %349 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %348, i32 0, i32 0
  %350 = extractvalue { i64, i64 } %call337, 0
  store i64 %350, i64* %349, align 8
  %351 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %348, i32 0, i32 1
  %352 = extractvalue { i64, i64 } %call337, 1
  store i64 %352, i64* %351, align 8
  %353 = bitcast %struct.tnum* %agg.tmp334 to { i64, i64 }*
  %354 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %353, i32 0, i32 0
  %355 = load i64, i64* %354, align 8
  %356 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %353, i32 0, i32 1
  %357 = load i64, i64* %356, align 8
  %358 = bitcast %struct.tnum* %agg.tmp336 to { i64, i64 }*
  %359 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %358, i32 0, i32 0
  %360 = load i64, i64* %359, align 8
  %361 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %358, i32 0, i32 1
  %362 = load i64, i64* %361, align 8
  %call338 = call { i64, i64 } @tnum_or(i64 %355, i64 %357, i64 %360, i64 %362) #14
  %363 = bitcast %struct.tnum* %tmp333 to { i64, i64 }*
  %364 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %363, i32 0, i32 0
  %365 = extractvalue { i64, i64 } %call338, 0
  store i64 %365, i64* %364, align 8
  %366 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %363, i32 0, i32 1
  %367 = extractvalue { i64, i64 } %call338, 1
  store i64 %367, i64* %366, align 8
  %368 = bitcast %struct.tnum* %var_off332 to i8*
  %369 = bitcast %struct.tnum* %tmp333 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %368, i8* align 8 %369, i64 16, i1 false)
  %370 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off339 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %370, i32 0, i32 5
  %371 = bitcast %struct.tnum* %true_64off to { i64, i64 }*
  %372 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %371, i32 0, i32 0
  %373 = load i64, i64* %372, align 8
  %374 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %371, i32 0, i32 1
  %375 = load i64, i64* %374, align 8
  %call342 = call { i64, i64 } @tnum_clear_subreg(i64 %373, i64 %375) #14
  %376 = bitcast %struct.tnum* %agg.tmp341 to { i64, i64 }*
  %377 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %376, i32 0, i32 0
  %378 = extractvalue { i64, i64 } %call342, 0
  store i64 %378, i64* %377, align 8
  %379 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %376, i32 0, i32 1
  %380 = extractvalue { i64, i64 } %call342, 1
  store i64 %380, i64* %379, align 8
  %381 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %382 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %381, i32 0, i32 0
  %383 = load i64, i64* %382, align 8
  %384 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %381, i32 0, i32 1
  %385 = load i64, i64* %384, align 8
  %call344 = call { i64, i64 } @tnum_subreg(i64 %383, i64 %385) #14
  %386 = bitcast %struct.tnum* %agg.tmp343 to { i64, i64 }*
  %387 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %386, i32 0, i32 0
  %388 = extractvalue { i64, i64 } %call344, 0
  store i64 %388, i64* %387, align 8
  %389 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %386, i32 0, i32 1
  %390 = extractvalue { i64, i64 } %call344, 1
  store i64 %390, i64* %389, align 8
  %391 = bitcast %struct.tnum* %agg.tmp341 to { i64, i64 }*
  %392 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %391, i32 0, i32 0
  %393 = load i64, i64* %392, align 8
  %394 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %391, i32 0, i32 1
  %395 = load i64, i64* %394, align 8
  %396 = bitcast %struct.tnum* %agg.tmp343 to { i64, i64 }*
  %397 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %396, i32 0, i32 0
  %398 = load i64, i64* %397, align 8
  %399 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %396, i32 0, i32 1
  %400 = load i64, i64* %399, align 8
  %call345 = call { i64, i64 } @tnum_or(i64 %393, i64 %395, i64 %398, i64 %400) #14
  %401 = bitcast %struct.tnum* %tmp340 to { i64, i64 }*
  %402 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %401, i32 0, i32 0
  %403 = extractvalue { i64, i64 } %call345, 0
  store i64 %403, i64* %402, align 8
  %404 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %401, i32 0, i32 1
  %405 = extractvalue { i64, i64 } %call345, 1
  store i64 %405, i64* %404, align 8
  %406 = bitcast %struct.tnum* %var_off339 to i8*
  %407 = bitcast %struct.tnum* %tmp340 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %406, i8* align 8 %407, i64 16, i1 false)
  %408 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %408) #14
  %409 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %409) #14
  br label %if.end349

if.else346:                                       ; preds = %sw.epilog
  %410 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off347 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %410, i32 0, i32 5
  %411 = bitcast %struct.tnum* %var_off347 to i8*
  %412 = bitcast %struct.tnum* %false_64off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %411, i8* align 8 %412, i64 16, i1 false)
  %413 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off348 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %413, i32 0, i32 5
  %414 = bitcast %struct.tnum* %var_off348 to i8*
  %415 = bitcast %struct.tnum* %true_64off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %414, i8* align 8 %415, i64 16, i1 false)
  %416 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %416) #14
  %417 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %417) #14
  br label %if.end349

if.end349:                                        ; preds = %if.then, %sw.default, %if.else346, %if.then331
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i32 noundef %val32, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %val32.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 %val32, i32* %val32.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %call = call i32 @flip_opcode(i32 noundef %conv) #14
  %conv1 = trunc i32 %call to i8
  store i8 %conv1, i8* %opcode.addr, align 1
  %1 = load i8, i8* %opcode.addr, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %4 = load i64, i64* %val.addr, align 8
  %5 = load i32, i32* %val32.addr, align 4
  %6 = load i8, i8* %opcode.addr, align 1
  %7 = load i8, i8* %is_jmp32.addr, align 1
  %tobool2 = trunc i8 %7 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %2, %struct.bpf_reg_state* noundef %3, i64 noundef %4, i32 noundef %5, i8 noundef zeroext %6, i1 noundef zeroext %tobool2) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_combine_min_max(%struct.bpf_reg_state* noundef %true_src, %struct.bpf_reg_state* noundef %true_dst, %struct.bpf_reg_state* noundef %false_src, %struct.bpf_reg_state* noundef %false_dst, i8 noundef zeroext %opcode) #0 {
entry:
  %true_src.addr = alloca %struct.bpf_reg_state*, align 8
  %true_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %false_src.addr = alloca %struct.bpf_reg_state*, align 8
  %false_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %opcode.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_src, %struct.bpf_reg_state** %true_src.addr, align 8
  store %struct.bpf_reg_state* %true_dst, %struct.bpf_reg_state** %true_dst.addr, align 8
  store %struct.bpf_reg_state* %false_src, %struct.bpf_reg_state** %false_src.addr, align 8
  store %struct.bpf_reg_state* %false_dst, %struct.bpf_reg_state** %false_dst.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_src.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %1, %struct.bpf_reg_state* noundef %2) #14
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_src.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef %4) #14
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 45, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 61, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 93, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -83, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -67, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 109, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 125, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -51, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -35, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 30, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 46, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 62, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 94, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -82, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -66, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 110, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 126, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -50, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -34, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #14
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #14
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #14
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #14
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #14
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #14
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #14
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #14
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #14
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #14
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #14
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #14
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #14
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #14
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #14
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #14
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #14
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #14
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #14
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check_attach_target(%struct.bpf_verifier_log* noundef %log, %struct.bpf_prog* noundef %prog, %struct.bpf_prog* noundef %tgt_prog, i32 noundef %btf_id, %struct.bpf_attach_target_info* noundef %tgt_info) #0 {
entry:
  %retval = alloca i32, align 4
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %tgt_prog.addr = alloca %struct.bpf_prog*, align 8
  %btf_id.addr = alloca i32, align 4
  %tgt_info.addr = alloca %struct.bpf_attach_target_info*, align 8
  %prog_extension = alloca i8, align 1
  %prefix = alloca [11 x i8], align 1
  %ret = alloca i32, align 4
  %subprog = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.btf_type*, align 8
  %conservative = alloca i8, align 1
  %tname = alloca i8*, align 8
  %btf = alloca %struct.btf*, align 8
  %addr = alloca i64, align 8
  %aux16 = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_prog* %tgt_prog, %struct.bpf_prog** %tgt_prog.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  store %struct.bpf_attach_target_info* %tgt_info, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 2
  %1 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %1, 28
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %prog_extension, align 1
  %2 = bitcast [11 x i8]* %prefix to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 getelementptr inbounds ([11 x i8], [11 x i8]* @__const.bpf_check_attach_target.prefix, i32 0, i32 0), i64 11, i1 false)
  store i32 0, i32* %ret, align 4
  store i32 -1, i32* %subprog, align 4
  store i8 1, i8* %conservative, align 1
  store i64 0, i64* %addr, align 8
  %3 = load i32, i32* %btf_id.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %4, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.5, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool1 = icmp ne %struct.bpf_prog* %5, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 47
  %8 = load %struct.btf*, %struct.btf** %btf2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 10
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %attach_btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 14
  %11 = load %struct.btf*, %struct.btf** %attach_btf, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.btf* [ %8, %cond.true ], [ %11, %cond.false ]
  store %struct.btf* %cond, %struct.btf** %btf, align 8
  %12 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool4 = icmp ne %struct.btf* %12, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %cond.end
  %13 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %13, i8* noundef getelementptr inbounds ([81 x i8], [81 x i8]* @.str.6, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %cond.end
  %14 = load %struct.btf*, %struct.btf** %btf, align 8
  %15 = load i32, i32* %btf_id.addr, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %14, i32 noundef %15) #14
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %16 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %tobool7 = icmp ne %struct.btf_type* %16, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  %17 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %18 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %17, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.7, i64 0, i64 0), i32 noundef %18) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end6
  %19 = load %struct.btf*, %struct.btf** %btf, align 8
  %20 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %20, i32 0, i32 0
  %21 = load i32, i32* %name_off, align 4
  %call10 = call i8* @btf_name_by_offset(%struct.btf* noundef %19, i32 noundef %21) #14
  store i8* %call10, i8** %tname, align 8
  %22 = load i8*, i8** %tname, align 8
  %tobool11 = icmp ne i8* %22, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end9
  %23 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %24 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %23, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.8, i64 0, i64 0), i32 noundef %24) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool14 = icmp ne %struct.bpf_prog* %25, null
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end13
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux17 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %26, i32 0, i32 10
  %27 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux17, align 8
  store %struct.bpf_prog_aux* %27, %struct.bpf_prog_aux** %aux16, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then15
  %28 = load i32, i32* %i, align 4
  %29 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %29, i32 0, i32 52
  %30 = load i32, i32* %func_info_cnt, align 8
  %cmp18 = icmp ult i32 %28, %30
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %31, i32 0, i32 48
  %32 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %32, i64 %idxprom
  %type_id = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx, i32 0, i32 1
  %34 = load i32, i32* %type_id, align 4
  %35 = load i32, i32* %btf_id.addr, align 4
  %cmp19 = icmp eq i32 %34, %35
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %for.body
  %36 = load i32, i32* %i, align 4
  store i32 %36, i32* %subprog, align 4
  br label %for.end

if.end21:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end21
  %37 = load i32, i32* %i, align 4
  %inc = add i32 %37, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then20, %for.cond
  %38 = load i32, i32* %subprog, align 4
  %cmp22 = icmp eq i32 %38, -1
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %for.end
  %39 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %40 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %39, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i64 0, i64 0), i8* noundef %40) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %for.end
  %41 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %41, i32 0, i32 49
  %42 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %43 = load i32, i32* %subprog, align 4
  %idxprom25 = sext i32 %43 to i64
  %arrayidx26 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %42, i64 %idxprom25
  %unreliable = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx26, i32 0, i32 1
  %44 = load i8, i8* %unreliable, align 2
  %tobool27 = trunc i8 %44 to i1
  %frombool28 = zext i1 %tobool27 to i8
  store i8 %frombool28, i8* %conservative, align 1
  %45 = load i8, i8* %prog_extension, align 1
  %tobool29 = trunc i8 %45 to i1
  br i1 %tobool29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %if.end24
  %46 = load i8, i8* %conservative, align 1
  %tobool31 = trunc i8 %46 to i1
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.then30
  %47 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %47, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then30
  %48 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %48, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %tobool34 = icmp ne i16 %bf.clear, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end33
  %49 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %49, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.11, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end33
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end24
  %50 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %50, i32 0, i32 1
  %bf.load38 = load i16, i16* %jited, align 2
  %bf.clear39 = and i16 %bf.load38, 1
  %tobool40 = icmp ne i16 %bf.clear39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end37
  %51 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %51, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.12, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.end37
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type43 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 2
  %53 = load i32, i32* %type43, align 4
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 2
  %55 = load i32, i32* %type44, align 4
  %cmp45 = icmp eq i32 %53, %55
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end42
  %56 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %56, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.13, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.end42
  %57 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type48 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %57, i32 0, i32 2
  %58 = load i32, i32* %type48, align 4
  %cmp49 = icmp eq i32 %58, 26
  br i1 %cmp49, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %if.end47
  %59 = load i8, i8* %prog_extension, align 1
  %tobool50 = trunc i8 %59 to i1
  br i1 %tobool50, label %land.lhs.true51, label %if.end56

land.lhs.true51:                                  ; preds = %land.lhs.true
  %60 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %60, i32 0, i32 3
  %61 = load i32, i32* %expected_attach_type, align 8
  %cmp52 = icmp eq i32 %61, 24
  br i1 %cmp52, label %if.then55, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true51
  %62 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type53 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %62, i32 0, i32 3
  %63 = load i32, i32* %expected_attach_type53, align 8
  %cmp54 = icmp eq i32 %63, 25
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %lor.lhs.false, %land.lhs.true51
  %64 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %64, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end56:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.end47
  br label %if.end60

if.else:                                          ; preds = %if.end13
  %65 = load i8, i8* %prog_extension, align 1
  %tobool57 = trunc i8 %65 to i1
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.else
  %66 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %66, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.15, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end59:                                         ; preds = %if.else
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end56
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %expected_attach_type61 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 3
  %68 = load i32, i32* %expected_attach_type61, align 8
  switch i32 %68, label %sw.default [
    i32 23, label %sw.bb
    i32 28, label %sw.bb82
    i32 26, label %sw.bb98
    i32 27, label %sw.bb98
    i32 24, label %sw.bb98
    i32 25, label %sw.bb98
  ]

sw.bb:                                            ; preds = %if.end60
  %69 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool62 = icmp ne %struct.bpf_prog* %69, null
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %sw.bb
  %70 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %70, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.16, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %sw.bb
  %71 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call65 = call zeroext i1 @btf_type_is_typedef(%struct.btf_type* noundef %71) #14
  br i1 %call65, label %if.end67, label %if.then66

if.then66:                                        ; preds = %if.end64
  %72 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %73 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %72, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.17, i64 0, i64 0), i32 noundef %73) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.end64
  %arraydecay = getelementptr inbounds [11 x i8], [11 x i8]* %prefix, i64 0, i64 0
  %74 = load i8*, i8** %tname, align 8
  %call68 = call i32 @strncmp(i8* noundef %arraydecay, i8* noundef %74, i64 noundef 10) #14
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.end67
  %75 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %76 = load i32, i32* %btf_id.addr, align 4
  %77 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %75, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.18, i64 0, i64 0), i32 noundef %76, i8* noundef %77) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.end67
  %78 = load i8*, i8** %tname, align 8
  %add.ptr = getelementptr i8, i8* %78, i64 10
  store i8* %add.ptr, i8** %tname, align 8
  %79 = load %struct.btf*, %struct.btf** %btf, align 8
  %80 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %81 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %80, i32 0, i32 2
  %type72 = bitcast %union.anon.123* %81 to i32*
  %82 = load i32, i32* %type72, align 4
  %call73 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %79, i32 noundef %82) #14
  store %struct.btf_type* %call73, %struct.btf_type** %t, align 8
  %83 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call74 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %83) #14
  br i1 %call74, label %if.end76, label %if.then75

if.then75:                                        ; preds = %if.end71
  store i32 -22, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %if.end71
  %84 = load %struct.btf*, %struct.btf** %btf, align 8
  %85 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %86 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %85, i32 0, i32 2
  %type77 = bitcast %union.anon.123* %86 to i32*
  %87 = load i32, i32* %type77, align 4
  %call78 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %84, i32 noundef %87) #14
  store %struct.btf_type* %call78, %struct.btf_type** %t, align 8
  %88 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call79 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %88) #14
  br i1 %call79, label %if.end81, label %if.then80

if.then80:                                        ; preds = %if.end76
  store i32 -22, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.end76
  br label %sw.epilog190

sw.bb82:                                          ; preds = %if.end60
  %89 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call83 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %89) #14
  br i1 %call83, label %if.end85, label %if.then84

if.then84:                                        ; preds = %sw.bb82
  %90 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %91 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %90, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.19, i64 0, i64 0), i32 noundef %91) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end85:                                         ; preds = %sw.bb82
  %92 = load %struct.btf*, %struct.btf** %btf, align 8
  %93 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %94 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %93, i32 0, i32 2
  %type86 = bitcast %union.anon.123* %94 to i32*
  %95 = load i32, i32* %type86, align 4
  %call87 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %92, i32 noundef %95) #14
  store %struct.btf_type* %call87, %struct.btf_type** %t, align 8
  %96 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call88 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %96) #14
  br i1 %call88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %if.end85
  store i32 -22, i32* %retval, align 4
  br label %return

if.end90:                                         ; preds = %if.end85
  %97 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %98 = load %struct.btf*, %struct.btf** %btf, align 8
  %99 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %100 = load i8*, i8** %tname, align 8
  %101 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %fmodel = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %101, i32 0, i32 0
  %call91 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %97, %struct.btf* noundef %98, %struct.btf_type* noundef %99, i8* noundef %100, %struct.btf_func_model* noundef %fmodel) #14
  store i32 %call91, i32* %ret, align 4
  %102 = load i32, i32* %ret, align 4
  %tobool92 = icmp ne i32 %102, 0
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end90
  %103 = load i32, i32* %ret, align 4
  store i32 %103, i32* %retval, align 4
  br label %return

if.end94:                                         ; preds = %if.end90
  br label %sw.epilog190

sw.default:                                       ; preds = %if.end60
  %104 = load i8, i8* %prog_extension, align 1
  %tobool95 = trunc i8 %104 to i1
  br i1 %tobool95, label %if.end97, label %if.then96

if.then96:                                        ; preds = %sw.default
  store i32 -22, i32* %retval, align 4
  br label %return

if.end97:                                         ; preds = %sw.default
  br label %sw.bb98

sw.bb98:                                          ; preds = %if.end60, %if.end60, %if.end60, %if.end60, %if.end97
  %105 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call99 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %105) #14
  br i1 %call99, label %if.end101, label %if.then100

if.then100:                                       ; preds = %sw.bb98
  %106 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %107 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %106, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.19, i64 0, i64 0), i32 noundef %107) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end101:                                        ; preds = %sw.bb98
  %108 = load i8, i8* %prog_extension, align 1
  %tobool102 = trunc i8 %108 to i1
  br i1 %tobool102, label %land.lhs.true103, label %if.end107

land.lhs.true103:                                 ; preds = %if.end101
  %109 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %110 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %111 = load %struct.btf*, %struct.btf** %btf, align 8
  %112 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call104 = call i32 @btf_check_type_match(%struct.bpf_verifier_log* noundef %109, %struct.bpf_prog* noundef %110, %struct.btf* noundef %111, %struct.btf_type* noundef %112) #14
  %tobool105 = icmp ne i32 %call104, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %land.lhs.true103
  store i32 -22, i32* %retval, align 4
  br label %return

if.end107:                                        ; preds = %land.lhs.true103, %if.end101
  %113 = load %struct.btf*, %struct.btf** %btf, align 8
  %114 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %115 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %114, i32 0, i32 2
  %type108 = bitcast %union.anon.123* %115 to i32*
  %116 = load i32, i32* %type108, align 4
  %call109 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %113, i32 noundef %116) #14
  store %struct.btf_type* %call109, %struct.btf_type** %t, align 8
  %117 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call110 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %117) #14
  br i1 %call110, label %if.end112, label %if.then111

if.then111:                                       ; preds = %if.end107
  store i32 -22, i32* %retval, align 4
  br label %return

if.end112:                                        ; preds = %if.end107
  %118 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux113 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %118, i32 0, i32 10
  %119 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux113, align 8
  %saved_dst_prog_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %119, i32 0, i32 19
  %120 = load i32, i32* %saved_dst_prog_type, align 8
  %tobool114 = icmp ne i32 %120, 0
  br i1 %tobool114, label %land.lhs.true118, label %lor.lhs.false115

lor.lhs.false115:                                 ; preds = %if.end112
  %121 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux116 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %121, i32 0, i32 10
  %122 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux116, align 8
  %saved_dst_attach_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %122, i32 0, i32 20
  %123 = load i32, i32* %saved_dst_attach_type, align 4
  %tobool117 = icmp ne i32 %123, 0
  br i1 %tobool117, label %land.lhs.true118, label %if.end131

land.lhs.true118:                                 ; preds = %lor.lhs.false115, %if.end112
  %124 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool119 = icmp ne %struct.bpf_prog* %124, null
  br i1 %tobool119, label %lor.lhs.false120, label %if.then130

lor.lhs.false120:                                 ; preds = %land.lhs.true118
  %125 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux121 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %125, i32 0, i32 10
  %126 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux121, align 8
  %saved_dst_prog_type122 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %126, i32 0, i32 19
  %127 = load i32, i32* %saved_dst_prog_type122, align 8
  %128 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type123 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %128, i32 0, i32 2
  %129 = load i32, i32* %type123, align 4
  %cmp124 = icmp ne i32 %127, %129
  br i1 %cmp124, label %if.then130, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %lor.lhs.false120
  %130 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux126 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %130, i32 0, i32 10
  %131 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux126, align 8
  %saved_dst_attach_type127 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %131, i32 0, i32 20
  %132 = load i32, i32* %saved_dst_attach_type127, align 4
  %133 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type128 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %133, i32 0, i32 3
  %134 = load i32, i32* %expected_attach_type128, align 8
  %cmp129 = icmp ne i32 %132, %134
  br i1 %cmp129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %lor.lhs.false125, %lor.lhs.false120, %land.lhs.true118
  store i32 -22, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %lor.lhs.false125, %lor.lhs.false115
  %135 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool132 = icmp ne %struct.bpf_prog* %135, null
  br i1 %tobool132, label %land.lhs.true133, label %if.end136

land.lhs.true133:                                 ; preds = %if.end131
  %136 = load i8, i8* %conservative, align 1
  %tobool134 = trunc i8 %136 to i1
  br i1 %tobool134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %land.lhs.true133
  store %struct.btf_type* null, %struct.btf_type** %t, align 8
  br label %if.end136

if.end136:                                        ; preds = %if.then135, %land.lhs.true133, %if.end131
  %137 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %138 = load %struct.btf*, %struct.btf** %btf, align 8
  %139 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %140 = load i8*, i8** %tname, align 8
  %141 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %fmodel137 = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %141, i32 0, i32 0
  %call138 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %137, %struct.btf* noundef %138, %struct.btf_type* noundef %139, i8* noundef %140, %struct.btf_func_model* noundef %fmodel137) #14
  store i32 %call138, i32* %ret, align 4
  %142 = load i32, i32* %ret, align 4
  %cmp139 = icmp slt i32 %142, 0
  br i1 %cmp139, label %if.then140, label %if.end141

if.then140:                                       ; preds = %if.end136
  %143 = load i32, i32* %ret, align 4
  store i32 %143, i32* %retval, align 4
  br label %return

if.end141:                                        ; preds = %if.end136
  %144 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool142 = icmp ne %struct.bpf_prog* %144, null
  br i1 %tobool142, label %if.then143, label %if.else152

if.then143:                                       ; preds = %if.end141
  %145 = load i32, i32* %subprog, align 4
  %cmp144 = icmp eq i32 %145, 0
  br i1 %cmp144, label %if.then145, label %if.else146

if.then145:                                       ; preds = %if.then143
  %146 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %146, i32 0, i32 9
  %147 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %148 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %147 to i64
  store i64 %148, i64* %addr, align 8
  br label %if.end151

if.else146:                                       ; preds = %if.then143
  %149 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux147 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %149, i32 0, i32 10
  %150 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux147, align 8
  %func = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %150, i32 0, i32 30
  %151 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %152 = load i32, i32* %subprog, align 4
  %idxprom148 = sext i32 %152 to i64
  %arrayidx149 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %151, i64 %idxprom148
  %153 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx149, align 8
  %bpf_func150 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %153, i32 0, i32 9
  %154 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func150, align 8
  %155 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %154 to i64
  store i64 %155, i64* %addr, align 8
  br label %if.end151

if.end151:                                        ; preds = %if.else146, %if.then145
  br label %if.end157

if.else152:                                       ; preds = %if.end141
  %156 = load i8*, i8** %tname, align 8
  %call153 = call i64 @kallsyms_lookup_name(i8* noundef %156) #14
  store i64 %call153, i64* %addr, align 8
  %157 = load i64, i64* %addr, align 8
  %tobool154 = icmp ne i64 %157, 0
  br i1 %tobool154, label %if.end156, label %if.then155

if.then155:                                       ; preds = %if.else152
  %158 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %159 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %158, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.20, i64 0, i64 0), i8* noundef %159) #14
  store i32 -2, i32* %retval, align 4
  br label %return

if.end156:                                        ; preds = %if.else152
  br label %if.end157

if.end157:                                        ; preds = %if.end156, %if.end151
  %160 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux158 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %160, i32 0, i32 10
  %161 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux158, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %161, i32 0, i32 25
  %162 = load i8, i8* %sleepable, align 4
  %tobool159 = trunc i8 %162 to i1
  br i1 %tobool159, label %if.then160, label %if.else177

if.then160:                                       ; preds = %if.end157
  store i32 -22, i32* %ret, align 4
  %163 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type161 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %163, i32 0, i32 2
  %164 = load i32, i32* %type161, align 4
  switch i32 %164, label %sw.default173 [
    i32 26, label %sw.bb162
    i32 29, label %sw.bb169
  ]

sw.bb162:                                         ; preds = %if.then160
  %165 = load i32, i32* %btf_id.addr, align 4
  %call163 = call i32 @check_non_sleepable_error_inject(i32 noundef %165) #14
  %tobool164 = icmp ne i32 %call163, 0
  br i1 %tobool164, label %if.end168, label %land.lhs.true165

land.lhs.true165:                                 ; preds = %sw.bb162
  %166 = load i64, i64* %addr, align 8
  %call166 = call zeroext i1 @within_error_injection_list(i64 noundef %166) #14
  br i1 %call166, label %if.then167, label %if.end168

if.then167:                                       ; preds = %land.lhs.true165
  store i32 0, i32* %ret, align 4
  br label %if.end168

if.end168:                                        ; preds = %if.then167, %land.lhs.true165, %sw.bb162
  br label %sw.epilog

sw.bb169:                                         ; preds = %if.then160
  %167 = load i32, i32* %btf_id.addr, align 4
  %call170 = call zeroext i1 @bpf_lsm_is_sleepable_hook(i32 noundef %167) #14
  br i1 %call170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %sw.bb169
  store i32 0, i32* %ret, align 4
  br label %if.end172

if.end172:                                        ; preds = %if.then171, %sw.bb169
  br label %sw.epilog

sw.default173:                                    ; preds = %if.then160
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default173, %if.end172, %if.end168
  %168 = load i32, i32* %ret, align 4
  %tobool174 = icmp ne i32 %168, 0
  br i1 %tobool174, label %if.then175, label %if.end176

if.then175:                                       ; preds = %sw.epilog
  %169 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %170 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %169, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.21, i64 0, i64 0), i8* noundef %170) #14
  %171 = load i32, i32* %ret, align 4
  store i32 %171, i32* %retval, align 4
  br label %return

if.end176:                                        ; preds = %sw.epilog
  br label %if.end189

if.else177:                                       ; preds = %if.end157
  %172 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %expected_attach_type178 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %172, i32 0, i32 3
  %173 = load i32, i32* %expected_attach_type178, align 8
  %cmp179 = icmp eq i32 %173, 26
  br i1 %cmp179, label %if.then180, label %if.end188

if.then180:                                       ; preds = %if.else177
  %174 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool181 = icmp ne %struct.bpf_prog* %174, null
  br i1 %tobool181, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.then180
  %175 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %175, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.22, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end183:                                        ; preds = %if.then180
  %176 = load i64, i64* %addr, align 8
  %177 = load i8*, i8** %tname, align 8
  %call184 = call i32 @check_attach_modify_return(i64 noundef %176, i8* noundef %177) #14
  store i32 %call184, i32* %ret, align 4
  %178 = load i32, i32* %ret, align 4
  %tobool185 = icmp ne i32 %178, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.end183
  %179 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %180 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %179, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.23, i64 0, i64 0), i8* noundef %180) #14
  %181 = load i32, i32* %ret, align 4
  store i32 %181, i32* %retval, align 4
  br label %return

if.end187:                                        ; preds = %if.end183
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %if.else177
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %if.end176
  br label %sw.epilog190

sw.epilog190:                                     ; preds = %if.end189, %if.end94, %if.end81
  %182 = load i64, i64* %addr, align 8
  %183 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_addr = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %183, i32 0, i32 1
  store i64 %182, i64* %tgt_addr, align 8
  %184 = load i8*, i8** %tname, align 8
  %185 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_name = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %185, i32 0, i32 2
  store i8* %184, i8** %tgt_name, align 8
  %186 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %187 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_type = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %187, i32 0, i32 3
  store %struct.btf_type* %186, %struct.btf_type** %tgt_type, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog190, %if.then186, %if.then182, %if.then175, %if.then155, %if.then140, %if.then130, %if.then111, %if.then106, %if.then100, %if.then96, %if.then93, %if.then89, %if.then84, %if.then80, %if.then75, %if.then70, %if.then66, %if.then63, %if.then58, %if.then55, %if.then46, %if.then41, %if.then35, %if.then32, %if.then23, %if.then12, %if.then8, %if.then5, %if.then
  %188 = load i32, i32* %retval, align 4
  ret i32 %188
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_by_id(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @btf_name_by_offset(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_typedef(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 8
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @strncmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 13
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 12
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, %struct.btf_type* noundef, i8* noundef, %struct.btf_func_model* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_type_match(%struct.bpf_verifier_log* noundef, %struct.bpf_prog* noundef, %struct.btf* noundef, %struct.btf_type* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @kallsyms_lookup_name(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_non_sleepable_error_inject(i32 noundef %btf_id) #0 {
entry:
  %btf_id.addr = alloca i32, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load i32, i32* %btf_id.addr, align 4
  %call = call zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef @btf_non_sleepable_error_inject, i32 noundef %0) #14
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @within_error_injection_list(i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_lsm_is_sleepable_hook(i32 noundef %btf_id) #0 {
entry:
  %btf_id.addr = alloca i32, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  ret i1 false
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_attach_modify_return(i64 noundef %addr, i8* noundef %func_name) #0 {
entry:
  %retval = alloca i32, align 4
  %addr.addr = alloca i64, align 8
  %func_name.addr = alloca i8*, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i8* %func_name, i8** %func_name.addr, align 8
  %0 = load i64, i64* %addr.addr, align 8
  %call = call zeroext i1 @within_error_injection_list(i64 noundef %0) #14
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8*, i8** %func_name.addr, align 8
  %call1 = call i32 @strncmp(i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.130, i64 0, i64 0), i8* noundef %1, i64 noundef 9) #14
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local %struct.btf* @bpf_get_btf_vmlinux() #0 {
entry:
  %0 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %0, null
  br i1 %tobool, label %if.end3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  br i1 false, label %if.then, label %if.end3

if.then:                                          ; preds = %land.lhs.true
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #14
  %1 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool1 = icmp ne %struct.btf* %1, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %call = call %struct.btf* @btf_parse_vmlinux() #14
  store %struct.btf* %call, %struct.btf** @btf_vmlinux, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #14
  br label %if.end3

if.end3:                                          ; preds = %if.end, %land.lhs.true, %entry
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  ret %struct.btf* %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_lock(%struct.mutex* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_parse_vmlinux() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_unlock(%struct.mutex* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check(%struct.bpf_prog** noundef %prog, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %prog.addr = alloca %struct.bpf_prog**, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %start_time = alloca i64, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %log = alloca %struct.bpf_verifier_log*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %ret = alloca i32, align 4
  %is_priv = alloca i8, align 1
  %tmp = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_prog** %prog, %struct.bpf_prog*** %prog.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %call = call i64 @ktime_get_ns() #14
  store i64 %call, i64* %start_time, align 8
  store i32 -22, i32* %ret, align 4
  %call1 = call i8* @kzalloc(i64 noundef 7488, i32 noundef 3264) #14
  %3 = bitcast i8* %call1 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %3, %struct.bpf_verifier_env** %env, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %tobool = icmp ne %struct.bpf_verifier_env* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 26
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %6 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %6, align 8
  %len3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len3, align 4
  store i32 %8, i32* %len, align 4
  %9 = load i32, i32* %len, align 4
  %conv = sext i32 %9 to i64
  %call4 = call i64 @array_size(i64 noundef 56, i64 noundef %conv) #14
  %call5 = call i8* @vzalloc(i64 noundef %call4) #14
  %10 = bitcast i8* %call5 to %struct.bpf_insn_aux_data*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 24
  store %struct.bpf_insn_aux_data* %10, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store i32 -12, i32* %ret, align 4
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 24
  %13 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data6, align 8
  %tobool7 = icmp ne %struct.bpf_insn_aux_data* %13, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %err_free_env

if.end9:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %14 = load i32, i32* %i, align 4
  %15 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %14, %15
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32, i32* %i, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 24
  %18 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data11, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %18, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  store i32 %16, i32* %orig_idx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, i32* %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %21, align 8
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %23, i32 0, i32 2
  store %struct.bpf_prog* %22, %struct.bpf_prog** %prog12, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 2
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 2
  %26 = load i32, i32* %type, align 4
  %idxprom14 = zext i32 %26 to i64
  %arrayidx15 = getelementptr [32 x %struct.bpf_verifier_ops*], [32 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom14
  %27 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx15, align 8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 3
  store %struct.bpf_verifier_ops* %27, %struct.bpf_verifier_ops** %ops, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %fd_array = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 41
  %30 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %31 = bitcast %union.bpf_attr* %30 to %struct.anon.130*
  %fd_array16 = getelementptr inbounds %struct.anon.130, %struct.anon.130* %31, i32 0, i32 22
  %32 = load i64, i64* %fd_array16, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call17 = call { i8*, i8 } @make_bpfptr(i64 noundef %32, i1 noundef zeroext %bf.cast) #14
  %33 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %34 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %33, i32 0, i32 0
  %35 = extractvalue { i8*, i8 } %call17, 0
  store i8* %35, i8** %34, align 8
  %36 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %33, i32 0, i32 1
  %37 = extractvalue { i8*, i8 } %call17, 1
  store i8 %37, i8* %36, align 8
  %38 = bitcast %struct.sockptr_t* %fd_array to i8*
  %39 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %38, i8* align 8 %39, i64 16, i1 false)
  %call18 = call zeroext i1 @bpf_capable() #14
  %frombool = zext i1 %call18 to i8
  store i8 %frombool, i8* %is_priv, align 1
  %call19 = call %struct.btf* @bpf_get_btf_vmlinux() #14
  %40 = load i8, i8* %is_priv, align 1
  %tobool20 = trunc i8 %40 to i1
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %for.end
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #14
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %for.end
  %41 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %42 = bitcast %union.bpf_attr* %41 to %struct.anon.130*
  %log_level = getelementptr inbounds %struct.anon.130, %struct.anon.130* %42, i32 0, i32 4
  %43 = load i32, i32* %log_level, align 8
  %tobool23 = icmp ne i32 %43, 0
  br i1 %tobool23, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end22
  %44 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %45 = bitcast %union.bpf_attr* %44 to %struct.anon.130*
  %log_buf = getelementptr inbounds %struct.anon.130, %struct.anon.130* %45, i32 0, i32 6
  %46 = load i64, i64* %log_buf, align 8
  %tobool24 = icmp ne i64 %46, 0
  br i1 %tobool24, label %if.then27, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %lor.lhs.false
  %47 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %48 = bitcast %union.bpf_attr* %47 to %struct.anon.130*
  %log_size = getelementptr inbounds %struct.anon.130, %struct.anon.130* %48, i32 0, i32 5
  %49 = load i32, i32* %log_size, align 4
  %tobool26 = icmp ne i32 %49, 0
  br i1 %tobool26, label %if.then27, label %if.end49

if.then27:                                        ; preds = %lor.lhs.false25, %lor.lhs.false, %if.end22
  %50 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %51 = bitcast %union.bpf_attr* %50 to %struct.anon.130*
  %log_level28 = getelementptr inbounds %struct.anon.130, %struct.anon.130* %51, i32 0, i32 4
  %52 = load i32, i32* %log_level28, align 8
  %53 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %53, i32 0, i32 0
  store i32 %52, i32* %level, align 8
  %54 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %55 = bitcast %union.bpf_attr* %54 to %struct.anon.130*
  %log_buf29 = getelementptr inbounds %struct.anon.130, %struct.anon.130* %55, i32 0, i32 6
  %56 = load i64, i64* %log_buf29, align 8
  %57 = inttoptr i64 %56 to i8*
  %58 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %58, i32 0, i32 2
  store i8* %57, i8** %ubuf, align 8
  %59 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %60 = bitcast %union.bpf_attr* %59 to %struct.anon.130*
  %log_size30 = getelementptr inbounds %struct.anon.130, %struct.anon.130* %60, i32 0, i32 5
  %61 = load i32, i32* %log_size30, align 4
  %62 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %62, i32 0, i32 4
  store i32 %61, i32* %len_total, align 4
  store i32 -22, i32* %ret, align 4
  %63 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total31 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %63, i32 0, i32 4
  %64 = load i32, i32* %len_total31, align 4
  %cmp32 = icmp ult i32 %64, 128
  br i1 %cmp32, label %if.then47, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %if.then27
  %65 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total35 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %65, i32 0, i32 4
  %66 = load i32, i32* %len_total35, align 4
  %cmp36 = icmp ugt i32 %66, 1073741823
  br i1 %cmp36, label %if.then47, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %lor.lhs.false34
  %67 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level39 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %67, i32 0, i32 0
  %68 = load i32, i32* %level39, align 8
  %tobool40 = icmp ne i32 %68, 0
  br i1 %tobool40, label %lor.lhs.false41, label %if.then47

lor.lhs.false41:                                  ; preds = %lor.lhs.false38
  %69 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf42 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %69, i32 0, i32 2
  %70 = load i8*, i8** %ubuf42, align 8
  %tobool43 = icmp ne i8* %70, null
  br i1 %tobool43, label %lor.lhs.false44, label %if.then47

lor.lhs.false44:                                  ; preds = %lor.lhs.false41
  %71 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level45 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %71, i32 0, i32 0
  %72 = load i32, i32* %level45, align 8
  %and = and i32 %72, -8
  %tobool46 = icmp ne i32 %and, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %lor.lhs.false44, %lor.lhs.false41, %lor.lhs.false38, %lor.lhs.false34, %if.then27
  br label %err_unlock

if.end48:                                         ; preds = %lor.lhs.false44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %lor.lhs.false25
  %73 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %74 = bitcast %struct.btf* %73 to i8*
  %call50 = call zeroext i1 @IS_ERR(i8* noundef %74) #14
  br i1 %call50, label %if.then51, label %if.end54

if.then51:                                        ; preds = %if.end49
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.24, i64 0, i64 0)) #14
  %77 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %78 = bitcast %struct.btf* %77 to i8*
  %call52 = call i64 @PTR_ERR(i8* noundef %78) #14
  %conv53 = trunc i64 %call52 to i32
  store i32 %conv53, i32* %ret, align 4
  br label %skip_full_check

if.end54:                                         ; preds = %if.end49
  %79 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %80 = bitcast %union.bpf_attr* %79 to %struct.anon.130*
  %prog_flags = getelementptr inbounds %struct.anon.130, %struct.anon.130* %80, i32 0, i32 8
  %81 = load i32, i32* %prog_flags, align 4
  %and55 = and i32 %81, 1
  %tobool56 = icmp ne i32 %and55, 0
  %lnot = xor i1 %tobool56, true
  %lnot57 = xor i1 %lnot, true
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 6
  %frombool58 = zext i1 %lnot57 to i8
  store i8 %frombool58, i8* %strict_alignment, align 4
  %83 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %84 = bitcast %union.bpf_attr* %83 to %struct.anon.130*
  %prog_flags59 = getelementptr inbounds %struct.anon.130, %struct.anon.130* %84, i32 0, i32 8
  %85 = load i32, i32* %prog_flags59, align 4
  %and60 = and i32 %85, 2
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then62, label %if.end64

if.then62:                                        ; preds = %if.end54
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment63 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %86, i32 0, i32 6
  store i8 0, i8* %strict_alignment63, align 4
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %if.end54
  %call65 = call zeroext i1 @bpf_allow_ptr_leaks() #14
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %87, i32 0, i32 17
  %frombool66 = zext i1 %call65 to i8
  store i8 %frombool66, i8* %allow_ptr_leaks, align 1
  %call67 = call zeroext i1 @bpf_allow_uninit_stack() #14
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_uninit_stack = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %88, i32 0, i32 18
  %frombool68 = zext i1 %call67 to i8
  store i8 %frombool68, i8* %allow_uninit_stack, align 2
  %call69 = call zeroext i1 @bpf_allow_ptr_to_map_access() #14
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_to_map_access = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %89, i32 0, i32 19
  %frombool70 = zext i1 %call69 to i8
  store i8 %frombool70, i8* %allow_ptr_to_map_access, align 1
  %call71 = call zeroext i1 @bpf_bypass_spec_v1() #14
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %90, i32 0, i32 21
  %frombool72 = zext i1 %call71 to i8
  store i8 %frombool72, i8* %bypass_spec_v1, align 1
  %call73 = call zeroext i1 @bpf_bypass_spec_v4() #14
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bypass_spec_v4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 22
  %frombool74 = zext i1 %call73 to i8
  store i8 %frombool74, i8* %bypass_spec_v4, align 2
  %call75 = call zeroext i1 @bpf_capable() #14
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %92, i32 0, i32 20
  %frombool76 = zext i1 %call75 to i8
  store i8 %frombool76, i8* %bpf_capable, align 8
  %93 = load i8, i8* %is_priv, align 1
  %tobool77 = trunc i8 %93 to i1
  br i1 %tobool77, label %if.then78, label %if.end83

if.then78:                                        ; preds = %if.end64
  %94 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %95 = bitcast %union.bpf_attr* %94 to %struct.anon.130*
  %prog_flags79 = getelementptr inbounds %struct.anon.130, %struct.anon.130* %95, i32 0, i32 8
  %96 = load i32, i32* %prog_flags79, align 4
  %and80 = and i32 %96, 8
  %tobool81 = icmp ne i32 %and80, 0
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %97, i32 0, i32 7
  %frombool82 = zext i1 %tobool81 to i8
  store i8 %frombool82, i8* %test_state_freq, align 1
  br label %if.end83

if.end83:                                         ; preds = %if.then78, %if.end64
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call84 = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %98) #14
  %conv85 = zext i32 %call84 to i64
  %call86 = call i8* @kvcalloc(i64 noundef %conv85, i64 noundef 8, i32 noundef 1051840) #14
  %99 = bitcast i8* %call86 to %struct.bpf_verifier_state_list**
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %100, i32 0, i32 9
  store %struct.bpf_verifier_state_list** %99, %struct.bpf_verifier_state_list*** %explored_states, align 8
  store i32 -12, i32* %ret, align 4
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 9
  %102 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states87, align 8
  %tobool88 = icmp ne %struct.bpf_verifier_state_list** %102, null
  br i1 %tobool88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %if.end83
  br label %skip_full_check

if.end90:                                         ; preds = %if.end83
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call91 = call i32 @add_subprog_and_kfunc(%struct.bpf_verifier_env* noundef %103) #14
  store i32 %call91, i32* %ret, align 4
  %104 = load i32, i32* %ret, align 4
  %cmp92 = icmp slt i32 %104, 0
  br i1 %cmp92, label %if.then94, label %if.end95

if.then94:                                        ; preds = %if.end90
  br label %skip_full_check

if.end95:                                         ; preds = %if.end90
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call96 = call i32 @check_subprogs(%struct.bpf_verifier_env* noundef %105) #14
  store i32 %call96, i32* %ret, align 4
  %106 = load i32, i32* %ret, align 4
  %cmp97 = icmp slt i32 %106, 0
  br i1 %cmp97, label %if.then99, label %if.end100

if.then99:                                        ; preds = %if.end95
  br label %skip_full_check

if.end100:                                        ; preds = %if.end95
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %108 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %109 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %110 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %109, i32 0, i32 0
  %111 = load i8*, i8** %110, align 8
  %112 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %109, i32 0, i32 1
  %113 = load i8, i8* %112, align 8
  %call101 = call i32 @check_btf_info(%struct.bpf_verifier_env* noundef %107, %union.bpf_attr* noundef %108, i8* %111, i8 %113) #14
  store i32 %call101, i32* %ret, align 4
  %114 = load i32, i32* %ret, align 4
  %cmp102 = icmp slt i32 %114, 0
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end100
  br label %skip_full_check

if.end105:                                        ; preds = %if.end100
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call106 = call i32 @check_attach_btf_id(%struct.bpf_verifier_env* noundef %115) #14
  store i32 %call106, i32* %ret, align 4
  %116 = load i32, i32* %ret, align 4
  %tobool107 = icmp ne i32 %116, 0
  br i1 %tobool107, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end105
  br label %skip_full_check

if.end109:                                        ; preds = %if.end105
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call110 = call i32 @resolve_pseudo_ldimm64(%struct.bpf_verifier_env* noundef %117) #14
  store i32 %call110, i32* %ret, align 4
  %118 = load i32, i32* %ret, align 4
  %cmp111 = icmp slt i32 %118, 0
  br i1 %cmp111, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.end109
  br label %skip_full_check

if.end114:                                        ; preds = %if.end109
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog115 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %119, i32 0, i32 2
  %120 = load %struct.bpf_prog*, %struct.bpf_prog** %prog115, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %120, i32 0, i32 10
  %121 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call116 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %121) #14
  br i1 %call116, label %if.then117, label %if.end123

if.then117:                                       ; preds = %if.end114
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog118 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %122, i32 0, i32 2
  %123 = load %struct.bpf_prog*, %struct.bpf_prog** %prog118, align 8
  %call119 = call i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef %123) #14
  store i32 %call119, i32* %ret, align 4
  %124 = load i32, i32* %ret, align 4
  %tobool120 = icmp ne i32 %124, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.then117
  br label %skip_full_check

if.end122:                                        ; preds = %if.then117
  br label %if.end123

if.end123:                                        ; preds = %if.end122, %if.end114
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call124 = call i32 @check_cfg(%struct.bpf_verifier_env* noundef %125) #14
  store i32 %call124, i32* %ret, align 4
  %126 = load i32, i32* %ret, align 4
  %cmp125 = icmp slt i32 %126, 0
  br i1 %cmp125, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.end123
  br label %skip_full_check

if.end128:                                        ; preds = %if.end123
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call129 = call i32 @do_check_subprogs(%struct.bpf_verifier_env* noundef %127) #14
  store i32 %call129, i32* %ret, align 4
  %128 = load i32, i32* %ret, align 4
  %tobool130 = icmp ne i32 %128, 0
  br i1 %tobool130, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end128
  br label %cond.end

cond.false:                                       ; preds = %if.end128
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call131 = call i32 @do_check_main(%struct.bpf_verifier_env* noundef %129) #14
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %128, %cond.true ], [ %call131, %cond.false ]
  store i32 %cond, i32* %ret, align 4
  %130 = load i32, i32* %ret, align 4
  %cmp132 = icmp eq i32 %130, 0
  br i1 %cmp132, label %land.lhs.true, label %if.end140

land.lhs.true:                                    ; preds = %cond.end
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog134 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %131, i32 0, i32 2
  %132 = load %struct.bpf_prog*, %struct.bpf_prog** %prog134, align 8
  %aux135 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %132, i32 0, i32 10
  %133 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux135, align 8
  %call136 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %133) #14
  br i1 %call136, label %if.then138, label %if.end140

if.then138:                                       ; preds = %land.lhs.true
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call139 = call i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef %134) #14
  store i32 %call139, i32* %ret, align 4
  br label %if.end140

if.end140:                                        ; preds = %if.then138, %land.lhs.true, %cond.end
  br label %skip_full_check

skip_full_check:                                  ; preds = %if.end140, %if.then127, %if.then121, %if.then113, %if.then108, %if.then104, %if.then99, %if.then94, %if.then89, %if.then51
  %135 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states141 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %135, i32 0, i32 9
  %136 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states141, align 8
  %137 = bitcast %struct.bpf_verifier_state_list** %136 to i8*
  call void @kvfree(i8* noundef %137) #14
  %138 = load i32, i32* %ret, align 4
  %cmp142 = icmp eq i32 %138, 0
  br i1 %cmp142, label %if.then144, label %if.end146

if.then144:                                       ; preds = %skip_full_check
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call145 = call i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %139) #14
  store i32 %call145, i32* %ret, align 4
  br label %if.end146

if.end146:                                        ; preds = %if.then144, %skip_full_check
  %140 = load i8, i8* %is_priv, align 1
  %tobool147 = trunc i8 %140 to i1
  br i1 %tobool147, label %if.then148, label %if.else

if.then148:                                       ; preds = %if.end146
  %141 = load i32, i32* %ret, align 4
  %cmp149 = icmp eq i32 %141, 0
  br i1 %cmp149, label %if.then151, label %if.end152

if.then151:                                       ; preds = %if.then148
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %142) #14
  br label %if.end152

if.end152:                                        ; preds = %if.then151, %if.then148
  %143 = load i32, i32* %ret, align 4
  %cmp153 = icmp eq i32 %143, 0
  br i1 %cmp153, label %if.then155, label %if.end157

if.then155:                                       ; preds = %if.end152
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call156 = call i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %144) #14
  store i32 %call156, i32* %ret, align 4
  br label %if.end157

if.end157:                                        ; preds = %if.then155, %if.end152
  %145 = load i32, i32* %ret, align 4
  %cmp158 = icmp eq i32 %145, 0
  br i1 %cmp158, label %if.then160, label %if.end162

if.then160:                                       ; preds = %if.end157
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call161 = call i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %146) #14
  store i32 %call161, i32* %ret, align 4
  br label %if.end162

if.end162:                                        ; preds = %if.then160, %if.end157
  br label %if.end167

if.else:                                          ; preds = %if.end146
  %147 = load i32, i32* %ret, align 4
  %cmp163 = icmp eq i32 %147, 0
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.else
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %148) #14
  br label %if.end166

if.end166:                                        ; preds = %if.then165, %if.else
  br label %if.end167

if.end167:                                        ; preds = %if.end166, %if.end162
  %149 = load i32, i32* %ret, align 4
  %cmp168 = icmp eq i32 %149, 0
  br i1 %cmp168, label %if.then170, label %if.end172

if.then170:                                       ; preds = %if.end167
  %150 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call171 = call i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %150) #14
  store i32 %call171, i32* %ret, align 4
  br label %if.end172

if.end172:                                        ; preds = %if.then170, %if.end167
  %151 = load i32, i32* %ret, align 4
  %cmp173 = icmp eq i32 %151, 0
  br i1 %cmp173, label %if.then175, label %if.end177

if.then175:                                       ; preds = %if.end172
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call176 = call i32 @do_misc_fixups(%struct.bpf_verifier_env* noundef %152) #14
  store i32 %call176, i32* %ret, align 4
  br label %if.end177

if.end177:                                        ; preds = %if.then175, %if.end172
  %153 = load i32, i32* %ret, align 4
  %cmp178 = icmp eq i32 %153, 0
  br i1 %cmp178, label %land.lhs.true180, label %if.end198

land.lhs.true180:                                 ; preds = %if.end177
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog181 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 2
  %155 = load %struct.bpf_prog*, %struct.bpf_prog** %prog181, align 8
  %aux182 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %155, i32 0, i32 10
  %156 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux182, align 8
  %call183 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %156) #14
  br i1 %call183, label %if.end198, label %if.then184

if.then184:                                       ; preds = %land.lhs.true180
  %157 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %158 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %call185 = call i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %157, %union.bpf_attr* noundef %158) #14
  store i32 %call185, i32* %ret, align 4
  %call186 = call zeroext i1 @bpf_jit_needs_zext() #14
  br i1 %call186, label %cond.true188, label %cond.false191

cond.true188:                                     ; preds = %if.then184
  %159 = load i32, i32* %ret, align 4
  %tobool189 = icmp ne i32 %159, 0
  %lnot190 = xor i1 %tobool189, true
  %lnot.ext = zext i1 %lnot190 to i32
  br label %cond.end192

cond.false191:                                    ; preds = %if.then184
  br label %cond.end192

cond.end192:                                      ; preds = %cond.false191, %cond.true188
  %cond193 = phi i32 [ %lnot.ext, %cond.true188 ], [ 0, %cond.false191 ]
  %tobool194 = icmp ne i32 %cond193, 0
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog195 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %160, i32 0, i32 2
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %prog195, align 8
  %aux196 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 10
  %162 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux196, align 8
  %verifier_zext = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %162, i32 0, i32 21
  %frombool197 = zext i1 %tobool194 to i8
  store i8 %frombool197, i8* %verifier_zext, align 8
  br label %if.end198

if.end198:                                        ; preds = %cond.end192, %land.lhs.true180, %if.end177
  %163 = load i32, i32* %ret, align 4
  %cmp199 = icmp eq i32 %163, 0
  br i1 %cmp199, label %if.then201, label %if.end203

if.then201:                                       ; preds = %if.end198
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call202 = call i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %164) #14
  store i32 %call202, i32* %ret, align 4
  br label %if.end203

if.end203:                                        ; preds = %if.then201, %if.end198
  %call204 = call i64 @ktime_get_ns() #14
  %165 = load i64, i64* %start_time, align 8
  %sub = sub i64 %call204, %165
  %166 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %166, i32 0, i32 36
  store i64 %sub, i64* %verification_time, align 8
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @print_verification_stats(%struct.bpf_verifier_env* noundef %167) #14
  %168 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level205 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %168, i32 0, i32 0
  %169 = load i32, i32* %level205, align 8
  %tobool206 = icmp ne i32 %169, 0
  br i1 %tobool206, label %land.lhs.true207, label %if.end211

land.lhs.true207:                                 ; preds = %if.end203
  %170 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %call208 = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %170) #14
  br i1 %call208, label %if.then210, label %if.end211

if.then210:                                       ; preds = %land.lhs.true207
  store i32 -28, i32* %ret, align 4
  br label %if.end211

if.end211:                                        ; preds = %if.then210, %land.lhs.true207, %if.end203
  %171 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level212 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %171, i32 0, i32 0
  %172 = load i32, i32* %level212, align 8
  %tobool213 = icmp ne i32 %172, 0
  br i1 %tobool213, label %land.lhs.true214, label %if.end218

land.lhs.true214:                                 ; preds = %if.end211
  %173 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf215 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %173, i32 0, i32 2
  %174 = load i8*, i8** %ubuf215, align 8
  %tobool216 = icmp ne i8* %174, null
  br i1 %tobool216, label %if.end218, label %if.then217

if.then217:                                       ; preds = %land.lhs.true214
  store i32 -14, i32* %ret, align 4
  br label %err_release_maps

if.end218:                                        ; preds = %land.lhs.true214, %if.end211
  %175 = load i32, i32* %ret, align 4
  %tobool219 = icmp ne i32 %175, 0
  br i1 %tobool219, label %if.then220, label %if.end221

if.then220:                                       ; preds = %if.end218
  br label %err_release_maps

if.end221:                                        ; preds = %if.end218
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %176, i32 0, i32 13
  %177 = load i32, i32* %used_map_cnt, align 8
  %tobool222 = icmp ne i32 %177, 0
  br i1 %tobool222, label %if.then223, label %if.end245

if.then223:                                       ; preds = %if.end221
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt224 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %178, i32 0, i32 13
  %179 = load i32, i32* %used_map_cnt224, align 8
  %conv225 = zext i32 %179 to i64
  %call226 = call i8* @kmalloc_array(i64 noundef %conv225, i64 noundef 8, i32 noundef 3264) #14
  %180 = bitcast i8* %call226 to %struct.bpf_map**
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog227 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %181, i32 0, i32 2
  %182 = load %struct.bpf_prog*, %struct.bpf_prog** %prog227, align 8
  %aux228 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %182, i32 0, i32 10
  %183 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux228, align 8
  %used_maps = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %183, i32 0, i32 37
  store %struct.bpf_map** %180, %struct.bpf_map*** %used_maps, align 8
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog229 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %184, i32 0, i32 2
  %185 = load %struct.bpf_prog*, %struct.bpf_prog** %prog229, align 8
  %aux230 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %185, i32 0, i32 10
  %186 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux230, align 8
  %used_maps231 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %186, i32 0, i32 37
  %187 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps231, align 8
  %tobool232 = icmp ne %struct.bpf_map** %187, null
  br i1 %tobool232, label %if.end234, label %if.then233

if.then233:                                       ; preds = %if.then223
  store i32 -12, i32* %ret, align 4
  br label %err_release_maps

if.end234:                                        ; preds = %if.then223
  %188 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog235 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %188, i32 0, i32 2
  %189 = load %struct.bpf_prog*, %struct.bpf_prog** %prog235, align 8
  %aux236 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %189, i32 0, i32 10
  %190 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux236, align 8
  %used_maps237 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %190, i32 0, i32 37
  %191 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps237, align 8
  %192 = bitcast %struct.bpf_map** %191 to i8*
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_maps238 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %193, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps238, i64 0, i64 0
  %194 = bitcast %struct.bpf_map** %arraydecay to i8*
  %195 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt239 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %195, i32 0, i32 13
  %196 = load i32, i32* %used_map_cnt239, align 8
  %conv240 = zext i32 %196 to i64
  %mul = mul i64 8, %conv240
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %192, i8* align 8 %194, i64 %mul, i1 false)
  %197 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt241 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %197, i32 0, i32 13
  %198 = load i32, i32* %used_map_cnt241, align 8
  %199 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog242 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %199, i32 0, i32 2
  %200 = load %struct.bpf_prog*, %struct.bpf_prog** %prog242, align 8
  %aux243 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %200, i32 0, i32 10
  %201 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux243, align 8
  %used_map_cnt244 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %201, i32 0, i32 1
  store i32 %198, i32* %used_map_cnt244, align 8
  br label %if.end245

if.end245:                                        ; preds = %if.end234, %if.end221
  %202 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %202, i32 0, i32 14
  %203 = load i32, i32* %used_btf_cnt, align 4
  %tobool246 = icmp ne i32 %203, 0
  br i1 %tobool246, label %if.then247, label %if.end271

if.then247:                                       ; preds = %if.end245
  %204 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt248 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %204, i32 0, i32 14
  %205 = load i32, i32* %used_btf_cnt248, align 4
  %conv249 = zext i32 %205 to i64
  %call250 = call i8* @kmalloc_array(i64 noundef %conv249, i64 noundef 16, i32 noundef 3264) #14
  %206 = bitcast i8* %call250 to %struct.btf_mod_pair*
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog251 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %207, i32 0, i32 2
  %208 = load %struct.bpf_prog*, %struct.bpf_prog** %prog251, align 8
  %aux252 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %208, i32 0, i32 10
  %209 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux252, align 8
  %used_btfs = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %209, i32 0, i32 39
  store %struct.btf_mod_pair* %206, %struct.btf_mod_pair** %used_btfs, align 8
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog253 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %210, i32 0, i32 2
  %211 = load %struct.bpf_prog*, %struct.bpf_prog** %prog253, align 8
  %aux254 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %211, i32 0, i32 10
  %212 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux254, align 8
  %used_btfs255 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %212, i32 0, i32 39
  %213 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %used_btfs255, align 8
  %tobool256 = icmp ne %struct.btf_mod_pair* %213, null
  br i1 %tobool256, label %if.end258, label %if.then257

if.then257:                                       ; preds = %if.then247
  store i32 -12, i32* %ret, align 4
  br label %err_release_maps

if.end258:                                        ; preds = %if.then247
  %214 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog259 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %214, i32 0, i32 2
  %215 = load %struct.bpf_prog*, %struct.bpf_prog** %prog259, align 8
  %aux260 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %215, i32 0, i32 10
  %216 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux260, align 8
  %used_btfs261 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %216, i32 0, i32 39
  %217 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %used_btfs261, align 8
  %218 = bitcast %struct.btf_mod_pair* %217 to i8*
  %219 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btfs262 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %219, i32 0, i32 12
  %arraydecay263 = getelementptr inbounds [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs262, i64 0, i64 0
  %220 = bitcast %struct.btf_mod_pair* %arraydecay263 to i8*
  %221 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt264 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %221, i32 0, i32 14
  %222 = load i32, i32* %used_btf_cnt264, align 4
  %conv265 = zext i32 %222 to i64
  %mul266 = mul i64 16, %conv265
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %218, i8* align 8 %220, i64 %mul266, i1 false)
  %223 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt267 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %223, i32 0, i32 14
  %224 = load i32, i32* %used_btf_cnt267, align 4
  %225 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog268 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %225, i32 0, i32 2
  %226 = load %struct.bpf_prog*, %struct.bpf_prog** %prog268, align 8
  %aux269 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %226, i32 0, i32 10
  %227 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux269, align 8
  %used_btf_cnt270 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %227, i32 0, i32 2
  store i32 %224, i32* %used_btf_cnt270, align 4
  br label %if.end271

if.end271:                                        ; preds = %if.end258, %if.end245
  %228 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt272 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %228, i32 0, i32 13
  %229 = load i32, i32* %used_map_cnt272, align 8
  %tobool273 = icmp ne i32 %229, 0
  br i1 %tobool273, label %if.then277, label %lor.lhs.false274

lor.lhs.false274:                                 ; preds = %if.end271
  %230 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt275 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %230, i32 0, i32 14
  %231 = load i32, i32* %used_btf_cnt275, align 4
  %tobool276 = icmp ne i32 %231, 0
  br i1 %tobool276, label %if.then277, label %if.end278

if.then277:                                       ; preds = %lor.lhs.false274, %if.end271
  %232 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %232) #14
  br label %if.end278

if.end278:                                        ; preds = %if.then277, %lor.lhs.false274
  %233 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @adjust_btf_func(%struct.bpf_verifier_env* noundef %233) #14
  br label %err_release_maps

err_release_maps:                                 ; preds = %if.end278, %if.then257, %if.then233, %if.then220, %if.then217
  %234 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog279 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %234, i32 0, i32 2
  %235 = load %struct.bpf_prog*, %struct.bpf_prog** %prog279, align 8
  %aux280 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %235, i32 0, i32 10
  %236 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux280, align 8
  %used_maps281 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %236, i32 0, i32 37
  %237 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps281, align 8
  %tobool282 = icmp ne %struct.bpf_map** %237, null
  br i1 %tobool282, label %if.end284, label %if.then283

if.then283:                                       ; preds = %err_release_maps
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @release_maps(%struct.bpf_verifier_env* noundef %238) #14
  br label %if.end284

if.end284:                                        ; preds = %if.then283, %err_release_maps
  %239 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog285 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %239, i32 0, i32 2
  %240 = load %struct.bpf_prog*, %struct.bpf_prog** %prog285, align 8
  %aux286 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %240, i32 0, i32 10
  %241 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux286, align 8
  %used_btfs287 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %241, i32 0, i32 39
  %242 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %used_btfs287, align 8
  %tobool288 = icmp ne %struct.btf_mod_pair* %242, null
  br i1 %tobool288, label %if.end290, label %if.then289

if.then289:                                       ; preds = %if.end284
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @release_btfs(%struct.bpf_verifier_env* noundef %243) #14
  br label %if.end290

if.end290:                                        ; preds = %if.then289, %if.end284
  %244 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog291 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %244, i32 0, i32 2
  %245 = load %struct.bpf_prog*, %struct.bpf_prog** %prog291, align 8
  %type292 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %245, i32 0, i32 2
  %246 = load i32, i32* %type292, align 4
  %cmp293 = icmp eq i32 %246, 28
  br i1 %cmp293, label %if.then295, label %if.end297

if.then295:                                       ; preds = %if.end290
  %247 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog296 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %247, i32 0, i32 2
  %248 = load %struct.bpf_prog*, %struct.bpf_prog** %prog296, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %248, i32 0, i32 3
  store i32 0, i32* %expected_attach_type, align 8
  br label %if.end297

if.end297:                                        ; preds = %if.then295, %if.end290
  %249 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog298 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %249, i32 0, i32 2
  %250 = load %struct.bpf_prog*, %struct.bpf_prog** %prog298, align 8
  %251 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  store %struct.bpf_prog* %250, %struct.bpf_prog** %251, align 8
  br label %err_unlock

err_unlock:                                       ; preds = %if.end297, %if.then47
  %252 = load i8, i8* %is_priv, align 1
  %tobool299 = trunc i8 %252 to i1
  br i1 %tobool299, label %if.end301, label %if.then300

if.then300:                                       ; preds = %err_unlock
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #14
  br label %if.end301

if.end301:                                        ; preds = %if.then300, %err_unlock
  %253 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data302 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %253, i32 0, i32 24
  %254 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data302, align 8
  %255 = bitcast %struct.bpf_insn_aux_data* %254 to i8*
  call void @vfree(i8* noundef %255) #14
  br label %err_free_env

err_free_env:                                     ; preds = %if.end301, %if.then8
  %256 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %257 = bitcast %struct.bpf_verifier_env* %256 to i8*
  call void @kfree(i8* noundef %257) #14
  %258 = load i32, i32* %ret, align 4
  store i32 %258, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free_env, %if.then
  %259 = load i32, i32* %retval, align 4
  ret i32 %259
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_get_ns() #0 {
entry:
  %call = call i64 @ktime_get() #14
  %call1 = call i64 @ktime_to_ns(i64 noundef %call) #14
  ret i64 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kzalloc(i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %retval.i16 = alloca i32, align 4
  %size.addr.i17 = alloca i64, align 8
  %retval.i11 = alloca i32, align 4
  %flags.addr.i12 = alloca i32, align 4
  %retval.i4 = alloca i32, align 4
  %size.addr.i5 = alloca i64, align 8
  %size_is_constant.addr.i = alloca i8, align 1
  %size.addr.i1 = alloca i64, align 8
  %flags.addr.i2 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 256
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64, i64* %size.addr.i, align 8
  %3 = call i1 @llvm.is.constant.i64(i64 %2) #13
  br i1 %3, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %entry
  %4 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %4, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %5 = load i64, i64* %size.addr.i, align 8
  %6 = load i32, i32* %flags.addr.i, align 4
  store i64 %5, i64* %size.addr.i1, align 8
  store i32 %6, i32* %flags.addr.i2, align 4
  %7 = load i64, i64* %size.addr.i1, align 8
  store i64 %7, i64* %size.addr.i17, align 8
  %8 = load i64, i64* %size.addr.i17, align 8
  %9 = call i1 @llvm.is.constant.i64(i64 %8) #13
  br i1 %9, label %if.then.i19, label %if.end14.i23

if.then.i19:                                      ; preds = %if.then1.i
  %10 = load i64, i64* %size.addr.i17, align 8
  %tobool.i18 = icmp ne i64 %10, 0
  br i1 %tobool.i18, label %if.end.i22, label %if.then1.i20

if.then1.i20:                                     ; preds = %if.then.i19
  store i32 52, i32* %retval.i16, align 4
  br label %get_order.exit

if.end.i22:                                       ; preds = %if.then.i19
  %11 = load i64, i64* %size.addr.i17, align 8
  %cmp.i21 = icmp ult i64 %11, 4096
  br i1 %cmp.i21, label %if.then2.i, label %if.end3.i

if.then2.i:                                       ; preds = %if.end.i22
  store i32 0, i32* %retval.i16, align 4
  br label %get_order.exit

if.end3.i:                                        ; preds = %if.end.i22
  %12 = load i64, i64* %size.addr.i17, align 8
  %sub.i = sub i64 %12, 1
  %13 = call i1 @llvm.is.constant.i64(i64 %sub.i) #13
  br i1 %13, label %cond.true.i, label %cond.false9.i

cond.true.i:                                      ; preds = %if.end3.i
  %14 = load i64, i64* %size.addr.i17, align 8
  %sub4.i = sub i64 %14, 1
  %cmp5.i = icmp ult i64 %sub4.i, 2
  br i1 %cmp5.i, label %cond.true6.i, label %cond.false.i

cond.true6.i:                                     ; preds = %cond.true.i
  br label %cond.end.i

cond.false.i:                                     ; preds = %cond.true.i
  %15 = load i64, i64* %size.addr.i17, align 8
  %sub7.i = sub i64 %15, 1
  %16 = call i64 @llvm.ctlz.i64(i64 %sub7.i, i1 true) #13
  %cast.i = trunc i64 %16 to i32
  %sub8.i = sub i32 63, %cast.i
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true6.i
  %cond.i = phi i32 [ 0, %cond.true6.i ], [ %sub8.i, %cond.false.i ]
  br label %cond.end11.i

cond.false9.i:                                    ; preds = %if.end3.i
  %17 = load i64, i64* %size.addr.i17, align 8
  %sub10.i = sub i64 %17, 1
  %call.i = call i32 @__ilog2_u64(i64 noundef %sub10.i) #17
  br label %cond.end11.i

cond.end11.i:                                     ; preds = %cond.false9.i, %cond.end.i
  %cond12.i = phi i32 [ %cond.i, %cond.end.i ], [ %call.i, %cond.false9.i ]
  %sub13.i = sub i32 %cond12.i, 12
  %add.i = add i32 %sub13.i, 1
  store i32 %add.i, i32* %retval.i16, align 4
  br label %get_order.exit

if.end14.i23:                                     ; preds = %if.then1.i
  %18 = load i64, i64* %size.addr.i17, align 8
  %dec.i = add i64 %18, -1
  store i64 %dec.i, i64* %size.addr.i17, align 8
  %19 = load i64, i64* %size.addr.i17, align 8
  %shr.i = lshr i64 %19, 12
  store i64 %shr.i, i64* %size.addr.i17, align 8
  %20 = load i64, i64* %size.addr.i17, align 8
  store i64 %20, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %21 = load i32, i32* %bitpos.i, align 4
  %22 = load i64, i64* %x.addr.i, align 8
  %23 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %22, i32 %21) #12, !srcloc !14
  store i32 %23, i32* %bitpos.i, align 4
  %24 = load i32, i32* %bitpos.i, align 4
  %add.i24 = add i32 %24, 1
  store i32 %add.i24, i32* %retval.i16, align 4
  br label %get_order.exit

get_order.exit:                                   ; preds = %if.then1.i20, %if.then2.i, %cond.end11.i, %if.end14.i23
  %25 = load i32, i32* %retval.i16, align 4
  store i32 %25, i32* %order.i, align 4
  %26 = load i64, i64* %size.addr.i1, align 8
  %27 = load i32, i32* %flags.addr.i2, align 4
  %28 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %26, i32 noundef %27, i32 noundef %28) #16
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %29 = load i64, i64* %size.addr.i, align 8
  store i64 %29, i64* %size.addr.i5, align 8
  store i8 1, i8* %size_is_constant.addr.i, align 1
  %30 = load i64, i64* %size.addr.i5, align 8
  %tobool.i6 = icmp ne i64 %30, 0
  br i1 %tobool.i6, label %if.end.i9, label %if.then.i7

if.then.i7:                                       ; preds = %if.end.i
  store i32 0, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end.i9:                                        ; preds = %if.end.i
  %31 = load i64, i64* %size.addr.i5, align 8
  %cmp.i8 = icmp ule i64 %31, 8
  br i1 %cmp.i8, label %if.then1.i10, label %if.end2.i

if.then1.i10:                                     ; preds = %if.end.i9
  store i32 3, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i9
  %32 = load i64, i64* %size.addr.i5, align 8
  %cmp3.i = icmp ugt i64 %32, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %33 = load i64, i64* %size.addr.i5, align 8
  %cmp4.i = icmp ule i64 %33, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %34 = load i64, i64* %size.addr.i5, align 8
  %cmp7.i = icmp ugt i64 %34, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %35 = load i64, i64* %size.addr.i5, align 8
  %cmp9.i = icmp ule i64 %35, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %36 = load i64, i64* %size.addr.i5, align 8
  %cmp12.i = icmp ule i64 %36, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %37 = load i64, i64* %size.addr.i5, align 8
  %cmp15.i = icmp ule i64 %37, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %38 = load i64, i64* %size.addr.i5, align 8
  %cmp18.i = icmp ule i64 %38, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %39 = load i64, i64* %size.addr.i5, align 8
  %cmp21.i = icmp ule i64 %39, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %40 = load i64, i64* %size.addr.i5, align 8
  %cmp24.i = icmp ule i64 %40, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %41 = load i64, i64* %size.addr.i5, align 8
  %cmp27.i = icmp ule i64 %41, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %42 = load i64, i64* %size.addr.i5, align 8
  %cmp30.i = icmp ule i64 %42, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %43 = load i64, i64* %size.addr.i5, align 8
  %cmp33.i = icmp ule i64 %43, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %44 = load i64, i64* %size.addr.i5, align 8
  %cmp36.i = icmp ule i64 %44, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %45 = load i64, i64* %size.addr.i5, align 8
  %cmp39.i = icmp ule i64 %45, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %46 = load i64, i64* %size.addr.i5, align 8
  %cmp42.i = icmp ule i64 %46, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %47 = load i64, i64* %size.addr.i5, align 8
  %cmp45.i = icmp ule i64 %47, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %48 = load i64, i64* %size.addr.i5, align 8
  %cmp48.i = icmp ule i64 %48, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %49 = load i64, i64* %size.addr.i5, align 8
  %cmp51.i = icmp ule i64 %49, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %50 = load i64, i64* %size.addr.i5, align 8
  %cmp54.i = icmp ule i64 %50, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %51 = load i64, i64* %size.addr.i5, align 8
  %cmp57.i = icmp ule i64 %51, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %52 = load i64, i64* %size.addr.i5, align 8
  %cmp60.i = icmp ule i64 %52, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %53 = load i64, i64* %size.addr.i5, align 8
  %cmp63.i = icmp ule i64 %53, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %54 = load i64, i64* %size.addr.i5, align 8
  %cmp66.i = icmp ule i64 %54, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %55 = load i64, i64* %size.addr.i5, align 8
  %cmp69.i = icmp ule i64 %55, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %56 = load i64, i64* %size.addr.i5, align 8
  %cmp72.i = icmp ule i64 %56, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %57 = load i64, i64* %size.addr.i5, align 8
  %cmp75.i = icmp ule i64 %57, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %58 = load i64, i64* %size.addr.i5, align 8
  %cmp78.i = icmp ule i64 %58, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %59 = load i8, i8* %size_is_constant.addr.i, align 1
  %tobool81.i = trunc i8 %59 to i1
  br i1 %tobool81.i, label %if.then82.i, label %if.else.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 -1, i32* %retval.i4, align 4
  br label %__kmalloc_index.exit

if.else.i:                                        ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.131, i64 0, i64 0), i32 420, i32 0, i64 12) #13, !srcloc !15
  call void asm sideeffect "87:\0A\09.pushsection .discard.unreachable\0A\09.long 87b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !16
  unreachable

__kmalloc_index.exit:                             ; preds = %if.then.i7, %if.then1.i10, %if.then5.i, %if.then10.i, %if.then13.i, %if.then16.i, %if.then19.i, %if.then22.i, %if.then25.i, %if.then28.i, %if.then31.i, %if.then34.i, %if.then37.i, %if.then40.i, %if.then43.i, %if.then46.i, %if.then49.i, %if.then52.i, %if.then55.i, %if.then58.i, %if.then61.i, %if.then64.i, %if.then67.i, %if.then70.i, %if.then73.i, %if.then76.i, %if.then79.i, %if.then82.i
  %60 = load i32, i32* %retval.i4, align 4
  store i32 %60, i32* %index.i, align 4
  %61 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %61, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %__kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %__kmalloc_index.exit
  %62 = load i32, i32* %flags.addr.i, align 4
  store i32 %62, i32* %flags.addr.i12, align 4
  %63 = load i32, i32* %flags.addr.i12, align 4
  %and.i = and i32 %63, 17
  %cmp.i13 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i13, true
  %lnot.ext.i = zext i1 %cmp.i13 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i13, label %if.then.i14, label %if.end.i15

if.then.i14:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

if.end.i15:                                       ; preds = %if.end4.i
  %64 = load i32, i32* %flags.addr.i12, align 4
  %and2.i = and i32 %64, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i15
  store i32 2, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

if.end5.i:                                        ; preds = %if.end.i15
  store i32 1, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.then.i14, %if.then4.i, %if.end5.i
  %65 = load i32, i32* %retval.i11, align 4
  %idxprom.i = zext i32 %65 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %66 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %66 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %67 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %68 = load i32, i32* %flags.addr.i, align 4
  %69 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %67, i32 noundef %68, i64 noundef %69) #16
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %entry
  %70 = load i64, i64* %size.addr.i, align 8
  %71 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %70, i32 noundef %71) #16
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %get_order.exit, %if.then3.i, %kmalloc_type.exit, %if.end9.i
  %72 = load i8*, i8** %retval.i, align 8
  ret i8* %72
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @vzalloc(i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @array_size(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i64, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %b.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %bytes, align 8
  store i64 %10, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, i64* %retval, align 8
  ret i64 %11
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i8*, i8 } @make_bpfptr(i64 noundef %addr, i1 noundef zeroext %is_kernel) #0 {
entry:
  %retval = alloca %struct.sockptr_t, align 8
  %addr.addr = alloca i64, align 8
  %is_kernel.addr = alloca i8, align 1
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp1 = alloca i8*, align 8
  store i64 %addr, i64* %addr.addr, align 8
  %frombool = zext i1 %is_kernel to i8
  store i8 %frombool, i8* %is_kernel.addr, align 1
  %0 = load i8, i8* %is_kernel.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %addr.addr, align 8
  %2 = inttoptr i64 %1 to i8*
  %call = call { i8*, i8 } @KERNEL_BPFPTR(i8* noundef %2) #14
  %3 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = extractvalue { i8*, i8 } %call, 0
  store i8* %5, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = extractvalue { i8*, i8 } %call, 1
  store i8 %7, i8* %6, align 8
  br label %return

if.else:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %8 = load i32, i32* %tmp, align 4
  %9 = load i64, i64* %addr.addr, align 8
  %10 = inttoptr i64 %9 to i8*
  store i8* %10, i8** %tmp1, align 8
  %11 = load i8*, i8** %tmp1, align 8
  %call2 = call { i8*, i8 } @USER_BPFPTR(i8* noundef %11) #14
  %12 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %13 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %12, i32 0, i32 0
  %14 = extractvalue { i8*, i8 } %call2, 0
  store i8* %14, i8** %13, align 8
  %15 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %12, i32 0, i32 1
  %16 = extractvalue { i8*, i8 } %call2, 1
  store i8 %16, i8* %15, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %17 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %18 = load { i8*, i8 }, { i8*, i8 }* %17, align 8
  ret { i8*, i8 } %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_capable() #0 {
entry:
  %call = call zeroext i1 @capable(i32 noundef 39) #14
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call zeroext i1 @capable(i32 noundef 21) #14
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @IS_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %2 = inttoptr i64 %1 to i8*
  %3 = ptrtoint i8* %2 to i64
  %cmp = icmp uge i64 %3, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @PTR_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  ret i64 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_ptr_leaks() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #14
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_uninit_stack() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #14
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_ptr_to_map_access() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #14
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_bypass_spec_v1() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #14
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_bypass_spec_v4() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #14
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call i8* @kvmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #14
  ret i8* %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @state_htab_size(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_subprog_and_kfunc(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 13
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %6, i32 noundef 0) #14
  store i32 %call, i32* %ret, align 4
  %7 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load i32, i32* %ret, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call3 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %11) #14
  br i1 %call3, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call4 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %12) #14
  br i1 %call4, label %if.end8, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call6 = call zeroext i1 @bpf_pseudo_kfunc_call(%struct.bpf_insn* noundef %13) #14
  br i1 %call6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %land.lhs.true5
  br label %for.inc

if.end8:                                          ; preds = %land.lhs.true5, %land.lhs.true, %for.body
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 20
  %15 = load i8, i8* %bpf_capable, align 8
  %tobool9 = trunc i8 %15 to i1
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([89 x i8], [89 x i8]* @.str.132, i64 0, i64 0)) #14
  store i32 -1, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call12 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %18) #14
  br i1 %call12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end11
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 3
  %22 = load i32, i32* %imm, align 4
  %add = add i32 %20, %22
  %add14 = add i32 %add, 1
  %call15 = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %19, i32 noundef %add14) #14
  store i32 %call15, i32* %ret, align 4
  %23 = load i32, i32* %ret, align 4
  %cmp16 = icmp sge i32 %23, 0
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.then13
  %24 = load i32, i32* %ret, align 4
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %25, i64 1
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 3
  store i32 %24, i32* %imm18, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then13
  br label %if.end30

if.else:                                          ; preds = %if.end11
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call20 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %26) #14
  br i1 %call20, label %if.then21, label %if.else26

if.then21:                                        ; preds = %if.else
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %i, align 4
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 3
  %30 = load i32, i32* %imm22, align 4
  %add23 = add i32 %28, %30
  %add24 = add i32 %add23, 1
  %call25 = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %27, i32 noundef %add24) #14
  store i32 %call25, i32* %ret, align 4
  br label %if.end29

if.else26:                                        ; preds = %if.else
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm27 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 3
  %33 = load i32, i32* %imm27, align 4
  %call28 = call i32 @add_kfunc_call(%struct.bpf_verifier_env* noundef %31, i32 noundef %33) #14
  store i32 %call28, i32* %ret, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.else26, %if.then21
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end19
  %34 = load i32, i32* %ret, align 4
  %cmp31 = icmp slt i32 %34, 0
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end30
  %35 = load i32, i32* %ret, align 4
  store i32 %35, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end30
  br label %for.inc

for.inc:                                          ; preds = %if.end33, %if.then7
  %36 = load i32, i32* %i, align 4
  %inc = add i32 %36, 1
  store i32 %inc, i32* %i, align 4
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %37, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %38 = load i32, i32* %insn_cnt, align 4
  %39 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %40, i32 0, i32 31
  %41 = load i32, i32* %subprog_cnt, align 4
  %idxprom = zext i32 %41 to i64
  %arrayidx34 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %39, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx34, i32 0, i32 0
  store i32 %38, i32* %start, align 4
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %43 = load i32, i32* %level, align 8
  %and = and i32 %43, 2
  %tobool35 = icmp ne i32 %and, 0
  br i1 %tobool35, label %if.then36, label %if.end47

if.then36:                                        ; preds = %for.end
  store i32 0, i32* %i, align 4
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc44, %if.then36
  %44 = load i32, i32* %i, align 4
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt38 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 31
  %46 = load i32, i32* %subprog_cnt38, align 4
  %cmp39 = icmp ult i32 %44, %46
  br i1 %cmp39, label %for.body40, label %for.end46

for.body40:                                       ; preds = %for.cond37
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  %49 = load i32, i32* %i, align 4
  %50 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom41 = sext i32 %51 to i64
  %arrayidx42 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %50, i64 %idxprom41
  %start43 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx42, i32 0, i32 0
  %52 = load i32, i32* %start43, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.133, i64 0, i64 0), i32 noundef %49, i32 noundef %52) #14
  br label %for.inc44

for.inc44:                                        ; preds = %for.body40
  %53 = load i32, i32* %i, align 4
  %inc45 = add i32 %53, 1
  store i32 %inc45, i32* %i, align 4
  br label %for.cond37

for.end46:                                        ; preds = %for.cond37
  br label %if.end47

if.end47:                                         ; preds = %for.end46, %for.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end47, %if.then32, %if.then10, %if.then
  %54 = load i32, i32* %retval, align 4
  ret i32 %54
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %off = alloca i32, align 4
  %cur_subprog = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %code = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %cur_subprog, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 13
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  %6 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %7 = load i32, i32* %cur_subprog, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %6, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %8 = load i32, i32* %start, align 4
  store i32 %8, i32* %subprog_start, align 4
  %9 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %10 = load i32, i32* %cur_subprog, align 4
  %add = add i32 %10, 1
  %idxprom3 = sext i32 %add to i64
  %arrayidx4 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %9, i64 %idxprom3
  %start5 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx4, i32 0, i32 0
  %11 = load i32, i32* %start5, align 4
  store i32 %11, i32* %subprog_end, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %12, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %14, i64 %idxprom6
  %code8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx7, i32 0, i32 0
  %16 = load i8, i8* %code8, align 4
  store i8 %16, i8* %code, align 1
  %17 = load i8, i8* %code, align 1
  %conv = zext i8 %17 to i32
  %cmp9 = icmp eq i32 %conv, 133
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %19 to i64
  %arrayidx12 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %18, i64 %idxprom11
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx12, i32 0, i32 3
  %20 = load i32, i32* %imm, align 4
  %cmp13 = icmp eq i32 %20, 12
  br i1 %cmp13, label %land.lhs.true15, label %if.end

land.lhs.true15:                                  ; preds = %land.lhs.true
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %22 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %22 to i64
  %arrayidx17 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %21, i64 %idxprom16
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx17, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv18 = zext i8 %bf.lshr to i32
  %cmp19 = icmp ne i32 %conv18, 1
  br i1 %cmp19, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true15
  %23 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %24 = load i32, i32* %cur_subprog, align 4
  %idxprom21 = sext i32 %24 to i64
  %arrayidx22 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %23, i64 %idxprom21
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx22, i32 0, i32 3
  store i8 1, i8* %has_tail_call, align 2
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true15, %land.lhs.true, %for.body
  %25 = load i8, i8* %code, align 1
  %conv23 = zext i8 %25 to i32
  %and = and i32 %conv23, 7
  %cmp24 = icmp eq i32 %and, 0
  br i1 %cmp24, label %land.lhs.true26, label %if.end38

land.lhs.true26:                                  ; preds = %if.end
  %26 = load i8, i8* %code, align 1
  %conv27 = zext i8 %26 to i32
  %and28 = and i32 %conv27, 224
  %cmp29 = icmp eq i32 %and28, 32
  br i1 %cmp29, label %if.then35, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true26
  %27 = load i8, i8* %code, align 1
  %conv31 = zext i8 %27 to i32
  %and32 = and i32 %conv31, 224
  %cmp33 = icmp eq i32 %and32, 64
  br i1 %cmp33, label %if.then35, label %if.end38

if.then35:                                        ; preds = %lor.lhs.false, %land.lhs.true26
  %28 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %29 = load i32, i32* %cur_subprog, align 4
  %idxprom36 = sext i32 %29 to i64
  %arrayidx37 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %28, i64 %idxprom36
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx37, i32 0, i32 5
  store i8 1, i8* %has_ld_abs, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then35, %lor.lhs.false, %if.end
  %30 = load i8, i8* %code, align 1
  %conv39 = zext i8 %30 to i32
  %and40 = and i32 %conv39, 7
  %cmp41 = icmp ne i32 %and40, 5
  br i1 %cmp41, label %land.lhs.true43, label %if.end49

land.lhs.true43:                                  ; preds = %if.end38
  %31 = load i8, i8* %code, align 1
  %conv44 = zext i8 %31 to i32
  %and45 = and i32 %conv44, 7
  %cmp46 = icmp ne i32 %and45, 6
  br i1 %cmp46, label %if.then48, label %if.end49

if.then48:                                        ; preds = %land.lhs.true43
  br label %next

if.end49:                                         ; preds = %land.lhs.true43, %if.end38
  %32 = load i8, i8* %code, align 1
  %conv50 = zext i8 %32 to i32
  %and51 = and i32 %conv50, 240
  %cmp52 = icmp eq i32 %and51, 144
  br i1 %cmp52, label %if.then59, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %if.end49
  %33 = load i8, i8* %code, align 1
  %conv55 = zext i8 %33 to i32
  %and56 = and i32 %conv55, 240
  %cmp57 = icmp eq i32 %and56, 128
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %lor.lhs.false54, %if.end49
  br label %next

if.end60:                                         ; preds = %lor.lhs.false54
  %34 = load i32, i32* %i, align 4
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom61 = sext i32 %36 to i64
  %arrayidx62 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %35, i64 %idxprom61
  %off63 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx62, i32 0, i32 2
  %37 = load i16, i16* %off63, align 2
  %conv64 = sext i16 %37 to i32
  %add65 = add i32 %34, %conv64
  %add66 = add i32 %add65, 1
  store i32 %add66, i32* %off, align 4
  %38 = load i32, i32* %off, align 4
  %39 = load i32, i32* %subprog_start, align 4
  %cmp67 = icmp slt i32 %38, %39
  br i1 %cmp67, label %if.then72, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %if.end60
  %40 = load i32, i32* %off, align 4
  %41 = load i32, i32* %subprog_end, align 4
  %cmp70 = icmp sge i32 %40, %41
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %lor.lhs.false69, %if.end60
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* %off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.144, i64 0, i64 0), i32 noundef %44, i32 noundef %45) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %lor.lhs.false69
  br label %next

next:                                             ; preds = %if.end73, %if.then59, %if.then48
  %46 = load i32, i32* %i, align 4
  %47 = load i32, i32* %subprog_end, align 4
  %sub = sub i32 %47, 1
  %cmp74 = icmp eq i32 %46, %sub
  br i1 %cmp74, label %if.then76, label %if.end94

if.then76:                                        ; preds = %next
  %48 = load i8, i8* %code, align 1
  %conv77 = zext i8 %48 to i32
  %cmp78 = icmp ne i32 %conv77, 149
  br i1 %cmp78, label %land.lhs.true80, label %if.end85

land.lhs.true80:                                  ; preds = %if.then76
  %49 = load i8, i8* %code, align 1
  %conv81 = zext i8 %49 to i32
  %cmp82 = icmp ne i32 %conv81, 5
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %land.lhs.true80
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.145, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end85:                                         ; preds = %land.lhs.true80, %if.then76
  %52 = load i32, i32* %subprog_end, align 4
  store i32 %52, i32* %subprog_start, align 4
  %53 = load i32, i32* %cur_subprog, align 4
  %inc = add i32 %53, 1
  store i32 %inc, i32* %cur_subprog, align 4
  %54 = load i32, i32* %cur_subprog, align 4
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 31
  %56 = load i32, i32* %subprog_cnt, align 4
  %cmp86 = icmp ult i32 %54, %56
  br i1 %cmp86, label %if.then88, label %if.end93

if.then88:                                        ; preds = %if.end85
  %57 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %58 = load i32, i32* %cur_subprog, align 4
  %add89 = add i32 %58, 1
  %idxprom90 = sext i32 %add89 to i64
  %arrayidx91 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %57, i64 %idxprom90
  %start92 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx91, i32 0, i32 0
  %59 = load i32, i32* %start92, align 4
  store i32 %59, i32* %subprog_end, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then88, %if.end85
  br label %if.end94

if.end94:                                         ; preds = %if.end93, %next
  br label %for.inc

for.inc:                                          ; preds = %if.end94
  %60 = load i32, i32* %i, align 4
  %inc95 = add i32 %60, 1
  store i32 %inc95, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then84, %if.then72
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_info(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %btf = alloca %struct.btf*, align 8
  %err = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.130*
  %func_info_cnt = getelementptr inbounds %struct.anon.130, %struct.anon.130* %4, i32 0, i32 15
  %5 = load i32, i32* %func_info_cnt, align 8
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %6 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %7 = bitcast %union.bpf_attr* %6 to %struct.anon.130*
  %line_info_cnt = getelementptr inbounds %struct.anon.130, %struct.anon.130* %7, i32 0, i32 18
  %8 = load i32, i32* %line_info_cnt, align 8
  %tobool1 = icmp ne i32 %8, 0
  br i1 %tobool1, label %if.end4, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %9) #14
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %entry
  %10 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %11 = bitcast %union.bpf_attr* %10 to %struct.anon.130*
  %prog_btf_fd = getelementptr inbounds %struct.anon.130, %struct.anon.130* %11, i32 0, i32 12
  %12 = load i32, i32* %prog_btf_fd, align 8
  %call5 = call %struct.btf* @btf_get_by_fd(i32 noundef %12) #14
  store %struct.btf* %call5, %struct.btf** %btf, align 8
  %13 = load %struct.btf*, %struct.btf** %btf, align 8
  %14 = bitcast %struct.btf* %13 to i8*
  %call6 = call zeroext i1 @IS_ERR(i8* noundef %14) #14
  br i1 %call6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = bitcast %struct.btf* %15 to i8*
  %call8 = call i64 @PTR_ERR(i8* noundef %16) #14
  %conv = trunc i64 %call8 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  %17 = load %struct.btf*, %struct.btf** %btf, align 8
  %call10 = call zeroext i1 @btf_is_kernel(%struct.btf* noundef %17) #14
  br i1 %call10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %18 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %18) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %19 = load %struct.btf*, %struct.btf** %btf, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 10
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 47
  store %struct.btf* %19, %struct.btf** %btf13, align 8
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %25 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %26 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %25, i32 0, i32 0
  %27 = load i8*, i8** %26, align 8
  %28 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %25, i32 0, i32 1
  %29 = load i8, i8* %28, align 8
  %call14 = call i32 @check_btf_func(%struct.bpf_verifier_env* noundef %23, %union.bpf_attr* noundef %24, i8* %27, i8 %29) #14
  store i32 %call14, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool15 = icmp ne i32 %30, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end12
  %31 = load i32, i32* %err, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end12
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %34 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %35 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %34, i32 0, i32 0
  %36 = load i8*, i8** %35, align 8
  %37 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %34, i32 0, i32 1
  %38 = load i8, i8* %37, align 8
  %call18 = call i32 @check_btf_line(%struct.bpf_verifier_env* noundef %32, %union.bpf_attr* noundef %33, i8* %36, i8 %38) #14
  store i32 %call18, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool19 = icmp ne i32 %39, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then16, %if.then11, %if.then7, %if.end, %if.then3
  %41 = load i32, i32* %retval, align 4
  ret i32 %41
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_attach_btf_id(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %tgt_prog = alloca %struct.bpf_prog*, align 8
  %tgt_info = alloca %struct.bpf_attach_target_info, align 8
  %btf_id = alloca i32, align 4
  %tr = alloca %struct.bpf_trampoline*, align 8
  %ret = alloca i32, align 4
  %key = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %dst_prog = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 17
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog, align 8
  store %struct.bpf_prog* %4, %struct.bpf_prog** %tgt_prog, align 8
  %5 = bitcast %struct.bpf_attach_target_info* %tgt_info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %5, i8 0, i64 40, i1 false)
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux2, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 10
  %8 = load i32, i32* %attach_btf_id, align 4
  store i32 %8, i32* %btf_id, align 4
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 2
  %10 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %10, 31
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %11, i32 0, i32 10
  %12 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %12, i32 0, i32 25
  %13 = load i8, i8* %sleepable, align 4
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.163, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %entry
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux6 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 10
  %17 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux6, align 8
  %sleepable7 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %17, i32 0, i32 25
  %18 = load i8, i8* %sleepable7, align 4
  %tobool8 = trunc i8 %18 to i1
  br i1 %tobool8, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end5
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type9 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 2
  %20 = load i32, i32* %type9, align 4
  %cmp10 = icmp ne i32 %20, 26
  br i1 %cmp10, label %land.lhs.true11, label %if.end15

land.lhs.true11:                                  ; preds = %land.lhs.true
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type12 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 2
  %22 = load i32, i32* %type12, align 4
  %cmp13 = icmp ne i32 %22, 29
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true11
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.164, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true11, %land.lhs.true, %if.end5
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type16 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 2
  %26 = load i32, i32* %type16, align 4
  %cmp17 = icmp eq i32 %26, 27
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_struct_ops_btf_id(%struct.bpf_verifier_env* noundef %27) #14
  store i32 %call, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end15
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type20 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 2
  %29 = load i32, i32* %type20, align 4
  %cmp21 = icmp ne i32 %29, 26
  br i1 %cmp21, label %land.lhs.true22, label %if.end29

land.lhs.true22:                                  ; preds = %if.end19
  %30 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type23 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %30, i32 0, i32 2
  %31 = load i32, i32* %type23, align 4
  %cmp24 = icmp ne i32 %31, 29
  br i1 %cmp24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %land.lhs.true22
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %32, i32 0, i32 2
  %33 = load i32, i32* %type26, align 4
  %cmp27 = icmp ne i32 %33, 28
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true25
  store i32 0, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %land.lhs.true25, %land.lhs.true22, %if.end19
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 26
  %35 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %37 = load i32, i32* %btf_id, align 4
  %call30 = call i32 @bpf_check_attach_target(%struct.bpf_verifier_log* noundef %log, %struct.bpf_prog* noundef %35, %struct.bpf_prog* noundef %36, i32 noundef %37, %struct.bpf_attach_target_info* noundef %tgt_info) #14
  store i32 %call30, i32* %ret, align 4
  %38 = load i32, i32* %ret, align 4
  %tobool31 = icmp ne i32 %38, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  %39 = load i32, i32* %ret, align 4
  store i32 %39, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end29
  %40 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %tobool34 = icmp ne %struct.bpf_prog* %40, null
  br i1 %tobool34, label %land.lhs.true35, label %if.end41

land.lhs.true35:                                  ; preds = %if.end33
  %41 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type36 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %41, i32 0, i32 2
  %42 = load i32, i32* %type36, align 4
  %cmp37 = icmp eq i32 %42, 28
  br i1 %cmp37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %land.lhs.true35
  %43 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %type39 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %43, i32 0, i32 2
  %44 = load i32, i32* %type39, align 4
  %idxprom = zext i32 %44 to i64
  %arrayidx = getelementptr [32 x %struct.bpf_verifier_ops*], [32 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom
  %45 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx, align 8
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %46, i32 0, i32 3
  store %struct.bpf_verifier_ops* %45, %struct.bpf_verifier_ops** %ops, align 8
  %47 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %47, i32 0, i32 3
  %48 = load i32, i32* %expected_attach_type, align 8
  %49 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type40 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %49, i32 0, i32 3
  store i32 %48, i32* %expected_attach_type40, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %land.lhs.true35, %if.end33
  %tgt_type = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %tgt_info, i32 0, i32 3
  %50 = load %struct.btf_type*, %struct.btf_type** %tgt_type, align 8
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux42 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %51, i32 0, i32 10
  %52 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux42, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %52, i32 0, i32 28
  store %struct.btf_type* %50, %struct.btf_type** %attach_func_proto, align 8
  %tgt_name = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %tgt_info, i32 0, i32 2
  %53 = load i8*, i8** %tgt_name, align 8
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux43 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 10
  %55 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux43, align 8
  %attach_func_name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %55, i32 0, i32 29
  store i8* %53, i8** %attach_func_name, align 8
  %56 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %tobool44 = icmp ne %struct.bpf_prog* %56, null
  br i1 %tobool44, label %if.then45, label %if.end50

if.then45:                                        ; preds = %if.end41
  %57 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %type46 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %57, i32 0, i32 2
  %58 = load i32, i32* %type46, align 4
  %59 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux47 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %59, i32 0, i32 10
  %60 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux47, align 8
  %saved_dst_prog_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %60, i32 0, i32 19
  store i32 %58, i32* %saved_dst_prog_type, align 8
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %expected_attach_type48 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %61, i32 0, i32 3
  %62 = load i32, i32* %expected_attach_type48, align 8
  %63 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux49 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %63, i32 0, i32 10
  %64 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux49, align 8
  %saved_dst_attach_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %64, i32 0, i32 20
  store i32 %62, i32* %saved_dst_attach_type, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.then45, %if.end41
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type51 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %65, i32 0, i32 3
  %66 = load i32, i32* %expected_attach_type51, align 8
  %cmp52 = icmp eq i32 %66, 23
  br i1 %cmp52, label %if.then53, label %if.else

if.then53:                                        ; preds = %if.end50
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux54 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 10
  %68 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux54, align 8
  %attach_btf_trace = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %68, i32 0, i32 23
  store i8 1, i8* %attach_btf_trace, align 2
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end50
  %69 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type55 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %69, i32 0, i32 3
  %70 = load i32, i32* %expected_attach_type55, align 8
  %cmp56 = icmp eq i32 %70, 28
  br i1 %cmp56, label %if.then57, label %if.end61

if.then57:                                        ; preds = %if.else
  %71 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call58 = call zeroext i1 @bpf_iter_prog_supported(%struct.bpf_prog* noundef %71) #14
  br i1 %call58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %if.then57
  store i32 -22, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.then57
  store i32 0, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.else
  br label %if.end62

if.end62:                                         ; preds = %if.end61
  %72 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type63 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %72, i32 0, i32 2
  %73 = load i32, i32* %type63, align 4
  %cmp64 = icmp eq i32 %73, 29
  br i1 %cmp64, label %if.then65, label %if.else71

if.then65:                                        ; preds = %if.end62
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log66 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 26
  %75 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call67 = call i32 @bpf_lsm_verify_prog(%struct.bpf_verifier_log* noundef %log66, %struct.bpf_prog* noundef %75) #14
  store i32 %call67, i32* %ret, align 4
  %76 = load i32, i32* %ret, align 4
  %cmp68 = icmp slt i32 %76, 0
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.then65
  %77 = load i32, i32* %ret, align 4
  store i32 %77, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.then65
  br label %if.end78

if.else71:                                        ; preds = %if.end62
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type72 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %78, i32 0, i32 2
  %79 = load i32, i32* %type72, align 4
  %cmp73 = icmp eq i32 %79, 26
  br i1 %cmp73, label %land.lhs.true74, label %if.end77

land.lhs.true74:                                  ; preds = %if.else71
  %80 = load i32, i32* %btf_id, align 4
  %call75 = call zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef @btf_id_deny, i32 noundef %80) #14
  br i1 %call75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %land.lhs.true74
  store i32 -22, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %land.lhs.true74, %if.else71
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.end70
  %81 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux79 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %82, i32 0, i32 10
  %83 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux79, align 8
  %attach_btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %83, i32 0, i32 14
  %84 = load %struct.btf*, %struct.btf** %attach_btf, align 8
  %85 = load i32, i32* %btf_id, align 4
  %call80 = call i64 @bpf_trampoline_compute_key(%struct.bpf_prog* noundef %81, %struct.btf* noundef %84, i32 noundef %85) #14
  store i64 %call80, i64* %key, align 8
  %86 = load i64, i64* %key, align 8
  %call81 = call %struct.bpf_trampoline* @bpf_trampoline_get(i64 noundef %86, %struct.bpf_attach_target_info* noundef %tgt_info) #14
  store %struct.bpf_trampoline* %call81, %struct.bpf_trampoline** %tr, align 8
  %87 = load %struct.bpf_trampoline*, %struct.bpf_trampoline** %tr, align 8
  %tobool82 = icmp ne %struct.bpf_trampoline* %87, null
  br i1 %tobool82, label %if.end84, label %if.then83

if.then83:                                        ; preds = %if.end78
  store i32 -12, i32* %retval, align 4
  br label %return

if.end84:                                         ; preds = %if.end78
  %88 = load %struct.bpf_trampoline*, %struct.bpf_trampoline** %tr, align 8
  %89 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux85 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %89, i32 0, i32 10
  %90 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux85, align 8
  %dst_trampoline = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %90, i32 0, i32 18
  store %struct.bpf_trampoline* %88, %struct.bpf_trampoline** %dst_trampoline, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end84, %if.then83, %if.then76, %if.then69, %if.end60, %if.then59, %if.then53, %if.then32, %if.then28, %if.then18, %if.then14, %if.end, %if.then4
  %91 = load i32, i32* %retval, align 4
  ret i32 %91
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_pseudo_ldimm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %f = alloca %struct.fd, align 8
  %addr = alloca i64, align 8
  %fd = alloca i32, align 4
  %tmp = alloca %struct.fd, align 8
  %off146 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %6) #14
  store i32 %call, i32* %err, align 4
  %7 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load i32, i32* %err, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc209, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end212

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 0
  %12 = load i8, i8* %code, align 4
  %conv = zext i8 %12 to i32
  %and = and i32 %conv, 7
  %cmp3 = icmp eq i32 %and, 1
  br i1 %cmp3, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %for.body
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %14 to i32
  %and7 = and i32 %conv6, 224
  %cmp8 = icmp ne i32 %and7, 96
  br i1 %cmp8, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %cmp10 = icmp ne i32 %16, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.170, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false, %for.body
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %19, i64 0
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %20 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %20 to i32
  %cmp16 = icmp eq i32 %conv15, 24
  br i1 %cmp16, label %if.then18, label %if.end202

if.then18:                                        ; preds = %if.end13
  %21 = load i32, i32* %i, align 4
  %22 = load i32, i32* %insn_cnt, align 4
  %sub = sub i32 %22, 1
  %cmp19 = icmp eq i32 %21, %sub
  br i1 %cmp19, label %if.then43, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.then18
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx22 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %23, i64 1
  %code23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx22, i32 0, i32 0
  %24 = load i8, i8* %code23, align 4
  %conv24 = zext i8 %24 to i32
  %cmp25 = icmp ne i32 %conv24, 0
  br i1 %cmp25, label %if.then43, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %lor.lhs.false21
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx28 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %25, i64 1
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx28, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv29 = zext i8 %bf.clear to i32
  %cmp30 = icmp ne i32 %conv29, 0
  br i1 %cmp30, label %if.then43, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %lor.lhs.false27
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx33 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %26, i64 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx33, i32 0, i32 1
  %bf.load34 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load34, 4
  %conv35 = zext i8 %bf.lshr to i32
  %cmp36 = icmp ne i32 %conv35, 0
  br i1 %cmp36, label %if.then43, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %lor.lhs.false32
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx39 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %27, i64 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx39, i32 0, i32 2
  %28 = load i16, i16* %off, align 2
  %conv40 = sext i16 %28 to i32
  %cmp41 = icmp ne i32 %conv40, 0
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %lor.lhs.false38, %lor.lhs.false32, %lor.lhs.false27, %lor.lhs.false21, %if.then18
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.171, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %lor.lhs.false38
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %31, i64 0
  %src_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx45, i32 0, i32 1
  %bf.load47 = load i8, i8* %src_reg46, align 1
  %bf.lshr48 = lshr i8 %bf.load47, 4
  %conv49 = zext i8 %bf.lshr48 to i32
  %cmp50 = icmp eq i32 %conv49, 0
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end44
  br label %next_insn

if.end53:                                         ; preds = %if.end44
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx54 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %32, i64 0
  %src_reg55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx54, i32 0, i32 1
  %bf.load56 = load i8, i8* %src_reg55, align 1
  %bf.lshr57 = lshr i8 %bf.load56, 4
  %conv58 = zext i8 %bf.lshr57 to i32
  %cmp59 = icmp eq i32 %conv58, 3
  br i1 %cmp59, label %if.then61, label %if.end67

if.then61:                                        ; preds = %if.end53
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 24
  %34 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom = sext i32 %35 to i64
  %arrayidx62 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %34, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx62, %struct.bpf_insn_aux_data** %aux, align 8
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %38 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call63 = call i32 @check_pseudo_btf_id(%struct.bpf_verifier_env* noundef %36, %struct.bpf_insn* noundef %37, %struct.bpf_insn_aux_data* noundef %38) #14
  store i32 %call63, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool64 = icmp ne i32 %39, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.then61
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.then61
  br label %next_insn

if.end67:                                         ; preds = %if.end53
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx68 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %41, i64 0
  %src_reg69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx68, i32 0, i32 1
  %bf.load70 = load i8, i8* %src_reg69, align 1
  %bf.lshr71 = lshr i8 %bf.load70, 4
  %conv72 = zext i8 %bf.lshr71 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.end79

if.then75:                                        ; preds = %if.end67
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data76 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 24
  %43 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data76, align 8
  %44 = load i32, i32* %i, align 4
  %idxprom77 = sext i32 %44 to i64
  %arrayidx78 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %43, i64 %idxprom77
  store %struct.bpf_insn_aux_data* %arrayidx78, %struct.bpf_insn_aux_data** %aux, align 8
  %45 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %46 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %45, i32 0, i32 0
  %ptr_type = bitcast %union.anon.163* %46 to i32*
  store i32 28, i32* %ptr_type, align 8
  br label %next_insn

if.end79:                                         ; preds = %if.end67
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx80 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %47, i64 0
  %src_reg81 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx80, i32 0, i32 1
  %bf.load82 = load i8, i8* %src_reg81, align 1
  %bf.lshr83 = lshr i8 %bf.load82, 4
  %conv84 = zext i8 %bf.lshr83 to i32
  switch i32 %conv84, label %sw.default [
    i32 2, label %sw.bb
    i32 6, label %sw.bb
    i32 1, label %sw.bb85
    i32 5, label %sw.bb85
  ]

sw.bb:                                            ; preds = %if.end79, %if.end79
  br label %sw.epilog

sw.bb85:                                          ; preds = %if.end79, %if.end79
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx86 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %48, i64 1
  %imm87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx86, i32 0, i32 3
  %49 = load i32, i32* %imm87, align 4
  %cmp88 = icmp eq i32 %49, 0
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %sw.bb85
  br label %sw.epilog

if.end91:                                         ; preds = %sw.bb85
  br label %sw.default

sw.default:                                       ; preds = %if.end79, %if.end91
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.172, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.then90, %sw.bb
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx92 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %52, i64 0
  %src_reg93 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx92, i32 0, i32 1
  %bf.load94 = load i8, i8* %src_reg93, align 1
  %bf.lshr95 = lshr i8 %bf.load94, 4
  %conv96 = zext i8 %bf.lshr95 to i32
  switch i32 %conv96, label %sw.default109 [
    i32 6, label %sw.bb97
    i32 5, label %sw.bb97
  ]

sw.bb97:                                          ; preds = %sw.epilog, %sw.epilog
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %fd_array = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 41
  %54 = bitcast %struct.sockptr_t* %fd_array to { i8*, i8 }*
  %55 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %54, i32 0, i32 0
  %56 = load i8*, i8** %55, align 8
  %57 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %54, i32 0, i32 1
  %58 = load i8, i8* %57, align 8
  %call98 = call zeroext i1 @bpfptr_is_null(i8* %56, i8 %58) #14
  br i1 %call98, label %if.then99, label %if.end100

if.then99:                                        ; preds = %sw.bb97
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = bitcast %struct.bpf_verifier_env* %59 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %60, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.173, i64 0, i64 0)) #14
  store i32 -71, i32* %retval, align 4
  br label %return

if.end100:                                        ; preds = %sw.bb97
  %61 = bitcast i32* %fd to i8*
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %fd_array101 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %62, i32 0, i32 41
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx102 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %63, i64 0
  %imm103 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx102, i32 0, i32 3
  %64 = load i32, i32* %imm103, align 4
  %conv104 = sext i32 %64 to i64
  %mul = mul i64 %conv104, 4
  %65 = bitcast %struct.sockptr_t* %fd_array101 to { i8*, i8 }*
  %66 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %65, i32 0, i32 0
  %67 = load i8*, i8** %66, align 8
  %68 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %65, i32 0, i32 1
  %69 = load i8, i8* %68, align 8
  %call105 = call i32 @copy_from_bpfptr_offset(i8* noundef %61, i8* %67, i8 %69, i64 noundef %mul, i64 noundef 4) #14
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end100
  store i32 -14, i32* %retval, align 4
  br label %return

if.end108:                                        ; preds = %if.end100
  br label %sw.epilog112

sw.default109:                                    ; preds = %sw.epilog
  %70 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx110 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %70, i64 0
  %imm111 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx110, i32 0, i32 3
  %71 = load i32, i32* %imm111, align 4
  store i32 %71, i32* %fd, align 4
  br label %sw.epilog112

sw.epilog112:                                     ; preds = %sw.default109, %if.end108
  %72 = load i32, i32* %fd, align 4
  %call113 = call { %struct.file*, i32 } @fdget(i32 noundef %72) #14
  %73 = bitcast %struct.fd* %tmp to { %struct.file*, i32 }*
  %74 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %73, i32 0, i32 0
  %75 = extractvalue { %struct.file*, i32 } %call113, 0
  store %struct.file* %75, %struct.file** %74, align 8
  %76 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %73, i32 0, i32 1
  %77 = extractvalue { %struct.file*, i32 } %call113, 1
  store i32 %77, i32* %76, align 8
  %78 = bitcast %struct.fd* %f to i8*
  %79 = bitcast %struct.fd* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %78, i8* align 8 %79, i64 16, i1 false)
  %80 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %81 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %80, i32 0, i32 0
  %82 = load %struct.file*, %struct.file** %81, align 8
  %83 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %80, i32 0, i32 1
  %84 = load i32, i32* %83, align 8
  %call114 = call %struct.bpf_map* @__bpf_map_get(%struct.file* %82, i32 %84) #14
  store %struct.bpf_map* %call114, %struct.bpf_map** %map, align 8
  %85 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %86 = bitcast %struct.bpf_map* %85 to i8*
  %call115 = call zeroext i1 @IS_ERR(i8* noundef %86) #14
  br i1 %call115, label %if.then116, label %if.end121

if.then116:                                       ; preds = %sw.epilog112
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = bitcast %struct.bpf_verifier_env* %87 to i8*
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx117 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %89, i64 0
  %imm118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx117, i32 0, i32 3
  %90 = load i32, i32* %imm118, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %88, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.174, i64 0, i64 0), i32 noundef %90) #14
  %91 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %92 = bitcast %struct.bpf_map* %91 to i8*
  %call119 = call i64 @PTR_ERR(i8* noundef %92) #14
  %conv120 = trunc i64 %call119 to i32
  store i32 %conv120, i32* %retval, align 4
  br label %return

if.end121:                                        ; preds = %sw.epilog112
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %94 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog122 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %95, i32 0, i32 2
  %96 = load %struct.bpf_prog*, %struct.bpf_prog** %prog122, align 8
  %call123 = call i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %93, %struct.bpf_map* noundef %94, %struct.bpf_prog* noundef %96) #14
  store i32 %call123, i32* %err, align 4
  %97 = load i32, i32* %err, align 4
  %tobool124 = icmp ne i32 %97, 0
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end121
  %98 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %99 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %98, i32 0, i32 0
  %100 = load %struct.file*, %struct.file** %99, align 8
  %101 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %98, i32 0, i32 1
  %102 = load i32, i32* %101, align 8
  call void @fdput(%struct.file* %100, i32 %102) #14
  %103 = load i32, i32* %err, align 4
  store i32 %103, i32* %retval, align 4
  br label %return

if.end126:                                        ; preds = %if.end121
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data127 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %104, i32 0, i32 24
  %105 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data127, align 8
  %106 = load i32, i32* %i, align 4
  %idxprom128 = sext i32 %106 to i64
  %arrayidx129 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %105, i64 %idxprom128
  store %struct.bpf_insn_aux_data* %arrayidx129, %struct.bpf_insn_aux_data** %aux, align 8
  %107 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx130 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %107, i64 0
  %src_reg131 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx130, i32 0, i32 1
  %bf.load132 = load i8, i8* %src_reg131, align 1
  %bf.lshr133 = lshr i8 %bf.load132, 4
  %conv134 = zext i8 %bf.lshr133 to i32
  %cmp135 = icmp eq i32 %conv134, 1
  br i1 %cmp135, label %if.then145, label %lor.lhs.false137

lor.lhs.false137:                                 ; preds = %if.end126
  %108 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx138 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %108, i64 0
  %src_reg139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx138, i32 0, i32 1
  %bf.load140 = load i8, i8* %src_reg139, align 1
  %bf.lshr141 = lshr i8 %bf.load140, 4
  %conv142 = zext i8 %bf.lshr141 to i32
  %cmp143 = icmp eq i32 %conv142, 5
  br i1 %cmp143, label %if.then145, label %if.else

if.then145:                                       ; preds = %lor.lhs.false137, %if.end126
  %109 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %110 = ptrtoint %struct.bpf_map* %109 to i64
  store i64 %110, i64* %addr, align 8
  br label %if.end163

if.else:                                          ; preds = %lor.lhs.false137
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx147 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %111, i64 1
  %imm148 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx147, i32 0, i32 3
  %112 = load i32, i32* %imm148, align 4
  store i32 %112, i32* %off146, align 4
  %113 = load i32, i32* %off146, align 4
  %cmp149 = icmp uge i32 %113, 536870912
  br i1 %cmp149, label %if.then151, label %if.end152

if.then151:                                       ; preds = %if.else
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = bitcast %struct.bpf_verifier_env* %114 to i8*
  %116 = load i32, i32* %off146, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %115, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.175, i64 0, i64 0), i32 noundef %116) #14
  %117 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %118 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %117, i32 0, i32 0
  %119 = load %struct.file*, %struct.file** %118, align 8
  %120 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %117, i32 0, i32 1
  %121 = load i32, i32* %120, align 8
  call void @fdput(%struct.file* %119, i32 %121) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %if.else
  %122 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %122, i32 0, i32 0
  %123 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %123, i32 0, i32 27
  %124 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool153 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %124, null
  br i1 %tobool153, label %if.end155, label %if.then154

if.then154:                                       ; preds = %if.end152
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %126 = bitcast %struct.bpf_verifier_env* %125 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %126, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.176, i64 0, i64 0)) #14
  %127 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %128 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %127, i32 0, i32 0
  %129 = load %struct.file*, %struct.file** %128, align 8
  %130 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %127, i32 0, i32 1
  %131 = load i32, i32* %130, align 8
  call void @fdput(%struct.file* %129, i32 %131) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.end152
  %132 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops156 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %132, i32 0, i32 0
  %133 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops156, align 64
  %map_direct_value_addr157 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %133, i32 0, i32 27
  %134 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr157, align 8
  %135 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %136 = load i32, i32* %off146, align 4
  %call158 = call i32 %134(%struct.bpf_map* noundef %135, i64* noundef %addr, i32 noundef %136) #14
  store i32 %call158, i32* %err, align 4
  %137 = load i32, i32* %err, align 4
  %tobool159 = icmp ne i32 %137, 0
  br i1 %tobool159, label %if.then160, label %if.end161

if.then160:                                       ; preds = %if.end155
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = bitcast %struct.bpf_verifier_env* %138 to i8*
  %140 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %140, i32 0, i32 5
  %141 = load i32, i32* %value_size, align 32
  %142 = load i32, i32* %off146, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %139, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.177, i64 0, i64 0), i32 noundef %141, i32 noundef %142) #14
  %143 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %144 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %143, i32 0, i32 0
  %145 = load %struct.file*, %struct.file** %144, align 8
  %146 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %143, i32 0, i32 1
  %147 = load i32, i32* %146, align 8
  call void @fdput(%struct.file* %145, i32 %147) #14
  %148 = load i32, i32* %err, align 4
  store i32 %148, i32* %retval, align 4
  br label %return

if.end161:                                        ; preds = %if.end155
  %149 = load i32, i32* %off146, align 4
  %150 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %151 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %150, i32 0, i32 0
  %152 = bitcast %union.anon.163* %151 to %struct.anon.164*
  %map_off = getelementptr inbounds %struct.anon.164, %struct.anon.164* %152, i32 0, i32 1
  store i32 %149, i32* %map_off, align 4
  %153 = load i32, i32* %off146, align 4
  %conv162 = zext i32 %153 to i64
  %154 = load i64, i64* %addr, align 8
  %add = add i64 %154, %conv162
  store i64 %add, i64* %addr, align 8
  br label %if.end163

if.end163:                                        ; preds = %if.end161, %if.then145
  %155 = load i64, i64* %addr, align 8
  %conv164 = trunc i64 %155 to i32
  %156 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx165 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %156, i64 0
  %imm166 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx165, i32 0, i32 3
  store i32 %conv164, i32* %imm166, align 4
  %157 = load i64, i64* %addr, align 8
  %shr = lshr i64 %157, 32
  %conv167 = trunc i64 %shr to i32
  %158 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx168 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %158, i64 1
  %imm169 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx168, i32 0, i32 3
  store i32 %conv167, i32* %imm169, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond170

for.cond170:                                      ; preds = %for.inc, %if.end163
  %159 = load i32, i32* %j, align 4
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %160, i32 0, i32 13
  %161 = load i32, i32* %used_map_cnt, align 8
  %cmp171 = icmp ult i32 %159, %161
  br i1 %cmp171, label %for.body173, label %for.end

for.body173:                                      ; preds = %for.cond170
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %162, i32 0, i32 11
  %163 = load i32, i32* %j, align 4
  %idxprom174 = sext i32 %163 to i64
  %arrayidx175 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom174
  %164 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx175, align 8
  %165 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp176 = icmp eq %struct.bpf_map* %164, %165
  br i1 %cmp176, label %if.then178, label %if.end179

if.then178:                                       ; preds = %for.body173
  %166 = load i32, i32* %j, align 4
  %167 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %168 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %167, i32 0, i32 0
  %169 = bitcast %union.anon.163* %168 to %struct.anon.164*
  %map_index = getelementptr inbounds %struct.anon.164, %struct.anon.164* %169, i32 0, i32 0
  store i32 %166, i32* %map_index, align 8
  %170 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %171 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %170, i32 0, i32 0
  %172 = load %struct.file*, %struct.file** %171, align 8
  %173 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %170, i32 0, i32 1
  %174 = load i32, i32* %173, align 8
  call void @fdput(%struct.file* %172, i32 %174) #14
  br label %next_insn

if.end179:                                        ; preds = %for.body173
  br label %for.inc

for.inc:                                          ; preds = %if.end179
  %175 = load i32, i32* %j, align 4
  %inc = add i32 %175, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond170

for.end:                                          ; preds = %for.cond170
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt180 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %176, i32 0, i32 13
  %177 = load i32, i32* %used_map_cnt180, align 8
  %cmp181 = icmp uge i32 %177, 64
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %for.end
  %178 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %179 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %178, i32 0, i32 0
  %180 = load %struct.file*, %struct.file** %179, align 8
  %181 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %178, i32 0, i32 1
  %182 = load i32, i32* %181, align 8
  call void @fdput(%struct.file* %180, i32 %182) #14
  store i32 -7, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %for.end
  %183 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  call void @bpf_map_inc(%struct.bpf_map* noundef %183) #14
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt185 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %184, i32 0, i32 13
  %185 = load i32, i32* %used_map_cnt185, align 8
  %186 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %187 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %186, i32 0, i32 0
  %188 = bitcast %union.anon.163* %187 to %struct.anon.164*
  %map_index186 = getelementptr inbounds %struct.anon.164, %struct.anon.164* %188, i32 0, i32 0
  store i32 %185, i32* %map_index186, align 8
  %189 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps187 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %190, i32 0, i32 11
  %191 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt188 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %191, i32 0, i32 13
  %192 = load i32, i32* %used_map_cnt188, align 8
  %inc189 = add i32 %192, 1
  store i32 %inc189, i32* %used_map_cnt188, align 8
  %idxprom190 = zext i32 %192 to i64
  %arrayidx191 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps187, i64 0, i64 %idxprom190
  store %struct.bpf_map* %189, %struct.bpf_map** %arrayidx191, align 8
  %193 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call192 = call zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %193) #14
  br i1 %call192, label %land.lhs.true194, label %if.end200

land.lhs.true194:                                 ; preds = %if.end184
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog195 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %194, i32 0, i32 2
  %195 = load %struct.bpf_prog*, %struct.bpf_prog** %prog195, align 8
  %aux196 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %195, i32 0, i32 10
  %196 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux196, align 8
  %197 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call197 = call i32 @bpf_cgroup_storage_assign(%struct.bpf_prog_aux* noundef %196, %struct.bpf_map* noundef %197) #14
  %tobool198 = icmp ne i32 %call197, 0
  br i1 %tobool198, label %if.then199, label %if.end200

if.then199:                                       ; preds = %land.lhs.true194
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %199 = bitcast %struct.bpf_verifier_env* %198 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %199, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.178, i64 0, i64 0)) #14
  %200 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %201 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %200, i32 0, i32 0
  %202 = load %struct.file*, %struct.file** %201, align 8
  %203 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %200, i32 0, i32 1
  %204 = load i32, i32* %203, align 8
  call void @fdput(%struct.file* %202, i32 %204) #14
  store i32 -16, i32* %retval, align 4
  br label %return

if.end200:                                        ; preds = %land.lhs.true194, %if.end184
  %205 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %206 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %205, i32 0, i32 0
  %207 = load %struct.file*, %struct.file** %206, align 8
  %208 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %205, i32 0, i32 1
  %209 = load i32, i32* %208, align 8
  call void @fdput(%struct.file* %207, i32 %209) #14
  br label %next_insn

next_insn:                                        ; preds = %if.end200, %if.then178, %if.then75, %if.end66, %if.then52
  %210 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %210, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  %211 = load i32, i32* %i, align 4
  %inc201 = add i32 %211, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.inc209

if.end202:                                        ; preds = %if.end13
  %212 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %212, i32 0, i32 0
  %213 = load i8, i8* %code203, align 4
  %call204 = call zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext %213) #14
  br i1 %call204, label %if.end208, label %if.then205

if.then205:                                       ; preds = %if.end202
  %214 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %215 = bitcast %struct.bpf_verifier_env* %214 to i8*
  %216 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code206 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %216, i32 0, i32 0
  %217 = load i8, i8* %code206, align 4
  %conv207 = zext i8 %217 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %215, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.179, i64 0, i64 0), i32 noundef %conv207) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end208:                                        ; preds = %if.end202
  br label %for.inc209

for.inc209:                                       ; preds = %if.end208, %next_insn
  %218 = load i32, i32* %i, align 4
  %inc210 = add i32 %218, 1
  store i32 %inc210, i32* %i, align 4
  %219 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr211 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %219, i32 1
  store %struct.bpf_insn* %incdec.ptr211, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end212:                                       ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end212, %if.then205, %if.then199, %if.then183, %if.then160, %if.then154, %if.then151, %if.then125, %if.then116, %if.then107, %if.then99, %sw.default, %if.then65, %if.then43, %if.then12, %if.then
  %220 = load i32, i32* %retval, align 4
  ret i32 %220
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  %0 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux.addr, align 8
  %offload_requested = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %0, i32 0, i32 22
  %1 = load i8, i8* %offload_requested, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cfg(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_cnt = alloca i32, align 4
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  store i32 %2, i32* %insn_cnt, align 4
  store i32 0, i32* %ret, align 4
  %3 = load i32, i32* %insn_cnt, align 4
  %conv = sext i32 %3 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv, i64 noundef 4, i32 noundef 3264) #14
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 29
  %insn_state1 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg, i32 0, i32 0
  store i32* %4, i32** %insn_state1, align 8
  store i32* %4, i32** %insn_state, align 8
  %6 = load i32*, i32** %insn_state, align 8
  %tobool = icmp ne i32* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %insn_cnt, align 4
  %conv2 = sext i32 %7 to i64
  %call3 = call i8* @kvcalloc(i64 noundef %conv2, i64 noundef 4, i32 noundef 3264) #14
  %8 = bitcast i8* %call3 to i32*
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 29
  %insn_stack5 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg4, i32 0, i32 1
  store i32* %8, i32** %insn_stack5, align 8
  store i32* %8, i32** %insn_stack, align 8
  %10 = load i32*, i32** %insn_stack, align 8
  %tobool6 = icmp ne i32* %10, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  %11 = load i32*, i32** %insn_state, align 8
  %12 = bitcast i32* %11 to i8*
  call void @kvfree(i8* noundef %12) #14
  store i32 -12, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %13 = load i32*, i32** %insn_state, align 8
  %arrayidx = getelementptr i32, i32* %13, i64 0
  store i32 16, i32* %arrayidx, align 4
  %14 = load i32*, i32** %insn_stack, align 8
  %arrayidx9 = getelementptr i32, i32* %14, i64 0
  store i32 0, i32* %arrayidx9, align 4
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 29
  %cur_stack = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg10, i32 0, i32 2
  store i32 1, i32* %cur_stack, align 8
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %if.end8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 29
  %cur_stack12 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg11, i32 0, i32 2
  %17 = load i32, i32* %cur_stack12, align 8
  %cmp = icmp sgt i32 %17, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %18 = load i32*, i32** %insn_stack, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 29
  %cur_stack15 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg14, i32 0, i32 2
  %20 = load i32, i32* %cur_stack15, align 8
  %sub = sub i32 %20, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx16 = getelementptr i32, i32* %18, i64 %idxprom
  %21 = load i32, i32* %arrayidx16, align 4
  store i32 %21, i32* %t, align 4
  %22 = load i32, i32* %t, align 4
  %23 = load i32, i32* %insn_cnt, align 4
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call17 = call i32 @visit_insn(i32 noundef %22, i32 noundef %23, %struct.bpf_verifier_env* noundef %24) #14
  store i32 %call17, i32* %ret, align 4
  %25 = load i32, i32* %ret, align 4
  switch i32 %25, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb22
  ]

sw.bb:                                            ; preds = %while.body
  %26 = load i32*, i32** %insn_state, align 8
  %27 = load i32, i32* %t, align 4
  %idxprom18 = sext i32 %27 to i64
  %arrayidx19 = getelementptr i32, i32* %26, i64 %idxprom18
  store i32 32, i32* %arrayidx19, align 4
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 29
  %cur_stack21 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg20, i32 0, i32 2
  %29 = load i32, i32* %cur_stack21, align 8
  %dec = add i32 %29, -1
  store i32 %dec, i32* %cur_stack21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %while.body
  br label %sw.epilog

sw.default:                                       ; preds = %while.body
  %30 = load i32, i32* %ret, align 4
  %cmp23 = icmp sgt i32 %30, 0
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %sw.default
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.197, i64 0, i64 0)) #14
  store i32 -14, i32* %ret, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %sw.default
  br label %err_free

sw.epilog:                                        ; preds = %sw.bb22, %sw.bb
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 29
  %cur_stack28 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg27, i32 0, i32 2
  %34 = load i32, i32* %cur_stack28, align 8
  %cmp29 = icmp slt i32 %34, 0
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %while.end
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.198, i64 0, i64 0)) #14
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end32:                                         ; preds = %while.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end32
  %37 = load i32, i32* %i, align 4
  %38 = load i32, i32* %insn_cnt, align 4
  %cmp33 = icmp slt i32 %37, %38
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load i32*, i32** %insn_state, align 8
  %40 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %40 to i64
  %arrayidx36 = getelementptr i32, i32* %39, i64 %idxprom35
  %41 = load i32, i32* %arrayidx36, align 4
  %cmp37 = icmp ne i32 %41, 32
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %for.body
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.199, i64 0, i64 0), i32 noundef %44) #14
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end40:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end40
  %45 = load i32, i32* %i, align 4
  %inc = add i32 %45, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %ret, align 4
  br label %err_free

err_free:                                         ; preds = %for.end, %if.then39, %if.then31, %if.end26
  %46 = load i32*, i32** %insn_state, align 8
  %47 = bitcast i32* %46 to i8*
  call void @kvfree(i8* noundef %47) #14
  %48 = load i32*, i32** %insn_stack, align 8
  %49 = bitcast i32* %48 to i8*
  call void @kvfree(i8* noundef %49) #14
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg41 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 29
  %insn_stack42 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg41, i32 0, i32 1
  store i32* null, i32** %insn_stack42, align 8
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 29
  %insn_state44 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg43, i32 0, i32 0
  store i32* null, i32** %insn_state44, align 8
  %52 = load i32, i32* %ret, align 4
  store i32 %52, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.then7, %if.then
  %53 = load i32, i32* %retval, align 4
  ret i32 %53
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 48
  %4 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool = icmp ne %struct.bpf_func_info* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 31
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %8, i32 0, i32 49
  %9 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %9, i64 %idxprom
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx, i32 0, i32 0
  %11 = load i16, i16* %linkage, align 2
  %conv = zext i16 %11 to i32
  %cmp2 = icmp ne i32 %conv, 1
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.body
  br label %for.inc

if.end5:                                          ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 27
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom6
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %14 = load i32, i32* %start, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 0
  store i32 %14, i32* %insn_idx, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 0
  %17 = load i32, i32* %insn_idx8, align 8
  %cmp9 = icmp eq i32 %17, 0
  %lnot = xor i1 %cmp9, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %18, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %if.end5
  br label %do.body

do.body:                                          ; preds = %if.then19
  br label %do.body20

do.body20:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body20
  br label %do.body21

do.body21:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 15143, i32 2307, i64 12) #13, !srcloc !17
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  call void asm sideeffect "563:\0A\09.pushsection .discard.reachable\0A\09.long 563b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !18
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %if.end26

if.end26:                                         ; preds = %do.end25, %if.end5
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %19, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load i32, i32* %i, align 4
  %call = call i32 @do_check_common(%struct.bpf_verifier_env* noundef %21, i32 noundef %22) #14
  store i32 %call, i32* %ret, align 4
  %23 = load i32, i32* %ret, align 4
  %tobool33 = icmp ne i32 %23, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end26
  %24 = load i32, i32* %ret, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end26
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %26 = load i32, i32* %level, align 8
  %and = and i32 %26, 3
  %tobool35 = icmp ne i32 %and, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.204, i64 0, i64 0), i32 noundef %29) #14
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.else
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  br label %for.inc

for.inc:                                          ; preds = %if.end38, %if.then4
  %30 = load i32, i32* %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then34, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_main(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 0
  store i32 0, i32* %insn_idx, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @do_check_common(%struct.bpf_verifier_env* noundef %1, i32 noundef 0) #14
  store i32 %call, i32* %ret, align 4
  %2 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 27
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %4 = load i16, i16* %stack_depth, align 8
  %conv = zext i16 %4 to i32
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %stack_depth1 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 6
  store i32 %conv, i32* %stack_depth1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i32, i32* %ret, align 4
  ret i32 %8
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kvfree(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %depth = alloca i32, align 4
  %frame = alloca i32, align 4
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %tail_call_reachable = alloca i8, align 1
  %ret_insn = alloca [8 x i32], align 16
  %ret_prog = alloca [8 x i32], align 16
  %j = alloca i32, align 4
  %__UNIQUE_ID___x476 = alloca i32, align 4
  %__UNIQUE_ID___y477 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %next_insn = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp67 = alloca i64, align 8
  %tmp75 = alloca i64, align 8
  %__UNIQUE_ID___x479 = alloca i32, align 4
  %__UNIQUE_ID___y480 = alloca i32, align 4
  %tmp135 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %depth, align 4
  store i32 0, i32* %frame, align 4
  store i32 0, i32* %idx, align 4
  store i32 0, i32* %i, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 13
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  store i8 0, i8* %tail_call_reachable, align 1
  br label %process_func

process_func:                                     ; preds = %if.end103, %entry
  %3 = load i32, i32* %idx, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %process_func
  %4 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %5 = load i32, i32* %idx, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i64 %idxprom
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 3
  %6 = load i8, i8* %has_tail_call, align 2
  %tobool2 = trunc i8 %6 to i1
  br i1 %tobool2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %depth, align 4
  %cmp = icmp sge i32 %7, 256
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([86 x i8], [86 x i8]* @.str.439, i64 0, i64 0), i32 noundef %10) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %process_func
  %11 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %12 = load i32, i32* %idx, align 4
  %idxprom4 = sext i32 %12 to i64
  %arrayidx5 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %11, i64 %idxprom4
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx5, i32 0, i32 2
  %13 = load i16, i16* %stack_depth, align 4
  %conv = zext i16 %13 to i32
  store i32 %conv, i32* %__UNIQUE_ID___x476, align 4
  store i32 1, i32* %__UNIQUE_ID___y477, align 4
  %14 = load i32, i32* %__UNIQUE_ID___x476, align 4
  %15 = load i32, i32* %__UNIQUE_ID___y477, align 4
  %cmp6 = icmp ugt i32 %14, %15
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %16 = load i32, i32* %__UNIQUE_ID___x476, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %17 = load i32, i32* %__UNIQUE_ID___y477, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %16, %cond.true ], [ %17, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %18 = load i32, i32* %tmp, align 4
  %sub = sub i32 %18, 1
  %or = or i32 %sub, 31
  %add = add i32 %or, 1
  %19 = load i32, i32* %depth, align 4
  %add8 = add i32 %19, %add
  store i32 %add8, i32* %depth, align 4
  %20 = load i32, i32* %depth, align 4
  %cmp9 = icmp sgt i32 %20, 512
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %cond.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load i32, i32* %frame, align 4
  %add12 = add i32 %23, 1
  %24 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.440, i64 0, i64 0), i32 noundef %add12, i32 noundef %24) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %cond.end
  br label %continue_func

continue_func:                                    ; preds = %cond.end140, %if.end13
  %25 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %26 = load i32, i32* %idx, align 4
  %add14 = add i32 %26, 1
  %idxprom15 = sext i32 %add14 to i64
  %arrayidx16 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %25, i64 %idxprom15
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx16, i32 0, i32 0
  %27 = load i32, i32* %start, align 4
  store i32 %27, i32* %subprog_end, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %continue_func
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %subprog_end, align 4
  %cmp17 = icmp slt i32 %28, %29
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %31 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %31 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %30, i64 %idx.ext
  %call = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %add.ptr) #14
  br i1 %call, label %if.end24, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %for.body
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %33 = load i32, i32* %i, align 4
  %idx.ext20 = sext i32 %33 to i64
  %add.ptr21 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %32, i64 %idx.ext20
  %call22 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %add.ptr21) #14
  br i1 %call22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true19
  br label %for.inc

if.end24:                                         ; preds = %land.lhs.true19, %for.body
  %34 = load i32, i32* %i, align 4
  %add25 = add i32 %34, 1
  %35 = load i32, i32* %frame, align 4
  %idxprom26 = sext i32 %35 to i64
  %arrayidx27 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom26
  store i32 %add25, i32* %arrayidx27, align 4
  %36 = load i32, i32* %idx, align 4
  %37 = load i32, i32* %frame, align 4
  %idxprom28 = sext i32 %37 to i64
  %arrayidx29 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom28
  store i32 %36, i32* %arrayidx29, align 4
  %38 = load i32, i32* %i, align 4
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %40 = load i32, i32* %i, align 4
  %idxprom30 = sext i32 %40 to i64
  %arrayidx31 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %39, i64 %idxprom30
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx31, i32 0, i32 3
  %41 = load i32, i32* %imm, align 4
  %add32 = add i32 %38, %41
  %add33 = add i32 %add32, 1
  store i32 %add33, i32* %next_insn, align 4
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = load i32, i32* %next_insn, align 4
  %call34 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %42, i32 noundef %43) #14
  store i32 %call34, i32* %idx, align 4
  %44 = load i32, i32* %idx, align 4
  %cmp35 = icmp slt i32 %44, 0
  br i1 %cmp35, label %if.then37, label %if.end82

if.then37:                                        ; preds = %if.end24
  store i8 1, i8* %__ret_do_once, align 1
  %45 = load i8, i8* %__ret_do_once, align 1
  %tobool38 = trunc i8 %45 to i1
  br i1 %tobool38, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then37
  %46 = load i8, i8* @check_max_stack_depth.__already_done, align 1
  %tobool40 = trunc i8 %46 to i1
  %lnot = xor i1 %tobool40, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then37
  %47 = phi i1 [ false, %if.then37 ], [ %lnot, %land.rhs ]
  %lnot41 = xor i1 %47, true
  %lnot42 = xor i1 %lnot41, true
  %lnot.ext = zext i1 %lnot42 to i32
  %conv43 = sext i32 %lnot.ext to i64
  %tobool44 = icmp ne i64 %conv43, 0
  br i1 %tobool44, label %if.then45, label %if.end74

if.then45:                                        ; preds = %land.end
  store i8 1, i8* @check_max_stack_depth.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %48 = load i32, i32* %__ret_warn_on, align 4
  %tobool46 = icmp ne i32 %48, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %tobool52 = icmp ne i64 %conv51, 0
  br i1 %tobool52, label %if.then53, label %if.end66

if.then53:                                        ; preds = %if.then45
  br label %do.body

do.body:                                          ; preds = %if.then53
  br label %do.body54

do.body54:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body54
  %49 = load i32, i32* %next_insn, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.323, i64 0, i64 0), i32 noundef %49) #14
  br label %do.body55

do.body55:                                        ; preds = %do.end
  br label %do.body56

do.body56:                                        ; preds = %do.body55
  br label %do.end57

do.end57:                                         ; preds = %do.body56
  br label %do.body58

do.body58:                                        ; preds = %do.end57
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 3793, i32 2313, i64 12) #13, !srcloc !19
  br label %do.end59

do.end59:                                         ; preds = %do.body58
  call void asm sideeffect "478:\0A\09.pushsection .discard.reachable\0A\09.long 478b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !20
  br label %do.body60

do.body60:                                        ; preds = %do.end59
  br label %do.end61

do.end61:                                         ; preds = %do.body60
  br label %do.end62

do.end62:                                         ; preds = %do.end61
  br label %do.body63

do.body63:                                        ; preds = %do.end62
  br label %do.end64

do.end64:                                         ; preds = %do.body63
  br label %do.end65

do.end65:                                         ; preds = %do.end64
  br label %if.end66

if.end66:                                         ; preds = %do.end65, %if.then45
  %50 = load i32, i32* %__ret_warn_on, align 4
  %tobool68 = icmp ne i32 %50, 0
  %lnot69 = xor i1 %tobool68, true
  %lnot71 = xor i1 %lnot69, true
  %lnot.ext72 = zext i1 %lnot71 to i32
  %conv73 = sext i32 %lnot.ext72 to i64
  store i64 %conv73, i64* %tmp67, align 8
  %51 = load i64, i64* %tmp67, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.end66, %land.end
  %52 = load i8, i8* %__ret_do_once, align 1
  %tobool76 = trunc i8 %52 to i1
  %lnot77 = xor i1 %tobool76, true
  %lnot79 = xor i1 %lnot77, true
  %lnot.ext80 = zext i1 %lnot79 to i32
  %conv81 = sext i32 %lnot.ext80 to i64
  store i64 %conv81, i64* %tmp75, align 8
  %53 = load i64, i64* %tmp75, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.end24
  %54 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %55 = load i32, i32* %idx, align 4
  %idxprom83 = sext i32 %55 to i64
  %arrayidx84 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %54, i64 %idxprom83
  %is_async_cb = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx84, i32 0, i32 6
  %56 = load i8, i8* %is_async_cb, align 1
  %tobool85 = trunc i8 %56 to i1
  br i1 %tobool85, label %if.then86, label %if.end93

if.then86:                                        ; preds = %if.end82
  %57 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %58 = load i32, i32* %idx, align 4
  %idxprom87 = sext i32 %58 to i64
  %arrayidx88 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %57, i64 %idxprom87
  %has_tail_call89 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx88, i32 0, i32 3
  %59 = load i8, i8* %has_tail_call89, align 2
  %tobool90 = trunc i8 %59 to i1
  br i1 %tobool90, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.then86
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.441, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end92:                                         ; preds = %if.then86
  br label %for.inc

if.end93:                                         ; preds = %if.end82
  %62 = load i32, i32* %next_insn, align 4
  store i32 %62, i32* %i, align 4
  %63 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %64 = load i32, i32* %idx, align 4
  %idxprom94 = sext i32 %64 to i64
  %arrayidx95 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %63, i64 %idxprom94
  %has_tail_call96 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx95, i32 0, i32 3
  %65 = load i8, i8* %has_tail_call96, align 2
  %tobool97 = trunc i8 %65 to i1
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end93
  store i8 1, i8* %tail_call_reachable, align 1
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.end93
  %66 = load i32, i32* %frame, align 4
  %inc = add i32 %66, 1
  store i32 %inc, i32* %frame, align 4
  %67 = load i32, i32* %frame, align 4
  %cmp100 = icmp sge i32 %67, 8
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.end99
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = bitcast %struct.bpf_verifier_env* %68 to i8*
  %70 = load i32, i32* %frame, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %69, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.442, i64 0, i64 0), i32 noundef %70) #14
  store i32 -7, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %if.end99
  br label %process_func

for.inc:                                          ; preds = %if.end92, %if.then23
  %71 = load i32, i32* %i, align 4
  %inc104 = add i32 %71, 1
  store i32 %inc104, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %72 = load i8, i8* %tail_call_reachable, align 1
  %tobool105 = trunc i8 %72 to i1
  br i1 %tobool105, label %if.then106, label %if.end119

if.then106:                                       ; preds = %for.end
  store i32 0, i32* %j, align 4
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc116, %if.then106
  %73 = load i32, i32* %j, align 4
  %74 = load i32, i32* %frame, align 4
  %cmp108 = icmp slt i32 %73, %74
  br i1 %cmp108, label %for.body110, label %for.end118

for.body110:                                      ; preds = %for.cond107
  %75 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %76 = load i32, i32* %j, align 4
  %idxprom111 = sext i32 %76 to i64
  %arrayidx112 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom111
  %77 = load i32, i32* %arrayidx112, align 4
  %idxprom113 = sext i32 %77 to i64
  %arrayidx114 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %75, i64 %idxprom113
  %tail_call_reachable115 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx114, i32 0, i32 4
  store i8 1, i8* %tail_call_reachable115, align 1
  br label %for.inc116

for.inc116:                                       ; preds = %for.body110
  %78 = load i32, i32* %j, align 4
  %inc117 = add i32 %78, 1
  store i32 %inc117, i32* %j, align 4
  br label %for.cond107

for.end118:                                       ; preds = %for.cond107
  br label %if.end119

if.end119:                                        ; preds = %for.end118, %for.end
  %79 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %arrayidx120 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %79, i64 0
  %tail_call_reachable121 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx120, i32 0, i32 4
  %80 = load i8, i8* %tail_call_reachable121, align 1
  %tobool122 = trunc i8 %80 to i1
  br i1 %tobool122, label %if.then123, label %if.end126

if.then123:                                       ; preds = %if.end119
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog124 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 2
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %prog124, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %82, i32 0, i32 10
  %83 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %tail_call_reachable125 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %83, i32 0, i32 26
  store i8 1, i8* %tail_call_reachable125, align 1
  br label %if.end126

if.end126:                                        ; preds = %if.then123, %if.end119
  %84 = load i32, i32* %frame, align 4
  %cmp127 = icmp eq i32 %84, 0
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.end126
  store i32 0, i32* %retval, align 4
  br label %return

if.end130:                                        ; preds = %if.end126
  %85 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %86 = load i32, i32* %idx, align 4
  %idxprom131 = sext i32 %86 to i64
  %arrayidx132 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %85, i64 %idxprom131
  %stack_depth133 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx132, i32 0, i32 2
  %87 = load i16, i16* %stack_depth133, align 4
  %conv134 = zext i16 %87 to i32
  store i32 %conv134, i32* %__UNIQUE_ID___x479, align 4
  store i32 1, i32* %__UNIQUE_ID___y480, align 4
  %88 = load i32, i32* %__UNIQUE_ID___x479, align 4
  %89 = load i32, i32* %__UNIQUE_ID___y480, align 4
  %cmp136 = icmp ugt i32 %88, %89
  br i1 %cmp136, label %cond.true138, label %cond.false139

cond.true138:                                     ; preds = %if.end130
  %90 = load i32, i32* %__UNIQUE_ID___x479, align 4
  br label %cond.end140

cond.false139:                                    ; preds = %if.end130
  %91 = load i32, i32* %__UNIQUE_ID___y480, align 4
  br label %cond.end140

cond.end140:                                      ; preds = %cond.false139, %cond.true138
  %cond141 = phi i32 [ %90, %cond.true138 ], [ %91, %cond.false139 ]
  store i32 %cond141, i32* %tmp135, align 4
  %92 = load i32, i32* %tmp135, align 4
  %sub142 = sub i32 %92, 1
  %or143 = or i32 %sub142, 31
  %add144 = add i32 %or143, 1
  %93 = load i32, i32* %depth, align 4
  %sub145 = sub i32 %93, %add144
  store i32 %sub145, i32* %depth, align 4
  %94 = load i32, i32* %frame, align 4
  %dec = add i32 %94, -1
  store i32 %dec, i32* %frame, align 4
  %95 = load i32, i32* %frame, align 4
  %idxprom146 = sext i32 %95 to i64
  %arrayidx147 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom146
  %96 = load i32, i32* %arrayidx147, align 4
  store i32 %96, i32* %i, align 4
  %97 = load i32, i32* %frame, align 4
  %idxprom148 = sext i32 %97 to i64
  %arrayidx149 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom148
  %98 = load i32, i32* %arrayidx149, align 4
  store i32 %98, i32* %idx, align 4
  br label %continue_func

return:                                           ; preds = %if.then129, %if.then102, %if.then91, %if.end74, %if.then11, %if.then
  %99 = load i32, i32* %retval, align 4
  ret i32 %99
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_hard_wire_dead_code_branches.ja, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 0
  %11 = load i8, i8* %code, align 4
  %call = call zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %11) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %13 = load i32, i32* %i, align 4
  %add = add i32 %13, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %14 = load i32, i32* %seen, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 2
  %16 = load i16, i16* %off, align 2
  %off3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 %16, i16* %off3, align 2
  br label %if.end15

if.else:                                          ; preds = %if.end
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %18 = load i32, i32* %i, align 4
  %add4 = add i32 %18, 1
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 2
  %20 = load i16, i16* %off5, align 2
  %conv = sext i16 %20 to i32
  %add6 = add i32 %add4, %conv
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %17, i64 %idxprom7
  %seen9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx8, i32 0, i32 3
  %21 = load i32, i32* %seen9, align 4
  %tobool10 = icmp ne i32 %21, 0
  br i1 %tobool10, label %if.else13, label %if.then11

if.then11:                                        ; preds = %if.else
  %off12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 0, i16* %off12, align 2
  br label %if.end14

if.else13:                                        ; preds = %if.else
  br label %for.inc

if.end14:                                         ; preds = %if.then11
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then2
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog16, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 10
  %24 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call17 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %24) #14
  br i1 %call17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %i, align 4
  call void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef %25, i32 noundef %26, %struct.bpf_insn* noundef %ja) #14
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %28 = bitcast %struct.bpf_insn* %27 to i8*
  %29 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %28, i8* align 4 %29, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.else13, %if.then
  %30 = load i32, i32* %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %i, align 4
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %31, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %j, align 4
  %add = add i32 %7, %8
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp1 = icmp slt i32 %add, %9
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %j, align 4
  %add2 = add i32 %11, %12
  %idxprom = sext i32 %add2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %13 = load i32, i32* %seen, align 4
  %tobool = icmp ne i32 %13, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load i32, i32* %j, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %j, align 4
  br label %while.cond

while.end:                                        ; preds = %land.end
  %16 = load i32, i32* %j, align 4
  %tobool3 = icmp ne i32 %16, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.inc

if.end:                                           ; preds = %while.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %i, align 4
  %19 = load i32, i32* %j, align 4
  %call = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #14
  store i32 %call, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %20, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog7, align 8
  %len8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 4
  %24 = load i32, i32* %len8, align 4
  store i32 %24, i32* %insn_cnt, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end6, %if.then
  %25 = load i32, i32* %i, align 4
  %inc9 = add i32 %25, 1
  store i32 %inc9, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_remove_nops.ja, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %8, i64 %idxprom
  %10 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %11 = bitcast %struct.bpf_insn* %ja to i8*
  %call = call i32 @memcmp(i8* noundef %10, i8* noundef %11, i64 noundef 8) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %i, align 4
  %call2 = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %12, i32 noundef %13, i32 noundef 1) #14
  store i32 %call2, i32* %err, align 4
  %14 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %14, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %15 = load i32, i32* %err, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %16 = load i32, i32* %insn_cnt, align 4
  %dec = add i32 %16, -1
  store i32 %dec, i32* %insn_cnt, align 4
  %17 = load i32, i32* %i, align 4
  %dec6 = add i32 %17, -1
  store i32 %dec6, i32* %i, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end5, %if.then
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %trap = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.sanitize_dead_code.trap, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %12 = load i32, i32* %seen, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %14 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %14 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %13, i64 %idx.ext
  %15 = bitcast %struct.bpf_insn* %add.ptr to i8*
  %16 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %15, i8* align 4 %16, i64 8, i1 false)
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %18 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %18 to i64
  %arrayidx3 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %17, i64 %idxprom2
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx3, i32 0, i32 5
  store i8 0, i8* %zext_dst, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ops = alloca %struct.bpf_verifier_ops*, align 8
  %i = alloca i32, align 4
  %cnt = alloca i32, align 4
  %size = alloca i32, align 4
  %ctx_field_size = alloca i32, align 4
  %delta = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %insn = alloca %struct.bpf_insn*, align 8
  %target_size = alloca i32, align 4
  %size_default = alloca i32, align 4
  %off = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %type = alloca i32, align 4
  %is_narrower_load = alloca i8, align 1
  %convert_ctx_access = alloca i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, align 8
  %ctx_access = alloca i8, align 1
  %patch = alloca [2 x %struct.bpf_insn], align 16
  %__size = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp213 = alloca i64, align 8
  %tmp220 = alloca i32, align 4
  %size_code = alloca i8, align 1
  %shift = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral311 = alloca %struct.bpf_insn, align 4
  %.compoundliteral335 = alloca %struct.bpf_insn, align 4
  %.compoundliteral356 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 3
  %1 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops1, align 8
  store %struct.bpf_verifier_ops* %1, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  %5 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %5, i32 0, i32 2
  %6 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %6, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 23
  %8 = load i8, i8* %seen_direct_write, align 1
  %tobool2 = trunc i8 %8 to i1
  br i1 %tobool2, label %if.then, label %if.end22

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue3 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 2
  %10 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue3, align 8
  %tobool4 = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %10, null
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %13 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue6 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %13, i32 0, i32 2
  %14 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue6, align 8
  %arraydecay = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 23
  %16 = load i8, i8* %seen_direct_write7, align 1
  %tobool8 = trunc i8 %16 to i1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  %call = call i32 %14(%struct.bpf_insn* noundef %arraydecay, i1 noundef zeroext %tobool8, %struct.bpf_prog* noundef %18) #14
  store i32 %call, i32* %cnt, align 4
  %19 = load i32, i32* %cnt, align 4
  %conv = sext i32 %19 to i64
  %cmp = icmp uge i64 %conv, 16
  br i1 %cmp, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %22 = load i32, i32* %cnt, align 4
  %tobool12 = icmp ne i32 %22, 0
  br i1 %tobool12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %if.else
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %arraydecay14 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %24 = load i32, i32* %cnt, align 4
  %call15 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %23, i32 noundef 0, %struct.bpf_insn* noundef %arraydecay14, i32 noundef %24) #14
  store %struct.bpf_prog* %call15, %struct.bpf_prog** %new_prog, align 8
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool16 = icmp ne %struct.bpf_prog* %25, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.then13
  store i32 -12, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then13
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  store %struct.bpf_prog* %26, %struct.bpf_prog** %prog19, align 8
  %28 = load i32, i32* %cnt, align 4
  %sub = sub i32 %28, 1
  %29 = load i32, i32* %delta, align 4
  %add = add i32 %29, %sub
  store i32 %add, i32* %delta, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %lor.lhs.false
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog23, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %31, i32 0, i32 10
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call24 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %32) #14
  br i1 %call24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end22
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 2
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog27, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 13
  %arraydecay28 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %35 = load i32, i32* %delta, align 4
  %idx.ext = sext i32 %35 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay28, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %36 = load i32, i32* %i, align 4
  %37 = load i32, i32* %insn_cnt, align 4
  %cmp29 = icmp slt i32 %36, %37
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 0
  %39 = load i8, i8* %code, align 4
  %conv31 = zext i8 %39 to i32
  %cmp32 = icmp eq i32 %conv31, 113
  br i1 %cmp32, label %if.then49, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %for.body
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 0
  %41 = load i8, i8* %code35, align 4
  %conv36 = zext i8 %41 to i32
  %cmp37 = icmp eq i32 %conv36, 105
  br i1 %cmp37, label %if.then49, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code40, align 4
  %conv41 = zext i8 %43 to i32
  %cmp42 = icmp eq i32 %conv41, 97
  br i1 %cmp42, label %if.then49, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false39
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code45 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 0
  %45 = load i8, i8* %code45, align 4
  %conv46 = zext i8 %45 to i32
  %cmp47 = icmp eq i32 %conv46, 121
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %lor.lhs.false44, %lor.lhs.false39, %lor.lhs.false34, %for.body
  store i32 1, i32* %type, align 4
  store i8 1, i8* %ctx_access, align 1
  br label %if.end97

if.else50:                                        ; preds = %lor.lhs.false44
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %47 to i32
  %cmp53 = icmp eq i32 %conv52, 115
  br i1 %cmp53, label %if.then90, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %if.else50
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 0
  %49 = load i8, i8* %code56, align 4
  %conv57 = zext i8 %49 to i32
  %cmp58 = icmp eq i32 %conv57, 107
  br i1 %cmp58, label %if.then90, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %lor.lhs.false55
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 0
  %51 = load i8, i8* %code61, align 4
  %conv62 = zext i8 %51 to i32
  %cmp63 = icmp eq i32 %conv62, 99
  br i1 %cmp63, label %if.then90, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %lor.lhs.false60
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 0
  %53 = load i8, i8* %code66, align 4
  %conv67 = zext i8 %53 to i32
  %cmp68 = icmp eq i32 %conv67, 123
  br i1 %cmp68, label %if.then90, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %lor.lhs.false65
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %54, i32 0, i32 0
  %55 = load i8, i8* %code71, align 4
  %conv72 = zext i8 %55 to i32
  %cmp73 = icmp eq i32 %conv72, 114
  br i1 %cmp73, label %if.then90, label %lor.lhs.false75

lor.lhs.false75:                                  ; preds = %lor.lhs.false70
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code76 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %56, i32 0, i32 0
  %57 = load i8, i8* %code76, align 4
  %conv77 = zext i8 %57 to i32
  %cmp78 = icmp eq i32 %conv77, 106
  br i1 %cmp78, label %if.then90, label %lor.lhs.false80

lor.lhs.false80:                                  ; preds = %lor.lhs.false75
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code81 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %58, i32 0, i32 0
  %59 = load i8, i8* %code81, align 4
  %conv82 = zext i8 %59 to i32
  %cmp83 = icmp eq i32 %conv82, 98
  br i1 %cmp83, label %if.then90, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %lor.lhs.false80
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 0
  %61 = load i8, i8* %code86, align 4
  %conv87 = zext i8 %61 to i32
  %cmp88 = icmp eq i32 %conv87, 122
  br i1 %cmp88, label %if.then90, label %if.else95

if.then90:                                        ; preds = %lor.lhs.false85, %lor.lhs.false80, %lor.lhs.false75, %lor.lhs.false70, %lor.lhs.false65, %lor.lhs.false60, %lor.lhs.false55, %if.else50
  store i32 2, i32* %type, align 4
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %62, i32 0, i32 0
  %63 = load i8, i8* %code91, align 4
  %conv92 = zext i8 %63 to i32
  %and = and i32 %conv92, 7
  %cmp93 = icmp eq i32 %and, 3
  %frombool = zext i1 %cmp93 to i8
  store i8 %frombool, i8* %ctx_access, align 1
  br label %if.end96

if.else95:                                        ; preds = %lor.lhs.false85
  br label %for.inc

if.end96:                                         ; preds = %if.then90
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.then49
  %64 = load i32, i32* %type, align 4
  %cmp98 = icmp eq i32 %64, 2
  br i1 %cmp98, label %land.lhs.true, label %if.end124

land.lhs.true:                                    ; preds = %if.end97
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %65, i32 0, i32 24
  %66 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %67 = load i32, i32* %i, align 4
  %68 = load i32, i32* %delta, align 4
  %add100 = add i32 %67, %68
  %idxprom = sext i32 %add100 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %66, i64 %idxprom
  %sanitize_stack_spill = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  %69 = load i8, i8* %sanitize_stack_spill, align 8
  %tobool101 = trunc i8 %69 to i1
  br i1 %tobool101, label %if.then103, label %if.end124

if.then103:                                       ; preds = %land.lhs.true
  %arrayinit.begin = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %70 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %71 = bitcast %struct.bpf_insn* %arrayinit.begin to i8*
  %72 = bitcast %struct.bpf_insn* %70 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 4 %72, i64 8, i1 false)
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 -62, i8* %code104, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg, align 1
  %bf.clear106 = and i8 %bf.load105, 15
  %bf.set107 = or i8 %bf.clear106, 0
  store i8 %bf.set107, i8* %src_reg, align 1
  %off108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 0, i16* %off108, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  store i32 2, i32* %cnt, align 4
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = load i32, i32* %i, align 4
  %75 = load i32, i32* %delta, align 4
  %add109 = add i32 %74, %75
  %arraydecay110 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %76 = load i32, i32* %cnt, align 4
  %call111 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %73, i32 noundef %add109, %struct.bpf_insn* noundef %arraydecay110, i32 noundef %76) #14
  store %struct.bpf_prog* %call111, %struct.bpf_prog** %new_prog, align 8
  %77 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool112 = icmp ne %struct.bpf_prog* %77, null
  br i1 %tobool112, label %if.end114, label %if.then113

if.then113:                                       ; preds = %if.then103
  store i32 -12, i32* %retval, align 4
  br label %return

if.end114:                                        ; preds = %if.then103
  %78 = load i32, i32* %cnt, align 4
  %sub115 = sub i32 %78, 1
  %79 = load i32, i32* %delta, align 4
  %add116 = add i32 %79, %sub115
  store i32 %add116, i32* %delta, align 4
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog117 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 2
  store %struct.bpf_prog* %80, %struct.bpf_prog** %prog117, align 8
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi118 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %82, i32 0, i32 13
  %arraydecay119 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi118, i64 0, i64 0
  %83 = load i32, i32* %i, align 4
  %idx.ext120 = sext i32 %83 to i64
  %add.ptr121 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay119, i64 %idx.ext120
  %84 = load i32, i32* %delta, align 4
  %idx.ext122 = sext i32 %84 to i64
  %add.ptr123 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr121, i64 %idx.ext122
  store %struct.bpf_insn* %add.ptr123, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end124:                                        ; preds = %land.lhs.true, %if.end97
  %85 = load i8, i8* %ctx_access, align 1
  %tobool125 = trunc i8 %85 to i1
  br i1 %tobool125, label %if.end127, label %if.then126

if.then126:                                       ; preds = %if.end124
  br label %for.inc

if.end127:                                        ; preds = %if.end124
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data128 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %86, i32 0, i32 24
  %87 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data128, align 8
  %88 = load i32, i32* %i, align 4
  %89 = load i32, i32* %delta, align 4
  %add129 = add i32 %88, %89
  %idxprom130 = sext i32 %add129 to i64
  %arrayidx131 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %87, i64 %idxprom130
  %90 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx131, i32 0, i32 0
  %ptr_type = bitcast %union.anon.163* %90 to i32*
  %91 = load i32, i32* %ptr_type, align 8
  switch i32 %91, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb137
    i32 13, label %sw.bb137
    i32 15, label %sw.bb138
    i32 18, label %sw.bb139
    i32 19, label %sw.bb140
  ]

sw.bb:                                            ; preds = %if.end127
  %92 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access132 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %92, i32 0, i32 4
  %93 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access132, align 8
  %tobool133 = icmp ne i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %93, null
  br i1 %tobool133, label %if.end135, label %if.then134

if.then134:                                       ; preds = %sw.bb
  br label %for.inc

if.end135:                                        ; preds = %sw.bb
  %94 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access136 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %94, i32 0, i32 4
  %95 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access136, align 8
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %95, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb137:                                         ; preds = %if.end127, %if.end127
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb138:                                         ; preds = %if.end127
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_tcp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb139:                                         ; preds = %if.end127
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_xdp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb140:                                         ; preds = %if.end127
  %96 = load i32, i32* %type, align 4
  %cmp141 = icmp eq i32 %96, 1
  br i1 %cmp141, label %if.then143, label %if.else151

if.then143:                                       ; preds = %sw.bb140
  %97 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code144 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %97, i32 0, i32 0
  %98 = load i8, i8* %code144, align 4
  %conv145 = zext i8 %98 to i32
  %and146 = and i32 %conv145, 24
  %or = or i32 33, %and146
  %conv147 = trunc i32 %or to i8
  %99 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code148 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %99, i32 0, i32 0
  store i8 %conv147, i8* %code148, align 4
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog149 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %100, i32 0, i32 2
  %101 = load %struct.bpf_prog*, %struct.bpf_prog** %prog149, align 8
  %aux150 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %101, i32 0, i32 10
  %102 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux150, align 8
  %num_exentries = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %102, i32 0, i32 55
  %103 = load i32, i32* %num_exentries, align 4
  %inc = add i32 %103, 1
  store i32 %inc, i32* %num_exentries, align 4
  br label %if.end158

if.else151:                                       ; preds = %sw.bb140
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog152 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %104, i32 0, i32 2
  %105 = load %struct.bpf_prog*, %struct.bpf_prog** %prog152, align 8
  %call153 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %105) #14
  %cmp154 = icmp ne i32 %call153, 27
  br i1 %cmp154, label %if.then156, label %if.end157

if.then156:                                       ; preds = %if.else151
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.443, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end157:                                        ; preds = %if.else151
  br label %if.end158

if.end158:                                        ; preds = %if.end157, %if.then143
  br label %for.inc

sw.default:                                       ; preds = %if.end127
  br label %for.inc

sw.epilog:                                        ; preds = %sw.bb139, %sw.bb138, %sw.bb137, %if.end135
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data159 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %108, i32 0, i32 24
  %109 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data159, align 8
  %110 = load i32, i32* %i, align 4
  %111 = load i32, i32* %delta, align 4
  %add160 = add i32 %110, %111
  %idxprom161 = sext i32 %add160 to i64
  %arrayidx162 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %109, i64 %idxprom161
  %ctx_field_size163 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx162, i32 0, i32 2
  %112 = load i32, i32* %ctx_field_size163, align 8
  store i32 %112, i32* %ctx_field_size, align 4
  store i32 -22, i32* %bytes, align 4
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code164 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %113, i32 0, i32 0
  %114 = load i8, i8* %code164, align 4
  %conv165 = zext i8 %114 to i32
  %and166 = and i32 %conv165, 24
  %cmp167 = icmp eq i32 %and166, 16
  br i1 %cmp167, label %if.then169, label %if.else170

if.then169:                                       ; preds = %sw.epilog
  store i32 1, i32* %bytes, align 4
  br label %if.end194

if.else170:                                       ; preds = %sw.epilog
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code171 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %115, i32 0, i32 0
  %116 = load i8, i8* %code171, align 4
  %conv172 = zext i8 %116 to i32
  %and173 = and i32 %conv172, 24
  %cmp174 = icmp eq i32 %and173, 8
  br i1 %cmp174, label %if.then176, label %if.else177

if.then176:                                       ; preds = %if.else170
  store i32 2, i32* %bytes, align 4
  br label %if.end193

if.else177:                                       ; preds = %if.else170
  %117 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code178 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %117, i32 0, i32 0
  %118 = load i8, i8* %code178, align 4
  %conv179 = zext i8 %118 to i32
  %and180 = and i32 %conv179, 24
  %cmp181 = icmp eq i32 %and180, 0
  br i1 %cmp181, label %if.then183, label %if.else184

if.then183:                                       ; preds = %if.else177
  store i32 4, i32* %bytes, align 4
  br label %if.end192

if.else184:                                       ; preds = %if.else177
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code185 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 0
  %120 = load i8, i8* %code185, align 4
  %conv186 = zext i8 %120 to i32
  %and187 = and i32 %conv186, 24
  %cmp188 = icmp eq i32 %and187, 24
  br i1 %cmp188, label %if.then190, label %if.end191

if.then190:                                       ; preds = %if.else184
  store i32 8, i32* %bytes, align 4
  br label %if.end191

if.end191:                                        ; preds = %if.then190, %if.else184
  br label %if.end192

if.end192:                                        ; preds = %if.end191, %if.then183
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.then176
  br label %if.end194

if.end194:                                        ; preds = %if.end193, %if.then169
  %121 = load i32, i32* %bytes, align 4
  store i32 %121, i32* %tmp, align 4
  %122 = load i32, i32* %tmp, align 4
  store i32 %122, i32* %__size, align 4
  %123 = load i32, i32* %__size, align 4
  %cmp195 = icmp slt i32 %123, 0
  %lnot = xor i1 %cmp195, true
  %lnot197 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot197 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %124 = load i32, i32* %__ret_warn_on, align 4
  %tobool198 = icmp ne i32 %124, 0
  %lnot199 = xor i1 %tobool198, true
  %lnot201 = xor i1 %lnot199, true
  %lnot.ext202 = zext i1 %lnot201 to i32
  %conv203 = sext i32 %lnot.ext202 to i64
  %tobool204 = icmp ne i64 %conv203, 0
  br i1 %tobool204, label %if.then205, label %if.end212

if.then205:                                       ; preds = %if.end194
  br label %do.body

do.body:                                          ; preds = %if.then205
  br label %do.body206

do.body206:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body206
  br label %do.body207

do.body207:                                       ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 14209, i32 2305, i64 12) #13, !srcloc !21
  br label %do.end208

do.end208:                                        ; preds = %do.body207
  call void asm sideeffect "553:\0A\09.pushsection .discard.reachable\0A\09.long 553b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !22
  br label %do.body209

do.body209:                                       ; preds = %do.end208
  br label %do.end210

do.end210:                                        ; preds = %do.body209
  br label %do.end211

do.end211:                                        ; preds = %do.end210
  br label %if.end212

if.end212:                                        ; preds = %do.end211, %if.end194
  %125 = load i32, i32* %__ret_warn_on, align 4
  %tobool214 = icmp ne i32 %125, 0
  %lnot215 = xor i1 %tobool214, true
  %lnot217 = xor i1 %lnot215, true
  %lnot.ext218 = zext i1 %lnot217 to i32
  %conv219 = sext i32 %lnot.ext218 to i64
  store i64 %conv219, i64* %tmp213, align 8
  %126 = load i64, i64* %tmp213, align 8
  %127 = load i32, i32* %__size, align 4
  store i32 %127, i32* %tmp220, align 4
  %128 = load i32, i32* %tmp220, align 4
  store i32 %128, i32* %size, align 4
  %129 = load i32, i32* %size, align 4
  %130 = load i32, i32* %ctx_field_size, align 4
  %cmp221 = icmp slt i32 %129, %130
  %frombool223 = zext i1 %cmp221 to i8
  store i8 %frombool223, i8* %is_narrower_load, align 1
  %131 = load i32, i32* %ctx_field_size, align 4
  %call224 = call i32 @bpf_ctx_off_adjust_machine(i32 noundef %131) #14
  store i32 %call224, i32* %size_default, align 4
  %132 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off225 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %132, i32 0, i32 2
  %133 = load i16, i16* %off225, align 2
  %conv226 = sext i16 %133 to i32
  store i32 %conv226, i32* %off, align 4
  %134 = load i8, i8* %is_narrower_load, align 1
  %tobool227 = trunc i8 %134 to i1
  br i1 %tobool227, label %if.then228, label %if.end250

if.then228:                                       ; preds = %if.end212
  %135 = load i32, i32* %type, align 4
  %cmp229 = icmp eq i32 %135, 2
  br i1 %cmp229, label %if.then231, label %if.end232

if.then231:                                       ; preds = %if.then228
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %137 = bitcast %struct.bpf_verifier_env* %136 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %137, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.444, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end232:                                        ; preds = %if.then228
  store i8 8, i8* %size_code, align 1
  %138 = load i32, i32* %ctx_field_size, align 4
  %cmp233 = icmp eq i32 %138, 4
  br i1 %cmp233, label %if.then235, label %if.else236

if.then235:                                       ; preds = %if.end232
  store i8 0, i8* %size_code, align 1
  br label %if.end241

if.else236:                                       ; preds = %if.end232
  %139 = load i32, i32* %ctx_field_size, align 4
  %cmp237 = icmp eq i32 %139, 8
  br i1 %cmp237, label %if.then239, label %if.end240

if.then239:                                       ; preds = %if.else236
  store i8 24, i8* %size_code, align 1
  br label %if.end240

if.end240:                                        ; preds = %if.then239, %if.else236
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.then235
  %140 = load i32, i32* %off, align 4
  %141 = load i32, i32* %size_default, align 4
  %sub242 = sub i32 %141, 1
  %neg = xor i32 %sub242, -1
  %and243 = and i32 %140, %neg
  %conv244 = trunc i32 %and243 to i16
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %142, i32 0, i32 2
  store i16 %conv244, i16* %off245, align 2
  %143 = load i8, i8* %size_code, align 1
  %conv246 = zext i8 %143 to i32
  %or247 = or i32 97, %conv246
  %conv248 = trunc i32 %or247 to i8
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code249 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %144, i32 0, i32 0
  store i8 %conv248, i8* %code249, align 4
  br label %if.end250

if.end250:                                        ; preds = %if.end241, %if.end212
  store i32 0, i32* %target_size, align 4
  %145 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  %146 = load i32, i32* %type, align 4
  %147 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay251 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog252 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %148, i32 0, i32 2
  %149 = load %struct.bpf_prog*, %struct.bpf_prog** %prog252, align 8
  %call253 = call i32 %145(i32 noundef %146, %struct.bpf_insn* noundef %147, %struct.bpf_insn* noundef %arraydecay251, %struct.bpf_prog* noundef %149, i32* noundef %target_size) #14
  store i32 %call253, i32* %cnt, align 4
  %150 = load i32, i32* %cnt, align 4
  %cmp254 = icmp eq i32 %150, 0
  br i1 %cmp254, label %if.then264, label %lor.lhs.false256

lor.lhs.false256:                                 ; preds = %if.end250
  %151 = load i32, i32* %cnt, align 4
  %conv257 = sext i32 %151 to i64
  %cmp258 = icmp uge i64 %conv257, 16
  br i1 %cmp258, label %if.then264, label %lor.lhs.false260

lor.lhs.false260:                                 ; preds = %lor.lhs.false256
  %152 = load i32, i32* %ctx_field_size, align 4
  %tobool261 = icmp ne i32 %152, 0
  br i1 %tobool261, label %land.lhs.true262, label %if.end265

land.lhs.true262:                                 ; preds = %lor.lhs.false260
  %153 = load i32, i32* %target_size, align 4
  %tobool263 = icmp ne i32 %153, 0
  br i1 %tobool263, label %if.end265, label %if.then264

if.then264:                                       ; preds = %land.lhs.true262, %lor.lhs.false256, %if.end250
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %155 = bitcast %struct.bpf_verifier_env* %154 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %155, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end265:                                        ; preds = %land.lhs.true262, %lor.lhs.false260
  %156 = load i8, i8* %is_narrower_load, align 1
  %tobool266 = trunc i8 %156 to i1
  br i1 %tobool266, label %land.lhs.true268, label %if.end377

land.lhs.true268:                                 ; preds = %if.end265
  %157 = load i32, i32* %size, align 4
  %158 = load i32, i32* %target_size, align 4
  %cmp269 = icmp ult i32 %157, %158
  br i1 %cmp269, label %if.then271, label %if.end377

if.then271:                                       ; preds = %land.lhs.true268
  %159 = load i32, i32* %off, align 4
  %160 = load i32, i32* %size, align 4
  %161 = load i32, i32* %size_default, align 4
  %call272 = call zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %159, i32 noundef %160, i32 noundef %161) #14
  %conv273 = zext i8 %call272 to i32
  %mul = mul i32 %conv273, 8
  %conv274 = trunc i32 %mul to i8
  store i8 %conv274, i8* %shift, align 1
  %162 = load i8, i8* %shift, align 1
  %conv275 = zext i8 %162 to i32
  %tobool276 = icmp ne i32 %conv275, 0
  br i1 %tobool276, label %land.lhs.true277, label %if.end283

land.lhs.true277:                                 ; preds = %if.then271
  %163 = load i32, i32* %cnt, align 4
  %add278 = add i32 %163, 1
  %conv279 = sext i32 %add278 to i64
  %cmp280 = icmp uge i64 %conv279, 16
  br i1 %cmp280, label %if.then282, label %if.end283

if.then282:                                       ; preds = %land.lhs.true277
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %165 = bitcast %struct.bpf_verifier_env* %164 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %165, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.445, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end283:                                        ; preds = %land.lhs.true277, %if.then271
  %166 = load i32, i32* %ctx_field_size, align 4
  %cmp284 = icmp sle i32 %166, 4
  br i1 %cmp284, label %if.then286, label %if.else329

if.then286:                                       ; preds = %if.end283
  %167 = load i8, i8* %shift, align 1
  %tobool287 = icmp ne i8 %167, 0
  br i1 %tobool287, label %if.then288, label %if.end307

if.then288:                                       ; preds = %if.then286
  %168 = load i32, i32* %cnt, align 4
  %inc289 = add i32 %168, 1
  store i32 %inc289, i32* %cnt, align 4
  %idxprom290 = sext i32 %168 to i64
  %arrayidx291 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom290
  %code292 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 116, i8* %code292, align 4
  %dst_reg293 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %169 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg294 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %169, i32 0, i32 1
  %bf.load295 = load i8, i8* %dst_reg294, align 1
  %bf.clear296 = and i8 %bf.load295, 15
  %bf.load297 = load i8, i8* %dst_reg293, align 1
  %bf.value = and i8 %bf.clear296, 15
  %bf.clear298 = and i8 %bf.load297, -16
  %bf.set299 = or i8 %bf.clear298, %bf.value
  store i8 %bf.set299, i8* %dst_reg293, align 1
  %src_reg300 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load301 = load i8, i8* %src_reg300, align 1
  %bf.clear302 = and i8 %bf.load301, 15
  %bf.set303 = or i8 %bf.clear302, 0
  store i8 %bf.set303, i8* %src_reg300, align 1
  %off304 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off304, align 2
  %imm305 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  %170 = load i8, i8* %shift, align 1
  %conv306 = zext i8 %170 to i32
  store i32 %conv306, i32* %imm305, align 4
  %171 = bitcast %struct.bpf_insn* %arrayidx291 to i8*
  %172 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %171, i8* align 4 %172, i64 8, i1 false)
  br label %if.end307

if.end307:                                        ; preds = %if.then288, %if.then286
  %173 = load i32, i32* %cnt, align 4
  %inc308 = add i32 %173, 1
  store i32 %inc308, i32* %cnt, align 4
  %idxprom309 = sext i32 %173 to i64
  %arrayidx310 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom309
  %code312 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 0
  store i8 84, i8* %code312, align 4
  %dst_reg313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 1
  %174 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg314 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %174, i32 0, i32 1
  %bf.load315 = load i8, i8* %dst_reg314, align 1
  %bf.clear316 = and i8 %bf.load315, 15
  %bf.load317 = load i8, i8* %dst_reg313, align 1
  %bf.value318 = and i8 %bf.clear316, 15
  %bf.clear319 = and i8 %bf.load317, -16
  %bf.set320 = or i8 %bf.clear319, %bf.value318
  store i8 %bf.set320, i8* %dst_reg313, align 1
  %src_reg321 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 1
  %bf.load322 = load i8, i8* %src_reg321, align 1
  %bf.clear323 = and i8 %bf.load322, 15
  %bf.set324 = or i8 %bf.clear323, 0
  store i8 %bf.set324, i8* %src_reg321, align 1
  %off325 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 2
  store i16 0, i16* %off325, align 2
  %imm326 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral311, i32 0, i32 3
  %175 = load i32, i32* %size, align 4
  %mul327 = mul i32 %175, 8
  %shl = shl i32 1, %mul327
  %sub328 = sub i32 %shl, 1
  store i32 %sub328, i32* %imm326, align 4
  %176 = bitcast %struct.bpf_insn* %arrayidx310 to i8*
  %177 = bitcast %struct.bpf_insn* %.compoundliteral311 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %176, i8* align 4 %177, i64 8, i1 false)
  br label %if.end376

if.else329:                                       ; preds = %if.end283
  %178 = load i8, i8* %shift, align 1
  %tobool330 = icmp ne i8 %178, 0
  br i1 %tobool330, label %if.then331, label %if.end352

if.then331:                                       ; preds = %if.else329
  %179 = load i32, i32* %cnt, align 4
  %inc332 = add i32 %179, 1
  store i32 %inc332, i32* %cnt, align 4
  %idxprom333 = sext i32 %179 to i64
  %arrayidx334 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom333
  %code336 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral335, i32 0, i32 0
  store i8 119, i8* %code336, align 4
  %dst_reg337 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral335, i32 0, i32 1
  %180 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg338 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %180, i32 0, i32 1
  %bf.load339 = load i8, i8* %dst_reg338, align 1
  %bf.clear340 = and i8 %bf.load339, 15
  %bf.load341 = load i8, i8* %dst_reg337, align 1
  %bf.value342 = and i8 %bf.clear340, 15
  %bf.clear343 = and i8 %bf.load341, -16
  %bf.set344 = or i8 %bf.clear343, %bf.value342
  store i8 %bf.set344, i8* %dst_reg337, align 1
  %src_reg345 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral335, i32 0, i32 1
  %bf.load346 = load i8, i8* %src_reg345, align 1
  %bf.clear347 = and i8 %bf.load346, 15
  %bf.set348 = or i8 %bf.clear347, 0
  store i8 %bf.set348, i8* %src_reg345, align 1
  %off349 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral335, i32 0, i32 2
  store i16 0, i16* %off349, align 2
  %imm350 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral335, i32 0, i32 3
  %181 = load i8, i8* %shift, align 1
  %conv351 = zext i8 %181 to i32
  store i32 %conv351, i32* %imm350, align 4
  %182 = bitcast %struct.bpf_insn* %arrayidx334 to i8*
  %183 = bitcast %struct.bpf_insn* %.compoundliteral335 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %182, i8* align 4 %183, i64 8, i1 false)
  br label %if.end352

if.end352:                                        ; preds = %if.then331, %if.else329
  %184 = load i32, i32* %cnt, align 4
  %inc353 = add i32 %184, 1
  store i32 %inc353, i32* %cnt, align 4
  %idxprom354 = sext i32 %184 to i64
  %arrayidx355 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom354
  %code357 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral356, i32 0, i32 0
  store i8 87, i8* %code357, align 4
  %dst_reg358 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral356, i32 0, i32 1
  %185 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg359 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %185, i32 0, i32 1
  %bf.load360 = load i8, i8* %dst_reg359, align 1
  %bf.clear361 = and i8 %bf.load360, 15
  %bf.load362 = load i8, i8* %dst_reg358, align 1
  %bf.value363 = and i8 %bf.clear361, 15
  %bf.clear364 = and i8 %bf.load362, -16
  %bf.set365 = or i8 %bf.clear364, %bf.value363
  store i8 %bf.set365, i8* %dst_reg358, align 1
  %src_reg366 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral356, i32 0, i32 1
  %bf.load367 = load i8, i8* %src_reg366, align 1
  %bf.clear368 = and i8 %bf.load367, 15
  %bf.set369 = or i8 %bf.clear368, 0
  store i8 %bf.set369, i8* %src_reg366, align 1
  %off370 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral356, i32 0, i32 2
  store i16 0, i16* %off370, align 2
  %imm371 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral356, i32 0, i32 3
  %186 = load i32, i32* %size, align 4
  %mul372 = mul i32 %186, 8
  %sh_prom = zext i32 %mul372 to i64
  %shl373 = shl i64 1, %sh_prom
  %sub374 = sub i64 %shl373, 1
  %conv375 = trunc i64 %sub374 to i32
  store i32 %conv375, i32* %imm371, align 4
  %187 = bitcast %struct.bpf_insn* %arrayidx355 to i8*
  %188 = bitcast %struct.bpf_insn* %.compoundliteral356 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %187, i8* align 4 %188, i64 8, i1 false)
  br label %if.end376

if.end376:                                        ; preds = %if.end352, %if.end307
  br label %if.end377

if.end377:                                        ; preds = %if.end376, %land.lhs.true268, %if.end265
  %189 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %190 = load i32, i32* %i, align 4
  %191 = load i32, i32* %delta, align 4
  %add378 = add i32 %190, %191
  %arraydecay379 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %192 = load i32, i32* %cnt, align 4
  %call380 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %189, i32 noundef %add378, %struct.bpf_insn* noundef %arraydecay379, i32 noundef %192) #14
  store %struct.bpf_prog* %call380, %struct.bpf_prog** %new_prog, align 8
  %193 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool381 = icmp ne %struct.bpf_prog* %193, null
  br i1 %tobool381, label %if.end383, label %if.then382

if.then382:                                       ; preds = %if.end377
  store i32 -12, i32* %retval, align 4
  br label %return

if.end383:                                        ; preds = %if.end377
  %194 = load i32, i32* %cnt, align 4
  %sub384 = sub i32 %194, 1
  %195 = load i32, i32* %delta, align 4
  %add385 = add i32 %195, %sub384
  store i32 %add385, i32* %delta, align 4
  %196 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %197 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog386 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %197, i32 0, i32 2
  store %struct.bpf_prog* %196, %struct.bpf_prog** %prog386, align 8
  %198 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi387 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %198, i32 0, i32 13
  %arraydecay388 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi387, i64 0, i64 0
  %199 = load i32, i32* %i, align 4
  %idx.ext389 = sext i32 %199 to i64
  %add.ptr390 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay388, i64 %idx.ext389
  %200 = load i32, i32* %delta, align 4
  %idx.ext391 = sext i32 %200 to i64
  %add.ptr392 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr390, i64 %idx.ext391
  store %struct.bpf_insn* %add.ptr392, %struct.bpf_insn** %insn, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end383, %sw.default, %if.end158, %if.then134, %if.then126, %if.end114, %if.else95
  %201 = load i32, i32* %i, align 4
  %inc393 = add i32 %201, 1
  store i32 %inc393, i32* %i, align 4
  %202 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %202, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then382, %if.then282, %if.then264, %if.then231, %if.then156, %if.then113, %if.then25, %if.then17, %if.then11, %if.then5
  %203 = load i32, i32* %retval, align 4
  ret i32 %203
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_misc_fixups(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %expect_blinding = alloca i8, align 1
  %prog_type = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %fn = alloca %struct.bpf_func_proto*, align 8
  %insn_cnt = alloca i32, align 4
  %ops = alloca %struct.bpf_map_ops*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %new_prog = alloca %struct.bpf_prog*, align 8
  %map_ptr = alloca %struct.bpf_map*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %cnt = alloca i32, align 4
  %delta = alloca i32, align 4
  %is64 = alloca i8, align 1
  %isdiv = alloca i8, align 1
  %patchlet = alloca %struct.bpf_insn*, align 8
  %chk_and_div = alloca [4 x %struct.bpf_insn], align 16
  %chk_and_mod = alloca [4 x %struct.bpf_insn], align 16
  %code_add = alloca i8, align 1
  %code_sub = alloca i8, align 1
  %patch = alloca %struct.bpf_insn*, align 8
  %issrc = alloca i8, align 1
  %isneg = alloca i8, align 1
  %isimm = alloca i8, align 1
  %off_reg = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral269 = alloca %struct.bpf_insn, align 4
  %.compoundliteral285 = alloca %struct.bpf_insn, align 4
  %.compoundliteral299 = alloca %struct.bpf_insn, align 4
  %.compoundliteral315 = alloca %struct.bpf_insn, align 4
  %.compoundliteral331 = alloca %struct.bpf_insn, align 4
  %.compoundliteral344 = alloca %struct.bpf_insn, align 4
  %.compoundliteral357 = alloca %struct.bpf_insn, align 4
  %.compoundliteral376 = alloca %struct.bpf_insn, align 4
  %.compoundliteral422 = alloca %struct.bpf_insn, align 4
  %desc = alloca %struct.bpf_jit_poke_descriptor, align 8
  %.compoundliteral559 = alloca %struct.bpf_insn, align 4
  %.compoundliteral572 = alloca %struct.bpf_insn, align 4
  %__mptr = alloca i8*, align 8
  %tmp = alloca %struct.bpf_array*, align 8
  %ld_addrs = alloca [2 x %struct.bpf_insn], align 16
  %ld_jiffies_addr = alloca [2 x %struct.bpf_insn], align 16
  %.compoundliteral827 = alloca %struct.bpf_insn, align 4
  %.compoundliteral863 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 @bpf_jit_blinding_enabled(%struct.bpf_prog* noundef %2) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %expect_blinding, align 1
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call2 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %3) #14
  store i32 %call2, i32* %prog_type, align 4
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 4
  %6 = load i32, i32* %len, align 4
  store i32 %6, i32* %insn_cnt, align 4
  store i32 0, i32* %delta, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code, align 4
  %conv = zext i8 %10 to i32
  %cmp3 = icmp eq i32 %conv, 159
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 0
  %12 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %12 to i32
  %cmp7 = icmp eq i32 %conv6, 63
  br i1 %cmp7, label %if.then, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code10 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code10, align 4
  %conv11 = zext i8 %14 to i32
  %cmp12 = icmp eq i32 %conv11, 156
  br i1 %cmp12, label %if.then, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %lor.lhs.false9
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code15 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code15, align 4
  %conv16 = zext i8 %16 to i32
  %cmp17 = icmp eq i32 %conv16, 60
  br i1 %cmp17, label %if.then, label %if.end158

if.then:                                          ; preds = %lor.lhs.false14, %lor.lhs.false9, %lor.lhs.false, %for.body
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 0
  %18 = load i8, i8* %code19, align 4
  %conv20 = zext i8 %18 to i32
  %and = and i32 %conv20, 7
  %cmp21 = icmp eq i32 %and, 7
  %frombool23 = zext i1 %cmp21 to i8
  store i8 %frombool23, i8* %is64, align 1
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 0
  %20 = load i8, i8* %code24, align 4
  %conv25 = zext i8 %20 to i32
  %and26 = and i32 %conv25, 240
  %cmp27 = icmp eq i32 %and26, 48
  %frombool29 = zext i1 %cmp27 to i8
  store i8 %frombool29, i8* %isdiv, align 1
  %arrayinit.begin = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_div, i64 0, i64 0
  %code30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  %21 = load i8, i8* %is64, align 1
  %tobool = trunc i8 %21 to i1
  %22 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 5, i32 6
  %or = or i32 %cond, 80
  %or32 = or i32 %or, 0
  %conv33 = trunc i32 %or32 to i8
  store i8 %conv33, i8* %code30, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.load34 = load i8, i8* %dst_reg, align 1
  %bf.value = and i8 %bf.lshr, 15
  %bf.clear = and i8 %bf.load34, -16
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load36 = load i8, i8* %src_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, 15
  %bf.set38 = or i8 %bf.clear37, 0
  store i8 %bf.set38, i8* %src_reg35, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  store i16 2, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 -84, i8* %code39, align 8
  %dst_reg40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg41 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load42 = load i8, i8* %dst_reg41, align 1
  %bf.clear43 = and i8 %bf.load42, 15
  %bf.load44 = load i8, i8* %dst_reg40, align 1
  %bf.value45 = and i8 %bf.clear43, 15
  %bf.clear46 = and i8 %bf.load44, -16
  %bf.set47 = or i8 %bf.clear46, %bf.value45
  store i8 %bf.set47, i8* %dst_reg40, align 1
  %src_reg48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg49 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %25, i32 0, i32 1
  %bf.load50 = load i8, i8* %dst_reg49, align 1
  %bf.clear51 = and i8 %bf.load50, 15
  %bf.load52 = load i8, i8* %src_reg48, align 1
  %bf.value53 = and i8 %bf.clear51, 15
  %bf.shl = shl i8 %bf.value53, 4
  %bf.clear54 = and i8 %bf.load52, 15
  %bf.set55 = or i8 %bf.clear54, %bf.shl
  store i8 %bf.set55, i8* %src_reg48, align 1
  %off56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 0, i16* %off56, align 2
  %imm57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 0, i32* %imm57, align 4
  %arrayinit.element58 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i64 1
  %code59 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element58, i32 0, i32 0
  store i8 5, i8* %code59, align 8
  %dst_reg60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element58, i32 0, i32 1
  %bf.load61 = load i8, i8* %dst_reg60, align 1
  %bf.clear62 = and i8 %bf.load61, -16
  %bf.set63 = or i8 %bf.clear62, 0
  store i8 %bf.set63, i8* %dst_reg60, align 1
  %src_reg64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element58, i32 0, i32 1
  %bf.load65 = load i8, i8* %src_reg64, align 1
  %bf.clear66 = and i8 %bf.load65, 15
  %bf.set67 = or i8 %bf.clear66, 0
  store i8 %bf.set67, i8* %src_reg64, align 1
  %off68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element58, i32 0, i32 2
  store i16 1, i16* %off68, align 2
  %imm69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element58, i32 0, i32 3
  store i32 0, i32* %imm69, align 4
  %arrayinit.element70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element58, i64 1
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %27 = bitcast %struct.bpf_insn* %arrayinit.element70 to i8*
  %28 = bitcast %struct.bpf_insn* %26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 4 %28, i64 8, i1 false)
  %arrayinit.begin71 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_mod, i64 0, i64 0
  %code72 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin71, i32 0, i32 0
  %29 = load i8, i8* %is64, align 1
  %tobool73 = trunc i8 %29 to i1
  %30 = zext i1 %tobool73 to i64
  %cond75 = select i1 %tobool73, i32 5, i32 6
  %or76 = or i32 %cond75, 16
  %or77 = or i32 %or76, 0
  %conv78 = trunc i32 %or77 to i8
  store i8 %conv78, i8* %code72, align 8
  %dst_reg79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin71, i32 0, i32 1
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg80 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load81 = load i8, i8* %src_reg80, align 1
  %bf.lshr82 = lshr i8 %bf.load81, 4
  %bf.load83 = load i8, i8* %dst_reg79, align 1
  %bf.value84 = and i8 %bf.lshr82, 15
  %bf.clear85 = and i8 %bf.load83, -16
  %bf.set86 = or i8 %bf.clear85, %bf.value84
  store i8 %bf.set86, i8* %dst_reg79, align 1
  %src_reg87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin71, i32 0, i32 1
  %bf.load88 = load i8, i8* %src_reg87, align 1
  %bf.clear89 = and i8 %bf.load88, 15
  %bf.set90 = or i8 %bf.clear89, 0
  store i8 %bf.set90, i8* %src_reg87, align 1
  %off91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin71, i32 0, i32 2
  %32 = load i8, i8* %is64, align 1
  %tobool92 = trunc i8 %32 to i1
  %33 = zext i1 %tobool92 to i64
  %cond94 = select i1 %tobool92, i32 0, i32 1
  %add = add i32 1, %cond94
  %conv95 = trunc i32 %add to i16
  store i16 %conv95, i16* %off91, align 2
  %imm96 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin71, i32 0, i32 3
  store i32 0, i32* %imm96, align 4
  %arrayinit.element97 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin71, i64 1
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %35 = bitcast %struct.bpf_insn* %arrayinit.element97 to i8*
  %36 = bitcast %struct.bpf_insn* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 4 %36, i64 8, i1 false)
  %arrayinit.element98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element97, i64 1
  %code99 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element98, i32 0, i32 0
  store i8 5, i8* %code99, align 8
  %dst_reg100 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element98, i32 0, i32 1
  %bf.load101 = load i8, i8* %dst_reg100, align 1
  %bf.clear102 = and i8 %bf.load101, -16
  %bf.set103 = or i8 %bf.clear102, 0
  store i8 %bf.set103, i8* %dst_reg100, align 1
  %src_reg104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element98, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg104, align 1
  %bf.clear106 = and i8 %bf.load105, 15
  %bf.set107 = or i8 %bf.clear106, 0
  store i8 %bf.set107, i8* %src_reg104, align 1
  %off108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element98, i32 0, i32 2
  store i16 1, i16* %off108, align 2
  %imm109 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element98, i32 0, i32 3
  store i32 0, i32* %imm109, align 4
  %arrayinit.element110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element98, i64 1
  %code111 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element110, i32 0, i32 0
  store i8 -68, i8* %code111, align 8
  %dst_reg112 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element110, i32 0, i32 1
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %37, i32 0, i32 1
  %bf.load114 = load i8, i8* %dst_reg113, align 1
  %bf.clear115 = and i8 %bf.load114, 15
  %bf.load116 = load i8, i8* %dst_reg112, align 1
  %bf.value117 = and i8 %bf.clear115, 15
  %bf.clear118 = and i8 %bf.load116, -16
  %bf.set119 = or i8 %bf.clear118, %bf.value117
  store i8 %bf.set119, i8* %dst_reg112, align 1
  %src_reg120 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element110, i32 0, i32 1
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg121 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load122 = load i8, i8* %dst_reg121, align 1
  %bf.clear123 = and i8 %bf.load122, 15
  %bf.load124 = load i8, i8* %src_reg120, align 1
  %bf.value125 = and i8 %bf.clear123, 15
  %bf.shl126 = shl i8 %bf.value125, 4
  %bf.clear127 = and i8 %bf.load124, 15
  %bf.set128 = or i8 %bf.clear127, %bf.shl126
  store i8 %bf.set128, i8* %src_reg120, align 1
  %off129 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element110, i32 0, i32 2
  store i16 0, i16* %off129, align 2
  %imm130 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element110, i32 0, i32 3
  store i32 0, i32* %imm130, align 4
  %39 = load i8, i8* %isdiv, align 1
  %tobool131 = trunc i8 %39 to i1
  br i1 %tobool131, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %arraydecay133 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_div, i64 0, i64 0
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %arraydecay134 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_mod, i64 0, i64 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond135 = phi %struct.bpf_insn* [ %arraydecay133, %cond.true ], [ %arraydecay134, %cond.false ]
  store %struct.bpf_insn* %cond135, %struct.bpf_insn** %patchlet, align 8
  %40 = load i8, i8* %isdiv, align 1
  %tobool136 = trunc i8 %40 to i1
  br i1 %tobool136, label %cond.true138, label %cond.false139

cond.true138:                                     ; preds = %cond.end
  br label %cond.end144

cond.false139:                                    ; preds = %cond.end
  %41 = load i8, i8* %is64, align 1
  %tobool140 = trunc i8 %41 to i1
  %42 = zext i1 %tobool140 to i64
  %cond142 = select i1 %tobool140, i32 2, i32 0
  %conv143 = sext i32 %cond142 to i64
  %sub = sub i64 4, %conv143
  br label %cond.end144

cond.end144:                                      ; preds = %cond.false139, %cond.true138
  %cond145 = phi i64 [ 4, %cond.true138 ], [ %sub, %cond.false139 ]
  %conv146 = trunc i64 %cond145 to i32
  store i32 %conv146, i32* %cnt, align 4
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* %delta, align 4
  %add147 = add i32 %44, %45
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %patchlet, align 8
  %47 = load i32, i32* %cnt, align 4
  %call148 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %43, i32 noundef %add147, %struct.bpf_insn* noundef %46, i32 noundef %47) #14
  store %struct.bpf_prog* %call148, %struct.bpf_prog** %new_prog, align 8
  %48 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool149 = icmp ne %struct.bpf_prog* %48, null
  br i1 %tobool149, label %if.end, label %if.then150

if.then150:                                       ; preds = %cond.end144
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end144
  %49 = load i32, i32* %cnt, align 4
  %sub151 = sub i32 %49, 1
  %50 = load i32, i32* %delta, align 4
  %add152 = add i32 %50, %sub151
  store i32 %add152, i32* %delta, align 4
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %51, %struct.bpf_prog** %prog, align 8
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog153 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %52, i32 0, i32 2
  store %struct.bpf_prog* %51, %struct.bpf_prog** %prog153, align 8
  %53 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi154 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %53, i32 0, i32 13
  %arraydecay155 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi154, i64 0, i64 0
  %54 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %54 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay155, i64 %idx.ext
  %55 = load i32, i32* %delta, align 4
  %idx.ext156 = sext i32 %55 to i64
  %add.ptr157 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext156
  store %struct.bpf_insn* %add.ptr157, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end158:                                        ; preds = %lor.lhs.false14
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code159 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %56, i32 0, i32 0
  %57 = load i8, i8* %code159, align 4
  %conv160 = zext i8 %57 to i32
  %and161 = and i32 %conv160, 7
  %cmp162 = icmp eq i32 %and161, 0
  br i1 %cmp162, label %land.lhs.true, label %if.end202

land.lhs.true:                                    ; preds = %if.end158
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code164 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %58, i32 0, i32 0
  %59 = load i8, i8* %code164, align 4
  %conv165 = zext i8 %59 to i32
  %and166 = and i32 %conv165, 224
  %cmp167 = icmp eq i32 %and166, 32
  br i1 %cmp167, label %if.then175, label %lor.lhs.false169

lor.lhs.false169:                                 ; preds = %land.lhs.true
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code170 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 0
  %61 = load i8, i8* %code170, align 4
  %conv171 = zext i8 %61 to i32
  %and172 = and i32 %conv171, 224
  %cmp173 = icmp eq i32 %and172, 64
  br i1 %cmp173, label %if.then175, label %if.end202

if.then175:                                       ; preds = %lor.lhs.false169, %land.lhs.true
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops176 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %62, i32 0, i32 3
  %63 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops176, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %63, i32 0, i32 3
  %64 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %65 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay177 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call178 = call i32 %64(%struct.bpf_insn* noundef %65, %struct.bpf_insn* noundef %arraydecay177) #14
  store i32 %call178, i32* %cnt, align 4
  %66 = load i32, i32* %cnt, align 4
  %cmp179 = icmp eq i32 %66, 0
  br i1 %cmp179, label %if.then185, label %lor.lhs.false181

lor.lhs.false181:                                 ; preds = %if.then175
  %67 = load i32, i32* %cnt, align 4
  %conv182 = sext i32 %67 to i64
  %cmp183 = icmp uge i64 %conv182, 16
  br i1 %cmp183, label %if.then185, label %if.end186

if.then185:                                       ; preds = %lor.lhs.false181, %if.then175
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = bitcast %struct.bpf_verifier_env* %68 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %69, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end186:                                        ; preds = %lor.lhs.false181
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load i32, i32* %i, align 4
  %72 = load i32, i32* %delta, align 4
  %add187 = add i32 %71, %72
  %arraydecay188 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %73 = load i32, i32* %cnt, align 4
  %call189 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %70, i32 noundef %add187, %struct.bpf_insn* noundef %arraydecay188, i32 noundef %73) #14
  store %struct.bpf_prog* %call189, %struct.bpf_prog** %new_prog, align 8
  %74 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool190 = icmp ne %struct.bpf_prog* %74, null
  br i1 %tobool190, label %if.end192, label %if.then191

if.then191:                                       ; preds = %if.end186
  store i32 -12, i32* %retval, align 4
  br label %return

if.end192:                                        ; preds = %if.end186
  %75 = load i32, i32* %cnt, align 4
  %sub193 = sub i32 %75, 1
  %76 = load i32, i32* %delta, align 4
  %add194 = add i32 %76, %sub193
  store i32 %add194, i32* %delta, align 4
  %77 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %77, %struct.bpf_prog** %prog, align 8
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog195 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 2
  store %struct.bpf_prog* %77, %struct.bpf_prog** %prog195, align 8
  %79 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi196 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %79, i32 0, i32 13
  %arraydecay197 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi196, i64 0, i64 0
  %80 = load i32, i32* %i, align 4
  %idx.ext198 = sext i32 %80 to i64
  %add.ptr199 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay197, i64 %idx.ext198
  %81 = load i32, i32* %delta, align 4
  %idx.ext200 = sext i32 %81 to i64
  %add.ptr201 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr199, i64 %idx.ext200
  store %struct.bpf_insn* %add.ptr201, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end202:                                        ; preds = %lor.lhs.false169, %if.end158
  %82 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %82, i32 0, i32 0
  %83 = load i8, i8* %code203, align 4
  %conv204 = zext i8 %83 to i32
  %cmp205 = icmp eq i32 %conv204, 15
  br i1 %cmp205, label %if.then212, label %lor.lhs.false207

lor.lhs.false207:                                 ; preds = %if.end202
  %84 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code208 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %84, i32 0, i32 0
  %85 = load i8, i8* %code208, align 4
  %conv209 = zext i8 %85 to i32
  %cmp210 = icmp eq i32 %conv209, 31
  br i1 %cmp210, label %if.then212, label %if.end454

if.then212:                                       ; preds = %lor.lhs.false207, %if.end202
  store i8 15, i8* %code_add, align 1
  store i8 31, i8* %code_sub, align 1
  %arrayidx = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %patch, align 8
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %86, i32 0, i32 24
  %87 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %88 = load i32, i32* %i, align 4
  %89 = load i32, i32* %delta, align 4
  %add213 = add i32 %88, %89
  %idxprom = sext i32 %add213 to i64
  %arrayidx214 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %87, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx214, %struct.bpf_insn_aux_data** %aux, align 8
  %90 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %90, i32 0, i32 6
  %91 = load i8, i8* %alu_state, align 2
  %tobool215 = icmp ne i8 %91, 0
  br i1 %tobool215, label %lor.lhs.false216, label %if.then221

lor.lhs.false216:                                 ; preds = %if.then212
  %92 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state217 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %92, i32 0, i32 6
  %93 = load i8, i8* %alu_state217, align 2
  %conv218 = zext i8 %93 to i32
  %cmp219 = icmp eq i32 %conv218, 8
  br i1 %cmp219, label %if.then221, label %if.end222

if.then221:                                       ; preds = %lor.lhs.false216, %if.then212
  br label %for.inc

if.end222:                                        ; preds = %lor.lhs.false216
  %94 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state223 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %94, i32 0, i32 6
  %95 = load i8, i8* %alu_state223, align 2
  %conv224 = zext i8 %95 to i32
  %and225 = and i32 %conv224, 4
  %tobool226 = icmp ne i32 %and225, 0
  %frombool227 = zext i1 %tobool226 to i8
  store i8 %frombool227, i8* %isneg, align 1
  %96 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state228 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %96, i32 0, i32 6
  %97 = load i8, i8* %alu_state228, align 2
  %conv229 = zext i8 %97 to i32
  %and230 = and i32 %conv229, 3
  %cmp231 = icmp eq i32 %and230, 1
  %frombool233 = zext i1 %cmp231 to i8
  store i8 %frombool233, i8* %issrc, align 1
  %98 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state234 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %98, i32 0, i32 6
  %99 = load i8, i8* %alu_state234, align 2
  %conv235 = zext i8 %99 to i32
  %and236 = and i32 %conv235, 16
  %tobool237 = icmp ne i32 %and236, 0
  %frombool238 = zext i1 %tobool237 to i8
  store i8 %frombool238, i8* %isimm, align 1
  %100 = load i8, i8* %issrc, align 1
  %tobool239 = trunc i8 %100 to i1
  br i1 %tobool239, label %cond.true241, label %cond.false246

cond.true241:                                     ; preds = %if.end222
  %101 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg242 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %101, i32 0, i32 1
  %bf.load243 = load i8, i8* %src_reg242, align 1
  %bf.lshr244 = lshr i8 %bf.load243, 4
  %conv245 = zext i8 %bf.lshr244 to i32
  br label %cond.end251

cond.false246:                                    ; preds = %if.end222
  %102 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg247 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %102, i32 0, i32 1
  %bf.load248 = load i8, i8* %dst_reg247, align 1
  %bf.clear249 = and i8 %bf.load248, 15
  %conv250 = zext i8 %bf.clear249 to i32
  br label %cond.end251

cond.end251:                                      ; preds = %cond.false246, %cond.true241
  %cond252 = phi i32 [ %conv245, %cond.true241 ], [ %conv250, %cond.false246 ]
  store i32 %cond252, i32* %off_reg, align 4
  %103 = load i8, i8* %isimm, align 1
  %tobool253 = trunc i8 %103 to i1
  br i1 %tobool253, label %if.then254, label %if.else

if.then254:                                       ; preds = %cond.end251
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %104, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %patch, align 8
  %code255 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -76, i8* %code255, align 4
  %dst_reg256 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load257 = load i8, i8* %dst_reg256, align 1
  %bf.clear258 = and i8 %bf.load257, -16
  %bf.set259 = or i8 %bf.clear258, 11
  store i8 %bf.set259, i8* %dst_reg256, align 1
  %src_reg260 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load261 = load i8, i8* %src_reg260, align 1
  %bf.clear262 = and i8 %bf.load261, 15
  %bf.set263 = or i8 %bf.clear262, 0
  store i8 %bf.set263, i8* %src_reg260, align 1
  %off264 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off264, align 2
  %imm265 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  %105 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %106 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %105, i32 0, i32 0
  %alu_limit = bitcast %union.anon.163* %106 to i32*
  %107 = load i32, i32* %alu_limit, align 8
  store i32 %107, i32* %imm265, align 4
  %108 = bitcast %struct.bpf_insn* %104 to i8*
  %109 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %108, i8* align 4 %109, i64 8, i1 false)
  br label %if.end372

if.else:                                          ; preds = %cond.end251
  %110 = load i8, i8* %isneg, align 1
  %tobool266 = trunc i8 %110 to i1
  br i1 %tobool266, label %if.then267, label %if.end283

if.then267:                                       ; preds = %if.else
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr268 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %111, i32 1
  store %struct.bpf_insn* %incdec.ptr268, %struct.bpf_insn** %patch, align 8
  %code270 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral269, i32 0, i32 0
  store i8 39, i8* %code270, align 4
  %dst_reg271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral269, i32 0, i32 1
  %112 = load i32, i32* %off_reg, align 4
  %conv272 = trunc i32 %112 to i8
  %bf.load273 = load i8, i8* %dst_reg271, align 1
  %bf.value274 = and i8 %conv272, 15
  %bf.clear275 = and i8 %bf.load273, -16
  %bf.set276 = or i8 %bf.clear275, %bf.value274
  store i8 %bf.set276, i8* %dst_reg271, align 1
  %src_reg277 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral269, i32 0, i32 1
  %bf.load278 = load i8, i8* %src_reg277, align 1
  %bf.clear279 = and i8 %bf.load278, 15
  %bf.set280 = or i8 %bf.clear279, 0
  store i8 %bf.set280, i8* %src_reg277, align 1
  %off281 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral269, i32 0, i32 2
  store i16 0, i16* %off281, align 2
  %imm282 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral269, i32 0, i32 3
  store i32 -1, i32* %imm282, align 4
  %113 = bitcast %struct.bpf_insn* %111 to i8*
  %114 = bitcast %struct.bpf_insn* %.compoundliteral269 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %113, i8* align 4 %114, i64 8, i1 false)
  br label %if.end283

if.end283:                                        ; preds = %if.then267, %if.else
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr284 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %115, i32 1
  store %struct.bpf_insn* %incdec.ptr284, %struct.bpf_insn** %patch, align 8
  %code286 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral285, i32 0, i32 0
  store i8 -76, i8* %code286, align 4
  %dst_reg287 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral285, i32 0, i32 1
  %bf.load288 = load i8, i8* %dst_reg287, align 1
  %bf.clear289 = and i8 %bf.load288, -16
  %bf.set290 = or i8 %bf.clear289, 11
  store i8 %bf.set290, i8* %dst_reg287, align 1
  %src_reg291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral285, i32 0, i32 1
  %bf.load292 = load i8, i8* %src_reg291, align 1
  %bf.clear293 = and i8 %bf.load292, 15
  %bf.set294 = or i8 %bf.clear293, 0
  store i8 %bf.set294, i8* %src_reg291, align 1
  %off295 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral285, i32 0, i32 2
  store i16 0, i16* %off295, align 2
  %imm296 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral285, i32 0, i32 3
  %116 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %117 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %116, i32 0, i32 0
  %alu_limit297 = bitcast %union.anon.163* %117 to i32*
  %118 = load i32, i32* %alu_limit297, align 8
  store i32 %118, i32* %imm296, align 4
  %119 = bitcast %struct.bpf_insn* %115 to i8*
  %120 = bitcast %struct.bpf_insn* %.compoundliteral285 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %119, i8* align 4 %120, i64 8, i1 false)
  %121 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr298 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %121, i32 1
  store %struct.bpf_insn* %incdec.ptr298, %struct.bpf_insn** %patch, align 8
  %code300 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral299, i32 0, i32 0
  store i8 31, i8* %code300, align 4
  %dst_reg301 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral299, i32 0, i32 1
  %bf.load302 = load i8, i8* %dst_reg301, align 1
  %bf.clear303 = and i8 %bf.load302, -16
  %bf.set304 = or i8 %bf.clear303, 11
  store i8 %bf.set304, i8* %dst_reg301, align 1
  %src_reg305 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral299, i32 0, i32 1
  %122 = load i32, i32* %off_reg, align 4
  %conv306 = trunc i32 %122 to i8
  %bf.load307 = load i8, i8* %src_reg305, align 1
  %bf.value308 = and i8 %conv306, 15
  %bf.shl309 = shl i8 %bf.value308, 4
  %bf.clear310 = and i8 %bf.load307, 15
  %bf.set311 = or i8 %bf.clear310, %bf.shl309
  store i8 %bf.set311, i8* %src_reg305, align 1
  %off312 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral299, i32 0, i32 2
  store i16 0, i16* %off312, align 2
  %imm313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral299, i32 0, i32 3
  store i32 0, i32* %imm313, align 4
  %123 = bitcast %struct.bpf_insn* %121 to i8*
  %124 = bitcast %struct.bpf_insn* %.compoundliteral299 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %123, i8* align 4 %124, i64 8, i1 false)
  %125 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr314 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %125, i32 1
  store %struct.bpf_insn* %incdec.ptr314, %struct.bpf_insn** %patch, align 8
  %code316 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral315, i32 0, i32 0
  store i8 79, i8* %code316, align 4
  %dst_reg317 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral315, i32 0, i32 1
  %bf.load318 = load i8, i8* %dst_reg317, align 1
  %bf.clear319 = and i8 %bf.load318, -16
  %bf.set320 = or i8 %bf.clear319, 11
  store i8 %bf.set320, i8* %dst_reg317, align 1
  %src_reg321 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral315, i32 0, i32 1
  %126 = load i32, i32* %off_reg, align 4
  %conv322 = trunc i32 %126 to i8
  %bf.load323 = load i8, i8* %src_reg321, align 1
  %bf.value324 = and i8 %conv322, 15
  %bf.shl325 = shl i8 %bf.value324, 4
  %bf.clear326 = and i8 %bf.load323, 15
  %bf.set327 = or i8 %bf.clear326, %bf.shl325
  store i8 %bf.set327, i8* %src_reg321, align 1
  %off328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral315, i32 0, i32 2
  store i16 0, i16* %off328, align 2
  %imm329 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral315, i32 0, i32 3
  store i32 0, i32* %imm329, align 4
  %127 = bitcast %struct.bpf_insn* %125 to i8*
  %128 = bitcast %struct.bpf_insn* %.compoundliteral315 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %127, i8* align 4 %128, i64 8, i1 false)
  %129 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr330 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %129, i32 1
  store %struct.bpf_insn* %incdec.ptr330, %struct.bpf_insn** %patch, align 8
  %code332 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral331, i32 0, i32 0
  store i8 -121, i8* %code332, align 4
  %dst_reg333 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral331, i32 0, i32 1
  %bf.load334 = load i8, i8* %dst_reg333, align 1
  %bf.clear335 = and i8 %bf.load334, -16
  %bf.set336 = or i8 %bf.clear335, 11
  store i8 %bf.set336, i8* %dst_reg333, align 1
  %src_reg337 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral331, i32 0, i32 1
  %bf.load338 = load i8, i8* %src_reg337, align 1
  %bf.clear339 = and i8 %bf.load338, 15
  %bf.set340 = or i8 %bf.clear339, 0
  store i8 %bf.set340, i8* %src_reg337, align 1
  %off341 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral331, i32 0, i32 2
  store i16 0, i16* %off341, align 2
  %imm342 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral331, i32 0, i32 3
  store i32 0, i32* %imm342, align 4
  %130 = bitcast %struct.bpf_insn* %129 to i8*
  %131 = bitcast %struct.bpf_insn* %.compoundliteral331 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %130, i8* align 4 %131, i64 8, i1 false)
  %132 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr343 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %132, i32 1
  store %struct.bpf_insn* %incdec.ptr343, %struct.bpf_insn** %patch, align 8
  %code345 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral344, i32 0, i32 0
  store i8 -57, i8* %code345, align 4
  %dst_reg346 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral344, i32 0, i32 1
  %bf.load347 = load i8, i8* %dst_reg346, align 1
  %bf.clear348 = and i8 %bf.load347, -16
  %bf.set349 = or i8 %bf.clear348, 11
  store i8 %bf.set349, i8* %dst_reg346, align 1
  %src_reg350 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral344, i32 0, i32 1
  %bf.load351 = load i8, i8* %src_reg350, align 1
  %bf.clear352 = and i8 %bf.load351, 15
  %bf.set353 = or i8 %bf.clear352, 0
  store i8 %bf.set353, i8* %src_reg350, align 1
  %off354 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral344, i32 0, i32 2
  store i16 0, i16* %off354, align 2
  %imm355 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral344, i32 0, i32 3
  store i32 63, i32* %imm355, align 4
  %133 = bitcast %struct.bpf_insn* %132 to i8*
  %134 = bitcast %struct.bpf_insn* %.compoundliteral344 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %133, i8* align 4 %134, i64 8, i1 false)
  %135 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr356 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %135, i32 1
  store %struct.bpf_insn* %incdec.ptr356, %struct.bpf_insn** %patch, align 8
  %code358 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral357, i32 0, i32 0
  store i8 95, i8* %code358, align 4
  %dst_reg359 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral357, i32 0, i32 1
  %bf.load360 = load i8, i8* %dst_reg359, align 1
  %bf.clear361 = and i8 %bf.load360, -16
  %bf.set362 = or i8 %bf.clear361, 11
  store i8 %bf.set362, i8* %dst_reg359, align 1
  %src_reg363 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral357, i32 0, i32 1
  %136 = load i32, i32* %off_reg, align 4
  %conv364 = trunc i32 %136 to i8
  %bf.load365 = load i8, i8* %src_reg363, align 1
  %bf.value366 = and i8 %conv364, 15
  %bf.shl367 = shl i8 %bf.value366, 4
  %bf.clear368 = and i8 %bf.load365, 15
  %bf.set369 = or i8 %bf.clear368, %bf.shl367
  store i8 %bf.set369, i8* %src_reg363, align 1
  %off370 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral357, i32 0, i32 2
  store i16 0, i16* %off370, align 2
  %imm371 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral357, i32 0, i32 3
  store i32 0, i32* %imm371, align 4
  %137 = bitcast %struct.bpf_insn* %135 to i8*
  %138 = bitcast %struct.bpf_insn* %.compoundliteral357 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %137, i8* align 4 %138, i64 8, i1 false)
  br label %if.end372

if.end372:                                        ; preds = %if.end283, %if.then254
  %139 = load i8, i8* %issrc, align 1
  %tobool373 = trunc i8 %139 to i1
  br i1 %tobool373, label %if.end397, label %if.then374

if.then374:                                       ; preds = %if.end372
  %140 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr375 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %140, i32 1
  store %struct.bpf_insn* %incdec.ptr375, %struct.bpf_insn** %patch, align 8
  %code377 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral376, i32 0, i32 0
  store i8 -65, i8* %code377, align 4
  %dst_reg378 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral376, i32 0, i32 1
  %141 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg379 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %141, i32 0, i32 1
  %bf.load380 = load i8, i8* %dst_reg379, align 1
  %bf.clear381 = and i8 %bf.load380, 15
  %bf.load382 = load i8, i8* %dst_reg378, align 1
  %bf.value383 = and i8 %bf.clear381, 15
  %bf.clear384 = and i8 %bf.load382, -16
  %bf.set385 = or i8 %bf.clear384, %bf.value383
  store i8 %bf.set385, i8* %dst_reg378, align 1
  %src_reg386 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral376, i32 0, i32 1
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg387 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %142, i32 0, i32 1
  %bf.load388 = load i8, i8* %src_reg387, align 1
  %bf.lshr389 = lshr i8 %bf.load388, 4
  %bf.load390 = load i8, i8* %src_reg386, align 1
  %bf.value391 = and i8 %bf.lshr389, 15
  %bf.shl392 = shl i8 %bf.value391, 4
  %bf.clear393 = and i8 %bf.load390, 15
  %bf.set394 = or i8 %bf.clear393, %bf.shl392
  store i8 %bf.set394, i8* %src_reg386, align 1
  %off395 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral376, i32 0, i32 2
  store i16 0, i16* %off395, align 2
  %imm396 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral376, i32 0, i32 3
  store i32 0, i32* %imm396, align 4
  %143 = bitcast %struct.bpf_insn* %140 to i8*
  %144 = bitcast %struct.bpf_insn* %.compoundliteral376 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %143, i8* align 4 %144, i64 8, i1 false)
  br label %if.end397

if.end397:                                        ; preds = %if.then374, %if.end372
  %145 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg398 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %145, i32 0, i32 1
  %bf.load399 = load i8, i8* %src_reg398, align 1
  %bf.clear400 = and i8 %bf.load399, 15
  %bf.set401 = or i8 %bf.clear400, -80
  store i8 %bf.set401, i8* %src_reg398, align 1
  %146 = load i8, i8* %isneg, align 1
  %tobool402 = trunc i8 %146 to i1
  br i1 %tobool402, label %if.then403, label %if.end411

if.then403:                                       ; preds = %if.end397
  %147 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code404 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %147, i32 0, i32 0
  %148 = load i8, i8* %code404, align 4
  %conv405 = zext i8 %148 to i32
  %cmp406 = icmp eq i32 %conv405, 15
  %149 = zext i1 %cmp406 to i64
  %cond408 = select i1 %cmp406, i32 31, i32 15
  %conv409 = trunc i32 %cond408 to i8
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code410 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %150, i32 0, i32 0
  store i8 %conv409, i8* %code410, align 4
  br label %if.end411

if.end411:                                        ; preds = %if.then403, %if.end397
  %151 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr412 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %151, i32 1
  store %struct.bpf_insn* %incdec.ptr412, %struct.bpf_insn** %patch, align 8
  %152 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %153 = bitcast %struct.bpf_insn* %151 to i8*
  %154 = bitcast %struct.bpf_insn* %152 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %153, i8* align 4 %154, i64 8, i1 false)
  %155 = load i8, i8* %issrc, align 1
  %tobool413 = trunc i8 %155 to i1
  br i1 %tobool413, label %land.lhs.true415, label %if.end436

land.lhs.true415:                                 ; preds = %if.end411
  %156 = load i8, i8* %isneg, align 1
  %tobool416 = trunc i8 %156 to i1
  br i1 %tobool416, label %land.lhs.true418, label %if.end436

land.lhs.true418:                                 ; preds = %land.lhs.true415
  %157 = load i8, i8* %isimm, align 1
  %tobool419 = trunc i8 %157 to i1
  br i1 %tobool419, label %if.end436, label %if.then420

if.then420:                                       ; preds = %land.lhs.true418
  %158 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr421 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %158, i32 1
  store %struct.bpf_insn* %incdec.ptr421, %struct.bpf_insn** %patch, align 8
  %code423 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral422, i32 0, i32 0
  store i8 39, i8* %code423, align 4
  %dst_reg424 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral422, i32 0, i32 1
  %159 = load i32, i32* %off_reg, align 4
  %conv425 = trunc i32 %159 to i8
  %bf.load426 = load i8, i8* %dst_reg424, align 1
  %bf.value427 = and i8 %conv425, 15
  %bf.clear428 = and i8 %bf.load426, -16
  %bf.set429 = or i8 %bf.clear428, %bf.value427
  store i8 %bf.set429, i8* %dst_reg424, align 1
  %src_reg430 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral422, i32 0, i32 1
  %bf.load431 = load i8, i8* %src_reg430, align 1
  %bf.clear432 = and i8 %bf.load431, 15
  %bf.set433 = or i8 %bf.clear432, 0
  store i8 %bf.set433, i8* %src_reg430, align 1
  %off434 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral422, i32 0, i32 2
  store i16 0, i16* %off434, align 2
  %imm435 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral422, i32 0, i32 3
  store i32 -1, i32* %imm435, align 4
  %160 = bitcast %struct.bpf_insn* %158 to i8*
  %161 = bitcast %struct.bpf_insn* %.compoundliteral422 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %160, i8* align 4 %161, i64 8, i1 false)
  br label %if.end436

if.end436:                                        ; preds = %if.then420, %land.lhs.true418, %land.lhs.true415, %if.end411
  %162 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %arraydecay437 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_insn* %162 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_insn* %arraydecay437 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv438 = trunc i64 %sub.ptr.div to i32
  store i32 %conv438, i32* %cnt, align 4
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %164 = load i32, i32* %i, align 4
  %165 = load i32, i32* %delta, align 4
  %add439 = add i32 %164, %165
  %arraydecay440 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %166 = load i32, i32* %cnt, align 4
  %call441 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %163, i32 noundef %add439, %struct.bpf_insn* noundef %arraydecay440, i32 noundef %166) #14
  store %struct.bpf_prog* %call441, %struct.bpf_prog** %new_prog, align 8
  %167 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool442 = icmp ne %struct.bpf_prog* %167, null
  br i1 %tobool442, label %if.end444, label %if.then443

if.then443:                                       ; preds = %if.end436
  store i32 -12, i32* %retval, align 4
  br label %return

if.end444:                                        ; preds = %if.end436
  %168 = load i32, i32* %cnt, align 4
  %sub445 = sub i32 %168, 1
  %169 = load i32, i32* %delta, align 4
  %add446 = add i32 %169, %sub445
  store i32 %add446, i32* %delta, align 4
  %170 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %170, %struct.bpf_prog** %prog, align 8
  %171 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog447 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %171, i32 0, i32 2
  store %struct.bpf_prog* %170, %struct.bpf_prog** %prog447, align 8
  %172 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi448 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %172, i32 0, i32 13
  %arraydecay449 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi448, i64 0, i64 0
  %173 = load i32, i32* %i, align 4
  %idx.ext450 = sext i32 %173 to i64
  %add.ptr451 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay449, i64 %idx.ext450
  %174 = load i32, i32* %delta, align 4
  %idx.ext452 = sext i32 %174 to i64
  %add.ptr453 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr451, i64 %idx.ext452
  store %struct.bpf_insn* %add.ptr453, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end454:                                        ; preds = %lor.lhs.false207
  %175 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code455 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %175, i32 0, i32 0
  %176 = load i8, i8* %code455, align 4
  %conv456 = zext i8 %176 to i32
  %cmp457 = icmp ne i32 %conv456, 133
  br i1 %cmp457, label %if.then459, label %if.end460

if.then459:                                       ; preds = %if.end454
  br label %for.inc

if.end460:                                        ; preds = %if.end454
  %177 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg461 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %177, i32 0, i32 1
  %bf.load462 = load i8, i8* %src_reg461, align 1
  %bf.lshr463 = lshr i8 %bf.load462, 4
  %conv464 = zext i8 %bf.lshr463 to i32
  %cmp465 = icmp eq i32 %conv464, 1
  br i1 %cmp465, label %if.then467, label %if.end468

if.then467:                                       ; preds = %if.end460
  br label %for.inc

if.end468:                                        ; preds = %if.end460
  %178 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg469 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %178, i32 0, i32 1
  %bf.load470 = load i8, i8* %src_reg469, align 1
  %bf.lshr471 = lshr i8 %bf.load470, 4
  %conv472 = zext i8 %bf.lshr471 to i32
  %cmp473 = icmp eq i32 %conv472, 2
  br i1 %cmp473, label %if.then475, label %if.end480

if.then475:                                       ; preds = %if.end468
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %180 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call476 = call i32 @fixup_kfunc_call(%struct.bpf_verifier_env* noundef %179, %struct.bpf_insn* noundef %180) #14
  store i32 %call476, i32* %ret, align 4
  %181 = load i32, i32* %ret, align 4
  %tobool477 = icmp ne i32 %181, 0
  br i1 %tobool477, label %if.then478, label %if.end479

if.then478:                                       ; preds = %if.then475
  %182 = load i32, i32* %ret, align 4
  store i32 %182, i32* %retval, align 4
  br label %return

if.end479:                                        ; preds = %if.then475
  br label %for.inc

if.end480:                                        ; preds = %if.end468
  %183 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm481 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %183, i32 0, i32 3
  %184 = load i32, i32* %imm481, align 4
  %cmp482 = icmp eq i32 %184, 24
  br i1 %cmp482, label %if.then484, label %if.end488

if.then484:                                       ; preds = %if.end480
  %185 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %dst_needed = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %185, i32 0, i32 1
  %bf.load485 = load i16, i16* %dst_needed, align 2
  %bf.clear486 = and i16 %bf.load485, -17
  %bf.set487 = or i16 %bf.clear486, 16
  store i16 %bf.set487, i16* %dst_needed, align 2
  br label %if.end488

if.end488:                                        ; preds = %if.then484, %if.end480
  %186 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm489 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %186, i32 0, i32 3
  %187 = load i32, i32* %imm489, align 4
  %cmp490 = icmp eq i32 %187, 7
  br i1 %cmp490, label %if.then492, label %if.end493

if.then492:                                       ; preds = %if.end488
  call void @bpf_user_rnd_init_once() #14
  br label %if.end493

if.end493:                                        ; preds = %if.then492, %if.end488
  %188 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm494 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %188, i32 0, i32 3
  %189 = load i32, i32* %imm494, align 4
  %cmp495 = icmp eq i32 %189, 58
  br i1 %cmp495, label %if.then497, label %if.end501

if.then497:                                       ; preds = %if.end493
  %190 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %kprobe_override = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %190, i32 0, i32 1
  %bf.load498 = load i16, i16* %kprobe_override, align 2
  %bf.clear499 = and i16 %bf.load498, -129
  %bf.set500 = or i16 %bf.clear499, 128
  store i16 %bf.set500, i16* %kprobe_override, align 2
  br label %if.end501

if.end501:                                        ; preds = %if.then497, %if.end493
  %191 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm502 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %191, i32 0, i32 3
  %192 = load i32, i32* %imm502, align 4
  %cmp503 = icmp eq i32 %192, 12
  br i1 %cmp503, label %if.then505, label %if.end601

if.then505:                                       ; preds = %if.end501
  %193 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %cb_access = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %193, i32 0, i32 1
  %bf.load506 = load i16, i16* %cb_access, align 2
  %bf.clear507 = and i16 %bf.load506, -9
  %bf.set508 = or i16 %bf.clear507, 8
  store i16 %bf.set508, i16* %cb_access, align 2
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call509 = call zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %194) #14
  br i1 %call509, label %if.end512, label %if.then510

if.then510:                                       ; preds = %if.then505
  %195 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux511 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %195, i32 0, i32 10
  %196 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux511, align 8
  %stack_depth = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %196, i32 0, i32 6
  store i32 512, i32* %stack_depth, align 4
  br label %if.end512

if.end512:                                        ; preds = %if.then510, %if.then505
  %197 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux513 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %197, i32 0, i32 10
  %198 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux513, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %198, i32 0, i32 4
  store i32 65535, i32* %max_pkt_offset, align 4
  %199 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm514 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %199, i32 0, i32 3
  store i32 0, i32* %imm514, align 4
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code515 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 0
  store i8 -11, i8* %code515, align 4
  %201 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data516 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %201, i32 0, i32 24
  %202 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data516, align 8
  %203 = load i32, i32* %i, align 4
  %204 = load i32, i32* %delta, align 4
  %add517 = add i32 %203, %204
  %idxprom518 = sext i32 %add517 to i64
  %arrayidx519 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %202, i64 %idxprom518
  store %struct.bpf_insn_aux_data* %arrayidx519, %struct.bpf_insn_aux_data** %aux, align 8
  %205 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %205, i32 0, i32 20
  %206 = load i8, i8* %bpf_capable, align 8
  %tobool520 = trunc i8 %206 to i1
  br i1 %tobool520, label %land.lhs.true522, label %if.end549

land.lhs.true522:                                 ; preds = %if.end512
  %207 = load i8, i8* %expect_blinding, align 1
  %tobool523 = trunc i8 %207 to i1
  br i1 %tobool523, label %if.end549, label %land.lhs.true524

land.lhs.true524:                                 ; preds = %land.lhs.true522
  %208 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %208, i32 0, i32 1
  %bf.load525 = load i16, i16* %jit_requested, align 2
  %bf.lshr526 = lshr i16 %bf.load525, 1
  %bf.clear527 = and i16 %bf.lshr526, 1
  %conv528 = zext i16 %bf.clear527 to i32
  %tobool529 = icmp ne i32 %conv528, 0
  br i1 %tobool529, label %land.lhs.true530, label %if.end549

land.lhs.true530:                                 ; preds = %land.lhs.true524
  %209 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call531 = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %209) #14
  br i1 %call531, label %if.end549, label %land.lhs.true532

land.lhs.true532:                                 ; preds = %land.lhs.true530
  %210 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call533 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %210) #14
  br i1 %call533, label %if.end549, label %land.lhs.true534

land.lhs.true534:                                 ; preds = %land.lhs.true532
  %211 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call535 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %211) #14
  br i1 %call535, label %if.end549, label %if.then536

if.then536:                                       ; preds = %land.lhs.true534
  %tailcall_target = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 0
  store i8* null, i8** %tailcall_target, align 8
  %tailcall_bypass = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 1
  store i8* null, i8** %tailcall_bypass, align 8
  %bypass_addr = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 2
  store i8* null, i8** %bypass_addr, align 8
  %aux537 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 3
  store i8* null, i8** %aux537, align 8
  %212 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 4
  %tail_call = bitcast %union.anon.124* %212 to %struct.anon.125*
  %map = getelementptr inbounds %struct.anon.125, %struct.anon.125* %tail_call, i32 0, i32 0
  %213 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %214 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %213, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.163* %214 to i64*
  %215 = load i64, i64* %map_ptr_state, align 8
  %and538 = and i64 %215, -2
  %216 = inttoptr i64 %and538 to %struct.bpf_map*
  store %struct.bpf_map* %216, %struct.bpf_map** %map, align 8
  %key = getelementptr inbounds %struct.anon.125, %struct.anon.125* %tail_call, i32 0, i32 1
  %217 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call539 = call i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %217) #14
  %conv540 = trunc i64 %call539 to i32
  store i32 %conv540, i32* %key, align 8
  %tailcall_target_stable = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 5
  store i8 0, i8* %tailcall_target_stable, align 8
  %adj_off = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 6
  store i8 0, i8* %adj_off, align 1
  %reason = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 7
  store i16 0, i16* %reason, align 2
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 8
  %218 = load i32, i32* %i, align 4
  %219 = load i32, i32* %delta, align 4
  %add541 = add i32 %218, %219
  store i32 %add541, i32* %insn_idx, align 4
  %220 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call542 = call i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %220, %struct.bpf_jit_poke_descriptor* noundef %desc) #14
  store i32 %call542, i32* %ret, align 4
  %221 = load i32, i32* %ret, align 4
  %cmp543 = icmp slt i32 %221, 0
  br i1 %cmp543, label %if.then545, label %if.end546

if.then545:                                       ; preds = %if.then536
  %222 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %223 = bitcast %struct.bpf_verifier_env* %222 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %223, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.447, i64 0, i64 0)) #14
  %224 = load i32, i32* %ret, align 4
  store i32 %224, i32* %retval, align 4
  br label %return

if.end546:                                        ; preds = %if.then536
  %225 = load i32, i32* %ret, align 4
  %add547 = add i32 %225, 1
  %226 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm548 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %226, i32 0, i32 3
  store i32 %add547, i32* %imm548, align 4
  br label %for.inc

if.end549:                                        ; preds = %land.lhs.true534, %land.lhs.true532, %land.lhs.true530, %land.lhs.true524, %land.lhs.true522, %if.end512
  %227 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call550 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %227) #14
  br i1 %call550, label %if.end552, label %if.then551

if.then551:                                       ; preds = %if.end549
  br label %for.inc

if.end552:                                        ; preds = %if.end549
  %228 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call553 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %228) #14
  br i1 %call553, label %if.then554, label %if.end555

if.then554:                                       ; preds = %if.end552
  %229 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %230 = bitcast %struct.bpf_verifier_env* %229 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %230, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.399, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end555:                                        ; preds = %if.end552
  %231 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %232 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %231, i32 0, i32 0
  %map_ptr_state556 = bitcast %union.anon.163* %232 to i64*
  %233 = load i64, i64* %map_ptr_state556, align 8
  %and557 = and i64 %233, -2
  %234 = inttoptr i64 %and557 to %struct.bpf_map*
  store %struct.bpf_map* %234, %struct.bpf_map** %map_ptr, align 8
  %arrayidx558 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code560 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral559, i32 0, i32 0
  store i8 53, i8* %code560, align 4
  %dst_reg561 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral559, i32 0, i32 1
  %bf.load562 = load i8, i8* %dst_reg561, align 1
  %bf.clear563 = and i8 %bf.load562, -16
  %bf.set564 = or i8 %bf.clear563, 3
  store i8 %bf.set564, i8* %dst_reg561, align 1
  %src_reg565 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral559, i32 0, i32 1
  %bf.load566 = load i8, i8* %src_reg565, align 1
  %bf.clear567 = and i8 %bf.load566, 15
  %bf.set568 = or i8 %bf.clear567, 0
  store i8 %bf.set568, i8* %src_reg565, align 1
  %off569 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral559, i32 0, i32 2
  store i16 2, i16* %off569, align 2
  %imm570 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral559, i32 0, i32 3
  %235 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %235, i32 0, i32 6
  %236 = load i32, i32* %max_entries, align 4
  store i32 %236, i32* %imm570, align 4
  %237 = bitcast %struct.bpf_insn* %arrayidx558 to i8*
  %238 = bitcast %struct.bpf_insn* %.compoundliteral559 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %237, i8* align 4 %238, i64 8, i1 false)
  %arrayidx571 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %code573 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral572, i32 0, i32 0
  store i8 84, i8* %code573, align 4
  %dst_reg574 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral572, i32 0, i32 1
  %bf.load575 = load i8, i8* %dst_reg574, align 1
  %bf.clear576 = and i8 %bf.load575, -16
  %bf.set577 = or i8 %bf.clear576, 3
  store i8 %bf.set577, i8* %dst_reg574, align 1
  %src_reg578 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral572, i32 0, i32 1
  %bf.load579 = load i8, i8* %src_reg578, align 1
  %bf.clear580 = and i8 %bf.load579, 15
  %bf.set581 = or i8 %bf.clear580, 0
  store i8 %bf.set581, i8* %src_reg578, align 1
  %off582 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral572, i32 0, i32 2
  store i16 0, i16* %off582, align 2
  %imm583 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral572, i32 0, i32 3
  %239 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %240 = bitcast %struct.bpf_map* %239 to i8*
  store i8* %240, i8** %__mptr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end555
  br label %do.end

do.end:                                           ; preds = %do.body
  %241 = load i8*, i8** %__mptr, align 8
  %add.ptr584 = getelementptr i8, i8* %241, i64 0
  %242 = bitcast i8* %add.ptr584 to %struct.bpf_array*
  store %struct.bpf_array* %242, %struct.bpf_array** %tmp, align 8
  %243 = load %struct.bpf_array*, %struct.bpf_array** %tmp, align 8
  %index_mask = getelementptr inbounds %struct.bpf_array, %struct.bpf_array* %243, i32 0, i32 2
  %244 = load i32, i32* %index_mask, align 4
  store i32 %244, i32* %imm583, align 4
  %245 = bitcast %struct.bpf_insn* %arrayidx571 to i8*
  %246 = bitcast %struct.bpf_insn* %.compoundliteral572 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %245, i8* align 4 %246, i64 8, i1 false)
  %arrayidx585 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %247 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %248 = bitcast %struct.bpf_insn* %arrayidx585 to i8*
  %249 = bitcast %struct.bpf_insn* %247 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %248, i8* align 4 %249, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %250 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %251 = load i32, i32* %i, align 4
  %252 = load i32, i32* %delta, align 4
  %add586 = add i32 %251, %252
  %arraydecay587 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %253 = load i32, i32* %cnt, align 4
  %call588 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %250, i32 noundef %add586, %struct.bpf_insn* noundef %arraydecay587, i32 noundef %253) #14
  store %struct.bpf_prog* %call588, %struct.bpf_prog** %new_prog, align 8
  %254 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool589 = icmp ne %struct.bpf_prog* %254, null
  br i1 %tobool589, label %if.end591, label %if.then590

if.then590:                                       ; preds = %do.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end591:                                        ; preds = %do.end
  %255 = load i32, i32* %cnt, align 4
  %sub592 = sub i32 %255, 1
  %256 = load i32, i32* %delta, align 4
  %add593 = add i32 %256, %sub592
  store i32 %add593, i32* %delta, align 4
  %257 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %257, %struct.bpf_prog** %prog, align 8
  %258 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog594 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %258, i32 0, i32 2
  store %struct.bpf_prog* %257, %struct.bpf_prog** %prog594, align 8
  %259 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi595 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %259, i32 0, i32 13
  %arraydecay596 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi595, i64 0, i64 0
  %260 = load i32, i32* %i, align 4
  %idx.ext597 = sext i32 %260 to i64
  %add.ptr598 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay596, i64 %idx.ext597
  %261 = load i32, i32* %delta, align 4
  %idx.ext599 = sext i32 %261 to i64
  %add.ptr600 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr598, i64 %idx.ext599
  store %struct.bpf_insn* %add.ptr600, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end601:                                        ; preds = %if.end501
  %262 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm602 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %262, i32 0, i32 3
  %263 = load i32, i32* %imm602, align 4
  %cmp603 = icmp eq i32 %263, 170
  br i1 %cmp603, label %if.then605, label %if.end654

if.then605:                                       ; preds = %if.end601
  %arrayinit.begin606 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_addrs, i64 0, i64 0
  %code607 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin606, i32 0, i32 0
  store i8 24, i8* %code607, align 8
  %dst_reg608 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin606, i32 0, i32 1
  %bf.load609 = load i8, i8* %dst_reg608, align 1
  %bf.clear610 = and i8 %bf.load609, -16
  %bf.set611 = or i8 %bf.clear610, 3
  store i8 %bf.set611, i8* %dst_reg608, align 1
  %src_reg612 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin606, i32 0, i32 1
  %bf.load613 = load i8, i8* %src_reg612, align 1
  %bf.clear614 = and i8 %bf.load613, 15
  %bf.set615 = or i8 %bf.clear614, 0
  store i8 %bf.set615, i8* %src_reg612, align 1
  %off616 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin606, i32 0, i32 2
  store i16 0, i16* %off616, align 2
  %imm617 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin606, i32 0, i32 3
  %264 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux618 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %264, i32 0, i32 10
  %265 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux618, align 8
  %266 = ptrtoint %struct.bpf_prog_aux* %265 to i64
  %conv619 = trunc i64 %266 to i32
  store i32 %conv619, i32* %imm617, align 4
  %arrayinit.element620 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin606, i64 1
  %code621 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element620, i32 0, i32 0
  store i8 0, i8* %code621, align 8
  %dst_reg622 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element620, i32 0, i32 1
  %bf.load623 = load i8, i8* %dst_reg622, align 1
  %bf.clear624 = and i8 %bf.load623, -16
  %bf.set625 = or i8 %bf.clear624, 0
  store i8 %bf.set625, i8* %dst_reg622, align 1
  %src_reg626 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element620, i32 0, i32 1
  %bf.load627 = load i8, i8* %src_reg626, align 1
  %bf.clear628 = and i8 %bf.load627, 15
  %bf.set629 = or i8 %bf.clear628, 0
  store i8 %bf.set629, i8* %src_reg626, align 1
  %off630 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element620, i32 0, i32 2
  store i16 0, i16* %off630, align 2
  %imm631 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element620, i32 0, i32 3
  %267 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux632 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %267, i32 0, i32 10
  %268 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux632, align 8
  %269 = ptrtoint %struct.bpf_prog_aux* %268 to i64
  %shr = lshr i64 %269, 32
  %conv633 = trunc i64 %shr to i32
  store i32 %conv633, i32* %imm631, align 4
  %arrayidx634 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %arrayidx635 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_addrs, i64 0, i64 0
  %270 = bitcast %struct.bpf_insn* %arrayidx634 to i8*
  %271 = bitcast %struct.bpf_insn* %arrayidx635 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %270, i8* align 16 %271, i64 8, i1 false)
  %arrayidx636 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %arrayidx637 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_addrs, i64 0, i64 1
  %272 = bitcast %struct.bpf_insn* %arrayidx636 to i8*
  %273 = bitcast %struct.bpf_insn* %arrayidx637 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %272, i8* align 8 %273, i64 8, i1 false)
  %arrayidx638 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %274 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %275 = bitcast %struct.bpf_insn* %arrayidx638 to i8*
  %276 = bitcast %struct.bpf_insn* %274 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %275, i8* align 4 %276, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %277 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %278 = load i32, i32* %i, align 4
  %279 = load i32, i32* %delta, align 4
  %add639 = add i32 %278, %279
  %arraydecay640 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %280 = load i32, i32* %cnt, align 4
  %call641 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %277, i32 noundef %add639, %struct.bpf_insn* noundef %arraydecay640, i32 noundef %280) #14
  store %struct.bpf_prog* %call641, %struct.bpf_prog** %new_prog, align 8
  %281 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool642 = icmp ne %struct.bpf_prog* %281, null
  br i1 %tobool642, label %if.end644, label %if.then643

if.then643:                                       ; preds = %if.then605
  store i32 -12, i32* %retval, align 4
  br label %return

if.end644:                                        ; preds = %if.then605
  %282 = load i32, i32* %cnt, align 4
  %sub645 = sub i32 %282, 1
  %283 = load i32, i32* %delta, align 4
  %add646 = add i32 %283, %sub645
  store i32 %add646, i32* %delta, align 4
  %284 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %284, %struct.bpf_prog** %prog, align 8
  %285 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog647 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %285, i32 0, i32 2
  store %struct.bpf_prog* %284, %struct.bpf_prog** %prog647, align 8
  %286 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi648 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %286, i32 0, i32 13
  %arraydecay649 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi648, i64 0, i64 0
  %287 = load i32, i32* %i, align 4
  %idx.ext650 = sext i32 %287 to i64
  %add.ptr651 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay649, i64 %idx.ext650
  %288 = load i32, i32* %delta, align 4
  %idx.ext652 = sext i32 %288 to i64
  %add.ptr653 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr651, i64 %idx.ext652
  store %struct.bpf_insn* %add.ptr653, %struct.bpf_insn** %insn, align 8
  br label %patch_call_imm

if.end654:                                        ; preds = %if.end601
  %289 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested655 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %289, i32 0, i32 1
  %bf.load656 = load i16, i16* %jit_requested655, align 2
  %bf.lshr657 = lshr i16 %bf.load656, 1
  %bf.clear658 = and i16 %bf.lshr657, 1
  %conv659 = zext i16 %bf.clear658 to i32
  %tobool660 = icmp ne i32 %conv659, 0
  br i1 %tobool660, label %land.lhs.true661, label %if.end786

land.lhs.true661:                                 ; preds = %if.end654
  %290 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm662 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %290, i32 0, i32 3
  %291 = load i32, i32* %imm662, align 4
  %cmp663 = icmp eq i32 %291, 1
  br i1 %cmp663, label %if.then689, label %lor.lhs.false665

lor.lhs.false665:                                 ; preds = %land.lhs.true661
  %292 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm666 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %292, i32 0, i32 3
  %293 = load i32, i32* %imm666, align 4
  %cmp667 = icmp eq i32 %293, 2
  br i1 %cmp667, label %if.then689, label %lor.lhs.false669

lor.lhs.false669:                                 ; preds = %lor.lhs.false665
  %294 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm670 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %294, i32 0, i32 3
  %295 = load i32, i32* %imm670, align 4
  %cmp671 = icmp eq i32 %295, 3
  br i1 %cmp671, label %if.then689, label %lor.lhs.false673

lor.lhs.false673:                                 ; preds = %lor.lhs.false669
  %296 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm674 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %296, i32 0, i32 3
  %297 = load i32, i32* %imm674, align 4
  %cmp675 = icmp eq i32 %297, 87
  br i1 %cmp675, label %if.then689, label %lor.lhs.false677

lor.lhs.false677:                                 ; preds = %lor.lhs.false673
  %298 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm678 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %298, i32 0, i32 3
  %299 = load i32, i32* %imm678, align 4
  %cmp679 = icmp eq i32 %299, 88
  br i1 %cmp679, label %if.then689, label %lor.lhs.false681

lor.lhs.false681:                                 ; preds = %lor.lhs.false677
  %300 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm682 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %300, i32 0, i32 3
  %301 = load i32, i32* %imm682, align 4
  %cmp683 = icmp eq i32 %301, 89
  br i1 %cmp683, label %if.then689, label %lor.lhs.false685

lor.lhs.false685:                                 ; preds = %lor.lhs.false681
  %302 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm686 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %302, i32 0, i32 3
  %303 = load i32, i32* %imm686, align 4
  %cmp687 = icmp eq i32 %303, 51
  br i1 %cmp687, label %if.then689, label %if.end786

if.then689:                                       ; preds = %lor.lhs.false685, %lor.lhs.false681, %lor.lhs.false677, %lor.lhs.false673, %lor.lhs.false669, %lor.lhs.false665, %land.lhs.true661
  %304 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data690 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %304, i32 0, i32 24
  %305 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data690, align 8
  %306 = load i32, i32* %i, align 4
  %307 = load i32, i32* %delta, align 4
  %add691 = add i32 %306, %307
  %idxprom692 = sext i32 %add691 to i64
  %arrayidx693 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %305, i64 %idxprom692
  store %struct.bpf_insn_aux_data* %arrayidx693, %struct.bpf_insn_aux_data** %aux, align 8
  %308 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call694 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %308) #14
  br i1 %call694, label %if.then695, label %if.end696

if.then695:                                       ; preds = %if.then689
  br label %patch_call_imm

if.end696:                                        ; preds = %if.then689
  %309 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %310 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %309, i32 0, i32 0
  %map_ptr_state697 = bitcast %union.anon.163* %310 to i64*
  %311 = load i64, i64* %map_ptr_state697, align 8
  %and698 = and i64 %311, -2
  %312 = inttoptr i64 %and698 to %struct.bpf_map*
  store %struct.bpf_map* %312, %struct.bpf_map** %map_ptr, align 8
  %313 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops699 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %313, i32 0, i32 0
  %314 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops699, align 64
  store %struct.bpf_map_ops* %314, %struct.bpf_map_ops** %ops, align 8
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm700 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %315, i32 0, i32 3
  %316 = load i32, i32* %imm700, align 4
  %cmp701 = icmp eq i32 %316, 1
  br i1 %cmp701, label %land.lhs.true703, label %if.end736

land.lhs.true703:                                 ; preds = %if.end696
  %317 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %317, i32 0, i32 20
  %318 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup, align 8
  %tobool704 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_insn*)* %318, null
  br i1 %tobool704, label %if.then705, label %if.end736

if.then705:                                       ; preds = %land.lhs.true703
  %319 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup706 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %319, i32 0, i32 20
  %320 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup706, align 8
  %321 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %arraydecay707 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call708 = call i32 %320(%struct.bpf_map* noundef %321, %struct.bpf_insn* noundef %arraydecay707) #14
  store i32 %call708, i32* %cnt, align 4
  %322 = load i32, i32* %cnt, align 4
  %cmp709 = icmp eq i32 %322, -95
  br i1 %cmp709, label %if.then711, label %if.end712

if.then711:                                       ; preds = %if.then705
  br label %patch_map_ops_generic

if.end712:                                        ; preds = %if.then705
  %323 = load i32, i32* %cnt, align 4
  %cmp713 = icmp sle i32 %323, 0
  br i1 %cmp713, label %if.then719, label %lor.lhs.false715

lor.lhs.false715:                                 ; preds = %if.end712
  %324 = load i32, i32* %cnt, align 4
  %conv716 = sext i32 %324 to i64
  %cmp717 = icmp uge i64 %conv716, 16
  br i1 %cmp717, label %if.then719, label %if.end720

if.then719:                                       ; preds = %lor.lhs.false715, %if.end712
  %325 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %326 = bitcast %struct.bpf_verifier_env* %325 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %326, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end720:                                        ; preds = %lor.lhs.false715
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %328 = load i32, i32* %i, align 4
  %329 = load i32, i32* %delta, align 4
  %add721 = add i32 %328, %329
  %arraydecay722 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %330 = load i32, i32* %cnt, align 4
  %call723 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %327, i32 noundef %add721, %struct.bpf_insn* noundef %arraydecay722, i32 noundef %330) #14
  store %struct.bpf_prog* %call723, %struct.bpf_prog** %new_prog, align 8
  %331 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool724 = icmp ne %struct.bpf_prog* %331, null
  br i1 %tobool724, label %if.end726, label %if.then725

if.then725:                                       ; preds = %if.end720
  store i32 -12, i32* %retval, align 4
  br label %return

if.end726:                                        ; preds = %if.end720
  %332 = load i32, i32* %cnt, align 4
  %sub727 = sub i32 %332, 1
  %333 = load i32, i32* %delta, align 4
  %add728 = add i32 %333, %sub727
  store i32 %add728, i32* %delta, align 4
  %334 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %334, %struct.bpf_prog** %prog, align 8
  %335 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog729 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %335, i32 0, i32 2
  store %struct.bpf_prog* %334, %struct.bpf_prog** %prog729, align 8
  %336 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi730 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %336, i32 0, i32 13
  %arraydecay731 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi730, i64 0, i64 0
  %337 = load i32, i32* %i, align 4
  %idx.ext732 = sext i32 %337 to i64
  %add.ptr733 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay731, i64 %idx.ext732
  %338 = load i32, i32* %delta, align 4
  %idx.ext734 = sext i32 %338 to i64
  %add.ptr735 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr733, i64 %idx.ext734
  store %struct.bpf_insn* %add.ptr735, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end736:                                        ; preds = %land.lhs.true703, %if.end696
  br label %do.body737

do.body737:                                       ; preds = %if.end736
  br label %do.end738

do.end738:                                        ; preds = %do.body737
  br label %do.body739

do.body739:                                       ; preds = %do.end738
  br label %do.end740

do.end740:                                        ; preds = %do.body739
  br label %do.body741

do.body741:                                       ; preds = %do.end740
  br label %do.end742

do.end742:                                        ; preds = %do.body741
  br label %do.body743

do.body743:                                       ; preds = %do.end742
  br label %do.end744

do.end744:                                        ; preds = %do.body743
  br label %do.body745

do.body745:                                       ; preds = %do.end744
  br label %do.end746

do.end746:                                        ; preds = %do.body745
  br label %do.body747

do.body747:                                       ; preds = %do.end746
  br label %do.end748

do.end748:                                        ; preds = %do.body747
  br label %do.body749

do.body749:                                       ; preds = %do.end748
  br label %do.end750

do.end750:                                        ; preds = %do.body749
  br label %patch_map_ops_generic

patch_map_ops_generic:                            ; preds = %do.end750, %if.then711
  %339 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm751 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %339, i32 0, i32 3
  %340 = load i32, i32* %imm751, align 4
  switch i32 %340, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb756
    i32 3, label %sw.bb761
    i32 87, label %sw.bb766
    i32 88, label %sw.bb771
    i32 89, label %sw.bb776
    i32 51, label %sw.bb781
  ]

sw.bb:                                            ; preds = %patch_map_ops_generic
  %341 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_lookup_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %341, i32 0, i32 12
  %342 = load i8* (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, i8*)** %map_lookup_elem, align 8
  %343 = bitcast i8* (%struct.bpf_map*, i8*)* %342 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast752 = ptrtoint i64 (i64, i64, i64, i64, i64)* %343 to i64
  %sub.ptr.sub753 = sub i64 %sub.ptr.lhs.cast752, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv754 = trunc i64 %sub.ptr.sub753 to i32
  %344 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm755 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %344, i32 0, i32 3
  store i32 %conv754, i32* %imm755, align 4
  br label %for.inc

sw.bb756:                                         ; preds = %patch_map_ops_generic
  %345 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_update_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %345, i32 0, i32 13
  %346 = load i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i8*, i64)** %map_update_elem, align 8
  %347 = bitcast i32 (%struct.bpf_map*, i8*, i8*, i64)* %346 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast757 = ptrtoint i64 (i64, i64, i64, i64, i64)* %347 to i64
  %sub.ptr.sub758 = sub i64 %sub.ptr.lhs.cast757, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv759 = trunc i64 %sub.ptr.sub758 to i32
  %348 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm760 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %348, i32 0, i32 3
  store i32 %conv759, i32* %imm760, align 4
  br label %for.inc

sw.bb761:                                         ; preds = %patch_map_ops_generic
  %349 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_delete_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %349, i32 0, i32 14
  %350 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_delete_elem, align 8
  %351 = bitcast i32 (%struct.bpf_map*, i8*)* %350 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast762 = ptrtoint i64 (i64, i64, i64, i64, i64)* %351 to i64
  %sub.ptr.sub763 = sub i64 %sub.ptr.lhs.cast762, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv764 = trunc i64 %sub.ptr.sub763 to i32
  %352 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm765 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %352, i32 0, i32 3
  store i32 %conv764, i32* %imm765, align 4
  br label %for.inc

sw.bb766:                                         ; preds = %patch_map_ops_generic
  %353 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_push_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %353, i32 0, i32 15
  %354 = load i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i64)** %map_push_elem, align 8
  %355 = bitcast i32 (%struct.bpf_map*, i8*, i64)* %354 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast767 = ptrtoint i64 (i64, i64, i64, i64, i64)* %355 to i64
  %sub.ptr.sub768 = sub i64 %sub.ptr.lhs.cast767, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv769 = trunc i64 %sub.ptr.sub768 to i32
  %356 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm770 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %356, i32 0, i32 3
  store i32 %conv769, i32* %imm770, align 4
  br label %for.inc

sw.bb771:                                         ; preds = %patch_map_ops_generic
  %357 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_pop_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %357, i32 0, i32 16
  %358 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_pop_elem, align 8
  %359 = bitcast i32 (%struct.bpf_map*, i8*)* %358 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast772 = ptrtoint i64 (i64, i64, i64, i64, i64)* %359 to i64
  %sub.ptr.sub773 = sub i64 %sub.ptr.lhs.cast772, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv774 = trunc i64 %sub.ptr.sub773 to i32
  %360 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm775 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %360, i32 0, i32 3
  store i32 %conv774, i32* %imm775, align 4
  br label %for.inc

sw.bb776:                                         ; preds = %patch_map_ops_generic
  %361 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_peek_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %361, i32 0, i32 17
  %362 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_peek_elem, align 8
  %363 = bitcast i32 (%struct.bpf_map*, i8*)* %362 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast777 = ptrtoint i64 (i64, i64, i64, i64, i64)* %363 to i64
  %sub.ptr.sub778 = sub i64 %sub.ptr.lhs.cast777, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv779 = trunc i64 %sub.ptr.sub778 to i32
  %364 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm780 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %364, i32 0, i32 3
  store i32 %conv779, i32* %imm780, align 4
  br label %for.inc

sw.bb781:                                         ; preds = %patch_map_ops_generic
  %365 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_redirect = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %365, i32 0, i32 34
  %366 = load i32 (%struct.bpf_map*, i32, i64)*, i32 (%struct.bpf_map*, i32, i64)** %map_redirect, align 8
  %367 = bitcast i32 (%struct.bpf_map*, i32, i64)* %366 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast782 = ptrtoint i64 (i64, i64, i64, i64, i64)* %367 to i64
  %sub.ptr.sub783 = sub i64 %sub.ptr.lhs.cast782, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv784 = trunc i64 %sub.ptr.sub783 to i32
  %368 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm785 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %368, i32 0, i32 3
  store i32 %conv784, i32* %imm785, align 4
  br label %for.inc

sw.epilog:                                        ; preds = %patch_map_ops_generic
  br label %patch_call_imm

if.end786:                                        ; preds = %lor.lhs.false685, %if.end654
  %369 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested787 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %369, i32 0, i32 1
  %bf.load788 = load i16, i16* %jit_requested787, align 2
  %bf.lshr789 = lshr i16 %bf.load788, 1
  %bf.clear790 = and i16 %bf.lshr789, 1
  %conv791 = zext i16 %bf.clear790 to i32
  %tobool792 = icmp ne i32 %conv791, 0
  br i1 %tobool792, label %land.lhs.true793, label %if.end854

land.lhs.true793:                                 ; preds = %if.end786
  %370 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm794 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %370, i32 0, i32 3
  %371 = load i32, i32* %imm794, align 4
  %cmp795 = icmp eq i32 %371, 118
  br i1 %cmp795, label %if.then797, label %if.end854

if.then797:                                       ; preds = %land.lhs.true793
  %arrayinit.begin798 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 0
  %code799 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin798, i32 0, i32 0
  store i8 24, i8* %code799, align 8
  %dst_reg800 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin798, i32 0, i32 1
  %bf.load801 = load i8, i8* %dst_reg800, align 1
  %bf.clear802 = and i8 %bf.load801, -16
  %bf.set803 = or i8 %bf.clear802, 0
  store i8 %bf.set803, i8* %dst_reg800, align 1
  %src_reg804 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin798, i32 0, i32 1
  %bf.load805 = load i8, i8* %src_reg804, align 1
  %bf.clear806 = and i8 %bf.load805, 15
  %bf.set807 = or i8 %bf.clear806, 0
  store i8 %bf.set807, i8* %src_reg804, align 1
  %off808 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin798, i32 0, i32 2
  store i16 0, i16* %off808, align 2
  %imm809 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin798, i32 0, i32 3
  store i32 ptrtoint (i64* @jiffies to i32), i32* %imm809, align 4
  %arrayinit.element810 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin798, i64 1
  %code811 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element810, i32 0, i32 0
  store i8 0, i8* %code811, align 8
  %dst_reg812 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element810, i32 0, i32 1
  %bf.load813 = load i8, i8* %dst_reg812, align 1
  %bf.clear814 = and i8 %bf.load813, -16
  %bf.set815 = or i8 %bf.clear814, 0
  store i8 %bf.set815, i8* %dst_reg812, align 1
  %src_reg816 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element810, i32 0, i32 1
  %bf.load817 = load i8, i8* %src_reg816, align 1
  %bf.clear818 = and i8 %bf.load817, 15
  %bf.set819 = or i8 %bf.clear818, 0
  store i8 %bf.set819, i8* %src_reg816, align 1
  %off820 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element810, i32 0, i32 2
  store i16 0, i16* %off820, align 2
  %imm821 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element810, i32 0, i32 3
  store i32 trunc (i64 lshr (i64 ptrtoint (i64* @jiffies to i64), i64 32) to i32), i32* %imm821, align 4
  %arrayidx822 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %arrayidx823 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 0
  %372 = bitcast %struct.bpf_insn* %arrayidx822 to i8*
  %373 = bitcast %struct.bpf_insn* %arrayidx823 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %372, i8* align 16 %373, i64 8, i1 false)
  %arrayidx824 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %arrayidx825 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 1
  %374 = bitcast %struct.bpf_insn* %arrayidx824 to i8*
  %375 = bitcast %struct.bpf_insn* %arrayidx825 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %374, i8* align 8 %375, i64 8, i1 false)
  %arrayidx826 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %code828 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral827, i32 0, i32 0
  store i8 121, i8* %code828, align 4
  %dst_reg829 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral827, i32 0, i32 1
  %bf.load830 = load i8, i8* %dst_reg829, align 1
  %bf.clear831 = and i8 %bf.load830, -16
  %bf.set832 = or i8 %bf.clear831, 0
  store i8 %bf.set832, i8* %dst_reg829, align 1
  %src_reg833 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral827, i32 0, i32 1
  %bf.load834 = load i8, i8* %src_reg833, align 1
  %bf.clear835 = and i8 %bf.load834, 15
  %bf.set836 = or i8 %bf.clear835, 0
  store i8 %bf.set836, i8* %src_reg833, align 1
  %off837 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral827, i32 0, i32 2
  store i16 0, i16* %off837, align 2
  %imm838 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral827, i32 0, i32 3
  store i32 0, i32* %imm838, align 4
  %376 = bitcast %struct.bpf_insn* %arrayidx826 to i8*
  %377 = bitcast %struct.bpf_insn* %.compoundliteral827 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %376, i8* align 4 %377, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %378 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %379 = load i32, i32* %i, align 4
  %380 = load i32, i32* %delta, align 4
  %add839 = add i32 %379, %380
  %arraydecay840 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %381 = load i32, i32* %cnt, align 4
  %call841 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %378, i32 noundef %add839, %struct.bpf_insn* noundef %arraydecay840, i32 noundef %381) #14
  store %struct.bpf_prog* %call841, %struct.bpf_prog** %new_prog, align 8
  %382 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool842 = icmp ne %struct.bpf_prog* %382, null
  br i1 %tobool842, label %if.end844, label %if.then843

if.then843:                                       ; preds = %if.then797
  store i32 -12, i32* %retval, align 4
  br label %return

if.end844:                                        ; preds = %if.then797
  %383 = load i32, i32* %cnt, align 4
  %sub845 = sub i32 %383, 1
  %384 = load i32, i32* %delta, align 4
  %add846 = add i32 %384, %sub845
  store i32 %add846, i32* %delta, align 4
  %385 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %385, %struct.bpf_prog** %prog, align 8
  %386 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog847 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %386, i32 0, i32 2
  store %struct.bpf_prog* %385, %struct.bpf_prog** %prog847, align 8
  %387 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi848 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %387, i32 0, i32 13
  %arraydecay849 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi848, i64 0, i64 0
  %388 = load i32, i32* %i, align 4
  %idx.ext850 = sext i32 %388 to i64
  %add.ptr851 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay849, i64 %idx.ext850
  %389 = load i32, i32* %delta, align 4
  %idx.ext852 = sext i32 %389 to i64
  %add.ptr853 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr851, i64 %idx.ext852
  store %struct.bpf_insn* %add.ptr853, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end854:                                        ; preds = %land.lhs.true793, %if.end786
  %390 = load i32, i32* %prog_type, align 4
  %cmp855 = icmp eq i32 %390, 26
  br i1 %cmp855, label %land.lhs.true857, label %if.end888

land.lhs.true857:                                 ; preds = %if.end854
  %391 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm858 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %391, i32 0, i32 3
  %392 = load i32, i32* %imm858, align 4
  %cmp859 = icmp eq i32 %392, 173
  br i1 %cmp859, label %if.then861, label %if.end888

if.then861:                                       ; preds = %land.lhs.true857
  %arrayidx862 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code864 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral863, i32 0, i32 0
  store i8 121, i8* %code864, align 4
  %dst_reg865 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral863, i32 0, i32 1
  %bf.load866 = load i8, i8* %dst_reg865, align 1
  %bf.clear867 = and i8 %bf.load866, -16
  %bf.set868 = or i8 %bf.clear867, 0
  store i8 %bf.set868, i8* %dst_reg865, align 1
  %src_reg869 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral863, i32 0, i32 1
  %bf.load870 = load i8, i8* %src_reg869, align 1
  %bf.clear871 = and i8 %bf.load870, 15
  %bf.set872 = or i8 %bf.clear871, 16
  store i8 %bf.set872, i8* %src_reg869, align 1
  %off873 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral863, i32 0, i32 2
  store i16 -8, i16* %off873, align 2
  %imm874 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral863, i32 0, i32 3
  store i32 0, i32* %imm874, align 4
  %393 = bitcast %struct.bpf_insn* %arrayidx862 to i8*
  %394 = bitcast %struct.bpf_insn* %.compoundliteral863 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %393, i8* align 4 %394, i64 8, i1 false)
  %395 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %396 = load i32, i32* %i, align 4
  %397 = load i32, i32* %delta, align 4
  %add875 = add i32 %396, %397
  %arraydecay876 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call877 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %395, i32 noundef %add875, %struct.bpf_insn* noundef %arraydecay876, i32 noundef 1) #14
  store %struct.bpf_prog* %call877, %struct.bpf_prog** %new_prog, align 8
  %398 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool878 = icmp ne %struct.bpf_prog* %398, null
  br i1 %tobool878, label %if.end880, label %if.then879

if.then879:                                       ; preds = %if.then861
  store i32 -12, i32* %retval, align 4
  br label %return

if.end880:                                        ; preds = %if.then861
  %399 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %399, %struct.bpf_prog** %prog, align 8
  %400 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog881 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %400, i32 0, i32 2
  store %struct.bpf_prog* %399, %struct.bpf_prog** %prog881, align 8
  %401 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi882 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %401, i32 0, i32 13
  %arraydecay883 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi882, i64 0, i64 0
  %402 = load i32, i32* %i, align 4
  %idx.ext884 = sext i32 %402 to i64
  %add.ptr885 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay883, i64 %idx.ext884
  %403 = load i32, i32* %delta, align 4
  %idx.ext886 = sext i32 %403 to i64
  %add.ptr887 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr885, i64 %idx.ext886
  store %struct.bpf_insn* %add.ptr887, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end888:                                        ; preds = %land.lhs.true857, %if.end854
  br label %patch_call_imm

patch_call_imm:                                   ; preds = %if.end888, %sw.epilog, %if.then695, %if.end644
  %404 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops889 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %404, i32 0, i32 3
  %405 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops889, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %405, i32 0, i32 0
  %406 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %407 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm890 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %407, i32 0, i32 3
  %408 = load i32, i32* %imm890, align 4
  %409 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog891 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %409, i32 0, i32 2
  %410 = load %struct.bpf_prog*, %struct.bpf_prog** %prog891, align 8
  %call892 = call %struct.bpf_func_proto* %406(i32 noundef %408, %struct.bpf_prog* noundef %410) #14
  store %struct.bpf_func_proto* %call892, %struct.bpf_func_proto** %fn, align 8
  %411 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %411, i32 0, i32 0
  %412 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %tobool893 = icmp ne i64 (i64, i64, i64, i64, i64)* %412, null
  br i1 %tobool893, label %if.end898, label %if.then894

if.then894:                                       ; preds = %patch_call_imm
  %413 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %414 = bitcast %struct.bpf_verifier_env* %413 to i8*
  %415 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm895 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %415, i32 0, i32 3
  %416 = load i32, i32* %imm895, align 4
  %call896 = call i8* @func_id_name(i32 noundef %416) #14
  %417 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm897 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %417, i32 0, i32 3
  %418 = load i32, i32* %imm897, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %414, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.338, i64 0, i64 0), i8* noundef %call896, i32 noundef %418) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end898:                                        ; preds = %patch_call_imm
  %419 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func899 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %419, i32 0, i32 0
  %420 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func899, align 8
  %sub.ptr.lhs.cast900 = ptrtoint i64 (i64, i64, i64, i64, i64)* %420 to i64
  %sub.ptr.sub901 = sub i64 %sub.ptr.lhs.cast900, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv902 = trunc i64 %sub.ptr.sub901 to i32
  %421 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm903 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %421, i32 0, i32 3
  store i32 %conv902, i32* %imm903, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end898, %if.end880, %if.end844, %sw.bb781, %sw.bb776, %sw.bb771, %sw.bb766, %sw.bb761, %sw.bb756, %sw.bb, %if.end726, %if.end591, %if.then551, %if.end546, %if.end479, %if.then467, %if.then459, %if.end444, %if.then221, %if.end192, %if.end
  %422 = load i32, i32* %i, align 4
  %inc = add i32 %422, 1
  store i32 %inc, i32* %i, align 4
  %423 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr904 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %423, i32 1
  store %struct.bpf_insn* %incdec.ptr904, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond905

for.cond905:                                      ; preds = %for.inc933, %for.end
  %424 = load i32, i32* %i, align 4
  %425 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux906 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %425, i32 0, i32 10
  %426 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux906, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %426, i32 0, i32 34
  %427 = load i32, i32* %size_poke_tab, align 8
  %cmp907 = icmp ult i32 %424, %427
  br i1 %cmp907, label %for.body909, label %for.end935

for.body909:                                      ; preds = %for.cond905
  %428 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux910 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %428, i32 0, i32 10
  %429 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux910, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %429, i32 0, i32 32
  %430 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  %431 = load i32, i32* %i, align 4
  %idxprom911 = sext i32 %431 to i64
  %arrayidx912 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %430, i64 %idxprom911
  %432 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx912, i32 0, i32 4
  %tail_call913 = bitcast %union.anon.124* %432 to %struct.anon.125*
  %map914 = getelementptr inbounds %struct.anon.125, %struct.anon.125* %tail_call913, i32 0, i32 0
  %433 = load %struct.bpf_map*, %struct.bpf_map** %map914, align 8
  store %struct.bpf_map* %433, %struct.bpf_map** %map_ptr, align 8
  %434 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops915 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %434, i32 0, i32 0
  %435 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops915, align 64
  %map_poke_track = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %435, i32 0, i32 24
  %436 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track, align 8
  %tobool916 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)* %436, null
  br i1 %tobool916, label %lor.lhs.false917, label %if.then923

lor.lhs.false917:                                 ; preds = %for.body909
  %437 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops918 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %437, i32 0, i32 0
  %438 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops918, align 64
  %map_poke_untrack = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %438, i32 0, i32 25
  %439 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack, align 8
  %tobool919 = icmp ne void (%struct.bpf_map*, %struct.bpf_prog_aux*)* %439, null
  br i1 %tobool919, label %lor.lhs.false920, label %if.then923

lor.lhs.false920:                                 ; preds = %lor.lhs.false917
  %440 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops921 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %440, i32 0, i32 0
  %441 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops921, align 64
  %map_poke_run = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %441, i32 0, i32 26
  %442 = load void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)** %map_poke_run, align 8
  %tobool922 = icmp ne void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)* %442, null
  br i1 %tobool922, label %if.end924, label %if.then923

if.then923:                                       ; preds = %lor.lhs.false920, %lor.lhs.false917, %for.body909
  %443 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %444 = bitcast %struct.bpf_verifier_env* %443 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %444, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end924:                                        ; preds = %lor.lhs.false920
  %445 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops925 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %445, i32 0, i32 0
  %446 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops925, align 64
  %map_poke_track926 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %446, i32 0, i32 24
  %447 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track926, align 8
  %448 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %449 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux927 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %449, i32 0, i32 10
  %450 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux927, align 8
  %call928 = call i32 %447(%struct.bpf_map* noundef %448, %struct.bpf_prog_aux* noundef %450) #14
  store i32 %call928, i32* %ret, align 4
  %451 = load i32, i32* %ret, align 4
  %cmp929 = icmp slt i32 %451, 0
  br i1 %cmp929, label %if.then931, label %if.end932

if.then931:                                       ; preds = %if.end924
  %452 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %453 = bitcast %struct.bpf_verifier_env* %452 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %453, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.448, i64 0, i64 0)) #14
  %454 = load i32, i32* %ret, align 4
  store i32 %454, i32* %retval, align 4
  br label %return

if.end932:                                        ; preds = %if.end924
  br label %for.inc933

for.inc933:                                       ; preds = %if.end932
  %455 = load i32, i32* %i, align 4
  %inc934 = add i32 %455, 1
  store i32 %inc934, i32* %i, align 4
  br label %for.cond905

for.end935:                                       ; preds = %for.cond905
  %456 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog936 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %456, i32 0, i32 2
  %457 = load %struct.bpf_prog*, %struct.bpf_prog** %prog936, align 8
  call void @sort_kfunc_descs_by_imm(%struct.bpf_prog* noundef %457) #14
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end935, %if.then931, %if.then923, %if.then894, %if.then879, %if.then843, %if.then725, %if.then719, %if.then643, %if.then590, %if.then554, %if.then545, %if.then478, %if.then443, %if.then191, %if.then185, %if.then150
  %458 = load i32, i32* %retval, align 4
  ret i32 %458
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %patch = alloca %struct.bpf_insn*, align 8
  %zext_patch = alloca [2 x %struct.bpf_insn], align 16
  %rnd_hi32_patch = alloca [4 x %struct.bpf_insn], align 16
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %i = alloca i32, align 4
  %patch_len = alloca i32, align 4
  %delta = alloca i32, align 4
  %len = alloca i32, align 4
  %insns = alloca %struct.bpf_insn*, align 8
  %new_prog = alloca %struct.bpf_prog*, align 8
  %rnd_hi32 = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral7 = alloca %struct.bpf_insn, align 4
  %.compoundliteral20 = alloca %struct.bpf_insn, align 4
  %.compoundliteral33 = alloca %struct.bpf_insn, align 4
  %adj_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn, align 4
  %load_reg = alloca i32, align 4
  %code49 = alloca i8, align 1
  %class = alloca i8, align 1
  %imm_rnd = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len1, align 4
  store i32 %4, i32* %len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %7 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %8 = bitcast %union.bpf_attr* %7 to %struct.anon.130*
  %prog_flags = getelementptr inbounds %struct.anon.130, %struct.anon.130* %8, i32 0, i32 8
  %9 = load i32, i32* %prog_flags, align 4
  %and = and i32 %9, 4
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %rnd_hi32, align 1
  %arrayidx = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -68, i8* %code, align 4
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 0
  store i8 %bf.set5, i8* %src_reg, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 1, i32* %imm, align 4
  %10 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %11 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 4 %11, i64 8, i1 false)
  %arrayidx6 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %code8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 0
  store i8 -73, i8* %code8, align 4
  %dst_reg9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load10 = load i8, i8* %dst_reg9, align 1
  %bf.clear11 = and i8 %bf.load10, -16
  %bf.set12 = or i8 %bf.clear11, 11
  store i8 %bf.set12, i8* %dst_reg9, align 1
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %bf.set16 = or i8 %bf.clear15, 0
  store i8 %bf.set16, i8* %src_reg13, align 1
  %off17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 2
  store i16 0, i16* %off17, align 2
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 3
  store i32 0, i32* %imm18, align 4
  %12 = bitcast %struct.bpf_insn* %arrayidx6 to i8*
  %13 = bitcast %struct.bpf_insn* %.compoundliteral7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 4 %13, i64 8, i1 false)
  %arrayidx19 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 2
  %code21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 0
  store i8 103, i8* %code21, align 4
  %dst_reg22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load23 = load i8, i8* %dst_reg22, align 1
  %bf.clear24 = and i8 %bf.load23, -16
  %bf.set25 = or i8 %bf.clear24, 11
  store i8 %bf.set25, i8* %dst_reg22, align 1
  %src_reg26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load27 = load i8, i8* %src_reg26, align 1
  %bf.clear28 = and i8 %bf.load27, 15
  %bf.set29 = or i8 %bf.clear28, 0
  store i8 %bf.set29, i8* %src_reg26, align 1
  %off30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 2
  store i16 0, i16* %off30, align 2
  %imm31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 3
  store i32 32, i32* %imm31, align 4
  %14 = bitcast %struct.bpf_insn* %arrayidx19 to i8*
  %15 = bitcast %struct.bpf_insn* %.compoundliteral20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %14, i8* align 4 %15, i64 8, i1 false)
  %arrayidx32 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %code34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 0
  store i8 79, i8* %code34, align 4
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, -16
  %bf.set38 = or i8 %bf.clear37, 0
  store i8 %bf.set38, i8* %dst_reg35, align 1
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.clear41 = and i8 %bf.load40, 15
  %bf.set42 = or i8 %bf.clear41, -80
  store i8 %bf.set42, i8* %src_reg39, align 1
  %off43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 2
  store i16 0, i16* %off43, align 2
  %imm44 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 3
  store i32 0, i32* %imm44, align 4
  %16 = bitcast %struct.bpf_insn* %arrayidx32 to i8*
  %17 = bitcast %struct.bpf_insn* %.compoundliteral33 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 4 %17, i64 8, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %18 = load i32, i32* %i, align 4
  %19 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %18, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, i32* %i, align 4
  %21 = load i32, i32* %delta, align 4
  %add = add i32 %20, %21
  store i32 %add, i32* %adj_idx, align 4
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %23 = load i32, i32* %adj_idx, align 4
  %idxprom = sext i32 %23 to i64
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %22, i64 %idxprom
  %24 = bitcast %struct.bpf_insn* %insn to i8*
  %25 = bitcast %struct.bpf_insn* %arrayidx45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %25, i64 8, i1 false)
  %call = call i32 @insn_def_regno(%struct.bpf_insn* noundef %insn) #14
  store i32 %call, i32* %load_reg, align 4
  %26 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %27 = load i32, i32* %adj_idx, align 4
  %idxprom46 = sext i32 %27 to i64
  %arrayidx47 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %26, i64 %idxprom46
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx47, i32 0, i32 5
  %28 = load i8, i8* %zext_dst, align 1
  %tobool48 = trunc i8 %28 to i1
  br i1 %tobool48, label %if.end92, label %if.then

if.then:                                          ; preds = %for.body
  %29 = load i8, i8* %rnd_hi32, align 1
  %tobool50 = trunc i8 %29 to i1
  br i1 %tobool50, label %if.end, label %if.then51

if.then51:                                        ; preds = %if.then
  br label %for.inc

if.end:                                           ; preds = %if.then
  %code52 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code52, align 4
  store i8 %30, i8* %code49, align 1
  %31 = load i8, i8* %code49, align 1
  %conv = zext i8 %31 to i32
  %and53 = and i32 %conv, 7
  %conv54 = trunc i32 %and53 to i8
  store i8 %conv54, i8* %class, align 1
  %32 = load i32, i32* %load_reg, align 4
  %cmp55 = icmp eq i32 %32, -1
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end
  br label %for.inc

if.end58:                                         ; preds = %if.end
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load i32, i32* %load_reg, align 4
  %call59 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %33, %struct.bpf_insn* noundef %insn, i32 noundef %34, %struct.bpf_reg_state* noundef null, i32 noundef 1) #14
  br i1 %call59, label %if.then60, label %if.end70

if.then60:                                        ; preds = %if.end58
  %35 = load i8, i8* %class, align 1
  %conv61 = zext i8 %35 to i32
  %cmp62 = icmp eq i32 %conv61, 0
  br i1 %cmp62, label %land.lhs.true, label %if.end69

land.lhs.true:                                    ; preds = %if.then60
  %36 = load i8, i8* %code49, align 1
  %conv64 = zext i8 %36 to i32
  %and65 = and i32 %conv64, 224
  %cmp66 = icmp eq i32 %and65, 0
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %land.lhs.true
  %37 = load i32, i32* %i, align 4
  %inc = add i32 %37, 1
  store i32 %inc, i32* %i, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.then68, %land.lhs.true, %if.then60
  br label %for.inc

if.end70:                                         ; preds = %if.end58
  %38 = load i8, i8* %class, align 1
  %conv71 = zext i8 %38 to i32
  %cmp72 = icmp eq i32 %conv71, 1
  br i1 %cmp72, label %land.lhs.true74, label %if.end80

land.lhs.true74:                                  ; preds = %if.end70
  %39 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %40 = load i32, i32* %adj_idx, align 4
  %idxprom75 = sext i32 %40 to i64
  %arrayidx76 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %39, i64 %idxprom75
  %41 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx76, i32 0, i32 0
  %ptr_type = bitcast %union.anon.163* %41 to i32*
  %42 = load i32, i32* %ptr_type, align 8
  %cmp77 = icmp eq i32 %42, 2
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %land.lhs.true74
  br label %for.inc

if.end80:                                         ; preds = %land.lhs.true74, %if.end70
  %call81 = call i32 @get_random_int() #14
  store i32 %call81, i32* %imm_rnd, align 4
  %arrayidx82 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  %43 = bitcast %struct.bpf_insn* %arrayidx82 to i8*
  %44 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %43, i8* align 4 %44, i64 8, i1 false)
  %45 = load i32, i32* %imm_rnd, align 4
  %arrayidx83 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %imm84 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx83, i32 0, i32 3
  store i32 %45, i32* %imm84, align 4
  %46 = load i32, i32* %load_reg, align 4
  %conv85 = trunc i32 %46 to i8
  %arrayidx86 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %dst_reg87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx86, i32 0, i32 1
  %bf.load88 = load i8, i8* %dst_reg87, align 1
  %bf.value = and i8 %conv85, 15
  %bf.clear89 = and i8 %bf.load88, -16
  %bf.set90 = or i8 %bf.clear89, %bf.value
  store i8 %bf.set90, i8* %dst_reg87, align 1
  %arraydecay91 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay91, %struct.bpf_insn** %patch, align 8
  store i32 4, i32* %patch_len, align 4
  br label %apply_patch_buffer

if.end92:                                         ; preds = %for.body
  %call93 = call zeroext i1 @bpf_jit_needs_zext() #14
  br i1 %call93, label %if.end97, label %land.lhs.true94

land.lhs.true94:                                  ; preds = %if.end92
  %call95 = call zeroext i1 @is_cmpxchg_insn(%struct.bpf_insn* noundef %insn) #14
  br i1 %call95, label %if.end97, label %if.then96

if.then96:                                        ; preds = %land.lhs.true94
  br label %for.inc

if.end97:                                         ; preds = %land.lhs.true94, %if.end92
  %47 = load i32, i32* %load_reg, align 4
  %cmp98 = icmp eq i32 %47, -1
  %lnot = xor i1 %cmp98, true
  %lnot100 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot100 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %48 = load i32, i32* %__ret_warn_on, align 4
  %tobool101 = icmp ne i32 %48, 0
  %lnot102 = xor i1 %tobool101, true
  %lnot104 = xor i1 %lnot102, true
  %lnot.ext105 = zext i1 %lnot104 to i32
  %conv106 = sext i32 %lnot.ext105 to i64
  %tobool107 = icmp ne i64 %conv106, 0
  br i1 %tobool107, label %if.then108, label %if.end115

if.then108:                                       ; preds = %if.end97
  br label %do.body

do.body:                                          ; preds = %if.then108
  br label %do.body109

do.body109:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body109
  br label %do.body110

do.body110:                                       ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 14069, i32 2305, i64 12) #13, !srcloc !23
  br label %do.end111

do.end111:                                        ; preds = %do.body110
  call void asm sideeffect "552:\0A\09.pushsection .discard.reachable\0A\09.long 552b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !24
  br label %do.body112

do.body112:                                       ; preds = %do.end111
  br label %do.end113

do.end113:                                        ; preds = %do.body112
  br label %do.end114

do.end114:                                        ; preds = %do.end113
  br label %if.end115

if.end115:                                        ; preds = %do.end114, %if.end97
  %49 = load i32, i32* %__ret_warn_on, align 4
  %tobool116 = icmp ne i32 %49, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  store i64 %conv121, i64* %tmp, align 8
  %50 = load i64, i64* %tmp, align 8
  %tobool122 = icmp ne i64 %50, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end115
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.450, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end124:                                        ; preds = %if.end115
  %arrayidx125 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  %53 = bitcast %struct.bpf_insn* %arrayidx125 to i8*
  %54 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %53, i8* align 4 %54, i64 8, i1 false)
  %55 = load i32, i32* %load_reg, align 4
  %conv126 = trunc i32 %55 to i8
  %arrayidx127 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %dst_reg128 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx127, i32 0, i32 1
  %bf.load129 = load i8, i8* %dst_reg128, align 1
  %bf.value130 = and i8 %conv126, 15
  %bf.clear131 = and i8 %bf.load129, -16
  %bf.set132 = or i8 %bf.clear131, %bf.value130
  store i8 %bf.set132, i8* %dst_reg128, align 1
  %56 = load i32, i32* %load_reg, align 4
  %conv133 = trunc i32 %56 to i8
  %arrayidx134 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %src_reg135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx134, i32 0, i32 1
  %bf.load136 = load i8, i8* %src_reg135, align 1
  %bf.value137 = and i8 %conv133, 15
  %bf.shl = shl i8 %bf.value137, 4
  %bf.clear138 = and i8 %bf.load136, 15
  %bf.set139 = or i8 %bf.clear138, %bf.shl
  store i8 %bf.set139, i8* %src_reg135, align 1
  %arraydecay140 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay140, %struct.bpf_insn** %patch, align 8
  store i32 2, i32* %patch_len, align 4
  br label %apply_patch_buffer

apply_patch_buffer:                               ; preds = %if.end124, %if.end80
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load i32, i32* %adj_idx, align 4
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %60 = load i32, i32* %patch_len, align 4
  %call141 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %57, i32 noundef %58, %struct.bpf_insn* noundef %59, i32 noundef %60) #14
  store %struct.bpf_prog* %call141, %struct.bpf_prog** %new_prog, align 8
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool142 = icmp ne %struct.bpf_prog* %61, null
  br i1 %tobool142, label %if.end144, label %if.then143

if.then143:                                       ; preds = %apply_patch_buffer
  store i32 -12, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %apply_patch_buffer
  %62 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog145 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %63, i32 0, i32 2
  store %struct.bpf_prog* %62, %struct.bpf_prog** %prog145, align 8
  %64 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi146 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %64, i32 0, i32 13
  %arraydecay147 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi146, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay147, %struct.bpf_insn** %insns, align 8
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data148 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %65, i32 0, i32 24
  %66 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data148, align 8
  store %struct.bpf_insn_aux_data* %66, %struct.bpf_insn_aux_data** %aux, align 8
  %67 = load i32, i32* %patch_len, align 4
  %sub = sub i32 %67, 1
  %68 = load i32, i32* %delta, align 4
  %add149 = add i32 %68, %sub
  store i32 %add149, i32* %delta, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end144, %if.then96, %if.then79, %if.end69, %if.then57, %if.then51
  %69 = load i32, i32* %i, align 4
  %inc150 = add i32 %69, 1
  store i32 %inc150, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then143, %if.then123
  %70 = load i32, i32* %retval, align 4
  ret i32 %70
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_needs_zext() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %has_kfunc_call = alloca i8, align 1
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 @bpf_prog_has_kfunc_call(%struct.bpf_prog* noundef %3) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %has_kfunc_call, align 1
  store i32 0, i32* %err, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 10
  %8 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call4 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %8) #14
  br i1 %call4, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call5 = call i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %9) #14
  store i32 %call5, i32* %err, align 4
  %10 = load i32, i32* %err, align 4
  %cmp = icmp eq i32 %10, 0
  br i1 %cmp, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %11 = load i32, i32* %err, align 4
  %cmp8 = icmp eq i32 %11, -14
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %12 = load i32, i32* %err, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %land.lhs.true, %entry
  %13 = load i8, i8* %has_kfunc_call, align 1
  %tobool13 = trunc i8 %13 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.451, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end12
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 31
  %17 = load i32, i32* %subprog_cnt, align 4
  %cmp16 = icmp ugt i32 %17, 1
  br i1 %cmp16, label %land.lhs.true18, label %if.end24

land.lhs.true18:                                  ; preds = %if.end15
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 2
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog19, align 8
  %aux20 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 10
  %20 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux20, align 8
  %tail_call_reachable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %20, i32 0, i32 26
  %21 = load i8, i8* %tail_call_reachable, align 1
  %tobool21 = trunc i8 %21 to i1
  br i1 %tobool21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %land.lhs.true18
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.403, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true18, %if.end15
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end24
  %24 = load i32, i32* %i, align 4
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 4
  %26 = load i32, i32* %len, align 4
  %cmp25 = icmp ult i32 %24, %26
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call27 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %27) #14
  br i1 %call27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %for.body
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.452, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %for.body
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call30 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %30) #14
  br i1 %call30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %for.inc

if.end32:                                         ; preds = %if.end29
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %33 = load i32, i32* %i, align 4
  %call33 = call i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %31, %struct.bpf_insn* noundef %32, i32 noundef %33) #14
  store i32 %call33, i32* %depth, align 4
  %34 = load i32, i32* %depth, align 4
  %cmp34 = icmp slt i32 %34, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end32
  %35 = load i32, i32* %depth, align 4
  store i32 %35, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end32
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %37 = load i32, i32* %depth, align 4
  call void @bpf_patch_call_args(%struct.bpf_insn* noundef %36, i32 noundef %37) #14
  br label %for.inc

for.inc:                                          ; preds = %if.end37, %if.then31
  %38 = load i32, i32* %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, i32* %i, align 4
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %39, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %err, align 4
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then36, %if.then28, %if.then23, %if.then14, %if.then10, %if.then7
  %41 = load i32, i32* %retval, align 4
  ret i32 %41
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verification_stats(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 36
  %5 = load i64, i64* %verification_time, align 8
  %call = call i64 @div_u64(i64 noundef %5, i32 noundef 1000) #14
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.454, i64 0, i64 0), i64 noundef %call) #14
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.455, i64 0, i64 0)) #14
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 31
  %10 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 27
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %13 = load i16, i16* %stack_depth, align 8
  %conv = zext i16 %13 to i32
  store i32 %conv, i32* %depth, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.456, i64 0, i64 0), i32 noundef %16) #14
  %17 = load i32, i32* %i, align 4
  %add = add i32 %17, 1
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 31
  %19 = load i32, i32* %subprog_cnt1, align 4
  %cmp2 = icmp ult i32 %add, %19
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %for.body
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.457, i64 0, i64 0)) #14
  br label %if.end

if.end:                                           ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i32, i32* %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.67, i64 0, i64 0)) #14
  br label %if.end5

if.end5:                                          ; preds = %for.end, %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 33
  %28 = load i32, i32* %insn_processed, align 4
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 37
  %30 = load i32, i32* %max_states_per_insn, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 38
  %32 = load i32, i32* %total_states, align 4
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 39
  %34 = load i32, i32* %peak_states, align 8
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 40
  %36 = load i32, i32* %longest_mark_read_walk, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([98 x i8], [98 x i8]* @.str.458, i64 0, i64 0), i32 noundef %28, i32 noundef 1000000, i32 noundef %30, i32 noundef %32, i32 noundef %34, i32 noundef %36) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 3
  %1 = load i32, i32* %len_used, align 8
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 4
  %3 = load i32, i32* %len_total, align 4
  %sub = sub i32 %3, 1
  %cmp = icmp uge i32 %1, %sub
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %retval.i25 = alloca i32, align 4
  %size.addr.i26 = alloca i64, align 8
  %retval.i20 = alloca i32, align 4
  %flags.addr.i21 = alloca i32, align 4
  %retval.i13 = alloca i32, align 4
  %size.addr.i14 = alloca i64, align 8
  %size_is_constant.addr.i = alloca i8, align 1
  %size.addr.i10 = alloca i64, align 8
  %flags.addr.i11 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #14
  %lnot = xor i1 %call, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %n.addr, align 8
  %11 = call i1 @llvm.is.constant.i64(i64 %10)
  br i1 %11, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end
  %12 = load i64, i64* %size.addr, align 8
  %13 = call i1 @llvm.is.constant.i64(i64 %12)
  br i1 %13, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %14 = load i64, i64* %bytes, align 8
  %15 = load i32, i32* %flags.addr, align 4
  store i64 %14, i64* %size.addr.i, align 8
  store i32 %15, i32* %flags.addr.i, align 4
  %16 = load i64, i64* %size.addr.i, align 8
  %17 = call i1 @llvm.is.constant.i64(i64 %16) #13
  br i1 %17, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %if.then6
  %18 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %18, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %19 = load i64, i64* %size.addr.i, align 8
  %20 = load i32, i32* %flags.addr.i, align 4
  store i64 %19, i64* %size.addr.i10, align 8
  store i32 %20, i32* %flags.addr.i11, align 4
  %21 = load i64, i64* %size.addr.i10, align 8
  store i64 %21, i64* %size.addr.i26, align 8
  %22 = load i64, i64* %size.addr.i26, align 8
  %23 = call i1 @llvm.is.constant.i64(i64 %22) #13
  br i1 %23, label %if.then.i28, label %if.end14.i32

if.then.i28:                                      ; preds = %if.then1.i
  %24 = load i64, i64* %size.addr.i26, align 8
  %tobool.i27 = icmp ne i64 %24, 0
  br i1 %tobool.i27, label %if.end.i31, label %if.then1.i29

if.then1.i29:                                     ; preds = %if.then.i28
  store i32 52, i32* %retval.i25, align 4
  br label %get_order.exit

if.end.i31:                                       ; preds = %if.then.i28
  %25 = load i64, i64* %size.addr.i26, align 8
  %cmp.i30 = icmp ult i64 %25, 4096
  br i1 %cmp.i30, label %if.then2.i, label %if.end3.i

if.then2.i:                                       ; preds = %if.end.i31
  store i32 0, i32* %retval.i25, align 4
  br label %get_order.exit

if.end3.i:                                        ; preds = %if.end.i31
  %26 = load i64, i64* %size.addr.i26, align 8
  %sub.i = sub i64 %26, 1
  %27 = call i1 @llvm.is.constant.i64(i64 %sub.i) #13
  br i1 %27, label %cond.true.i, label %cond.false9.i

cond.true.i:                                      ; preds = %if.end3.i
  %28 = load i64, i64* %size.addr.i26, align 8
  %sub4.i = sub i64 %28, 1
  %cmp5.i = icmp ult i64 %sub4.i, 2
  br i1 %cmp5.i, label %cond.true6.i, label %cond.false.i

cond.true6.i:                                     ; preds = %cond.true.i
  br label %cond.end.i

cond.false.i:                                     ; preds = %cond.true.i
  %29 = load i64, i64* %size.addr.i26, align 8
  %sub7.i = sub i64 %29, 1
  %30 = call i64 @llvm.ctlz.i64(i64 %sub7.i, i1 true) #13
  %cast.i = trunc i64 %30 to i32
  %sub8.i = sub i32 63, %cast.i
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true6.i
  %cond.i = phi i32 [ 0, %cond.true6.i ], [ %sub8.i, %cond.false.i ]
  br label %cond.end11.i

cond.false9.i:                                    ; preds = %if.end3.i
  %31 = load i64, i64* %size.addr.i26, align 8
  %sub10.i = sub i64 %31, 1
  %call.i = call i32 @__ilog2_u64(i64 noundef %sub10.i) #17
  br label %cond.end11.i

cond.end11.i:                                     ; preds = %cond.false9.i, %cond.end.i
  %cond12.i = phi i32 [ %cond.i, %cond.end.i ], [ %call.i, %cond.false9.i ]
  %sub13.i = sub i32 %cond12.i, 12
  %add.i = add i32 %sub13.i, 1
  store i32 %add.i, i32* %retval.i25, align 4
  br label %get_order.exit

if.end14.i32:                                     ; preds = %if.then1.i
  %32 = load i64, i64* %size.addr.i26, align 8
  %dec.i = add i64 %32, -1
  store i64 %dec.i, i64* %size.addr.i26, align 8
  %33 = load i64, i64* %size.addr.i26, align 8
  %shr.i = lshr i64 %33, 12
  store i64 %shr.i, i64* %size.addr.i26, align 8
  %34 = load i64, i64* %size.addr.i26, align 8
  store i64 %34, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %35 = load i32, i32* %bitpos.i, align 4
  %36 = load i64, i64* %x.addr.i, align 8
  %37 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %36, i32 %35) #12, !srcloc !14
  store i32 %37, i32* %bitpos.i, align 4
  %38 = load i32, i32* %bitpos.i, align 4
  %add.i33 = add i32 %38, 1
  store i32 %add.i33, i32* %retval.i25, align 4
  br label %get_order.exit

get_order.exit:                                   ; preds = %if.then1.i29, %if.then2.i, %cond.end11.i, %if.end14.i32
  %39 = load i32, i32* %retval.i25, align 4
  store i32 %39, i32* %order.i, align 4
  %40 = load i64, i64* %size.addr.i10, align 8
  %41 = load i32, i32* %flags.addr.i11, align 4
  %42 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %40, i32 noundef %41, i32 noundef %42) #16
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %43 = load i64, i64* %size.addr.i, align 8
  store i64 %43, i64* %size.addr.i14, align 8
  store i8 1, i8* %size_is_constant.addr.i, align 1
  %44 = load i64, i64* %size.addr.i14, align 8
  %tobool.i15 = icmp ne i64 %44, 0
  br i1 %tobool.i15, label %if.end.i18, label %if.then.i16

if.then.i16:                                      ; preds = %if.end.i
  store i32 0, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end.i18:                                       ; preds = %if.end.i
  %45 = load i64, i64* %size.addr.i14, align 8
  %cmp.i17 = icmp ule i64 %45, 8
  br i1 %cmp.i17, label %if.then1.i19, label %if.end2.i

if.then1.i19:                                     ; preds = %if.end.i18
  store i32 3, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i18
  %46 = load i64, i64* %size.addr.i14, align 8
  %cmp3.i = icmp ugt i64 %46, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %47 = load i64, i64* %size.addr.i14, align 8
  %cmp4.i = icmp ule i64 %47, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %48 = load i64, i64* %size.addr.i14, align 8
  %cmp7.i = icmp ugt i64 %48, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %49 = load i64, i64* %size.addr.i14, align 8
  %cmp9.i = icmp ule i64 %49, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %50 = load i64, i64* %size.addr.i14, align 8
  %cmp12.i = icmp ule i64 %50, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %51 = load i64, i64* %size.addr.i14, align 8
  %cmp15.i = icmp ule i64 %51, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %52 = load i64, i64* %size.addr.i14, align 8
  %cmp18.i = icmp ule i64 %52, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %53 = load i64, i64* %size.addr.i14, align 8
  %cmp21.i = icmp ule i64 %53, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %54 = load i64, i64* %size.addr.i14, align 8
  %cmp24.i = icmp ule i64 %54, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %55 = load i64, i64* %size.addr.i14, align 8
  %cmp27.i = icmp ule i64 %55, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %56 = load i64, i64* %size.addr.i14, align 8
  %cmp30.i = icmp ule i64 %56, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %57 = load i64, i64* %size.addr.i14, align 8
  %cmp33.i = icmp ule i64 %57, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %58 = load i64, i64* %size.addr.i14, align 8
  %cmp36.i = icmp ule i64 %58, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %59 = load i64, i64* %size.addr.i14, align 8
  %cmp39.i = icmp ule i64 %59, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %60 = load i64, i64* %size.addr.i14, align 8
  %cmp42.i = icmp ule i64 %60, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %61 = load i64, i64* %size.addr.i14, align 8
  %cmp45.i = icmp ule i64 %61, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %62 = load i64, i64* %size.addr.i14, align 8
  %cmp48.i = icmp ule i64 %62, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %63 = load i64, i64* %size.addr.i14, align 8
  %cmp51.i = icmp ule i64 %63, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %64 = load i64, i64* %size.addr.i14, align 8
  %cmp54.i = icmp ule i64 %64, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %65 = load i64, i64* %size.addr.i14, align 8
  %cmp57.i = icmp ule i64 %65, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %66 = load i64, i64* %size.addr.i14, align 8
  %cmp60.i = icmp ule i64 %66, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %67 = load i64, i64* %size.addr.i14, align 8
  %cmp63.i = icmp ule i64 %67, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %68 = load i64, i64* %size.addr.i14, align 8
  %cmp66.i = icmp ule i64 %68, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %69 = load i64, i64* %size.addr.i14, align 8
  %cmp69.i = icmp ule i64 %69, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %70 = load i64, i64* %size.addr.i14, align 8
  %cmp72.i = icmp ule i64 %70, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %71 = load i64, i64* %size.addr.i14, align 8
  %cmp75.i = icmp ule i64 %71, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %72 = load i64, i64* %size.addr.i14, align 8
  %cmp78.i = icmp ule i64 %72, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %73 = load i8, i8* %size_is_constant.addr.i, align 1
  %tobool81.i = trunc i8 %73 to i1
  br i1 %tobool81.i, label %if.then82.i, label %if.else.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 -1, i32* %retval.i13, align 4
  br label %__kmalloc_index.exit

if.else.i:                                        ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.131, i64 0, i64 0), i32 420, i32 0, i64 12) #13, !srcloc !15
  call void asm sideeffect "87:\0A\09.pushsection .discard.unreachable\0A\09.long 87b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !16
  unreachable

__kmalloc_index.exit:                             ; preds = %if.then.i16, %if.then1.i19, %if.then5.i, %if.then10.i, %if.then13.i, %if.then16.i, %if.then19.i, %if.then22.i, %if.then25.i, %if.then28.i, %if.then31.i, %if.then34.i, %if.then37.i, %if.then40.i, %if.then43.i, %if.then46.i, %if.then49.i, %if.then52.i, %if.then55.i, %if.then58.i, %if.then61.i, %if.then64.i, %if.then67.i, %if.then70.i, %if.then73.i, %if.then76.i, %if.then79.i, %if.then82.i
  %74 = load i32, i32* %retval.i13, align 4
  store i32 %74, i32* %index.i, align 4
  %75 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %75, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %__kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %__kmalloc_index.exit
  %76 = load i32, i32* %flags.addr.i, align 4
  store i32 %76, i32* %flags.addr.i21, align 4
  %77 = load i32, i32* %flags.addr.i21, align 4
  %and.i = and i32 %77, 17
  %cmp.i22 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i22, true
  %lnot.ext.i = zext i1 %cmp.i22 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i22, label %if.then.i23, label %if.end.i24

if.then.i23:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i20, align 4
  br label %kmalloc_type.exit

if.end.i24:                                       ; preds = %if.end4.i
  %78 = load i32, i32* %flags.addr.i21, align 4
  %and2.i = and i32 %78, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i24
  store i32 2, i32* %retval.i20, align 4
  br label %kmalloc_type.exit

if.end5.i:                                        ; preds = %if.end.i24
  store i32 1, i32* %retval.i20, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.then.i23, %if.then4.i, %if.end5.i
  %79 = load i32, i32* %retval.i20, align 4
  %idxprom.i = zext i32 %79 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %80 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %80 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %81 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %82 = load i32, i32* %flags.addr.i, align 4
  %83 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %81, i32 noundef %82, i64 noundef %83) #16
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %if.then6
  %84 = load i64, i64* %size.addr.i, align 8
  %85 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %84, i32 noundef %85) #16
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %get_order.exit, %if.then3.i, %kmalloc_type.exit, %if.end9.i
  %86 = load i8*, i8** %retval.i, align 8
  store i8* %86, i8** %retval, align 8
  br label %return

if.end8:                                          ; preds = %land.lhs.true, %if.end
  %87 = load i64, i64* %bytes, align 8
  %88 = load i32, i32* %flags.addr, align 4
  %call9 = call noalias align 8 i8* @__kmalloc(i64 noundef %87, i32 noundef %88) #14
  store i8* %call9, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %kmalloc.exit, %if.then
  %89 = load i8*, i8** %retval, align 8
  ret i8* %89
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code, align 4
  %conv = zext i8 %8 to i32
  %cmp2 = icmp ne i32 %conv, 24
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv4 = zext i8 %bf.lshr to i32
  %cmp5 = icmp eq i32 %conv4, 4
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  br label %for.inc

if.end8:                                          ; preds = %if.end
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 1
  %bf.load10 = load i8, i8* %src_reg9, align 1
  %bf.clear = and i8 %bf.load10, 15
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %src_reg9, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end8, %if.then7, %if.then
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %12, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_btf_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 48
  %4 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool = icmp ne %struct.bpf_func_info* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 31
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 27
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %10 = load i32, i32* %start, align 8
  %11 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %11, i32 0, i32 48
  %12 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info2, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %13 to i64
  %arrayidx4 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %12, i64 %idxprom3
  %insn_off = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx4, i32 0, i32 0
  store i32 %10, i32* %insn_off, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_maps(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 0
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 13
  %5 = load i32, i32* %used_map_cnt, align 8
  call void @__bpf_free_used_maps(%struct.bpf_prog_aux* noundef %2, %struct.bpf_map** noundef %arraydecay, i32 noundef %5) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_btfs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btfs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 12
  %arraydecay = getelementptr inbounds [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs, i64 0, i64 0
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 14
  %5 = load i32, i32* %used_btf_cnt, align 4
  call void @__bpf_free_used_btfs(%struct.bpf_prog_aux* noundef %2, %struct.btf_mod_pair* noundef %arraydecay, i32 noundef %5) #14
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @vfree(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kfree(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_to_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: convergent nofree nosync nounwind readnone willreturn
declare i1 @llvm.is.constant.i64(i64) #6

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @copy_overflow(i32 noundef %size, i64 noundef %count) #0 {
entry:
  %size.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %size, i32* %size.addr, align 4
  store i64 %count, i64* %count.addr, align 8
  store i32 1, i32* %__ret_warn_on, align 4
  %0 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body3

do.body3:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body3
  %1 = load i32, i32* %size.addr, align 4
  %2 = load i64, i64* %count.addr, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.26, i64 0, i64 0), i32 noundef %1, i64 noundef %2) #14
  br label %do.body4

do.body4:                                         ; preds = %do.end
  br label %do.body5

do.body5:                                         ; preds = %do.body4
  br label %do.end6

do.end6:                                          ; preds = %do.body5
  br label %do.body7

do.body7:                                         ; preds = %do.end6
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 200, i32 2313, i64 12) #13, !srcloc !25
  br label %do.end8

do.end8:                                          ; preds = %do.body7
  call void asm sideeffect "32:\0A\09.pushsection .discard.reachable\0A\09.long 32b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !26
  br label %do.body9

do.body9:                                         ; preds = %do.end8
  br label %do.end10

do.end10:                                         ; preds = %do.body9
  br label %do.end11

do.end11:                                         ; preds = %do.end10
  br label %do.body12

do.body12:                                        ; preds = %do.end11
  br label %do.end13

do.end13:                                         ; preds = %do.body12
  br label %do.end14

do.end14:                                         ; preds = %do.end13
  br label %if.end

if.end:                                           ; preds = %do.end14, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool15 = icmp ne i32 %3, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  store i64 %conv20, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_from() #7

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_to() #8

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @check_object_size(i8* noundef %ptr, i64 noundef %n, i1 noundef zeroext %to_user) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %to_user.addr = alloca i8, align 1
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %frombool = zext i1 %to_user to i8
  store i8 %frombool, i8* %to_user.addr, align 1
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_equals_const(i64 %a.coerce0, i64 %a.coerce1, i64 noundef %b) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %b.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i64 %b, i64* %b.addr, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #14
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value, align 8
  %9 = load i64, i64* %b.addr, align 8
  %cmp = icmp eq i64 %8, %9
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %10 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #14
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %call, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  ret %struct.bpf_reg_state* %arraydecay
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_packet_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %__UNIQUE_ID___x474 = alloca i32, align 4
  %__UNIQUE_ID___y475 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.31, i64 0, i64 0), i32 noundef %7) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 2
  %range = bitcast %union.anon.152* %9 to i32*
  %10 = load i32, i32* %range, align 8
  %cmp1 = icmp slt i32 %10, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 2
  %range2 = bitcast %union.anon.152* %16 to i32*
  %17 = load i32, i32* %range2, align 8
  %18 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %18 to i1
  %call3 = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %17, i1 noundef zeroext %tobool) #14
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -22, %cond.true ], [ %call3, %cond.false ]
  store i32 %cond, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %19, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %cond.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.32, i64 0, i64 0), i32 noundef %22) #14
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %cond.end
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 2
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 10
  %26 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %26, i32 0, i32 4
  %27 = load i32, i32* %max_pkt_offset, align 4
  store i32 %27, i32* %__UNIQUE_ID___x474, align 4
  %28 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %28 to i64
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 9
  %30 = load i64, i64* %umax_value, align 8
  %add = add i64 %conv, %30
  %31 = load i32, i32* %size.addr, align 4
  %conv7 = sext i32 %31 to i64
  %add8 = add i64 %add, %conv7
  %sub = sub i64 %add8, 1
  %conv9 = trunc i64 %sub to i32
  store i32 %conv9, i32* %__UNIQUE_ID___y475, align 4
  %32 = load i32, i32* %__UNIQUE_ID___x474, align 4
  %33 = load i32, i32* %__UNIQUE_ID___y475, align 4
  %cmp10 = icmp ugt i32 %32, %33
  br i1 %cmp10, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %if.end6
  %34 = load i32, i32* %__UNIQUE_ID___x474, align 4
  br label %cond.end14

cond.false13:                                     ; preds = %if.end6
  %35 = load i32, i32* %__UNIQUE_ID___y475, align 4
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.true12
  %cond15 = phi i32 [ %34, %cond.true12 ], [ %35, %cond.false13 ]
  store i32 %cond15, i32* %tmp, align 4
  %36 = load i32, i32* %tmp, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 2
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog16, align 8
  %aux17 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %38, i32 0, i32 10
  %39 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux17, align 8
  %max_pkt_offset18 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %39, i32 0, i32 4
  store i32 %36, i32* %max_pkt_offset18, align 4
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end14, %if.then5, %if.then
  %41 = load i32, i32* %retval, align 4
  ret i32 %41
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %mem_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %9 = load i32, i32* %level, align 8
  %and = and i32 %9, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %10, %struct.bpf_func_state* noundef %11) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %13, 0
  br i1 %cmp, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  %15 = load i64, i64* %smin_value3, align 8
  %cmp4 = icmp eq i64 %15, -9223372036854775808
  br i1 %cmp4, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %16 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %16 to i64
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value5, align 8
  %add = add i64 %conv, %18
  %19 = load i32, i32* %off.addr, align 4
  %conv6 = sext i32 %19 to i64
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 6
  %21 = load i64, i64* %smin_value7, align 8
  %add8 = add i64 %conv6, %21
  %conv9 = trunc i64 %add8 to i32
  %conv10 = sext i32 %conv9 to i64
  %cmp11 = icmp ne i64 %add, %conv10
  br i1 %cmp11, label %if.then19, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value14, align 8
  %24 = load i32, i32* %off.addr, align 4
  %conv15 = sext i32 %24 to i64
  %add16 = add i64 %23, %conv15
  %cmp17 = icmp slt i64 %add16, 0
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %lor.lhs.false13, %lor.lhs.false, %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.31, i64 0, i64 0), i32 noundef %27) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %lor.lhs.false13, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load i32, i32* %regno.addr, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  %31 = load i64, i64* %smin_value21, align 8
  %32 = load i32, i32* %off.addr, align 4
  %conv22 = sext i32 %32 to i64
  %add23 = add i64 %31, %conv22
  %conv24 = trunc i64 %add23 to i32
  %33 = load i32, i32* %size.addr, align 4
  %34 = load i32, i32* %mem_size.addr, align 4
  %35 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool25 = trunc i8 %35 to i1
  %call = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %28, i32 noundef %29, i32 noundef %conv24, i32 noundef %33, i32 noundef %34, i1 noundef zeroext %tobool25) #14
  store i32 %call, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %36, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end20
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.37, i64 0, i64 0), i32 noundef %39) #14
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end20
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value, align 8
  %cmp29 = icmp uge i64 %42, 536870912
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.38, i64 0, i64 0), i32 noundef %45) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end28
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %regno.addr, align 4
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 9
  %49 = load i64, i64* %umax_value33, align 8
  %50 = load i32, i32* %off.addr, align 4
  %conv34 = sext i32 %50 to i64
  %add35 = add i64 %49, %conv34
  %conv36 = trunc i64 %add35 to i32
  %51 = load i32, i32* %size.addr, align 4
  %52 = load i32, i32* %mem_size.addr, align 4
  %53 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool37 = trunc i8 %53 to i1
  %call38 = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %46, i32 noundef %47, i32 noundef %conv36, i32 noundef %51, i32 noundef %52, i1 noundef zeroext %tobool37) #14
  store i32 %call38, i32* %err, align 4
  %54 = load i32, i32* %err, align 4
  %tobool39 = icmp ne i32 %54, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end32
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  %57 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.39, i64 0, i64 0), i32 noundef %57) #14
  %58 = load i32, i32* %err, align 4
  store i32 %58, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end32
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.then40, %if.then31, %if.then27, %if.then19
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %cap = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 2
  %4 = bitcast %union.anon.152* %3 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call1 = call i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %6) #14
  store i32 %call1, i32* %cap, align 4
  %7 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %7, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load i32, i32* %cap, align 4
  %conv = zext i32 %8 to i64
  %and = and i64 %conv, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %11, i32 0, i32 5
  %12 = load i32, i32* %value_size, align 32
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.72, i64 0, i64 0), i32 noundef %12, i32 noundef %13, i32 noundef %14) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %15 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %15, 1
  br i1 %cmp2, label %land.lhs.true4, label %if.end10

land.lhs.true4:                                   ; preds = %if.end
  %16 = load i32, i32* %cap, align 4
  %conv5 = zext i32 %16 to i64
  %and6 = and i64 %conv5, 1
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %19, i32 0, i32 5
  %20 = load i32, i32* %value_size9, align 32
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.73, i64 0, i64 0), i32 noundef %20, i32 noundef %21, i32 noundef %22) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true4, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %lock = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 2
  %10 = bitcast %union.anon.152* %9 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %10, i32 0, i32 0
  %11 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %11, %struct.bpf_map** %map, align 8
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %regno.addr, align 4
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %16, i32 0, i32 5
  %17 = load i32, i32* %value_size, align 32
  %18 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %18 to i1
  %call = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15, i32 noundef %17, i1 noundef zeroext %tobool) #14
  store i32 %call, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %19, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %20 = load i32, i32* %err, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call4 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %21) #14
  br i1 %call4, label %if.then5, label %if.end18

if.then5:                                         ; preds = %if.end
  %22 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %22, i32 0, i32 8
  %23 = load i32, i32* %spin_lock_off, align 4
  store i32 %23, i32* %lock, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 6
  %25 = load i64, i64* %smin_value, align 8
  %26 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %26 to i64
  %add = add i64 %25, %conv
  %27 = load i32, i32* %lock, align 4
  %conv6 = zext i32 %27 to i64
  %add7 = add i64 %conv6, 4
  %cmp = icmp ult i64 %add, %add7
  br i1 %cmp, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then5
  %28 = load i32, i32* %lock, align 4
  %conv9 = zext i32 %28 to i64
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 9
  %30 = load i64, i64* %umax_value, align 8
  %31 = load i32, i32* %off.addr, align 4
  %conv10 = sext i32 %31 to i64
  %add11 = add i64 %30, %conv10
  %32 = load i32, i32* %size.addr, align 4
  %conv12 = sext i32 %32 to i64
  %add13 = add i64 %add11, %conv12
  %cmp14 = icmp ult i64 %conv9, %add13
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.74, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.then5
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call19 = call zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %35) #14
  br i1 %call19, label %if.then20, label %if.end39

if.then20:                                        ; preds = %if.end18
  %36 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %36, i32 0, i32 9
  %37 = load i32, i32* %timer_off, align 16
  store i32 %37, i32* %t, align 4
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 6
  %39 = load i64, i64* %smin_value21, align 8
  %40 = load i32, i32* %off.addr, align 4
  %conv22 = sext i32 %40 to i64
  %add23 = add i64 %39, %conv22
  %41 = load i32, i32* %t, align 4
  %conv24 = zext i32 %41 to i64
  %add25 = add i64 %conv24, 16
  %cmp26 = icmp ult i64 %add23, %add25
  br i1 %cmp26, label %land.lhs.true28, label %if.end38

land.lhs.true28:                                  ; preds = %if.then20
  %42 = load i32, i32* %t, align 4
  %conv29 = zext i32 %42 to i64
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 9
  %44 = load i64, i64* %umax_value30, align 8
  %45 = load i32, i32* %off.addr, align 4
  %conv31 = sext i32 %45 to i64
  %add32 = add i64 %44, %conv31
  %46 = load i32, i32* %size.addr, align 4
  %conv33 = sext i32 %46 to i64
  %add34 = add i64 %add32, %conv33
  %cmp35 = icmp ult i64 %conv29, %add34
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true28
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.75, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %land.lhs.true28, %if.then20
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end18
  %49 = load i32, i32* %err, align 4
  store i32 %49, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end39, %if.then37, %if.then16, %if.then
  %50 = load i32, i32* %retval, align 4
  ret i32 %50
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed, i8* noundef %buf_info, i32* noundef %max_access) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %buf_info.addr = alloca i8*, align 8
  %max_access.addr = alloca i32*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store i8* %buf_info, i8** %buf_info.addr, align 8
  store i32* %max_access, i32** %max_access.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i8*, i8** %buf_info.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  %4 = load i32, i32* %off.addr, align 4
  %5 = load i32, i32* %size.addr, align 4
  %call = call i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %0, i8* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5) #14
  store i32 %call, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %add = add i32 %8, %9
  %10 = load i32*, i32** %max_access.addr, align 8
  %11 = load i32, i32* %10, align 4
  %cmp = icmp ugt i32 %add, %11
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %12 = load i32, i32* %off.addr, align 4
  %13 = load i32, i32* %size.addr, align 4
  %add2 = add i32 %12, %13
  %14 = load i32*, i32** %max_access.addr, align 8
  store i32 %add2, i32* %14, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_range_initialized(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, i32 noundef %type, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %type.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %err_extra = alloca i8*, align 8
  %bounds_check_type = alloca i32, align 4
  %clobber = alloca i8, align 1
  %tn_buf = alloca [48 x i8], align 16
  %stype = alloca i8*, align 8
  %tn_buf126 = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store i32 %type, i32* %type.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #14
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %4, 2
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.78, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.79, i64 0, i64 0)
  store i8* %cond, i8** %err_extra, align 8
  store i8 0, i8* %clobber, align 1
  %6 = load i32, i32* %access_size.addr, align 4
  %cmp2 = icmp eq i32 %6, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %7 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.80, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %10 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %10, 2
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  store i32 2, i32* %bounds_check_type, align 4
  store i8 1, i8* %clobber, align 1
  br label %if.end5

if.else:                                          ; preds = %if.end
  store i32 1, i32* %bounds_check_type, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %access_size.addr, align 4
  %15 = load i32, i32* %type.addr, align 4
  %16 = load i32, i32* %bounds_check_type, align 4
  %call6 = call i32 @check_stack_access_within_bounds(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15, i32 noundef %16) #14
  store i32 %call6, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %tobool7 = icmp ne i32 %17, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %18 = load i32, i32* %err, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %20 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = load i64, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %call10 = call zeroext i1 @tnum_is_const(i64 %22, i64 %24) #14
  br i1 %call10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.end9
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off12, i32 0, i32 0
  %26 = load i64, i64* %value, align 8
  %27 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %27 to i64
  %add = add i64 %26, %conv
  %conv13 = trunc i64 %add to i32
  store i32 %conv13, i32* %max_off, align 4
  store i32 %conv13, i32* %min_off, align 4
  br label %if.end33

if.else14:                                        ; preds = %if.end9
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 21
  %29 = load i8, i8* %bypass_spec_v1, align 1
  %tobool15 = trunc i8 %29 to i1
  br i1 %tobool15, label %if.end20, label %if.then16

if.then16:                                        ; preds = %if.else14
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off17 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %call18 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %33, i64 %35) #14
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load i8*, i8** %err_extra, align 8
  %arraydecay19 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.81, i64 0, i64 0), i32 noundef %38, i8* noundef %39, i8* noundef %arraydecay19) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.else14
  %40 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool21 = icmp ne %struct.bpf_call_arg_meta* %40, null
  br i1 %tobool21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end20
  %41 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %41, i32 0, i32 1
  %42 = load i8, i8* %raw_mode, align 8
  %tobool23 = trunc i8 %42 to i1
  br i1 %tobool23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %land.lhs.true22, %if.end20
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 6
  %44 = load i64, i64* %smin_value, align 8
  %45 = load i32, i32* %off.addr, align 4
  %conv27 = sext i32 %45 to i64
  %add28 = add i64 %44, %conv27
  %conv29 = trunc i64 %add28 to i32
  store i32 %conv29, i32* %min_off, align 4
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 7
  %47 = load i64, i64* %smax_value, align 8
  %48 = load i32, i32* %off.addr, align 4
  %conv30 = sext i32 %48 to i64
  %add31 = add i64 %47, %conv30
  %conv32 = trunc i64 %add31 to i32
  store i32 %conv32, i32* %max_off, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.end26, %if.then11
  %49 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool34 = icmp ne %struct.bpf_call_arg_meta* %49, null
  br i1 %tobool34, label %land.lhs.true35, label %if.end42

land.lhs.true35:                                  ; preds = %if.end33
  %50 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode36 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %50, i32 0, i32 1
  %51 = load i8, i8* %raw_mode36, align 8
  %tobool37 = trunc i8 %51 to i1
  br i1 %tobool37, label %if.then39, label %if.end42

if.then39:                                        ; preds = %land.lhs.true35
  %52 = load i32, i32* %access_size.addr, align 4
  %53 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %access_size40 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %53, i32 0, i32 4
  store i32 %52, i32* %access_size40, align 8
  %54 = load i32, i32* %regno.addr, align 4
  %55 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %regno41 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %55, i32 0, i32 3
  store i32 %54, i32* %regno41, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %land.lhs.true35, %if.end33
  %56 = load i32, i32* %min_off, align 4
  store i32 %56, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc142, %if.end42
  %57 = load i32, i32* %i, align 4
  %58 = load i32, i32* %max_off, align 4
  %59 = load i32, i32* %access_size.addr, align 4
  %add43 = add i32 %58, %59
  %cmp44 = icmp slt i32 %57, %add43
  br i1 %cmp44, label %for.body, label %for.end144

for.body:                                         ; preds = %for.cond
  %60 = load i32, i32* %i, align 4
  %sub = sub i32 0, %60
  %sub46 = sub i32 %sub, 1
  store i32 %sub46, i32* %slot, align 4
  %61 = load i32, i32* %slot, align 4
  %div = sdiv i32 %61, 8
  store i32 %div, i32* %spi, align 4
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %62, i32 0, i32 9
  %63 = load i32, i32* %allocated_stack, align 8
  %64 = load i32, i32* %slot, align 4
  %cmp47 = icmp sle i32 %63, %64
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %for.body
  br label %err120

if.end50:                                         ; preds = %for.body
  %65 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %65, i32 0, i32 10
  %66 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %67 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %67 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %66, i64 %idxprom
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 1
  %68 = load i32, i32* %slot, align 4
  %rem = srem i32 %68, 8
  %idxprom51 = sext i32 %rem to i64
  %arrayidx52 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom51
  store i8* %arrayidx52, i8** %stype, align 8
  %69 = load i8*, i8** %stype, align 8
  %70 = load i8, i8* %69, align 1
  %conv53 = zext i8 %70 to i32
  %cmp54 = icmp eq i32 %conv53, 2
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end50
  br label %mark

if.end57:                                         ; preds = %if.end50
  %71 = load i8*, i8** %stype, align 8
  %72 = load i8, i8* %71, align 1
  %conv58 = zext i8 %72 to i32
  %cmp59 = icmp eq i32 %conv58, 3
  br i1 %cmp59, label %if.then61, label %if.end65

if.then61:                                        ; preds = %if.end57
  %73 = load i8, i8* %clobber, align 1
  %tobool62 = trunc i8 %73 to i1
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.then61
  %74 = load i8*, i8** %stype, align 8
  store i8 2, i8* %74, align 1
  br label %if.end64

if.end64:                                         ; preds = %if.then63, %if.then61
  br label %mark

if.end65:                                         ; preds = %if.end57
  %75 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack66 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %75, i32 0, i32 10
  %76 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack66, align 8
  %77 = load i32, i32* %spi, align 4
  %idxprom67 = sext i32 %77 to i64
  %arrayidx68 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %76, i64 %idxprom67
  %slot_type69 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx68, i32 0, i32 1
  %arrayidx70 = getelementptr [8 x i8], [8 x i8]* %slot_type69, i64 0, i64 0
  %78 = load i8, i8* %arrayidx70, align 8
  %conv71 = zext i8 %78 to i32
  %cmp72 = icmp eq i32 %conv71, 1
  br i1 %cmp72, label %land.lhs.true74, label %if.end82

land.lhs.true74:                                  ; preds = %if.end65
  %79 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack75 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %79, i32 0, i32 10
  %80 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack75, align 8
  %81 = load i32, i32* %spi, align 4
  %idxprom76 = sext i32 %81 to i64
  %arrayidx77 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %80, i64 %idxprom76
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx77, i32 0, i32 0
  %type78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  %82 = load i32, i32* %type78, align 8
  %cmp79 = icmp eq i32 %82, 19
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true74
  br label %mark

if.end82:                                         ; preds = %land.lhs.true74, %if.end65
  %83 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack83 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %83, i32 0, i32 10
  %84 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack83, align 8
  %85 = load i32, i32* %spi, align 4
  %idxprom84 = sext i32 %85 to i64
  %arrayidx85 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %84, i64 %idxprom84
  %slot_type86 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx85, i32 0, i32 1
  %arrayidx87 = getelementptr [8 x i8], [8 x i8]* %slot_type86, i64 0, i64 0
  %86 = load i8, i8* %arrayidx87, align 8
  %conv88 = zext i8 %86 to i32
  %cmp89 = icmp eq i32 %conv88, 1
  br i1 %cmp89, label %land.lhs.true91, label %if.end119

land.lhs.true91:                                  ; preds = %if.end82
  %87 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack92 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %87, i32 0, i32 10
  %88 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack92, align 8
  %89 = load i32, i32* %spi, align 4
  %idxprom93 = sext i32 %89 to i64
  %arrayidx94 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %88, i64 %idxprom93
  %spilled_ptr95 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx94, i32 0, i32 0
  %type96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr95, i32 0, i32 0
  %90 = load i32, i32* %type96, align 8
  %cmp97 = icmp eq i32 %90, 1
  br i1 %cmp97, label %if.then101, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true91
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 17
  %92 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool99 = trunc i8 %92 to i1
  br i1 %tobool99, label %if.then101, label %if.end119

if.then101:                                       ; preds = %lor.lhs.false, %land.lhs.true91
  %93 = load i8, i8* %clobber, align 1
  %tobool102 = trunc i8 %93 to i1
  br i1 %tobool102, label %if.then103, label %if.end118

if.then103:                                       ; preds = %if.then101
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack104 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 10
  %96 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack104, align 8
  %97 = load i32, i32* %spi, align 4
  %idxprom105 = sext i32 %97 to i64
  %arrayidx106 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %96, i64 %idxprom105
  %spilled_ptr107 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx106, i32 0, i32 0
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %94, %struct.bpf_reg_state* noundef %spilled_ptr107) #14
  store i32 0, i32* %j, align 4
  br label %for.cond108

for.cond108:                                      ; preds = %for.inc, %if.then103
  %98 = load i32, i32* %j, align 4
  %cmp109 = icmp slt i32 %98, 8
  br i1 %cmp109, label %for.body111, label %for.end

for.body111:                                      ; preds = %for.cond108
  %99 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack112 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %99, i32 0, i32 10
  %100 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack112, align 8
  %101 = load i32, i32* %spi, align 4
  %idxprom113 = sext i32 %101 to i64
  %arrayidx114 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %100, i64 %idxprom113
  %slot_type115 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx114, i32 0, i32 1
  %102 = load i32, i32* %j, align 4
  %idxprom116 = sext i32 %102 to i64
  %arrayidx117 = getelementptr [8 x i8], [8 x i8]* %slot_type115, i64 0, i64 %idxprom116
  store i8 2, i8* %arrayidx117, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body111
  %103 = load i32, i32* %j, align 4
  %inc = add i32 %103, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond108

for.end:                                          ; preds = %for.cond108
  br label %if.end118

if.end118:                                        ; preds = %for.end, %if.then101
  br label %mark

if.end119:                                        ; preds = %lor.lhs.false, %if.end82
  br label %err120

err120:                                           ; preds = %if.end119, %if.then49
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 5
  %105 = bitcast %struct.tnum* %var_off121 to { i64, i64 }*
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %105, i32 0, i32 0
  %107 = load i64, i64* %106, align 8
  %108 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %105, i32 0, i32 1
  %109 = load i64, i64* %108, align 8
  %call122 = call zeroext i1 @tnum_is_const(i64 %107, i64 %109) #14
  br i1 %call122, label %if.then123, label %if.else125

if.then123:                                       ; preds = %err120
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = bitcast %struct.bpf_verifier_env* %110 to i8*
  %112 = load i8*, i8** %err_extra, align 8
  %113 = load i32, i32* %regno.addr, align 4
  %114 = load i32, i32* %min_off, align 4
  %115 = load i32, i32* %i, align 4
  %116 = load i32, i32* %min_off, align 4
  %sub124 = sub i32 %115, %116
  %117 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %111, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.82, i64 0, i64 0), i8* noundef %112, i32 noundef %113, i32 noundef %114, i32 noundef %sub124, i32 noundef %117) #14
  br label %if.end132

if.else125:                                       ; preds = %err120
  %arraydecay127 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf126, i64 0, i64 0
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off128 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off128 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call129 = call i32 @tnum_strn(i8* noundef %arraydecay127, i64 noundef 48, i64 %121, i64 %123) #14
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = bitcast %struct.bpf_verifier_env* %124 to i8*
  %126 = load i8*, i8** %err_extra, align 8
  %127 = load i32, i32* %regno.addr, align 4
  %arraydecay130 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf126, i64 0, i64 0
  %128 = load i32, i32* %i, align 4
  %129 = load i32, i32* %min_off, align 4
  %sub131 = sub i32 %128, %129
  %130 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %125, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.83, i64 0, i64 0), i8* noundef %126, i32 noundef %127, i8* noundef %arraydecay130, i32 noundef %sub131, i32 noundef %130) #14
  br label %if.end132

if.end132:                                        ; preds = %if.else125, %if.then123
  store i32 -13, i32* %retval, align 4
  br label %return

mark:                                             ; preds = %if.end118, %if.then81, %if.end64, %if.then56
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack133 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %132, i32 0, i32 10
  %133 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack133, align 8
  %134 = load i32, i32* %spi, align 4
  %idxprom134 = sext i32 %134 to i64
  %arrayidx135 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %133, i64 %idxprom134
  %spilled_ptr136 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx135, i32 0, i32 0
  %135 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack137 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %135, i32 0, i32 10
  %136 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack137, align 8
  %137 = load i32, i32* %spi, align 4
  %idxprom138 = sext i32 %137 to i64
  %arrayidx139 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %136, i64 %idxprom138
  %spilled_ptr140 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx139, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr140, i32 0, i32 14
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call141 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %131, %struct.bpf_reg_state* noundef %spilled_ptr136, %struct.bpf_reg_state* noundef %138, i8 noundef zeroext 2) #14
  br label %for.inc142

for.inc142:                                       ; preds = %mark
  %139 = load i32, i32* %i, align 4
  %inc143 = add i32 %139, 1
  store i32 %inc143, i32* %i, align 4
  br label %for.cond

for.end144:                                       ; preds = %for.cond
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %142 = load i32, i32* %min_off, align 4
  %call145 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %140, %struct.bpf_func_state* noundef %141, i32 noundef %142) #14
  store i32 %call145, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end144, %if.end132, %if.then39, %if.then16, %if.then8, %if.then
  %143 = load i32, i32* %retval, align 4
  ret i32 %143
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %mem_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %size_ok = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %2 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %2 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %3 = phi i1 [ false, %lor.rhs ], [ %tobool, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %4 = phi i1 [ true, %entry ], [ %3, %land.end ]
  %frombool2 = zext i1 %4 to i8
  store i8 %frombool2, i8* %size_ok, align 1
  %5 = load i32, i32* %off.addr, align 4
  %cmp3 = icmp sge i32 %5, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.end
  %6 = load i8, i8* %size_ok, align 1
  %tobool4 = trunc i8 %6 to i1
  br i1 %tobool4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %7 to i64
  %8 = load i32, i32* %size.addr, align 4
  %conv6 = sext i32 %8 to i64
  %add = add i64 %conv, %conv6
  %9 = load i32, i32* %mem_size.addr, align 4
  %conv7 = zext i32 %9 to i64
  %cmp8 = icmp ule i64 %add, %conv7
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true5, %land.lhs.true, %lor.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %10) #14
  %11 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  switch i32 %13, label %sw.default [
    i32 29, label %sw.bb
    i32 4, label %sw.bb10
    i32 8, label %sw.bb11
    i32 7, label %sw.bb11
    i32 9, label %sw.bb11
    i32 21, label %sw.bb12
  ]

sw.bb:                                            ; preds = %if.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %mem_size.addr, align 4
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.33, i64 0, i64 0), i32 noundef %16, i32 noundef %17, i32 noundef %18) #14
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %mem_size.addr, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.34, i64 0, i64 0), i32 noundef %21, i32 noundef %22, i32 noundef %23) #14
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end, %if.end, %if.end
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i32, i32* %off.addr, align 4
  %27 = load i32, i32* %size.addr, align 4
  %28 = load i32, i32* %regno.addr, align 4
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 3
  %30 = load i32, i32* %id, align 8
  %31 = load i32, i32* %off.addr, align 4
  %32 = load i32, i32* %mem_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.35, i64 0, i64 0), i32 noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef %30, i32 noundef %31, i32 noundef %32) #14
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end
  br label %sw.default

sw.default:                                       ; preds = %if.end, %sw.bb12
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load i32, i32* %mem_size.addr, align 4
  %36 = load i32, i32* %off.addr, align 4
  %37 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.36, i64 0, i64 0), i32 noundef %35, i32 noundef %36, i32 noundef %37) #14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb10, %sw.bb
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca i32, align 4
  %i = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  %types_buf = alloca [9 x i8], align 1
  %valid = alloca i8, align 1
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 2
  %1 = load i32, i32* %frameno, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 2
  %5 = load i32, i32* %frameno1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.40, i64 0, i64 0), i32 noundef %5) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  store i32 %10, i32* %t, align 4
  %11 = load i32, i32* %t, align 4
  %cmp2 = icmp eq i32 %11, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.41, i64 0, i64 0), i32 noundef %14) #14
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 17
  %17 = load i32, i32* %live, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %15, i32 noundef %17) #14
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %t, align 4
  %idxprom5 = zext i32 %20 to i64
  %arrayidx6 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom5
  %21 = load i8*, i8** %arrayidx6, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i64 0, i64 0), i8* noundef %21) #14
  %22 = load i32, i32* %t, align 4
  %cmp7 = icmp eq i32 %22, 1
  br i1 %cmp7, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 18
  %24 = load i8, i8* %precise, align 4
  %tobool8 = trunc i8 %24 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.43, i64 0, i64 0)) #14
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true, %if.end4
  %27 = load i32, i32* %t, align 4
  %cmp11 = icmp eq i32 %27, 1
  br i1 %cmp11, label %land.lhs.true13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %28 = load i32, i32* %t, align 4
  %cmp12 = icmp eq i32 %28, 6
  br i1 %cmp12, label %land.lhs.true13, label %if.else

land.lhs.true13:                                  ; preds = %lor.lhs.false, %if.end10
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 5
  %30 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %32, i64 %34) #14
  br i1 %call, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true13
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %38 = load i64, i64* %value, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 1
  %40 = load i32, i32* %off, align 4
  %conv = sext i32 %40 to i64
  %add = add i64 %38, %conv
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i64 0, i64 0), i64 noundef %add) #14
  br label %if.end141

if.else:                                          ; preds = %land.lhs.true13, %lor.lhs.false
  %41 = load i32, i32* %t, align 4
  %cmp16 = icmp eq i32 %41, 19
  br i1 %cmp16, label %if.then24, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.else
  %42 = load i32, i32* %t, align 4
  %cmp19 = icmp eq i32 %42, 20
  br i1 %cmp19, label %if.then24, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %lor.lhs.false18
  %43 = load i32, i32* %t, align 4
  %cmp22 = icmp eq i32 %43, 27
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %lor.lhs.false21, %lor.lhs.false18, %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 2
  %48 = bitcast %union.anon.152* %47 to %struct.anon.154*
  %btf = getelementptr inbounds %struct.anon.154, %struct.anon.154* %48, i32 0, i32 0
  %49 = load %struct.btf*, %struct.btf** %btf, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 2
  %52 = bitcast %union.anon.152* %51 to %struct.anon.154*
  %btf_id = getelementptr inbounds %struct.anon.154, %struct.anon.154* %52, i32 0, i32 1
  %53 = load i32, i32* %btf_id, align 8
  %call25 = call i8* @kernel_type_name(%struct.btf* noundef %49, i32 noundef %53) #14
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.45, i64 0, i64 0), i8* noundef %call25) #14
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %lor.lhs.false21
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 3
  %57 = load i32, i32* %id, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.46, i64 0, i64 0), i32 noundef %57) #14
  %58 = load i32, i32* %t, align 4
  %call27 = call zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %58) #14
  br i1 %call27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end26
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = bitcast %struct.bpf_verifier_env* %59 to i8*
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 4
  %62 = load i32, i32* %ref_obj_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %60, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str.47, i64 0, i64 0), i32 noundef %62) #14
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end26
  %63 = load i32, i32* %t, align 4
  %cmp30 = icmp ne i32 %63, 1
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end29
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 1
  %67 = load i32, i32* %off33, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.48, i64 0, i64 0), i32 noundef %67) #14
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end29
  %68 = load i32, i32* %t, align 4
  %call35 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %68) #14
  br i1 %call35, label %if.then36, label %if.else37

if.then36:                                        ; preds = %if.end34
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = bitcast %struct.bpf_verifier_env* %69 to i8*
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 2
  %range = bitcast %union.anon.152* %72 to i32*
  %73 = load i32, i32* %range, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %70, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i64 0, i64 0), i32 noundef %73) #14
  br label %if.end52

if.else37:                                        ; preds = %if.end34
  %74 = load i32, i32* %t, align 4
  %cmp38 = icmp eq i32 %74, 3
  br i1 %cmp38, label %if.then49, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %if.else37
  %75 = load i32, i32* %t, align 4
  %cmp41 = icmp eq i32 %75, 29
  br i1 %cmp41, label %if.then49, label %lor.lhs.false43

lor.lhs.false43:                                  ; preds = %lor.lhs.false40
  %76 = load i32, i32* %t, align 4
  %cmp44 = icmp eq i32 %76, 4
  br i1 %cmp44, label %if.then49, label %lor.lhs.false46

lor.lhs.false46:                                  ; preds = %lor.lhs.false43
  %77 = load i32, i32* %t, align 4
  %cmp47 = icmp eq i32 %77, 5
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %lor.lhs.false46, %lor.lhs.false43, %lor.lhs.false40, %if.else37
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = bitcast %struct.bpf_verifier_env* %78 to i8*
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 2
  %82 = bitcast %union.anon.152* %81 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %82, i32 0, i32 0
  %83 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %83, i32 0, i32 4
  %84 = load i32, i32* %key_size, align 4
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 2
  %87 = bitcast %union.anon.152* %86 to %struct.anon.153*
  %map_ptr50 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %87, i32 0, i32 0
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr50, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %88, i32 0, i32 5
  %89 = load i32, i32* %value_size, align 32
  call void (i8*, i8*, ...) @verbose(i8* noundef %79, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.50, i64 0, i64 0), i32 noundef %84, i32 noundef %89) #14
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %lor.lhs.false46
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.then36
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 5
  %91 = bitcast %struct.tnum* %var_off53 to { i64, i64 }*
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %91, i32 0, i32 0
  %93 = load i64, i64* %92, align 8
  %94 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %91, i32 0, i32 1
  %95 = load i64, i64* %94, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %93, i64 %95) #14
  br i1 %call54, label %if.then55, label %if.else58

if.then55:                                        ; preds = %if.end52
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %97 = bitcast %struct.bpf_verifier_env* %96 to i8*
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %98, i32 0, i32 5
  %value57 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off56, i32 0, i32 0
  %99 = load i64, i64* %value57, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %97, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.51, i64 0, i64 0), i64 noundef %99) #14
  br label %if.end140

if.else58:                                        ; preds = %if.end52
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %100, i32 0, i32 6
  %101 = load i64, i64* %smin_value, align 8
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 8
  %103 = load i64, i64* %umin_value, align 8
  %cmp59 = icmp ne i64 %101, %103
  br i1 %cmp59, label %land.lhs.true61, label %if.end67

land.lhs.true61:                                  ; preds = %if.else58
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value62 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 6
  %105 = load i64, i64* %smin_value62, align 8
  %cmp63 = icmp ne i64 %105, -9223372036854775808
  br i1 %cmp63, label %if.then65, label %if.end67

if.then65:                                        ; preds = %land.lhs.true61
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %108, i32 0, i32 6
  %109 = load i64, i64* %smin_value66, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.52, i64 0, i64 0), i64 noundef %109) #14
  br label %if.end67

if.end67:                                         ; preds = %if.then65, %land.lhs.true61, %if.else58
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %110, i32 0, i32 7
  %111 = load i64, i64* %smax_value, align 8
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 9
  %113 = load i64, i64* %umax_value, align 8
  %cmp68 = icmp ne i64 %111, %113
  br i1 %cmp68, label %land.lhs.true70, label %if.end76

land.lhs.true70:                                  ; preds = %if.end67
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i32 0, i32 7
  %115 = load i64, i64* %smax_value71, align 8
  %cmp72 = icmp ne i64 %115, 9223372036854775807
  br i1 %cmp72, label %if.then74, label %if.end76

if.then74:                                        ; preds = %land.lhs.true70
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = bitcast %struct.bpf_verifier_env* %116 to i8*
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 7
  %119 = load i64, i64* %smax_value75, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %117, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.53, i64 0, i64 0), i64 noundef %119) #14
  br label %if.end76

if.end76:                                         ; preds = %if.then74, %land.lhs.true70, %if.end67
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %120, i32 0, i32 8
  %121 = load i64, i64* %umin_value77, align 8
  %cmp78 = icmp ne i64 %121, 0
  br i1 %cmp78, label %if.then80, label %if.end82

if.then80:                                        ; preds = %if.end76
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = bitcast %struct.bpf_verifier_env* %122 to i8*
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 8
  %125 = load i64, i64* %umin_value81, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %123, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.54, i64 0, i64 0), i64 noundef %125) #14
  br label %if.end82

if.end82:                                         ; preds = %if.then80, %if.end76
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 9
  %127 = load i64, i64* %umax_value83, align 8
  %cmp84 = icmp ne i64 %127, -1
  br i1 %cmp84, label %if.then86, label %if.end88

if.then86:                                        ; preds = %if.end82
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %129 = bitcast %struct.bpf_verifier_env* %128 to i8*
  %130 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %130, i32 0, i32 9
  %131 = load i64, i64* %umax_value87, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %129, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.55, i64 0, i64 0), i64 noundef %131) #14
  br label %if.end88

if.end88:                                         ; preds = %if.then86, %if.end82
  %132 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %132, i32 0, i32 5
  %133 = bitcast %struct.tnum* %var_off89 to { i64, i64 }*
  %134 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 0
  %135 = load i64, i64* %134, align 8
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 1
  %137 = load i64, i64* %136, align 8
  %call90 = call zeroext i1 @tnum_is_unknown(i64 %135, i64 %137) #14
  br i1 %call90, label %if.end95, label %if.then91

if.then91:                                        ; preds = %if.end88
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off92 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call93 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %141, i64 %143) #14
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %145 = bitcast %struct.bpf_verifier_env* %144 to i8*
  %arraydecay94 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %145, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.56, i64 0, i64 0), i8* noundef %arraydecay94) #14
  br label %if.end95

if.end95:                                         ; preds = %if.then91, %if.end88
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i32 0, i32 10
  %147 = load i32, i32* %s32_min_value, align 8
  %conv96 = sext i32 %147 to i64
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 6
  %149 = load i64, i64* %smin_value97, align 8
  %cmp98 = icmp ne i64 %conv96, %149
  br i1 %cmp98, label %land.lhs.true100, label %if.end106

land.lhs.true100:                                 ; preds = %if.end95
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value101 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i32 0, i32 10
  %151 = load i32, i32* %s32_min_value101, align 8
  %cmp102 = icmp ne i32 %151, -2147483648
  br i1 %cmp102, label %if.then104, label %if.end106

if.then104:                                       ; preds = %land.lhs.true100
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %153 = bitcast %struct.bpf_verifier_env* %152 to i8*
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value105 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 10
  %155 = load i32, i32* %s32_min_value105, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %153, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.57, i64 0, i64 0), i32 noundef %155) #14
  br label %if.end106

if.end106:                                        ; preds = %if.then104, %land.lhs.true100, %if.end95
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 11
  %157 = load i32, i32* %s32_max_value, align 4
  %conv107 = sext i32 %157 to i64
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 7
  %159 = load i64, i64* %smax_value108, align 8
  %cmp109 = icmp ne i64 %conv107, %159
  br i1 %cmp109, label %land.lhs.true111, label %if.end117

land.lhs.true111:                                 ; preds = %if.end106
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value112 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 11
  %161 = load i32, i32* %s32_max_value112, align 4
  %cmp113 = icmp ne i32 %161, 2147483647
  br i1 %cmp113, label %if.then115, label %if.end117

if.then115:                                       ; preds = %land.lhs.true111
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %163 = bitcast %struct.bpf_verifier_env* %162 to i8*
  %164 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value116 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %164, i32 0, i32 11
  %165 = load i32, i32* %s32_max_value116, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %163, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.58, i64 0, i64 0), i32 noundef %165) #14
  br label %if.end117

if.end117:                                        ; preds = %if.then115, %land.lhs.true111, %if.end106
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 12
  %167 = load i32, i32* %u32_min_value, align 8
  %conv118 = zext i32 %167 to i64
  %168 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value119 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %168, i32 0, i32 8
  %169 = load i64, i64* %umin_value119, align 8
  %cmp120 = icmp ne i64 %conv118, %169
  br i1 %cmp120, label %land.lhs.true122, label %if.end128

land.lhs.true122:                                 ; preds = %if.end117
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %170, i32 0, i32 12
  %171 = load i32, i32* %u32_min_value123, align 8
  %cmp124 = icmp ne i32 %171, 0
  br i1 %cmp124, label %if.then126, label %if.end128

if.then126:                                       ; preds = %land.lhs.true122
  %172 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %173 = bitcast %struct.bpf_verifier_env* %172 to i8*
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %174, i32 0, i32 12
  %175 = load i32, i32* %u32_min_value127, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %173, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.59, i64 0, i64 0), i32 noundef %175) #14
  br label %if.end128

if.end128:                                        ; preds = %if.then126, %land.lhs.true122, %if.end117
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i32 0, i32 13
  %177 = load i32, i32* %u32_max_value, align 4
  %conv129 = zext i32 %177 to i64
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value130 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 9
  %179 = load i64, i64* %umax_value130, align 8
  %cmp131 = icmp ne i64 %conv129, %179
  br i1 %cmp131, label %land.lhs.true133, label %if.end139

land.lhs.true133:                                 ; preds = %if.end128
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value134 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %180, i32 0, i32 13
  %181 = load i32, i32* %u32_max_value134, align 4
  %cmp135 = icmp ne i32 %181, -1
  br i1 %cmp135, label %if.then137, label %if.end139

if.then137:                                       ; preds = %land.lhs.true133
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %183 = bitcast %struct.bpf_verifier_env* %182 to i8*
  %184 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %184, i32 0, i32 13
  %185 = load i32, i32* %u32_max_value138, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %183, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.60, i64 0, i64 0), i32 noundef %185) #14
  br label %if.end139

if.end139:                                        ; preds = %if.then137, %land.lhs.true133, %if.end128
  br label %if.end140

if.end140:                                        ; preds = %if.end139, %if.then55
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %187 = bitcast %struct.bpf_verifier_env* %186 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %187, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.61, i64 0, i64 0)) #14
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.then14
  br label %for.inc

for.inc:                                          ; preds = %if.end141, %if.then3
  %188 = load i32, i32* %i, align 4
  %inc = add i32 %188, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond142

for.cond142:                                      ; preds = %for.inc221, %for.end
  %189 = load i32, i32* %i, align 4
  %190 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %190, i32 0, i32 9
  %191 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %191, 8
  %cmp143 = icmp slt i32 %189, %div
  br i1 %cmp143, label %for.body145, label %for.end223

for.body145:                                      ; preds = %for.cond142
  store i8 0, i8* %valid, align 1
  store i32 0, i32* %j, align 4
  br label %for.cond146

for.cond146:                                      ; preds = %for.inc169, %for.body145
  %192 = load i32, i32* %j, align 4
  %cmp147 = icmp slt i32 %192, 8
  br i1 %cmp147, label %for.body149, label %for.end171

for.body149:                                      ; preds = %for.cond146
  %193 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %193, i32 0, i32 10
  %194 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %195 = load i32, i32* %i, align 4
  %idxprom150 = sext i32 %195 to i64
  %arrayidx151 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %194, i64 %idxprom150
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx151, i32 0, i32 1
  %196 = load i32, i32* %j, align 4
  %idxprom152 = sext i32 %196 to i64
  %arrayidx153 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom152
  %197 = load i8, i8* %arrayidx153, align 1
  %conv154 = zext i8 %197 to i32
  %cmp155 = icmp ne i32 %conv154, 0
  br i1 %cmp155, label %if.then157, label %if.end158

if.then157:                                       ; preds = %for.body149
  store i8 1, i8* %valid, align 1
  br label %if.end158

if.end158:                                        ; preds = %if.then157, %for.body149
  %198 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack159 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %198, i32 0, i32 10
  %199 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack159, align 8
  %200 = load i32, i32* %i, align 4
  %idxprom160 = sext i32 %200 to i64
  %arrayidx161 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %199, i64 %idxprom160
  %slot_type162 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx161, i32 0, i32 1
  %201 = load i32, i32* %j, align 4
  %idxprom163 = sext i32 %201 to i64
  %arrayidx164 = getelementptr [8 x i8], [8 x i8]* %slot_type162, i64 0, i64 %idxprom163
  %202 = load i8, i8* %arrayidx164, align 1
  %idxprom165 = zext i8 %202 to i64
  %arrayidx166 = getelementptr [4 x i8], [4 x i8]* @slot_type_char, i64 0, i64 %idxprom165
  %203 = load i8, i8* %arrayidx166, align 1
  %204 = load i32, i32* %j, align 4
  %idxprom167 = sext i32 %204 to i64
  %arrayidx168 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 %idxprom167
  store i8 %203, i8* %arrayidx168, align 1
  br label %for.inc169

for.inc169:                                       ; preds = %if.end158
  %205 = load i32, i32* %j, align 4
  %inc170 = add i32 %205, 1
  store i32 %inc170, i32* %j, align 4
  br label %for.cond146

for.end171:                                       ; preds = %for.cond146
  %arrayidx172 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 8
  store i8 0, i8* %arrayidx172, align 1
  %206 = load i8, i8* %valid, align 1
  %tobool173 = trunc i8 %206 to i1
  br i1 %tobool173, label %if.end175, label %if.then174

if.then174:                                       ; preds = %for.end171
  br label %for.inc221

if.end175:                                        ; preds = %for.end171
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %208 = bitcast %struct.bpf_verifier_env* %207 to i8*
  %209 = load i32, i32* %i, align 4
  %sub = sub i32 0, %209
  %sub176 = sub i32 %sub, 1
  %mul = mul i32 %sub176, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %208, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.62, i64 0, i64 0), i32 noundef %mul) #14
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %211 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack177 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %211, i32 0, i32 10
  %212 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack177, align 8
  %213 = load i32, i32* %i, align 4
  %idxprom178 = sext i32 %213 to i64
  %arrayidx179 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %212, i64 %idxprom178
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx179, i32 0, i32 0
  %live180 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %214 = load i32, i32* %live180, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %210, i32 noundef %214) #14
  %215 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack181 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %215, i32 0, i32 10
  %216 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack181, align 8
  %217 = load i32, i32* %i, align 4
  %idxprom182 = sext i32 %217 to i64
  %arrayidx183 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %216, i64 %idxprom182
  %slot_type184 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx183, i32 0, i32 1
  %arrayidx185 = getelementptr [8 x i8], [8 x i8]* %slot_type184, i64 0, i64 0
  %218 = load i8, i8* %arrayidx185, align 8
  %conv186 = zext i8 %218 to i32
  %cmp187 = icmp eq i32 %conv186, 1
  br i1 %cmp187, label %if.then189, label %if.else218

if.then189:                                       ; preds = %if.end175
  %219 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack190 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %219, i32 0, i32 10
  %220 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack190, align 8
  %221 = load i32, i32* %i, align 4
  %idxprom191 = sext i32 %221 to i64
  %arrayidx192 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %220, i64 %idxprom191
  %spilled_ptr193 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx192, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr193, %struct.bpf_reg_state** %reg, align 8
  %222 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type194 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %222, i32 0, i32 0
  %223 = load i32, i32* %type194, align 8
  store i32 %223, i32* %t, align 4
  %224 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %225 = bitcast %struct.bpf_verifier_env* %224 to i8*
  %226 = load i32, i32* %t, align 4
  %idxprom195 = zext i32 %226 to i64
  %arrayidx196 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom195
  %227 = load i8*, i8** %arrayidx196, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %225, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i64 0, i64 0), i8* noundef %227) #14
  %228 = load i32, i32* %t, align 4
  %cmp197 = icmp eq i32 %228, 1
  br i1 %cmp197, label %land.lhs.true199, label %if.end204

land.lhs.true199:                                 ; preds = %if.then189
  %229 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %229, i32 0, i32 18
  %230 = load i8, i8* %precise200, align 4
  %tobool201 = trunc i8 %230 to i1
  br i1 %tobool201, label %if.then203, label %if.end204

if.then203:                                       ; preds = %land.lhs.true199
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %232 = bitcast %struct.bpf_verifier_env* %231 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %232, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.43, i64 0, i64 0)) #14
  br label %if.end204

if.end204:                                        ; preds = %if.then203, %land.lhs.true199, %if.then189
  %233 = load i32, i32* %t, align 4
  %cmp205 = icmp eq i32 %233, 1
  br i1 %cmp205, label %land.lhs.true207, label %if.end217

land.lhs.true207:                                 ; preds = %if.end204
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 5
  %235 = bitcast %struct.tnum* %var_off208 to { i64, i64 }*
  %236 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %235, i32 0, i32 0
  %237 = load i64, i64* %236, align 8
  %238 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %235, i32 0, i32 1
  %239 = load i64, i64* %238, align 8
  %call209 = call zeroext i1 @tnum_is_const(i64 %237, i64 %239) #14
  br i1 %call209, label %if.then211, label %if.end217

if.then211:                                       ; preds = %land.lhs.true207
  %240 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %241 = bitcast %struct.bpf_verifier_env* %240 to i8*
  %242 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off212 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %242, i32 0, i32 5
  %value213 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off212, i32 0, i32 0
  %243 = load i64, i64* %value213, align 8
  %244 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off214 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %244, i32 0, i32 1
  %245 = load i32, i32* %off214, align 4
  %conv215 = sext i32 %245 to i64
  %add216 = add i64 %243, %conv215
  call void (i8*, i8*, ...) @verbose(i8* noundef %241, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i64 0, i64 0), i64 noundef %add216) #14
  br label %if.end217

if.end217:                                        ; preds = %if.then211, %land.lhs.true207, %if.end204
  br label %if.end220

if.else218:                                       ; preds = %if.end175
  %246 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %247 = bitcast %struct.bpf_verifier_env* %246 to i8*
  %arraydecay219 = getelementptr inbounds [9 x i8], [9 x i8]* %types_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %247, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i64 0, i64 0), i8* noundef %arraydecay219) #14
  br label %if.end220

if.end220:                                        ; preds = %if.else218, %if.end217
  br label %for.inc221

for.inc221:                                       ; preds = %if.end220, %if.then174
  %248 = load i32, i32* %i, align 4
  %inc222 = add i32 %248, 1
  store i32 %inc222, i32* %i, align 4
  br label %for.cond142

for.end223:                                       ; preds = %for.cond142
  %249 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %249, i32 0, i32 7
  %250 = load i32, i32* %acquired_refs, align 4
  %tobool224 = icmp ne i32 %250, 0
  br i1 %tobool224, label %land.lhs.true225, label %if.end252

land.lhs.true225:                                 ; preds = %for.end223
  %251 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %251, i32 0, i32 8
  %252 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %arrayidx226 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %252, i64 0
  %id227 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx226, i32 0, i32 0
  %253 = load i32, i32* %id227, align 4
  %tobool228 = icmp ne i32 %253, 0
  br i1 %tobool228, label %if.then229, label %if.end252

if.then229:                                       ; preds = %land.lhs.true225
  %254 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %255 = bitcast %struct.bpf_verifier_env* %254 to i8*
  %256 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs230 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %256, i32 0, i32 8
  %257 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs230, align 8
  %arrayidx231 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %257, i64 0
  %id232 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx231, i32 0, i32 0
  %258 = load i32, i32* %id232, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %255, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.63, i64 0, i64 0), i32 noundef %258) #14
  store i32 1, i32* %i, align 4
  br label %for.cond233

for.cond233:                                      ; preds = %for.inc249, %if.then229
  %259 = load i32, i32* %i, align 4
  %260 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs234 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %260, i32 0, i32 7
  %261 = load i32, i32* %acquired_refs234, align 4
  %cmp235 = icmp slt i32 %259, %261
  br i1 %cmp235, label %for.body237, label %for.end251

for.body237:                                      ; preds = %for.cond233
  %262 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs238 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %262, i32 0, i32 8
  %263 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs238, align 8
  %264 = load i32, i32* %i, align 4
  %idxprom239 = sext i32 %264 to i64
  %arrayidx240 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %263, i64 %idxprom239
  %id241 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx240, i32 0, i32 0
  %265 = load i32, i32* %id241, align 4
  %tobool242 = icmp ne i32 %265, 0
  br i1 %tobool242, label %if.then243, label %if.end248

if.then243:                                       ; preds = %for.body237
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %267 = bitcast %struct.bpf_verifier_env* %266 to i8*
  %268 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs244 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %268, i32 0, i32 8
  %269 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs244, align 8
  %270 = load i32, i32* %i, align 4
  %idxprom245 = sext i32 %270 to i64
  %arrayidx246 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %269, i64 %idxprom245
  %id247 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx246, i32 0, i32 0
  %271 = load i32, i32* %id247, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %267, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.64, i64 0, i64 0), i32 noundef %271) #14
  br label %if.end248

if.end248:                                        ; preds = %if.then243, %for.body237
  br label %for.inc249

for.inc249:                                       ; preds = %if.end248
  %272 = load i32, i32* %i, align 4
  %inc250 = add i32 %272, 1
  store i32 %inc250, i32* %i, align 4
  br label %for.cond233

for.end251:                                       ; preds = %for.cond233
  br label %if.end252

if.end252:                                        ; preds = %for.end251, %land.lhs.true225, %for.end223
  %273 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %273, i32 0, i32 5
  %274 = load i8, i8* %in_callback_fn, align 8
  %tobool253 = trunc i8 %274 to i1
  br i1 %tobool253, label %if.then254, label %if.end255

if.then254:                                       ; preds = %if.end252
  %275 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %276 = bitcast %struct.bpf_verifier_env* %275 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %276, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.65, i64 0, i64 0)) #14
  br label %if.end255

if.end255:                                        ; preds = %if.then254, %if.end252
  %277 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %277, i32 0, i32 6
  %278 = load i8, i8* %in_async_callback_fn, align 1
  %tobool256 = trunc i8 %278 to i1
  br i1 %tobool256, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.end255
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %280 = bitcast %struct.bpf_verifier_env* %279 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %280, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.66, i64 0, i64 0)) #14
  br label %if.end258

if.end258:                                        ; preds = %if.then257, %if.end255
  %281 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %282 = bitcast %struct.bpf_verifier_env* %281 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %282, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.67, i64 0, i64 0)) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_liveness(%struct.bpf_verifier_env* noundef %env, i32 noundef %live) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %live.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %live, i32* %live.addr, align 4
  %0 = load i32, i32* %live.addr, align 4
  %and = and i32 %0, 15
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.68, i64 0, i64 0)) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %live.addr, align 4
  %and1 = and i32 %3, 3
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.69, i64 0, i64 0)) #14
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %6 = load i32, i32* %live.addr, align 4
  %and5 = and i32 %6, 4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.70, i64 0, i64 0)) #14
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %9 = load i32, i32* %live.addr, align 4
  %and9 = and i32 %9, 8
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i64 0, i64 0)) #14
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kernel_type_name(%struct.btf* noundef %btf, i32 noundef %id) #0 {
entry:
  %btf.addr = alloca %struct.btf*, align 8
  %id.addr = alloca i32, align 4
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %0 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %1 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %2 = load i32, i32* %id.addr, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %1, i32 noundef %2) #14
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %call, i32 0, i32 0
  %3 = load i32, i32* %name_off, align 4
  %call1 = call i8* @btf_name_by_offset(%struct.btf* noundef %0, i32 noundef %3) #14
  ret i8* %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 15
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 16
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp7 = icmp eq i32 %4, 21
  br i1 %cmp7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false6
  %5 = load i32, i32* %type.addr, align 4
  %cmp8 = icmp eq i32 %5, 22
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %6 = phi i1 [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp8, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_pkt_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_unknown(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %neg = xor i64 %3, -1
  %tobool = icmp ne i64 %neg, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %access_flags = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 7
  %1 = load i32, i32* %map_flags, align 8
  %and = and i32 %1, 384
  store i32 %and, i32* %access_flags, align 4
  %2 = load i32, i32* %access_flags, align 4
  %and1 = and i32 %2, 128
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %access_flags, align 4
  %and2 = and i32 %3, 256
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store i32 2, i32* %retval, align 4
  br label %return

if.else5:                                         ; preds = %if.else
  store i32 3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else5, %if.then4, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 8
  %1 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp sge i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %timer_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 9
  %1 = load i32, i32* %timer_off, align 16
  %cmp = icmp sge i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %env, i8* noundef %buf_info, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %buf_info.addr = alloca i8*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %buf_info, i8** %buf_info.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  %3 = load i32, i32* %regno.addr, align 4
  %4 = load i8*, i8** %buf_info.addr, align 8
  %5 = load i32, i32* %off.addr, align 4
  %6 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.76, i64 0, i64 0), i32 noundef %3, i8* noundef %4, i32 noundef %5, i32 noundef %6) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #14
  br i1 %call, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %14, 0
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call4 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %18, i64 %20) #14
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load i32, i32* %regno.addr, align 4
  %24 = load i32, i32* %off.addr, align 4
  %arraydecay5 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.77, i64 0, i64 0), i32 noundef %23, i32 noundef %24, i8* noundef %arraydecay5) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then2, %if.then
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idx.ext
  ret %struct.bpf_reg_state* %add.ptr
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 15
  %4 = load i32, i32* %frameno, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_access_within_bounds(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %access_size, i32 noundef %src, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %err = alloca i32, align 4
  %err_extra = alloca i8*, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  store i32 %src, i32* %src.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %3, %struct.bpf_reg_state* noundef %4) #14
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %5 = load i32, i32* %src.addr, align 4
  %cmp = icmp eq i32 %5, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.84, i64 0, i64 0), i8** %err_extra, align 8
  br label %if.end5

if.else:                                          ; preds = %entry
  %6 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %6, 1
  br i1 %cmp2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.else
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.85, i64 0, i64 0), i8** %err_extra, align 8
  br label %if.end

if.else4:                                         ; preds = %if.else
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.86, i64 0, i64 0), i8** %err_extra, align 8
  br label %if.end

if.end:                                           ; preds = %if.else4, %if.then3
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #14
  br i1 %call6, label %if.then7, label %if.else16

if.then7:                                         ; preds = %if.end5
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %15 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %15 to i64
  %add = add i64 %14, %conv
  %conv9 = trunc i64 %add to i32
  store i32 %conv9, i32* %min_off, align 4
  %16 = load i32, i32* %access_size.addr, align 4
  %cmp10 = icmp sgt i32 %16, 0
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.then7
  %17 = load i32, i32* %min_off, align 4
  %18 = load i32, i32* %access_size.addr, align 4
  %add13 = add i32 %17, %18
  %sub = sub i32 %add13, 1
  store i32 %sub, i32* %max_off, align 4
  br label %if.end15

if.else14:                                        ; preds = %if.then7
  %19 = load i32, i32* %min_off, align 4
  store i32 %19, i32* %max_off, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else14, %if.then12
  br label %if.end39

if.else16:                                        ; preds = %if.end5
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value, align 8
  %cmp17 = icmp sge i64 %21, 536870912
  br i1 %cmp17, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else16
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value, align 8
  %cmp19 = icmp sle i64 %23, -536870912
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %lor.lhs.false, %if.else16
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i8*, i8** %err_extra, align 8
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.87, i64 0, i64 0), i8* noundef %26, i32 noundef %27) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %lor.lhs.false
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 6
  %29 = load i64, i64* %smin_value23, align 8
  %30 = load i32, i32* %off.addr, align 4
  %conv24 = sext i32 %30 to i64
  %add25 = add i64 %29, %conv24
  %conv26 = trunc i64 %add25 to i32
  store i32 %conv26, i32* %min_off, align 4
  %31 = load i32, i32* %access_size.addr, align 4
  %cmp27 = icmp sgt i32 %31, 0
  br i1 %cmp27, label %if.then29, label %if.else37

if.then29:                                        ; preds = %if.end22
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 7
  %33 = load i64, i64* %smax_value30, align 8
  %34 = load i32, i32* %off.addr, align 4
  %conv31 = sext i32 %34 to i64
  %add32 = add i64 %33, %conv31
  %35 = load i32, i32* %access_size.addr, align 4
  %conv33 = sext i32 %35 to i64
  %add34 = add i64 %add32, %conv33
  %sub35 = sub i64 %add34, 1
  %conv36 = trunc i64 %sub35 to i32
  store i32 %conv36, i32* %max_off, align 4
  br label %if.end38

if.else37:                                        ; preds = %if.end22
  %36 = load i32, i32* %min_off, align 4
  store i32 %36, i32* %max_off, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.else37, %if.then29
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end15
  %37 = load i32, i32* %min_off, align 4
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %39 = load i32, i32* %type.addr, align 4
  %call40 = call i32 @check_stack_slot_within_bounds(i32 noundef %37, %struct.bpf_func_state* noundef %38, i32 noundef %39) #14
  store i32 %call40, i32* %err, align 4
  %40 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %40, 0
  br i1 %tobool, label %if.end43, label %if.then41

if.then41:                                        ; preds = %if.end39
  %41 = load i32, i32* %max_off, align 4
  %42 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %43 = load i32, i32* %type.addr, align 4
  %call42 = call i32 @check_stack_slot_within_bounds(i32 noundef %41, %struct.bpf_func_state* noundef %42, i32 noundef %43) #14
  store i32 %call42, i32* %err, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end39
  %44 = load i32, i32* %err, align 4
  %tobool44 = icmp ne i32 %44, 0
  br i1 %tobool44, label %if.then45, label %if.end54

if.then45:                                        ; preds = %if.end43
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = bitcast %struct.tnum* %var_off46 to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = load i64, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = load i64, i64* %49, align 8
  %call47 = call zeroext i1 @tnum_is_const(i64 %48, i64 %50) #14
  br i1 %call47, label %if.then48, label %if.else49

if.then48:                                        ; preds = %if.then45
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i8*, i8** %err_extra, align 8
  %54 = load i32, i32* %regno.addr, align 4
  %55 = load i32, i32* %off.addr, align 4
  %56 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.88, i64 0, i64 0), i8* noundef %53, i32 noundef %54, i32 noundef %55, i32 noundef %56) #14
  br label %if.end53

if.else49:                                        ; preds = %if.then45
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off50 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 5
  %58 = bitcast %struct.tnum* %var_off50 to { i64, i64 }*
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 0
  %60 = load i64, i64* %59, align 8
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 1
  %62 = load i64, i64* %61, align 8
  %call51 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %60, i64 %62) #14
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = bitcast %struct.bpf_verifier_env* %63 to i8*
  %65 = load i8*, i8** %err_extra, align 8
  %66 = load i32, i32* %regno.addr, align 4
  %arraydecay52 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %67 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %64, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.89, i64 0, i64 0), i8* noundef %65, i32 noundef %66, i8* noundef %arraydecay52, i32 noundef %67) #14
  br label %if.end53

if.end53:                                         ; preds = %if.else49, %if.then48
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end43
  %68 = load i32, i32* %err, align 4
  store i32 %68, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end54, %if.then21
  %69 = load i32, i32* %retval, align 4
  ret i32 %69
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 15
  store i32 0, i32* %frameno, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 31
  %5 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ugt i32 %5, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 20
  %7 = load i8, i8* %bpf_capable, align 8
  %tobool = trunc i8 %7 to i1
  %lnot = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %8 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 18
  %frombool = zext i1 %8 to i8
  store i8 %frombool, i8* %precise, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %10) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %state, %struct.bpf_reg_state* noundef %parent, i8 noundef zeroext %flag) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_reg_state*, align 8
  %parent.addr = alloca %struct.bpf_reg_state*, align 8
  %flag.addr = alloca i8, align 1
  %writes = alloca i8, align 1
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %state, %struct.bpf_reg_state** %state.addr, align 8
  store %struct.bpf_reg_state* %parent, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 %flag, i8* %flag.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 14
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent1, align 8
  %cmp = icmp eq %struct.bpf_reg_state* %0, %2
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %writes, align 1
  store i32 0, i32* %cnt, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8, i8* %writes, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 17
  %6 = load i32, i32* %live, align 8
  %and = and i32 %6, 4
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 17
  %8 = load i32, i32* %live4, align 8
  %and5 = and i32 %8, 8
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 0
  %12 = load i32, i32* %type, align 8
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %13 = load i8*, i8** %arrayidx, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %15 = load i64, i64* %value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 1
  %17 = load i32, i32* %off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.90, i64 0, i64 0), i8* noundef %13, i64 noundef %15, i32 noundef %17) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 17
  %19 = load i32, i32* %live9, align 8
  %and10 = and i32 %19, 3
  %20 = load i8, i8* %flag.addr, align 1
  %conv = zext i8 %20 to i32
  %cmp11 = icmp eq i32 %and10, %conv
  br i1 %cmp11, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 17
  %22 = load i32, i32* %live13, align 8
  %and14 = and i32 %22, 2
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end8
  br label %while.end

if.end17:                                         ; preds = %lor.lhs.false
  %23 = load i8, i8* %flag.addr, align 1
  %conv18 = zext i8 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 17
  %25 = load i32, i32* %live19, align 8
  %or = or i32 %25, %conv18
  store i32 %or, i32* %live19, align 8
  %26 = load i8, i8* %flag.addr, align 1
  %conv20 = zext i8 %26 to i32
  %cmp21 = icmp eq i32 %conv20, 2
  br i1 %cmp21, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.end17
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 17
  %28 = load i32, i32* %live24, align 8
  %and25 = and i32 %28, -2
  store i32 %and25, i32* %live24, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.end17
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  store %struct.bpf_reg_state* %29, %struct.bpf_reg_state** %state.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 14
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent27, align 8
  store %struct.bpf_reg_state* %31, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 1, i8* %writes, align 1
  %32 = load i32, i32* %cnt, align 4
  %inc = add i32 %32, 1
  store i32 %inc, i32* %cnt, align 4
  br label %while.cond

while.end:                                        ; preds = %if.then16, %if.then, %while.cond
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 40
  %34 = load i32, i32* %longest_mark_read_walk, align 4
  %35 = load i32, i32* %cnt, align 4
  %cmp28 = icmp ult i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %while.end
  %36 = load i32, i32* %cnt, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk31 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 40
  store i32 %36, i32* %longest_mark_read_walk31, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %while.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then7
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %func, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %stack = alloca i16, align 2
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %func, %struct.bpf_func_state** %func.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 3
  %2 = load i32, i32* %subprogno, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %3 = load i16, i16* %stack_depth, align 8
  store i16 %3, i16* %stack, align 2
  %4 = load i16, i16* %stack, align 2
  %conv = zext i16 %4 to i32
  %5 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %5
  %cmp = icmp sge i32 %conv, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %off.addr, align 4
  %sub2 = sub i32 0, %6
  %conv3 = trunc i32 %sub2 to i16
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 27
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 3
  %9 = load i32, i32* %subprogno5, align 8
  %idxprom6 = zext i32 %9 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info4, i64 0, i64 %idxprom6
  %stack_depth8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 2
  store i16 %conv3, i16* %stack_depth8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_slot_within_bounds(i32 noundef %off, %struct.bpf_func_state* noundef %state, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %t.addr = alloca i32, align 4
  %min_valid_off = alloca i32, align 4
  store i32 %off, i32* %off.addr, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load i32, i32* %t.addr, align 4
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -512, i32* %min_valid_off, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 9
  %2 = load i32, i32* %allocated_stack, align 8
  %sub = sub i32 0, %2
  store i32 %sub, i32* %min_valid_off, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %min_valid_off, align 4
  %cmp1 = icmp slt i32 %3, %4
  br i1 %cmp1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp sgt i32 %5, -1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  store i32 -13, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %1 = load i64, i64* %imm.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef %1) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @___mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load i64, i64* %imm.addr, align 8
  %call = call { i64, i64 } @tnum_const(i64 noundef %1) #14
  %2 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.tnum* %var_off to i8*
  %8 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 16, i1 false)
  %9 = load i64, i64* %imm.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  store i64 %9, i64* %smin_value, align 8
  %11 = load i64, i64* %imm.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  store i64 %11, i64* %smax_value, align 8
  %13 = load i64, i64* %imm.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  store i64 %13, i64* %umin_value, align 8
  %15 = load i64, i64* %imm.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  store i64 %15, i64* %umax_value, align 8
  %17 = load i64, i64* %imm.addr, align 8
  %conv = trunc i64 %17 to i32
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 10
  store i32 %conv, i32* %s32_min_value, align 8
  %19 = load i64, i64* %imm.addr, align 8
  %conv1 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  store i32 %conv1, i32* %s32_max_value, align 4
  %21 = load i64, i64* %imm.addr, align 8
  %conv2 = trunc i64 %21 to i32
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  store i32 %conv2, i32* %u32_min_value, align 8
  %23 = load i64, i64* %imm.addr, align 8
  %conv3 = trunc i64 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  store i32 %conv3, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_const(i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %var32_off = alloca %struct.tnum, align 8
  %__UNIQUE_ID___x435 = alloca i32, align 4
  %__UNIQUE_ID___y436 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x437 = alloca i32, align 4
  %__UNIQUE_ID___y438 = alloca i32, align 4
  %tmp8 = alloca i32, align 4
  %__UNIQUE_ID___x439 = alloca i32, align 4
  %__UNIQUE_ID___y440 = alloca i32, align 4
  %tmp18 = alloca i32, align 4
  %__UNIQUE_ID___x441 = alloca i32, align 4
  %__UNIQUE_ID___y442 = alloca i32, align 4
  %tmp30 = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #14
  %6 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 10
  %12 = load i32, i32* %s32_min_value, align 8
  store i32 %12, i32* %__UNIQUE_ID___x435, align 4
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %13 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %14 = load i64, i64* %mask, align 8
  %and = and i64 %14, -2147483648
  %or = or i64 %13, %and
  %conv = trunc i64 %or to i32
  store i32 %conv, i32* %__UNIQUE_ID___y436, align 4
  %15 = load i32, i32* %__UNIQUE_ID___x435, align 4
  %16 = load i32, i32* %__UNIQUE_ID___y436, align 4
  %cmp = icmp sgt i32 %15, %16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %17 = load i32, i32* %__UNIQUE_ID___x435, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load i32, i32* %__UNIQUE_ID___y436, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %17, %cond.true ], [ %18, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %19 = load i32, i32* %tmp, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 10
  store i32 %19, i32* %s32_min_value2, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 11
  %22 = load i32, i32* %s32_max_value, align 4
  store i32 %22, i32* %__UNIQUE_ID___x437, align 4
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %23 = load i64, i64* %value3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %24 = load i64, i64* %mask4, align 8
  %and5 = and i64 %24, 2147483647
  %or6 = or i64 %23, %and5
  %conv7 = trunc i64 %or6 to i32
  store i32 %conv7, i32* %__UNIQUE_ID___y438, align 4
  %25 = load i32, i32* %__UNIQUE_ID___x437, align 4
  %26 = load i32, i32* %__UNIQUE_ID___y438, align 4
  %cmp9 = icmp slt i32 %25, %26
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %27 = load i32, i32* %__UNIQUE_ID___x437, align 4
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %28 = load i32, i32* %__UNIQUE_ID___y438, align 4
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i32 [ %27, %cond.true11 ], [ %28, %cond.false12 ]
  store i32 %cond14, i32* %tmp8, align 4
  %29 = load i32, i32* %tmp8, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 11
  store i32 %29, i32* %s32_max_value15, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 12
  %32 = load i32, i32* %u32_min_value, align 8
  store i32 %32, i32* %__UNIQUE_ID___x439, align 4
  %value16 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %33 = load i64, i64* %value16, align 8
  %conv17 = trunc i64 %33 to i32
  store i32 %conv17, i32* %__UNIQUE_ID___y440, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x439, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y440, align 4
  %cmp19 = icmp ugt i32 %34, %35
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.end13
  %36 = load i32, i32* %__UNIQUE_ID___x439, align 4
  br label %cond.end23

cond.false22:                                     ; preds = %cond.end13
  %37 = load i32, i32* %__UNIQUE_ID___y440, align 4
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false22, %cond.true21
  %cond24 = phi i32 [ %36, %cond.true21 ], [ %37, %cond.false22 ]
  store i32 %cond24, i32* %tmp18, align 4
  %38 = load i32, i32* %tmp18, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 12
  store i32 %38, i32* %u32_min_value25, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  %41 = load i32, i32* %u32_max_value, align 4
  store i32 %41, i32* %__UNIQUE_ID___x441, align 4
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %42 = load i64, i64* %value26, align 8
  %mask27 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %43 = load i64, i64* %mask27, align 8
  %or28 = or i64 %42, %43
  %conv29 = trunc i64 %or28 to i32
  store i32 %conv29, i32* %__UNIQUE_ID___y442, align 4
  %44 = load i32, i32* %__UNIQUE_ID___x441, align 4
  %45 = load i32, i32* %__UNIQUE_ID___y442, align 4
  %cmp31 = icmp ult i32 %44, %45
  br i1 %cmp31, label %cond.true33, label %cond.false34

cond.true33:                                      ; preds = %cond.end23
  %46 = load i32, i32* %__UNIQUE_ID___x441, align 4
  br label %cond.end35

cond.false34:                                     ; preds = %cond.end23
  %47 = load i32, i32* %__UNIQUE_ID___y442, align 4
  br label %cond.end35

cond.end35:                                       ; preds = %cond.false34, %cond.true33
  %cond36 = phi i32 [ %46, %cond.true33 ], [ %47, %cond.false34 ]
  store i32 %cond36, i32* %tmp30, align 4
  %48 = load i32, i32* %tmp30, align 4
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 13
  store i32 %48, i32* %u32_max_value37, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg64_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x443 = alloca i64, align 8
  %__UNIQUE_ID___y444 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x445 = alloca i64, align 8
  %__UNIQUE_ID___y446 = alloca i64, align 8
  %tmp9 = alloca i64, align 8
  %__UNIQUE_ID___x447 = alloca i64, align 8
  %__UNIQUE_ID___y448 = alloca i64, align 8
  %tmp18 = alloca i64, align 8
  %__UNIQUE_ID___x449 = alloca i64, align 8
  %__UNIQUE_ID___y450 = alloca i64, align 8
  %tmp30 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x443, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %3 = load i64, i64* %value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 1
  %5 = load i64, i64* %mask, align 8
  %and = and i64 %5, -9223372036854775808
  %or = or i64 %3, %and
  store i64 %or, i64* %__UNIQUE_ID___y444, align 8
  %6 = load i64, i64* %__UNIQUE_ID___x443, align 8
  %7 = load i64, i64* %__UNIQUE_ID___y444, align 8
  %cmp = icmp sgt i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, i64* %__UNIQUE_ID___x443, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, i64* %__UNIQUE_ID___y444, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value2, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  store i64 %13, i64* %__UNIQUE_ID___x445, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %15 = load i64, i64* %value4, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  %17 = load i64, i64* %mask6, align 8
  %and7 = and i64 %17, 9223372036854775807
  %or8 = or i64 %15, %and7
  store i64 %or8, i64* %__UNIQUE_ID___y446, align 8
  %18 = load i64, i64* %__UNIQUE_ID___x445, align 8
  %19 = load i64, i64* %__UNIQUE_ID___y446, align 8
  %cmp10 = icmp slt i64 %18, %19
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %20 = load i64, i64* %__UNIQUE_ID___x445, align 8
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___y446, align 8
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i64 [ %20, %cond.true11 ], [ %21, %cond.false12 ]
  store i64 %cond14, i64* %tmp9, align 8
  %22 = load i64, i64* %tmp9, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 %22, i64* %smax_value15, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value, align 8
  store i64 %25, i64* %__UNIQUE_ID___x447, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 5
  %value17 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off16, i32 0, i32 0
  %27 = load i64, i64* %value17, align 8
  store i64 %27, i64* %__UNIQUE_ID___y448, align 8
  %28 = load i64, i64* %__UNIQUE_ID___x447, align 8
  %29 = load i64, i64* %__UNIQUE_ID___y448, align 8
  %cmp19 = icmp ugt i64 %28, %29
  br i1 %cmp19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end13
  %30 = load i64, i64* %__UNIQUE_ID___x447, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end13
  %31 = load i64, i64* %__UNIQUE_ID___y448, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %30, %cond.true20 ], [ %31, %cond.false21 ]
  store i64 %cond23, i64* %tmp18, align 8
  %32 = load i64, i64* %tmp18, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  store i64 %32, i64* %umin_value24, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value, align 8
  store i64 %35, i64* %__UNIQUE_ID___x449, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 5
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off25, i32 0, i32 0
  %37 = load i64, i64* %value26, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 5
  %mask28 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off27, i32 0, i32 1
  %39 = load i64, i64* %mask28, align 8
  %or29 = or i64 %37, %39
  store i64 %or29, i64* %__UNIQUE_ID___y450, align 8
  %40 = load i64, i64* %__UNIQUE_ID___x449, align 8
  %41 = load i64, i64* %__UNIQUE_ID___y450, align 8
  %cmp31 = icmp ult i64 %40, %41
  br i1 %cmp31, label %cond.true32, label %cond.false33

cond.true32:                                      ; preds = %cond.end22
  %42 = load i64, i64* %__UNIQUE_ID___x449, align 8
  br label %cond.end34

cond.false33:                                     ; preds = %cond.end22
  %43 = load i64, i64* %__UNIQUE_ID___y450, align 8
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false33, %cond.true32
  %cond35 = phi i64 [ %42, %cond.true32 ], [ %43, %cond.false33 ]
  store i64 %cond35, i64* %tmp30, align 8
  %44 = load i64, i64* %tmp30, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 9
  store i64 %44, i64* %umax_value36, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg32_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x451 = alloca i32, align 4
  %__UNIQUE_ID___y452 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x453 = alloca i32, align 4
  %__UNIQUE_ID___y454 = alloca i32, align 4
  %tmp7 = alloca i32, align 4
  %__UNIQUE_ID___x455 = alloca i32, align 4
  %__UNIQUE_ID___y456 = alloca i32, align 4
  %tmp22 = alloca i32, align 4
  %__UNIQUE_ID___x457 = alloca i32, align 4
  %__UNIQUE_ID___y458 = alloca i32, align 4
  %tmp35 = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  %cmp1 = icmp slt i32 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 10
  %5 = load i32, i32* %s32_min_value2, align 8
  store i32 %5, i32* %__UNIQUE_ID___x451, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  %7 = load i32, i32* %u32_min_value, align 8
  store i32 %7, i32* %__UNIQUE_ID___y452, align 4
  %8 = load i32, i32* %__UNIQUE_ID___x451, align 4
  %9 = load i32, i32* %__UNIQUE_ID___y452, align 4
  %cmp3 = icmp ugt i32 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i32, i32* %__UNIQUE_ID___x451, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i32, i32* %__UNIQUE_ID___y452, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %12 = load i32, i32* %tmp, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 12
  store i32 %12, i32* %u32_min_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 %12, i32* %s32_min_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  %16 = load i32, i32* %s32_max_value6, align 4
  store i32 %16, i32* %__UNIQUE_ID___x453, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 13
  %18 = load i32, i32* %u32_max_value, align 4
  store i32 %18, i32* %__UNIQUE_ID___y454, align 4
  %19 = load i32, i32* %__UNIQUE_ID___x453, align 4
  %20 = load i32, i32* %__UNIQUE_ID___y454, align 4
  %cmp8 = icmp ult i32 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i32, i32* %__UNIQUE_ID___x453, align 4
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i32, i32* %__UNIQUE_ID___y454, align 4
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i32 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i32 %cond12, i32* %tmp7, align 4
  %23 = load i32, i32* %tmp7, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  store i32 %23, i32* %u32_max_value13, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 11
  store i32 %23, i32* %s32_max_value14, align 4
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  %27 = load i32, i32* %u32_max_value15, align 4
  %cmp16 = icmp sge i32 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  %29 = load i32, i32* %u32_min_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 10
  store i32 %29, i32* %s32_min_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 11
  %32 = load i32, i32* %s32_max_value20, align 4
  store i32 %32, i32* %__UNIQUE_ID___x455, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  %34 = load i32, i32* %u32_max_value21, align 4
  store i32 %34, i32* %__UNIQUE_ID___y456, align 4
  %35 = load i32, i32* %__UNIQUE_ID___x455, align 4
  %36 = load i32, i32* %__UNIQUE_ID___y456, align 4
  %cmp23 = icmp ult i32 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i32, i32* %__UNIQUE_ID___x455, align 4
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i32, i32* %__UNIQUE_ID___y456, align 4
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i32 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i32 %cond27, i32* %tmp22, align 4
  %39 = load i32, i32* %tmp22, align 4
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  store i32 %39, i32* %u32_max_value28, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 11
  store i32 %39, i32* %s32_max_value29, align 4
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 12
  %43 = load i32, i32* %u32_min_value30, align 8
  %cmp31 = icmp slt i32 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 10
  %45 = load i32, i32* %s32_min_value33, align 8
  store i32 %45, i32* %__UNIQUE_ID___x457, align 4
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 12
  %47 = load i32, i32* %u32_min_value34, align 8
  store i32 %47, i32* %__UNIQUE_ID___y458, align 4
  %48 = load i32, i32* %__UNIQUE_ID___x457, align 4
  %49 = load i32, i32* %__UNIQUE_ID___y458, align 4
  %cmp36 = icmp ugt i32 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i32, i32* %__UNIQUE_ID___x457, align 4
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i32, i32* %__UNIQUE_ID___y458, align 4
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i32 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i32 %cond40, i32* %tmp35, align 4
  %52 = load i32, i32* %tmp35, align 4
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 12
  store i32 %52, i32* %u32_min_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 10
  store i32 %52, i32* %s32_min_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 13
  %56 = load i32, i32* %u32_max_value43, align 4
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 11
  store i32 %56, i32* %s32_max_value44, align 4
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %cond.end11, %if.end45, %cond.end26
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg64_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x459 = alloca i64, align 8
  %__UNIQUE_ID___y460 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x461 = alloca i64, align 8
  %__UNIQUE_ID___y462 = alloca i64, align 8
  %tmp7 = alloca i64, align 8
  %__UNIQUE_ID___x463 = alloca i64, align 8
  %__UNIQUE_ID___y464 = alloca i64, align 8
  %tmp22 = alloca i64, align 8
  %__UNIQUE_ID___x465 = alloca i64, align 8
  %__UNIQUE_ID___y466 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  %cmp = icmp sge i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  %cmp1 = icmp slt i64 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value2, align 8
  store i64 %5, i64* %__UNIQUE_ID___x459, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 8
  %7 = load i64, i64* %umin_value, align 8
  store i64 %7, i64* %__UNIQUE_ID___y460, align 8
  %8 = load i64, i64* %__UNIQUE_ID___x459, align 8
  %9 = load i64, i64* %__UNIQUE_ID___y460, align 8
  %cmp3 = icmp ugt i64 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i64, i64* %__UNIQUE_ID___x459, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i64, i64* %__UNIQUE_ID___y460, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 8
  store i64 %12, i64* %umin_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %12, i64* %smin_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value6, align 8
  store i64 %16, i64* %__UNIQUE_ID___x461, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 9
  %18 = load i64, i64* %umax_value, align 8
  store i64 %18, i64* %__UNIQUE_ID___y462, align 8
  %19 = load i64, i64* %__UNIQUE_ID___x461, align 8
  %20 = load i64, i64* %__UNIQUE_ID___y462, align 8
  %cmp8 = icmp ult i64 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___x461, align 8
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i64, i64* %__UNIQUE_ID___y462, align 8
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i64 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i64 %cond12, i64* %tmp7, align 8
  %23 = load i64, i64* %tmp7, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 %23, i64* %umax_value13, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 7
  store i64 %23, i64* %smax_value14, align 8
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value15, align 8
  %cmp16 = icmp sge i64 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  store i64 %29, i64* %smin_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 7
  %32 = load i64, i64* %smax_value20, align 8
  store i64 %32, i64* %__UNIQUE_ID___x463, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value21, align 8
  store i64 %34, i64* %__UNIQUE_ID___y464, align 8
  %35 = load i64, i64* %__UNIQUE_ID___x463, align 8
  %36 = load i64, i64* %__UNIQUE_ID___y464, align 8
  %cmp23 = icmp ult i64 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i64, i64* %__UNIQUE_ID___x463, align 8
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i64, i64* %__UNIQUE_ID___y464, align 8
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i64 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i64 %cond27, i64* %tmp22, align 8
  %39 = load i64, i64* %tmp22, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 9
  store i64 %39, i64* %umax_value28, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 7
  store i64 %39, i64* %smax_value29, align 8
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 8
  %43 = load i64, i64* %umin_value30, align 8
  %cmp31 = icmp slt i64 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value33, align 8
  store i64 %45, i64* %__UNIQUE_ID___x465, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 8
  %47 = load i64, i64* %umin_value34, align 8
  store i64 %47, i64* %__UNIQUE_ID___y466, align 8
  %48 = load i64, i64* %__UNIQUE_ID___x465, align 8
  %49 = load i64, i64* %__UNIQUE_ID___y466, align 8
  %cmp36 = icmp ugt i64 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i64, i64* %__UNIQUE_ID___x465, align 8
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i64, i64* %__UNIQUE_ID___y466, align 8
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i64 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i64 %cond40, i64* %tmp35, align 8
  %52 = load i64, i64* %tmp35, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  store i64 %52, i64* %umin_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 6
  store i64 %52, i64* %smin_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 9
  %56 = load i64, i64* %umax_value43, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 7
  store i64 %56, i64* %smax_value44, align 8
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %cond.end11, %if.end45, %cond.end26
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_intersect(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_range(i64 noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_or(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_clear_subreg(i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_subreg_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %5, i64 %7) #14
  %8 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 1
  %13 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %13, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @sanitize_needed(i8 noundef zeroext %opcode) #0 {
entry:
  %opcode.addr = alloca i8, align 1
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i8, i8* %opcode.addr, align 1
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 16
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp3, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call1 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %1, %struct.bpf_insn* noundef %2) #14
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call2 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %3, i32 noundef 8, i32 noundef 0) #14
  store i32 %call2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_err(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %reason, %struct.bpf_reg_state* noundef %off_reg, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %reason.addr = alloca i32, align 4
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %op = alloca i8*, align 8
  %dst = alloca i32, align 4
  %src = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %reason, i32* %reason.addr, align 4
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 240
  %cmp = icmp eq i32 %and, 0
  %2 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.122, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.123, i64 0, i64 0)
  store i8* %cond, i8** %op, align 8
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg2, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv3 = zext i8 %bf.clear to i32
  store i32 %conv3, i32* %dst, align 4
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 1
  %bf.load4 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load4, 4
  %conv5 = zext i8 %bf.lshr to i32
  store i32 %conv5, i32* %src, align 4
  %5 = load i32, i32* %reason.addr, align 4
  switch i32 %5, label %sw.default [
    i32 -1, label %sw.bb
    i32 -2, label %sw.bb9
    i32 -3, label %sw.bb16
    i32 -4, label %sw.bb17
    i32 -5, label %sw.bb18
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp6 = icmp eq %struct.bpf_reg_state* %8, %9
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  %10 = load i32, i32* %dst, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.bb
  %11 = load i32, i32* %src, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond8 = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  %12 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.124, i64 0, i64 0), i32 noundef %cond8, i8* noundef %12) #14
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp10 = icmp eq %struct.bpf_reg_state* %15, %16
  br i1 %cmp10, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %sw.bb9
  %17 = load i32, i32* %src, align 4
  br label %cond.end14

cond.false13:                                     ; preds = %sw.bb9
  %18 = load i32, i32* %dst, align 4
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.true12
  %cond15 = phi i32 [ %17, %cond.true12 ], [ %18, %cond.false13 ]
  %19 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.125, i64 0, i64 0), i32 noundef %cond15, i8* noundef %19) #14
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %dst, align 4
  %23 = load i8*, i8** %op, align 8
  %24 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.126, i64 0, i64 0), i32 noundef %22, i8* noundef %23, i8* noundef %24) #14
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %dst, align 4
  %28 = load i8*, i8** %op, align 8
  %29 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.127, i64 0, i64 0), i32 noundef %27, i8* noundef %28, i8* noundef %29) #14
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i32, i32* %dst, align 4
  %33 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([58 x i8], [58 x i8]* @.str.128, i64 0, i64 0), i32 noundef %32, i8* noundef %33) #14
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32, i32* %reason.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.129, i64 0, i64 0), i32 noundef %36) #14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb18, %sw.bb17, %sw.bb16, %cond.end14, %cond.end
  ret i32 -13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_add(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %smax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  store i32 %3, i32* %smax_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 12
  %5 = load i32, i32* %u32_min_value, align 8
  store i32 %5, i32* %umin_val, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 13
  %7 = load i32, i32* %u32_max_value, align 4
  store i32 %7, i32* %umax_val, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 10
  %9 = load i32, i32* %s32_min_value1, align 8
  %10 = load i32, i32* %smin_val, align 4
  %call = call zeroext i1 @signed_add32_overflows(i32 noundef %9, i32 noundef %10) #14
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %s32_max_value2, align 4
  %13 = load i32, i32* %smax_val, align 4
  %call3 = call zeroext i1 @signed_add32_overflows(i32 noundef %12, i32 noundef %13) #14
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value5, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i32, i32* %smin_val, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 10
  %18 = load i32, i32* %s32_min_value6, align 8
  %add = add i32 %18, %16
  store i32 %add, i32* %s32_min_value6, align 8
  %19 = load i32, i32* %smax_val, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  %21 = load i32, i32* %s32_max_value7, align 4
  %add8 = add i32 %21, %19
  store i32 %add8, i32* %s32_max_value7, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  %23 = load i32, i32* %u32_min_value9, align 8
  %24 = load i32, i32* %umin_val, align 4
  %add10 = add i32 %23, %24
  %25 = load i32, i32* %umin_val, align 4
  %cmp = icmp ult i32 %add10, %25
  br i1 %cmp, label %if.then15, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  %27 = load i32, i32* %u32_max_value12, align 4
  %28 = load i32, i32* %umax_val, align 4
  %add13 = add i32 %27, %28
  %29 = load i32, i32* %umax_val, align 4
  %cmp14 = icmp ult i32 %add13, %29
  br i1 %cmp14, label %if.then15, label %if.else18

if.then15:                                        ; preds = %lor.lhs.false11, %if.end
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 12
  store i32 0, i32* %u32_min_value16, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  store i32 -1, i32* %u32_max_value17, align 4
  br label %if.end23

if.else18:                                        ; preds = %lor.lhs.false11
  %32 = load i32, i32* %umin_val, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 12
  %34 = load i32, i32* %u32_min_value19, align 8
  %add20 = add i32 %34, %32
  store i32 %add20, i32* %u32_min_value19, align 8
  %35 = load i32, i32* %umax_val, align 4
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 13
  %37 = load i32, i32* %u32_max_value21, align 4
  %add22 = add i32 %37, %35
  store i32 %add22, i32* %u32_max_value21, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.else18, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_add(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  store i64 %3, i64* %smax_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 8
  %5 = load i64, i64* %umin_value, align 8
  store i64 %5, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  store i64 %7, i64* %umax_val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value1, align 8
  %10 = load i64, i64* %smin_val, align 8
  %call = call zeroext i1 @signed_add_overflows(i64 noundef %9, i64 noundef %10) #14
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value2, align 8
  %13 = load i64, i64* %smax_val, align 8
  %call3 = call zeroext i1 @signed_add_overflows(i64 noundef %12, i64 noundef %13) #14
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i64, i64* %smin_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value6, align 8
  %add = add i64 %18, %16
  store i64 %add, i64* %smin_value6, align 8
  %19 = load i64, i64* %smax_val, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value7, align 8
  %add8 = add i64 %21, %19
  store i64 %add8, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value9, align 8
  %24 = load i64, i64* %umin_val, align 8
  %add10 = add i64 %23, %24
  %25 = load i64, i64* %umin_val, align 8
  %cmp = icmp ult i64 %add10, %25
  br i1 %cmp, label %if.then15, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value12, align 8
  %28 = load i64, i64* %umax_val, align 8
  %add13 = add i64 %27, %28
  %29 = load i64, i64* %umax_val, align 8
  %cmp14 = icmp ult i64 %add13, %29
  br i1 %cmp14, label %if.then15, label %if.else18

if.then15:                                        ; preds = %lor.lhs.false11, %if.end
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 8
  store i64 0, i64* %umin_value16, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 9
  store i64 -1, i64* %umax_value17, align 8
  br label %if.end23

if.else18:                                        ; preds = %lor.lhs.false11
  %32 = load i64, i64* %umin_val, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  %34 = load i64, i64* %umin_value19, align 8
  %add20 = add i64 %34, %32
  store i64 %add20, i64* %umin_value19, align 8
  %35 = load i64, i64* %umax_val, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 9
  %37 = load i64, i64* %umax_value21, align 8
  %add22 = add i64 %37, %35
  store i64 %add22, i64* %umax_value21, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else18, %if.then15
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_add(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_sub(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %smax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  store i32 %3, i32* %smax_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 12
  %5 = load i32, i32* %u32_min_value, align 8
  store i32 %5, i32* %umin_val, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 13
  %7 = load i32, i32* %u32_max_value, align 4
  store i32 %7, i32* %umax_val, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 10
  %9 = load i32, i32* %s32_min_value1, align 8
  %10 = load i32, i32* %smax_val, align 4
  %call = call zeroext i1 @signed_sub32_overflows(i32 noundef %9, i32 noundef %10) #14
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %s32_max_value2, align 4
  %13 = load i32, i32* %smin_val, align 4
  %call3 = call zeroext i1 @signed_sub32_overflows(i32 noundef %12, i32 noundef %13) #14
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value5, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i32, i32* %smax_val, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 10
  %18 = load i32, i32* %s32_min_value6, align 8
  %sub = sub i32 %18, %16
  store i32 %sub, i32* %s32_min_value6, align 8
  %19 = load i32, i32* %smin_val, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  %21 = load i32, i32* %s32_max_value7, align 4
  %sub8 = sub i32 %21, %19
  store i32 %sub8, i32* %s32_max_value7, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  %23 = load i32, i32* %u32_min_value9, align 8
  %24 = load i32, i32* %umax_val, align 4
  %cmp = icmp ult i32 %23, %24
  br i1 %cmp, label %if.then10, label %if.else13

if.then10:                                        ; preds = %if.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 12
  store i32 0, i32* %u32_min_value11, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  store i32 -1, i32* %u32_max_value12, align 4
  br label %if.end18

if.else13:                                        ; preds = %if.end
  %27 = load i32, i32* %umax_val, align 4
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  %29 = load i32, i32* %u32_min_value14, align 8
  %sub15 = sub i32 %29, %27
  store i32 %sub15, i32* %u32_min_value14, align 8
  %30 = load i32, i32* %umin_val, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  %32 = load i32, i32* %u32_max_value16, align 4
  %sub17 = sub i32 %32, %30
  store i32 %sub17, i32* %u32_max_value16, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.else13, %if.then10
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_sub(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  store i64 %3, i64* %smax_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 8
  %5 = load i64, i64* %umin_value, align 8
  store i64 %5, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  store i64 %7, i64* %umax_val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value1, align 8
  %10 = load i64, i64* %smax_val, align 8
  %call = call zeroext i1 @signed_sub_overflows(i64 noundef %9, i64 noundef %10) #14
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value2, align 8
  %13 = load i64, i64* %smin_val, align 8
  %call3 = call zeroext i1 @signed_sub_overflows(i64 noundef %12, i64 noundef %13) #14
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i64, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value6, align 8
  %sub = sub i64 %18, %16
  store i64 %sub, i64* %smin_value6, align 8
  %19 = load i64, i64* %smin_val, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value7, align 8
  %sub8 = sub i64 %21, %19
  store i64 %sub8, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value9, align 8
  %24 = load i64, i64* %umax_val, align 8
  %cmp = icmp ult i64 %23, %24
  br i1 %cmp, label %if.then10, label %if.else13

if.then10:                                        ; preds = %if.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  store i64 0, i64* %umin_value11, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  store i64 -1, i64* %umax_value12, align 8
  br label %if.end18

if.else13:                                        ; preds = %if.end
  %27 = load i64, i64* %umax_val, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value14, align 8
  %sub15 = sub i64 %29, %27
  store i64 %sub15, i64* %umin_value14, align 8
  %30 = load i64, i64* %umin_val, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 9
  %32 = load i64, i64* %umax_value16, align 8
  %sub17 = sub i64 %32, %30
  store i64 %sub17, i64* %umax_value16, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else13, %if.then10
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_sub(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_mul(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_mul(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  %3 = load i32, i32* %u32_min_value, align 8
  store i32 %3, i32* %umin_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 13
  %5 = load i32, i32* %u32_max_value, align 4
  store i32 %5, i32* %umax_val, align 4
  %6 = load i32, i32* %smin_val, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 10
  %8 = load i32, i32* %s32_min_value1, align 8
  %cmp2 = icmp slt i32 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %9) #14
  br label %if.end20

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i32, i32* %umax_val, align 4
  %cmp3 = icmp ugt i32 %10, 65535
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 13
  %12 = load i32, i32* %u32_max_value5, align 4
  %cmp6 = icmp ugt i32 %12, 65535
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %13) #14
  br label %if.end20

if.end8:                                          ; preds = %lor.lhs.false4
  %14 = load i32, i32* %umin_val, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 12
  %16 = load i32, i32* %u32_min_value9, align 8
  %mul = mul i32 %16, %14
  store i32 %mul, i32* %u32_min_value9, align 8
  %17 = load i32, i32* %umax_val, align 4
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 13
  %19 = load i32, i32* %u32_max_value10, align 4
  %mul11 = mul i32 %19, %17
  store i32 %mul11, i32* %u32_max_value10, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value12, align 4
  %cmp13 = icmp ugt i32 %21, 2147483647
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value15, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end20

if.else:                                          ; preds = %if.end8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 12
  %25 = load i32, i32* %u32_min_value16, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 10
  store i32 %25, i32* %s32_min_value17, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 13
  %28 = load i32, i32* %u32_max_value18, align 4
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 11
  store i32 %28, i32* %s32_max_value19, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then, %if.then7, %if.else, %if.then14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_mul(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  store i64 %5, i64* %umax_val, align 8
  %6 = load i64, i64* %smin_val, align 8
  %cmp = icmp slt i64 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 6
  %8 = load i64, i64* %smin_value1, align 8
  %cmp2 = icmp slt i64 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %9) #14
  br label %if.end20

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i64, i64* %umax_val, align 8
  %cmp3 = icmp ugt i64 %10, 4294967295
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value5, align 8
  %cmp6 = icmp ugt i64 %12, 4294967295
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %13) #14
  br label %if.end20

if.end8:                                          ; preds = %lor.lhs.false4
  %14 = load i64, i64* %umin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value9, align 8
  %mul = mul i64 %16, %14
  store i64 %mul, i64* %umin_value9, align 8
  %17 = load i64, i64* %umax_val, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value10, align 8
  %mul11 = mul i64 %19, %17
  store i64 %mul11, i64* %umax_value10, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  %21 = load i64, i64* %umax_value12, align 8
  %cmp13 = icmp ugt i64 %21, 9223372036854775807
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value15, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %if.end8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value16, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 6
  store i64 %25, i64* %smin_value17, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value18, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 7
  store i64 %28, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then, %if.then7, %if.else, %if.then14
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_and(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_and(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  %__UNIQUE_ID___x482 = alloca i32, align 4
  %__UNIQUE_ID___y483 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #14
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 13
  %26 = load i32, i32* %u32_max_value, align 4
  store i32 %26, i32* %umax_val, align 4
  %27 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %27 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %28 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %28 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %30 = load i64, i64* %value, align 8
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %29, i64 noundef %30) #14
  br label %if.end22

if.end:                                           ; preds = %land.lhs.true, %entry
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %31 = load i64, i64* %value7, align 8
  %conv = trunc i64 %31 to i32
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 12
  store i32 %conv, i32* %u32_min_value, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  %34 = load i32, i32* %u32_max_value8, align 4
  store i32 %34, i32* %__UNIQUE_ID___x482, align 4
  %35 = load i32, i32* %umax_val, align 4
  store i32 %35, i32* %__UNIQUE_ID___y483, align 4
  %36 = load i32, i32* %__UNIQUE_ID___x482, align 4
  %37 = load i32, i32* %__UNIQUE_ID___y483, align 4
  %cmp = icmp ult i32 %36, %37
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %38 = load i32, i32* %__UNIQUE_ID___x482, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %39 = load i32, i32* %__UNIQUE_ID___y483, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %38, %cond.true ], [ %39, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %40 = load i32, i32* %tmp, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 13
  store i32 %40, i32* %u32_max_value10, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 10
  %43 = load i32, i32* %s32_min_value11, align 8
  %cmp12 = icmp slt i32 %43, 0
  br i1 %cmp12, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %44 = load i32, i32* %smin_val, align 4
  %cmp14 = icmp slt i32 %44, 0
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %lor.lhs.false, %cond.end
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value17, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end22

if.else:                                          ; preds = %lor.lhs.false
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 12
  %48 = load i32, i32* %u32_min_value18, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 10
  store i32 %48, i32* %s32_min_value19, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 13
  %51 = load i32, i32* %u32_max_value20, align 4
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 11
  store i32 %51, i32* %s32_max_value21, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then, %if.else, %if.then16
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_and(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %__UNIQUE_ID___x484 = alloca i64, align 8
  %__UNIQUE_ID___y485 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 9
  %15 = load i64, i64* %umax_value, align 8
  store i64 %15, i64* %umax_val, align 8
  %16 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %17 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %20 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %18, i64 noundef %20) #14
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off6, i32 0, i32 0
  %22 = load i64, i64* %value7, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  store i64 %22, i64* %umin_value, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  %25 = load i64, i64* %umax_value8, align 8
  store i64 %25, i64* %__UNIQUE_ID___x484, align 8
  %26 = load i64, i64* %umax_val, align 8
  store i64 %26, i64* %__UNIQUE_ID___y485, align 8
  %27 = load i64, i64* %__UNIQUE_ID___x484, align 8
  %28 = load i64, i64* %__UNIQUE_ID___y485, align 8
  %cmp = icmp ult i64 %27, %28
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %29 = load i64, i64* %__UNIQUE_ID___x484, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %30 = load i64, i64* %__UNIQUE_ID___y485, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %29, %cond.true ], [ %30, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %31 = load i64, i64* %tmp, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 9
  store i64 %31, i64* %umax_value9, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  %34 = load i64, i64* %smin_value10, align 8
  %cmp11 = icmp slt i64 %34, 0
  br i1 %cmp11, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %35 = load i64, i64* %smin_val, align 8
  %cmp12 = icmp slt i64 %35, 0
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %lor.lhs.false, %cond.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value14, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end19

if.else:                                          ; preds = %lor.lhs.false
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 8
  %39 = load i64, i64* %umin_value15, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 6
  store i64 %39, i64* %smin_value16, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value17, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %42, i64* %smax_value18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then13
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %44) #14
  br label %return

return:                                           ; preds = %if.end19, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_or(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %__UNIQUE_ID___x486 = alloca i32, align 4
  %__UNIQUE_ID___y487 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #14
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 12
  %26 = load i32, i32* %u32_min_value, align 8
  store i32 %26, i32* %umin_val, align 4
  %27 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %27 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %28 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %28 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %30 = load i64, i64* %value, align 8
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %29, i64 noundef %30) #14
  br label %if.end21

if.end:                                           ; preds = %land.lhs.true, %entry
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 12
  %32 = load i32, i32* %u32_min_value7, align 8
  store i32 %32, i32* %__UNIQUE_ID___x486, align 4
  %33 = load i32, i32* %umin_val, align 4
  store i32 %33, i32* %__UNIQUE_ID___y487, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x486, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y487, align 4
  %cmp = icmp ugt i32 %34, %35
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %36 = load i32, i32* %__UNIQUE_ID___x486, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %37 = load i32, i32* %__UNIQUE_ID___y487, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %36, %cond.true ], [ %37, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %38 = load i32, i32* %tmp, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 12
  store i32 %38, i32* %u32_min_value8, align 8
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %40 = load i64, i64* %value9, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %41 = load i64, i64* %mask, align 8
  %or = or i64 %40, %41
  %conv = trunc i64 %or to i32
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 13
  store i32 %conv, i32* %u32_max_value, align 4
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 10
  %44 = load i32, i32* %s32_min_value10, align 8
  %cmp11 = icmp slt i32 %44, 0
  br i1 %cmp11, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %45 = load i32, i32* %smin_val, align 4
  %cmp13 = icmp slt i32 %45, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %lor.lhs.false, %cond.end
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value16, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end21

if.else:                                          ; preds = %lor.lhs.false
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 12
  %49 = load i32, i32* %u32_min_value17, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 10
  store i32 %49, i32* %s32_min_value18, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 13
  %52 = load i32, i32* %u32_max_value19, align 4
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 11
  store i32 %52, i32* %s32_max_value20, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then, %if.else, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_or(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %__UNIQUE_ID___x488 = alloca i64, align 8
  %__UNIQUE_ID___y489 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  %15 = load i64, i64* %umin_value, align 8
  store i64 %15, i64* %umin_val, align 8
  %16 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %17 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %20 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %18, i64 noundef %20) #14
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value6, align 8
  store i64 %22, i64* %__UNIQUE_ID___x488, align 8
  %23 = load i64, i64* %umin_val, align 8
  store i64 %23, i64* %__UNIQUE_ID___y489, align 8
  %24 = load i64, i64* %__UNIQUE_ID___x488, align 8
  %25 = load i64, i64* %__UNIQUE_ID___y489, align 8
  %cmp = icmp ugt i64 %24, %25
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %26 = load i64, i64* %__UNIQUE_ID___x488, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %27 = load i64, i64* %__UNIQUE_ID___y489, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %26, %cond.true ], [ %27, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %28 = load i64, i64* %tmp, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 8
  store i64 %28, i64* %umin_value7, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %31 = load i64, i64* %value9, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 1
  %33 = load i64, i64* %mask, align 8
  %or = or i64 %31, %33
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  store i64 %or, i64* %umax_value, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 6
  %36 = load i64, i64* %smin_value11, align 8
  %cmp12 = icmp slt i64 %36, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %37 = load i64, i64* %smin_val, align 8
  %cmp13 = icmp slt i64 %37, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %lor.lhs.false, %cond.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value15, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %lor.lhs.false
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 8
  %41 = load i64, i64* %umin_value16, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 6
  store i64 %41, i64* %smin_value17, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 9
  %44 = load i64, i64* %umax_value18, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 7
  store i64 %44, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %46) #14
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_xor(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_xor(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #14
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %26 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %26 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %28 = load i64, i64* %value, align 8
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %27, i64 noundef %28) #14
  br label %if.end21

if.end:                                           ; preds = %land.lhs.true, %entry
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %29 = load i64, i64* %value7, align 8
  %conv = trunc i64 %29 to i32
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 12
  store i32 %conv, i32* %u32_min_value, align 8
  %value8 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %31 = load i64, i64* %value8, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %32 = load i64, i64* %mask, align 8
  %or = or i64 %31, %32
  %conv9 = trunc i64 %or to i32
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  store i32 %conv9, i32* %u32_max_value, align 4
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 10
  %35 = load i32, i32* %s32_min_value10, align 8
  %cmp = icmp sge i32 %35, 0
  br i1 %cmp, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %if.end
  %36 = load i32, i32* %smin_val, align 4
  %cmp13 = icmp sge i32 %36, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %land.lhs.true12
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 12
  %38 = load i32, i32* %u32_min_value16, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 10
  store i32 %38, i32* %s32_min_value17, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  %41 = load i32, i32* %u32_max_value18, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 11
  store i32 %41, i32* %s32_max_value, align 4
  br label %if.end21

if.else:                                          ; preds = %land.lhs.true12, %if.end
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value19, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value20, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then, %if.else, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_xor(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %15 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %15 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %18 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %16, i64 noundef %18) #14
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off6, i32 0, i32 0
  %20 = load i64, i64* %value7, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  store i64 %20, i64* %umin_value, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %23 = load i64, i64* %value9, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 1
  %25 = load i64, i64* %mask, align 8
  %or = or i64 %23, %25
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  store i64 %or, i64* %umax_value, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 6
  %28 = load i64, i64* %smin_value11, align 8
  %cmp = icmp sge i64 %28, 0
  br i1 %cmp, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %if.end
  %29 = load i64, i64* %smin_val, align 8
  %cmp13 = icmp sge i64 %29, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true12
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 8
  %31 = load i64, i64* %umin_value15, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %31, i64* %smin_value16, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value17, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  store i64 %34, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %land.lhs.true12, %if.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value18, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %38) #14
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %3) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %subreg = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 13
  %1 = load i32, i32* %u32_max_value, align 4
  store i32 %1, i32* %umax_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  %3 = load i32, i32* %u32_min_value, align 8
  store i32 %3, i32* %umin_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %7, i64 %9) #14
  %10 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = extractvalue { i64, i64 } %call, 0
  store i64 %12, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = extractvalue { i64, i64 } %call, 1
  store i64 %14, i64* %13, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %16 = load i32, i32* %umin_val, align 4
  %conv = zext i32 %16 to i64
  %17 = load i32, i32* %umax_val, align 4
  %conv1 = zext i32 %17 to i64
  call void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %15, i64 noundef %conv, i64 noundef %conv1) #14
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = load i32, i32* %umin_val, align 4
  %conv3 = trunc i32 %19 to i8
  %20 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = load i64, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %call4 = call { i64, i64 } @tnum_lshift(i64 %22, i64 %24, i8 noundef zeroext %conv3) #14
  %25 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call4, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call4, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %32, i64 %34) #14
  %35 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = extractvalue { i64, i64 } %call5, 0
  store i64 %37, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = extractvalue { i64, i64 } %call5, 1
  store i64 %39, i64* %38, align 8
  %40 = bitcast %struct.tnum* %var_off2 to i8*
  %41 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 %41, i64 16, i1 false)
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %42) #14
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %43) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  store i64 %1, i64* %umax_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %5 = load i64, i64* %umin_val, align 8
  %6 = load i64, i64* %umax_val, align 8
  call void @__scalar64_min_max_lsh(%struct.bpf_reg_state* noundef %4, i64 noundef %5, i64 noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %8 = load i64, i64* %umin_val, align 8
  %9 = load i64, i64* %umax_val, align 8
  call void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %7, i64 noundef %8, i64 noundef %9) #14
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %12 to i8
  %13 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call = call { i64, i64 } @tnum_lshift(i64 %15, i64 %17, i8 noundef zeroext %conv) #14
  %18 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call, 1
  store i64 %22, i64* %21, align 8
  %23 = bitcast %struct.tnum* %var_off to i8*
  %24 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %24, i64 16, i1 false)
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %25) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_rsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %subreg = alloca %struct.tnum, align 8
  %umax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #14
  %6 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 13
  %12 = load i32, i32* %u32_max_value, align 4
  store i32 %12, i32* %umax_val, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 12
  %14 = load i32, i32* %u32_min_value, align 8
  store i32 %14, i32* %umin_val, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = load i32, i32* %umin_val, align 4
  %conv = trunc i32 %18 to i8
  %19 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call2 = call { i64, i64 } @tnum_rshift(i64 %21, i64 %23, i8 noundef zeroext %conv) #14
  %24 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call2, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call2, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %var_off1 to i8*
  %30 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %30, i64 16, i1 false)
  %31 = load i32, i32* %umax_val, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 12
  %33 = load i32, i32* %u32_min_value3, align 8
  %shr = lshr i32 %33, %31
  store i32 %shr, i32* %u32_min_value3, align 8
  %34 = load i32, i32* %umin_val, align 4
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 13
  %36 = load i32, i32* %u32_max_value4, align 4
  %shr5 = lshr i32 %36, %34
  store i32 %shr5, i32* %u32_max_value4, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %37) #14
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %38) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_rsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  store i64 %1, i64* %umax_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %8 to i8
  %9 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = load i64, i64* %10, align 8
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = load i64, i64* %12, align 8
  %call = call { i64, i64 } @tnum_rshift(i64 %11, i64 %13, i8 noundef zeroext %conv) #14
  %14 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.tnum* %var_off to i8*
  %20 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 16, i1 false)
  %21 = load i64, i64* %umax_val, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value2, align 8
  %shr = lshr i64 %23, %21
  store i64 %shr, i64* %umin_value2, align 8
  %24 = load i64, i64* %umin_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 9
  %26 = load i64, i64* %umax_value3, align 8
  %shr4 = lshr i64 %26, %24
  store i64 %shr4, i64* %umax_value3, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %27) #14
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %28) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_arsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %1 to i64
  store i64 %conv, i64* %umin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 10
  %3 = load i32, i32* %s32_min_value, align 8
  %4 = load i64, i64* %umin_val, align 8
  %sh_prom = trunc i64 %4 to i32
  %shr = ashr i32 %3, %sh_prom
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 10
  store i32 %shr, i32* %s32_min_value1, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 11
  %7 = load i32, i32* %s32_max_value, align 4
  %8 = load i64, i64* %umin_val, align 8
  %sh_prom2 = trunc i64 %8 to i32
  %shr3 = ashr i32 %7, %sh_prom2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 11
  store i32 %shr3, i32* %s32_max_value4, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %14, i64 %16) #14
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call, 1
  store i64 %21, i64* %20, align 8
  %22 = load i64, i64* %umin_val, align 8
  %conv6 = trunc i64 %22 to i8
  %23 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call7 = call { i64, i64 } @tnum_arshift(i64 %25, i64 %27, i8 noundef zeroext %conv6, i8 noundef zeroext 32) #14
  %28 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 0
  %30 = extractvalue { i64, i64 } %call7, 0
  store i64 %30, i64* %29, align 8
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 1
  %32 = extractvalue { i64, i64 } %call7, 1
  store i64 %32, i64* %31, align 8
  %33 = bitcast %struct.tnum* %var_off to i8*
  %34 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %34, i64 16, i1 false)
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 12
  store i32 0, i32* %u32_min_value8, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %37) #14
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %38) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_arsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %umin_val, align 8
  %2 = load i64, i64* %umin_val, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %shr = ashr i64 %4, %2
  store i64 %shr, i64* %smin_value, align 8
  %5 = load i64, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  %7 = load i64, i64* %smax_value, align 8
  %shr1 = ashr i64 %7, %5
  store i64 %shr1, i64* %smax_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 5
  %10 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %10 to i8
  %11 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @tnum_arshift(i64 %13, i64 %15, i8 noundef zeroext %conv, i8 noundef zeroext 64) #14
  %16 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.tnum* %var_off to i8*
  %22 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  store i64 0, i64* %umin_value3, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %25) #14
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %26) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @zext_32_to_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = load i64, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %4, i64 %6) #14
  %7 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to i8*
  %13 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %14) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 0
  %3 = load i32, i32* %insn_idx, align 8
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  ret %struct.bpf_insn_aux_data* %arrayidx
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 21
  %1 = load i8, i8* %bypass_spec_v1, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 8
  %cmp = icmp eq i32 %and, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %aux, i32 noundef %alu_state, i32 noundef %alu_limit) #0 {
entry:
  %retval = alloca i32, align 4
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %alu_state.addr = alloca i32, align 4
  %alu_limit.addr = alloca i32, align 4
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i32 %alu_state, i32* %alu_state.addr, align 4
  store i32 %alu_limit, i32* %alu_limit.addr, align 4
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 6
  %1 = load i8, i8* %alu_state1, align 2
  %conv = zext i8 %1 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state2 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %2, i32 0, i32 6
  %3 = load i8, i8* %alu_state2, align 2
  %conv3 = zext i8 %3 to i32
  %4 = load i32, i32* %alu_state.addr, align 4
  %cmp = icmp ne i32 %conv3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %5, i32 0, i32 0
  %alu_limit5 = bitcast %union.anon.163* %6 to i32*
  %7 = load i32, i32* %alu_limit5, align 8
  %8 = load i32, i32* %alu_limit.addr, align 4
  %cmp6 = icmp ne i32 %7, %8
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  store i32 -3, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %9 = load i32, i32* %alu_state.addr, align 4
  %conv8 = trunc i32 %9 to i8
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i32 0, i32 6
  store i8 %conv8, i8* %alu_state9, align 2
  %11 = load i32, i32* %alu_limit.addr, align 4
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i32 0, i32 0
  %alu_limit10 = bitcast %union.anon.163* %13 to i32*
  store i32 %11, i32* %alu_limit10, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add32_overflows(i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %1 = load i32, i32* %b.addr, align 4
  %add = add i32 %0, %1
  store i32 %add, i32* %res, align 4
  %2 = load i32, i32* %b.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %res, align 4
  %4 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp sgt i32 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %res, align 4
  %6 = load i32, i32* %a.addr, align 4
  %cmp2 = icmp slt i32 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp sgt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp slt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub32_overflows(i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %1 = load i32, i32* %b.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, i32* %res, align 4
  %2 = load i32, i32* %b.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %res, align 4
  %4 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp slt i32 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %res, align 4
  %6 = load i32, i32* %a.addr, align 4
  %cmp2 = icmp sgt i32 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp slt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp sgt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg32_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i64, i64* %imm.addr, align 8
  %conv = trunc i64 %2 to i32
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_const_subreg(i64 %5, i64 %7, i32 noundef %conv) #14
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i64, i64* %imm.addr, align 8
  %conv2 = trunc i64 %15 to i32
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 10
  store i32 %conv2, i32* %s32_min_value, align 8
  %17 = load i64, i64* %imm.addr, align 8
  %conv3 = trunc i64 %17 to i32
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 11
  store i32 %conv3, i32* %s32_max_value, align 4
  %19 = load i64, i64* %imm.addr, align 8
  %conv4 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 12
  store i32 %conv4, i32* %u32_min_value, align 8
  %21 = load i64, i64* %imm.addr, align 8
  %conv5 = trunc i64 %21 to i32
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 13
  store i32 %conv5, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_const_subreg(i64, i64, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, i64 noundef %umin_val, i64 noundef %umax_val) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val.addr = alloca i64, align 8
  %umax_val.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i64 %umin_val, i64* %umin_val.addr, align 8
  store i64 %umax_val, i64* %umax_val.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %2 = load i64, i64* %umax_val.addr, align 8
  %cmp = icmp ugt i64 %2, 31
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  %4 = load i32, i32* %u32_max_value, align 4
  %conv = zext i32 %4 to i64
  %5 = load i64, i64* %umax_val.addr, align 8
  %sub = sub i64 31, %5
  %shl = shl i64 1, %sub
  %cmp1 = icmp ugt i64 %conv, %shl
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  store i32 -1, i32* %u32_max_value3, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %8 = load i64, i64* %umin_val.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 12
  %10 = load i32, i32* %u32_min_value4, align 8
  %sh_prom = trunc i64 %8 to i32
  %shl5 = shl i32 %10, %sh_prom
  store i32 %shl5, i32* %u32_min_value4, align 8
  %11 = load i64, i64* %umax_val.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 13
  %13 = load i32, i32* %u32_max_value6, align 4
  %sh_prom7 = trunc i64 %11 to i32
  %shl8 = shl i32 %13, %sh_prom7
  store i32 %shl8, i32* %u32_max_value6, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_lshift(i64, i64, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__scalar64_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, i64 noundef %umin_val, i64 noundef %umax_val) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val.addr = alloca i64, align 8
  %umax_val.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i64 %umin_val, i64* %umin_val.addr, align 8
  store i64 %umax_val, i64* %umax_val.addr, align 8
  %0 = load i64, i64* %umin_val.addr, align 8
  %cmp = icmp eq i64 %0, 32
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %umax_val.addr, align 8
  %cmp1 = icmp eq i64 %1, 32
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  %cmp3 = icmp sge i32 %3, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 11
  %5 = load i32, i32* %s32_max_value4, align 4
  %conv = sext i32 %5 to i64
  %shl = shl i64 %conv, 32
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  store i64 %shl, i64* %smax_value, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load i64, i64* %umin_val.addr, align 8
  %cmp6 = icmp eq i64 %8, 32
  br i1 %cmp6, label %land.lhs.true8, label %if.else18

land.lhs.true8:                                   ; preds = %if.end
  %9 = load i64, i64* %umax_val.addr, align 8
  %cmp9 = icmp eq i64 %9, 32
  br i1 %cmp9, label %land.lhs.true11, label %if.else18

land.lhs.true11:                                  ; preds = %land.lhs.true8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 10
  %11 = load i32, i32* %s32_min_value, align 8
  %cmp12 = icmp sge i32 %11, 0
  br i1 %cmp12, label %if.then14, label %if.else18

if.then14:                                        ; preds = %land.lhs.true11
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 10
  %13 = load i32, i32* %s32_min_value15, align 8
  %conv16 = sext i32 %13 to i64
  %shl17 = shl i64 %conv16, 32
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %shl17, i64* %smin_value, align 8
  br label %if.end20

if.else18:                                        ; preds = %land.lhs.true11, %land.lhs.true8, %if.end
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else18, %if.then14
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  %17 = load i64, i64* %umax_value, align 8
  %18 = load i64, i64* %umax_val.addr, align 8
  %sub = sub i64 63, %18
  %shl21 = shl i64 1, %sub
  %cmp22 = icmp ugt i64 %17, %shl21
  br i1 %cmp22, label %if.then24, label %if.else26

if.then24:                                        ; preds = %if.end20
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 -1, i64* %umax_value25, align 8
  br label %if.end31

if.else26:                                        ; preds = %if.end20
  %21 = load i64, i64* %umin_val.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value27, align 8
  %shl28 = shl i64 %23, %21
  store i64 %shl28, i64* %umin_value27, align 8
  %24 = load i64, i64* %umax_val.addr, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 9
  %26 = load i64, i64* %umax_value29, align 8
  %shl30 = shl i64 %26, %24
  store i64 %shl30, i64* %umax_value29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.else26, %if.then24
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_rshift(i64, i64, i8 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_arshift(i64, i64, i8 noundef zeroext, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %1 to i64
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 %conv, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  %4 = load i32, i32* %u32_max_value, align 4
  %conv1 = zext i32 %4 to i64
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  store i64 %conv1, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 10
  %7 = load i32, i32* %s32_min_value, align 8
  %cmp = icmp sge i32 %7, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 11
  %9 = load i32, i32* %s32_max_value, align 4
  %cmp3 = icmp sge i32 %9, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 11
  %11 = load i32, i32* %s32_max_value5, align 4
  %conv6 = sext i32 %11 to i64
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  store i64 %conv6, i64* %smax_value, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 7
  store i64 4294967295, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  %15 = load i32, i32* %s32_min_value8, align 8
  %cmp9 = icmp sge i32 %15, 0
  br i1 %cmp9, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.end
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 10
  %17 = load i32, i32* %s32_min_value12, align 8
  %conv13 = sext i32 %17 to i64
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 6
  store i64 %conv13, i64* %smin_value, align 8
  br label %if.end16

if.else14:                                        ; preds = %if.end
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 6
  store i64 0, i64* %smin_value15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else14, %if.then11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_pointer_value(i1 noundef zeroext %allow_ptr_leaks, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i1, align 1
  %allow_ptr_leaks.addr = alloca i8, align 1
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %frombool = zext i1 %allow_ptr_leaks to i8
  store i8 %frombool, i8* %allow_ptr_leaks.addr, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load i8, i8* %allow_ptr_leaks.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %2, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, i1* %retval, align 1
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_not_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 15
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 4
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 29
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp6 = icmp eq i32 %4, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp6, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch32_taken(%struct.bpf_reg_state* noundef %reg, i32 noundef %val, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %subreg = alloca %struct.tnum, align 8
  %sval = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %val, i32* %val.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #14
  %6 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load i32, i32* %val.addr, align 4
  store i32 %11, i32* %sval, align 4
  %12 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %12 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb5
    i32 64, label %sw.bb13
    i32 32, label %sw.bb25
    i32 96, label %sw.bb33
    i32 160, label %sw.bb43
    i32 192, label %sw.bb55
    i32 48, label %sw.bb67
    i32 112, label %sw.bb79
    i32 176, label %sw.bb91
    i32 208, label %sw.bb103
  ]

sw.bb:                                            ; preds = %entry
  %13 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %15, i64 %17) #14
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %18 = load i32, i32* %val.addr, align 4
  %conv2 = zext i32 %18 to i64
  %19 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call3 = call zeroext i1 @tnum_equals_const(i64 %21, i64 %23, i64 noundef %conv2) #14
  %lnot = xor i1 %call3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %24 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %26, i64 %28) #14
  br i1 %call6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %sw.bb5
  %29 = load i32, i32* %val.addr, align 4
  %conv8 = zext i32 %29 to i64
  %30 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call9 = call zeroext i1 @tnum_equals_const(i64 %32, i64 %34, i64 noundef %conv8) #14
  %lnot10 = xor i1 %call9, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  store i32 %lnot.ext11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb5
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 1
  %35 = load i64, i64* %mask, align 8
  %neg = xor i64 %35, -1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 0
  %36 = load i64, i64* %value, align 8
  %and = and i64 %neg, %36
  %37 = load i32, i32* %val.addr, align 4
  %conv14 = zext i32 %37 to i64
  %and15 = and i64 %and, %conv14
  %tobool = icmp ne i64 %and15, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.bb13
  store i32 1, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %sw.bb13
  %mask18 = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 1
  %38 = load i64, i64* %mask18, align 8
  %value19 = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 0
  %39 = load i64, i64* %value19, align 8
  %or = or i64 %38, %39
  %40 = load i32, i32* %val.addr, align 4
  %conv20 = zext i32 %40 to i64
  %and21 = and i64 %or, %conv20
  %tobool22 = icmp ne i64 %and21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end17
  store i32 0, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end17
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 12
  %42 = load i32, i32* %u32_min_value, align 8
  %43 = load i32, i32* %val.addr, align 4
  %cmp = icmp ugt i32 %42, %43
  br i1 %cmp, label %if.then27, label %if.else

if.then27:                                        ; preds = %sw.bb25
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb25
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 13
  %45 = load i32, i32* %u32_max_value, align 4
  %46 = load i32, i32* %val.addr, align 4
  %cmp28 = icmp ule i32 %45, %46
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.else
  br label %if.end32

if.end32:                                         ; preds = %if.end31
  br label %sw.epilog

sw.bb33:                                          ; preds = %entry
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 10
  %48 = load i32, i32* %s32_min_value, align 8
  %49 = load i32, i32* %sval, align 4
  %cmp34 = icmp sgt i32 %48, %49
  br i1 %cmp34, label %if.then36, label %if.else37

if.then36:                                        ; preds = %sw.bb33
  store i32 1, i32* %retval, align 4
  br label %return

if.else37:                                        ; preds = %sw.bb33
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 11
  %51 = load i32, i32* %s32_max_value, align 4
  %52 = load i32, i32* %sval, align 4
  %cmp38 = icmp sle i32 %51, %52
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.else37
  store i32 0, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.else37
  br label %if.end42

if.end42:                                         ; preds = %if.end41
  br label %sw.epilog

sw.bb43:                                          ; preds = %entry
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 13
  %54 = load i32, i32* %u32_max_value44, align 4
  %55 = load i32, i32* %val.addr, align 4
  %cmp45 = icmp ult i32 %54, %55
  br i1 %cmp45, label %if.then47, label %if.else48

if.then47:                                        ; preds = %sw.bb43
  store i32 1, i32* %retval, align 4
  br label %return

if.else48:                                        ; preds = %sw.bb43
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 12
  %57 = load i32, i32* %u32_min_value49, align 8
  %58 = load i32, i32* %val.addr, align 4
  %cmp50 = icmp uge i32 %57, %58
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.else48
  store i32 0, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.else48
  br label %if.end54

if.end54:                                         ; preds = %if.end53
  br label %sw.epilog

sw.bb55:                                          ; preds = %entry
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 11
  %60 = load i32, i32* %s32_max_value56, align 4
  %61 = load i32, i32* %sval, align 4
  %cmp57 = icmp slt i32 %60, %61
  br i1 %cmp57, label %if.then59, label %if.else60

if.then59:                                        ; preds = %sw.bb55
  store i32 1, i32* %retval, align 4
  br label %return

if.else60:                                        ; preds = %sw.bb55
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 10
  %63 = load i32, i32* %s32_min_value61, align 8
  %64 = load i32, i32* %sval, align 4
  %cmp62 = icmp sge i32 %63, %64
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.else60
  store i32 0, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.else60
  br label %if.end66

if.end66:                                         ; preds = %if.end65
  br label %sw.epilog

sw.bb67:                                          ; preds = %entry
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 12
  %66 = load i32, i32* %u32_min_value68, align 8
  %67 = load i32, i32* %val.addr, align 4
  %cmp69 = icmp uge i32 %66, %67
  br i1 %cmp69, label %if.then71, label %if.else72

if.then71:                                        ; preds = %sw.bb67
  store i32 1, i32* %retval, align 4
  br label %return

if.else72:                                        ; preds = %sw.bb67
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 13
  %69 = load i32, i32* %u32_max_value73, align 4
  %70 = load i32, i32* %val.addr, align 4
  %cmp74 = icmp ult i32 %69, %70
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.else72
  store i32 0, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.else72
  br label %if.end78

if.end78:                                         ; preds = %if.end77
  br label %sw.epilog

sw.bb79:                                          ; preds = %entry
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 10
  %72 = load i32, i32* %s32_min_value80, align 8
  %73 = load i32, i32* %sval, align 4
  %cmp81 = icmp sge i32 %72, %73
  br i1 %cmp81, label %if.then83, label %if.else84

if.then83:                                        ; preds = %sw.bb79
  store i32 1, i32* %retval, align 4
  br label %return

if.else84:                                        ; preds = %sw.bb79
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 11
  %75 = load i32, i32* %s32_max_value85, align 4
  %76 = load i32, i32* %sval, align 4
  %cmp86 = icmp slt i32 %75, %76
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.else84
  store i32 0, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.else84
  br label %if.end90

if.end90:                                         ; preds = %if.end89
  br label %sw.epilog

sw.bb91:                                          ; preds = %entry
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 13
  %78 = load i32, i32* %u32_max_value92, align 4
  %79 = load i32, i32* %val.addr, align 4
  %cmp93 = icmp ule i32 %78, %79
  br i1 %cmp93, label %if.then95, label %if.else96

if.then95:                                        ; preds = %sw.bb91
  store i32 1, i32* %retval, align 4
  br label %return

if.else96:                                        ; preds = %sw.bb91
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 12
  %81 = load i32, i32* %u32_min_value97, align 8
  %82 = load i32, i32* %val.addr, align 4
  %cmp98 = icmp ugt i32 %81, %82
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.else96
  store i32 0, i32* %retval, align 4
  br label %return

if.end101:                                        ; preds = %if.else96
  br label %if.end102

if.end102:                                        ; preds = %if.end101
  br label %sw.epilog

sw.bb103:                                         ; preds = %entry
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 11
  %84 = load i32, i32* %s32_max_value104, align 4
  %85 = load i32, i32* %sval, align 4
  %cmp105 = icmp sle i32 %84, %85
  br i1 %cmp105, label %if.then107, label %if.else108

if.then107:                                       ; preds = %sw.bb103
  store i32 1, i32* %retval, align 4
  br label %return

if.else108:                                       ; preds = %sw.bb103
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 10
  %87 = load i32, i32* %s32_min_value109, align 8
  %88 = load i32, i32* %sval, align 4
  %cmp110 = icmp sgt i32 %87, %88
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.else108
  store i32 0, i32* %retval, align 4
  br label %return

if.end113:                                        ; preds = %if.else108
  br label %if.end114

if.end114:                                        ; preds = %if.end113
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.end114, %if.end102, %if.end90, %if.end78, %if.end66, %if.end54, %if.end42, %if.end32, %if.end24, %if.end12, %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then112, %if.then107, %if.then100, %if.then95, %if.then88, %if.then83, %if.then76, %if.then71, %if.then64, %if.then59, %if.then52, %if.then47, %if.then40, %if.then36, %if.then30, %if.then27, %if.then23, %if.then16, %if.then7, %if.then
  %89 = load i32, i32* %retval, align 4
  ret i32 %89
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch64_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %sval = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i64, i64* %val.addr, align 8
  store i64 %0, i64* %sval, align 8
  %1 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb4
    i32 64, label %sw.bb13
    i32 32, label %sw.bb27
    i32 96, label %sw.bb35
    i32 160, label %sw.bb45
    i32 192, label %sw.bb57
    i32 48, label %sw.bb69
    i32 112, label %sw.bb81
    i32 176, label %sw.bb93
    i32 208, label %sw.bb105
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %9 = load i64, i64* %val.addr, align 8
  %10 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call2 = call zeroext i1 @tnum_equals_const(i64 %12, i64 %14, i64 noundef %9) #14
  %lnot = xor i1 %call2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %18, i64 %20) #14
  br i1 %call6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %sw.bb4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %22 = load i64, i64* %val.addr, align 8
  %23 = bitcast %struct.tnum* %var_off8 to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call9 = call zeroext i1 @tnum_equals_const(i64 %25, i64 %27, i64 noundef %22) #14
  %lnot10 = xor i1 %call9, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  store i32 %lnot.ext11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off14, i32 0, i32 1
  %29 = load i64, i64* %mask, align 8
  %neg = xor i64 %29, -1
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %31 = load i64, i64* %value, align 8
  %and = and i64 %neg, %31
  %32 = load i64, i64* %val.addr, align 8
  %and16 = and i64 %and, %32
  %tobool = icmp ne i64 %and16, 0
  br i1 %tobool, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb13
  store i32 1, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %sw.bb13
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 5
  %mask20 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 1
  %34 = load i64, i64* %mask20, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %value22 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off21, i32 0, i32 0
  %36 = load i64, i64* %value22, align 8
  %or = or i64 %34, %36
  %37 = load i64, i64* %val.addr, align 8
  %and23 = and i64 %or, %37
  %tobool24 = icmp ne i64 %and23, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 8
  %39 = load i64, i64* %umin_value, align 8
  %40 = load i64, i64* %val.addr, align 8
  %cmp = icmp ugt i64 %39, %40
  br i1 %cmp, label %if.then29, label %if.else

if.then29:                                        ; preds = %sw.bb27
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb27
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value, align 8
  %43 = load i64, i64* %val.addr, align 8
  %cmp30 = icmp ule i64 %42, %43
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.else
  br label %if.end34

if.end34:                                         ; preds = %if.end33
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value, align 8
  %46 = load i64, i64* %sval, align 8
  %cmp36 = icmp sgt i64 %45, %46
  br i1 %cmp36, label %if.then38, label %if.else39

if.then38:                                        ; preds = %sw.bb35
  store i32 1, i32* %retval, align 4
  br label %return

if.else39:                                        ; preds = %sw.bb35
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 7
  %48 = load i64, i64* %smax_value, align 8
  %49 = load i64, i64* %sval, align 8
  %cmp40 = icmp sle i64 %48, %49
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.else39
  store i32 0, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.else39
  br label %if.end44

if.end44:                                         ; preds = %if.end43
  br label %sw.epilog

sw.bb45:                                          ; preds = %entry
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 9
  %51 = load i64, i64* %umax_value46, align 8
  %52 = load i64, i64* %val.addr, align 8
  %cmp47 = icmp ult i64 %51, %52
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %sw.bb45
  store i32 1, i32* %retval, align 4
  br label %return

if.else50:                                        ; preds = %sw.bb45
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  %54 = load i64, i64* %umin_value51, align 8
  %55 = load i64, i64* %val.addr, align 8
  %cmp52 = icmp uge i64 %54, %55
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.else50
  store i32 0, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %if.else50
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  br label %sw.epilog

sw.bb57:                                          ; preds = %entry
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 7
  %57 = load i64, i64* %smax_value58, align 8
  %58 = load i64, i64* %sval, align 8
  %cmp59 = icmp slt i64 %57, %58
  br i1 %cmp59, label %if.then61, label %if.else62

if.then61:                                        ; preds = %sw.bb57
  store i32 1, i32* %retval, align 4
  br label %return

if.else62:                                        ; preds = %sw.bb57
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 6
  %60 = load i64, i64* %smin_value63, align 8
  %61 = load i64, i64* %sval, align 8
  %cmp64 = icmp sge i64 %60, %61
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.else62
  store i32 0, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.else62
  br label %if.end68

if.end68:                                         ; preds = %if.end67
  br label %sw.epilog

sw.bb69:                                          ; preds = %entry
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 8
  %63 = load i64, i64* %umin_value70, align 8
  %64 = load i64, i64* %val.addr, align 8
  %cmp71 = icmp uge i64 %63, %64
  br i1 %cmp71, label %if.then73, label %if.else74

if.then73:                                        ; preds = %sw.bb69
  store i32 1, i32* %retval, align 4
  br label %return

if.else74:                                        ; preds = %sw.bb69
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 9
  %66 = load i64, i64* %umax_value75, align 8
  %67 = load i64, i64* %val.addr, align 8
  %cmp76 = icmp ult i64 %66, %67
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.else74
  store i32 0, i32* %retval, align 4
  br label %return

if.end79:                                         ; preds = %if.else74
  br label %if.end80

if.end80:                                         ; preds = %if.end79
  br label %sw.epilog

sw.bb81:                                          ; preds = %entry
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 6
  %69 = load i64, i64* %smin_value82, align 8
  %70 = load i64, i64* %sval, align 8
  %cmp83 = icmp sge i64 %69, %70
  br i1 %cmp83, label %if.then85, label %if.else86

if.then85:                                        ; preds = %sw.bb81
  store i32 1, i32* %retval, align 4
  br label %return

if.else86:                                        ; preds = %sw.bb81
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 7
  %72 = load i64, i64* %smax_value87, align 8
  %73 = load i64, i64* %sval, align 8
  %cmp88 = icmp slt i64 %72, %73
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.else86
  store i32 0, i32* %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.else86
  br label %if.end92

if.end92:                                         ; preds = %if.end91
  br label %sw.epilog

sw.bb93:                                          ; preds = %entry
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 9
  %75 = load i64, i64* %umax_value94, align 8
  %76 = load i64, i64* %val.addr, align 8
  %cmp95 = icmp ule i64 %75, %76
  br i1 %cmp95, label %if.then97, label %if.else98

if.then97:                                        ; preds = %sw.bb93
  store i32 1, i32* %retval, align 4
  br label %return

if.else98:                                        ; preds = %sw.bb93
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 8
  %78 = load i64, i64* %umin_value99, align 8
  %79 = load i64, i64* %val.addr, align 8
  %cmp100 = icmp ugt i64 %78, %79
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.else98
  store i32 0, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %if.else98
  br label %if.end104

if.end104:                                        ; preds = %if.end103
  br label %sw.epilog

sw.bb105:                                         ; preds = %entry
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 7
  %81 = load i64, i64* %smax_value106, align 8
  %82 = load i64, i64* %sval, align 8
  %cmp107 = icmp sle i64 %81, %82
  br i1 %cmp107, label %if.then109, label %if.else110

if.then109:                                       ; preds = %sw.bb105
  store i32 1, i32* %retval, align 4
  br label %return

if.else110:                                       ; preds = %sw.bb105
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value111 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 6
  %84 = load i64, i64* %smin_value111, align 8
  %85 = load i64, i64* %sval, align 8
  %cmp112 = icmp sgt i64 %84, %85
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.else110
  store i32 0, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %if.else110
  br label %if.end116

if.end116:                                        ; preds = %if.end115
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.end116, %if.end104, %if.end92, %if.end80, %if.end68, %if.end56, %if.end44, %if.end34, %if.end26, %if.end12, %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then114, %if.then109, %if.then102, %if.then97, %if.then90, %if.then85, %if.then78, %if.then73, %if.then66, %if.then61, %if.then54, %if.then49, %if.then42, %if.then38, %if.then32, %if.then29, %if.then25, %if.then17, %if.then7, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal zeroext i1 @is_power_of_2(i64 noundef %n) #9 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %n.addr, align 8
  %2 = load i64, i64* %n.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %cmp1 = icmp eq i64 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_clear_subreg(i64 %3, i64 %5) #14
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call1 = call zeroext i1 @tnum_equals_const(i64 %13, i64 %15, i64 noundef 0) #14
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %16) #14
  br label %if.end

if.else:                                          ; preds = %entry
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %17) #14
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %18) #14
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %19) #14
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %20) #14
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %21) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %0) #14
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 6
  %2 = load i64, i64* %smin_value, align 8
  %call = call zeroext i1 @__reg64_bound_s32(i64 noundef %2) #14
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 7
  %4 = load i64, i64* %smax_value, align 8
  %call1 = call zeroext i1 @__reg64_bound_s32(i64 noundef %4) #14
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 6
  %6 = load i64, i64* %smin_value2, align 8
  %conv = trunc i64 %6 to i32
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 10
  store i32 %conv, i32* %s32_min_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  %9 = load i64, i64* %smax_value3, align 8
  %conv4 = trunc i64 %9 to i32
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 11
  store i32 %conv4, i32* %s32_max_value, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 8
  %12 = load i64, i64* %umin_value, align 8
  %call5 = call zeroext i1 @__reg64_bound_u32(i64 noundef %12) #14
  br i1 %call5, label %land.lhs.true7, label %if.end15

land.lhs.true7:                                   ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 9
  %14 = load i64, i64* %umax_value, align 8
  %call8 = call zeroext i1 @__reg64_bound_u32(i64 noundef %14) #14
  br i1 %call8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %land.lhs.true7
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value11, align 8
  %conv12 = trunc i64 %16 to i32
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 12
  store i32 %conv12, i32* %u32_min_value, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value13, align 8
  %conv14 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  store i32 %conv14, i32* %u32_max_value, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %land.lhs.true7, %if.end
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %21) #14
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %22) #14
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %23) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg64_bound_s32(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %cmp = icmp sgt i64 %0, -2147483648
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp slt i64 %1, 2147483647
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg64_bound_u32(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp ult i64 %1, 4294967295
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @flip_opcode(i32 noundef %opcode) #0 {
entry:
  %opcode.addr = alloca i32, align 4
  store i32 %opcode, i32* %opcode.addr, align 4
  %0 = load i32, i32* %opcode.addr, align 4
  %shr = lshr i32 %0, 4
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr [16 x i8], [16 x i8]* @flip_opcode.opcode_flip, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x528 = alloca i64, align 8
  %__UNIQUE_ID___y529 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x530 = alloca i64, align 8
  %__UNIQUE_ID___y531 = alloca i64, align 8
  %tmp5 = alloca i64, align 8
  %__UNIQUE_ID___x532 = alloca i64, align 8
  %__UNIQUE_ID___y533 = alloca i64, align 8
  %tmp14 = alloca i64, align 8
  %__UNIQUE_ID___x534 = alloca i64, align 8
  %__UNIQUE_ID___y535 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  %tmp32 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x528, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  store i64 %3, i64* %__UNIQUE_ID___y529, align 8
  %4 = load i64, i64* %__UNIQUE_ID___x528, align 8
  %5 = load i64, i64* %__UNIQUE_ID___y529, align 8
  %cmp = icmp ugt i64 %4, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___x528, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i64, i64* %__UNIQUE_ID___y529, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 8
  store i64 %8, i64* %umin_value2, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  store i64 %8, i64* %umin_value3, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value, align 8
  store i64 %12, i64* %__UNIQUE_ID___x530, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 9
  %14 = load i64, i64* %umax_value4, align 8
  store i64 %14, i64* %__UNIQUE_ID___y531, align 8
  %15 = load i64, i64* %__UNIQUE_ID___x530, align 8
  %16 = load i64, i64* %__UNIQUE_ID___y531, align 8
  %cmp6 = icmp ult i64 %15, %16
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %17 = load i64, i64* %__UNIQUE_ID___x530, align 8
  br label %cond.end9

cond.false8:                                      ; preds = %cond.end
  %18 = load i64, i64* %__UNIQUE_ID___y531, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true7
  %cond10 = phi i64 [ %17, %cond.true7 ], [ %18, %cond.false8 ]
  store i64 %cond10, i64* %tmp5, align 8
  %19 = load i64, i64* %tmp5, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value11, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 9
  store i64 %19, i64* %umax_value12, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value, align 8
  store i64 %23, i64* %__UNIQUE_ID___x532, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 6
  %25 = load i64, i64* %smin_value13, align 8
  store i64 %25, i64* %__UNIQUE_ID___y533, align 8
  %26 = load i64, i64* %__UNIQUE_ID___x532, align 8
  %27 = load i64, i64* %__UNIQUE_ID___y533, align 8
  %cmp15 = icmp sgt i64 %26, %27
  br i1 %cmp15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.end9
  %28 = load i64, i64* %__UNIQUE_ID___x532, align 8
  br label %cond.end18

cond.false17:                                     ; preds = %cond.end9
  %29 = load i64, i64* %__UNIQUE_ID___y533, align 8
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false17, %cond.true16
  %cond19 = phi i64 [ %28, %cond.true16 ], [ %29, %cond.false17 ]
  store i64 %cond19, i64* %tmp14, align 8
  %30 = load i64, i64* %tmp14, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 6
  store i64 %30, i64* %smin_value20, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %30, i64* %smin_value21, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 7
  %34 = load i64, i64* %smax_value, align 8
  store i64 %34, i64* %__UNIQUE_ID___x534, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  %36 = load i64, i64* %smax_value22, align 8
  store i64 %36, i64* %__UNIQUE_ID___y535, align 8
  %37 = load i64, i64* %__UNIQUE_ID___x534, align 8
  %38 = load i64, i64* %__UNIQUE_ID___y535, align 8
  %cmp24 = icmp slt i64 %37, %38
  br i1 %cmp24, label %cond.true25, label %cond.false26

cond.true25:                                      ; preds = %cond.end18
  %39 = load i64, i64* %__UNIQUE_ID___x534, align 8
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end18
  %40 = load i64, i64* %__UNIQUE_ID___y535, align 8
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true25
  %cond28 = phi i64 [ %39, %cond.true25 ], [ %40, %cond.false26 ]
  store i64 %cond28, i64* %tmp23, align 8
  %41 = load i64, i64* %tmp23, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 7
  store i64 %41, i64* %smax_value29, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %41, i64* %smax_value30, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 5
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 5
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 5
  %48 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = bitcast %struct.tnum* %var_off34 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call = call { i64, i64 } @tnum_intersect(i64 %50, i64 %52, i64 %55, i64 %57) #14
  %58 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 0
  %60 = extractvalue { i64, i64 } %call, 0
  store i64 %60, i64* %59, align 8
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 1
  %62 = extractvalue { i64, i64 } %call, 1
  store i64 %62, i64* %61, align 8
  %63 = bitcast %struct.tnum* %var_off31 to i8*
  %64 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %63, i8* align 8 %64, i64 16, i1 false)
  %65 = bitcast %struct.tnum* %var_off to i8*
  %66 = bitcast %struct.tnum* %var_off31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 %66, i64 16, i1 false)
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %67) #14
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %68) #14
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %69) #14
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %70) #14
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %71) #14
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %72) #14
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %73) #14
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %74) #14
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_to_ns(i64 noundef %kt) #0 {
entry:
  %kt.addr = alloca i64, align 8
  store i64 %kt, i64* %kt.addr, align 8
  %0 = load i64, i64* %kt.addr, align 8
  ret i64 %0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @ktime_get() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef, i32 noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @__kmalloc(i64 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @kmalloc_order_trace(i64 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #10

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal i32 @__ilog2_u64(i64 noundef %n) #9 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %1 = load i32, i32* %bitpos.i, align 4
  %2 = load i64, i64* %x.addr.i, align 8
  %3 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %2, i32 %1) #12, !srcloc !14
  store i32 %3, i32* %bitpos.i, align 4
  %4 = load i32, i32* %bitpos.i, align 4
  %add.i = add i32 %4, 1
  %sub = sub i32 %add.i, 1
  ret i32 %sub
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__must_check_overflow(i1 noundef zeroext %overflow) #0 {
entry:
  %overflow.addr = alloca i8, align 1
  %frombool = zext i1 %overflow to i8
  store i8 %frombool, i8* %overflow.addr, align 1
  %0 = load i8, i8* %overflow.addr, align 1
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  ret i1 %tobool2
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #10

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i8*, i8 } @KERNEL_BPFPTR(i8* noundef %p) #0 {
entry:
  %retval = alloca %struct.sockptr_t, align 8
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 0
  %kernel = bitcast %union.anon.169* %0 to i8**
  %1 = load i8*, i8** %p.addr, align 8
  store i8* %1, i8** %kernel, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %is_kernel, align 8
  %2 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %3 = load { i8*, i8 }, { i8*, i8 }* %2, align 8
  ret { i8*, i8 } %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i8*, i8 } @USER_BPFPTR(i8* noundef %p) #0 {
entry:
  %retval = alloca %struct.sockptr_t, align 8
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 0
  %user = bitcast %union.anon.169* %0 to i8**
  %1 = load i8*, i8** %p.addr, align 8
  store i8* %1, i8** %user, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %is_kernel, align 8
  %2 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %3 = load { i8*, i8 }, { i8*, i8 }* %2, align 8
  ret { i8*, i8 } %3
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @capable(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @perfmon_capable() #0 {
entry:
  %call = call zeroext i1 @capable(i32 noundef 38) #14
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call zeroext i1 @capable(i32 noundef 21) #14
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #14
  %lnot = xor i1 %call, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %bytes, align 8
  %11 = load i32, i32* %flags.addr, align 4
  %call6 = call i8* @kvmalloc(i64 noundef %10, i32 noundef %11) #14
  store i8* %call6, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i8*, i8** %retval, align 8
  ret i8* %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvmalloc(i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %call = call i8* @kvmalloc_node(i64 noundef %0, i32 noundef %1, i32 noundef -1) #14
  ret i8* %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @kvmalloc_node(i64 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  store i32 %2, i32* %insn_cnt, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp sge i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.134, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %8, i32 noundef %9) #14
  store i32 %call, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %cmp2 = icmp sge i32 %10, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load i32, i32* %ret, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 31
  %13 = load i32, i32* %subprog_cnt, align 4
  %cmp5 = icmp uge i32 %13, 256
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.135, i64 0, i64 0)) #14
  store i32 -7, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %16 = load i32, i32* %off.addr, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 27
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 31
  %19 = load i32, i32* %subprog_cnt8, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %subprog_cnt8, align 4
  %idxprom = zext i32 %19 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  store i32 %16, i32* %start, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info9, i64 0, i64 0
  %21 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 31
  %23 = load i32, i32* %subprog_cnt10, align 4
  %conv = zext i32 %23 to i64
  call void @sort(i8* noundef %21, i64 noundef %conv, i64 noundef 16, i32 (i8*, i8*)* noundef @cmp_subprogs, void (i8*, i8*, i32)* noundef null) #14
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 31
  %25 = load i32, i32* %subprog_cnt11, align 4
  %sub = sub i32 %25, 1
  store i32 %sub, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then3, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 24
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 133
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_pseudo_kfunc_call(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 133
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_kfunc_call(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %func = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  %prog_aux = alloca %struct.bpf_prog_aux*, align 8
  %desc = alloca %struct.bpf_kfunc_desc*, align 8
  %func_name = alloca i8*, align 8
  %addr = alloca i64, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %prog_aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %prog_aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 33
  %4 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %4, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %5 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc_tab* %5, null
  br i1 %tobool, label %if.end21, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool1 = icmp ne %struct.btf* %6, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.136, i64 0, i64 0)) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 2
  %10 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %10, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %tobool4 = icmp ne i16 %bf.clear, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.137, i64 0, i64 0)) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %call = call zeroext i1 @bpf_jit_supports_kfunc_call() #14
  br i1 %call, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end6
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.138, i64 0, i64 0)) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end6
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 2
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 1
  %bf.load10 = load i16, i16* %gpl_compatible, align 2
  %bf.lshr11 = lshr i16 %bf.load10, 2
  %bf.clear12 = and i16 %bf.lshr11, 1
  %tobool13 = icmp ne i16 %bf.clear12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([61 x i8], [61 x i8]* @.str.139, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end8
  %call16 = call i8* @kzalloc(i64 noundef 6148, i32 noundef 3264) #14
  %19 = bitcast i8* %call16 to %struct.bpf_kfunc_desc_tab*
  store %struct.bpf_kfunc_desc_tab* %19, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %20 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %tobool17 = icmp ne %struct.bpf_kfunc_desc_tab* %20, null
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end15
  store i32 -12, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end15
  %21 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %prog_aux, align 8
  %kfunc_tab20 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 33
  store %struct.bpf_kfunc_desc_tab* %21, %struct.bpf_kfunc_desc_tab** %kfunc_tab20, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.end19, %entry
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog22 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %23, i32 0, i32 2
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %prog22, align 8
  %25 = load i32, i32* %func_id.addr, align 4
  %call23 = call %struct.bpf_kfunc_desc* @find_kfunc_desc(%struct.bpf_prog* noundef %24, i32 noundef %25) #14
  %tobool24 = icmp ne %struct.bpf_kfunc_desc* %call23, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end21
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end21
  %26 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %26, i32 0, i32 1
  %27 = load i32, i32* %nr_descs, align 4
  %cmp = icmp eq i32 %27, 256
  br i1 %cmp, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end26
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.140, i64 0, i64 0)) #14
  store i32 -7, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end26
  %30 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %31 = load i32, i32* %func_id.addr, align 4
  %call29 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %30, i32 noundef %31) #14
  store %struct.btf_type* %call29, %struct.btf_type** %func, align 8
  %32 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %tobool30 = icmp ne %struct.btf_type* %32, null
  br i1 %tobool30, label %lor.lhs.false, label %if.then32

lor.lhs.false:                                    ; preds = %if.end28
  %33 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %call31 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %33) #14
  br i1 %call31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %lor.lhs.false, %if.end28
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.141, i64 0, i64 0), i32 noundef %36) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %lor.lhs.false
  %37 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %38 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %39 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %38, i32 0, i32 2
  %type = bitcast %union.anon.123* %39 to i32*
  %40 = load i32, i32* %type, align 4
  %call34 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %37, i32 noundef %40) #14
  store %struct.btf_type* %call34, %struct.btf_type** %func_proto, align 8
  %41 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool35 = icmp ne %struct.btf_type* %41, null
  br i1 %tobool35, label %lor.lhs.false36, label %if.then38

lor.lhs.false36:                                  ; preds = %if.end33
  %42 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call37 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %42) #14
  br i1 %call37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %lor.lhs.false36, %if.end33
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.142, i64 0, i64 0), i32 noundef %45) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end39:                                         ; preds = %lor.lhs.false36
  %46 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %47 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %47, i32 0, i32 0
  %48 = load i32, i32* %name_off, align 4
  %call40 = call i8* @btf_name_by_offset(%struct.btf* noundef %46, i32 noundef %48) #14
  store i8* %call40, i8** %func_name, align 8
  %49 = load i8*, i8** %func_name, align 8
  %call41 = call i64 @kallsyms_lookup_name(i8* noundef %49) #14
  store i64 %call41, i64* %addr, align 8
  %50 = load i64, i64* %addr, align 8
  %tobool42 = icmp ne i64 %50, 0
  br i1 %tobool42, label %if.end44, label %if.then43

if.then43:                                        ; preds = %if.end39
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i8*, i8** %func_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.143, i64 0, i64 0), i8* noundef %53) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end39
  %54 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %54, i32 0, i32 0
  %55 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs45 = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %55, i32 0, i32 1
  %56 = load i32, i32* %nr_descs45, align 4
  %inc = add i32 %56, 1
  store i32 %inc, i32* %nr_descs45, align 4
  %idxprom = zext i32 %56 to i64
  %arrayidx = getelementptr [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 %idxprom
  store %struct.bpf_kfunc_desc* %arrayidx, %struct.bpf_kfunc_desc** %desc, align 8
  %57 = load i32, i32* %func_id.addr, align 4
  %58 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %func_id46 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %58, i32 0, i32 1
  store i32 %57, i32* %func_id46, align 4
  %59 = load i64, i64* %addr, align 8
  %60 = inttoptr i64 %59 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast = ptrtoint i64 (i64, i64, i64, i64, i64)* %60 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv = trunc i64 %sub.ptr.sub to i32
  %61 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %imm = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %61, i32 0, i32 2
  store i32 %conv, i32* %imm, align 4
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %62, i32 0, i32 26
  %63 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %64 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %65 = load i8*, i8** %func_name, align 8
  %66 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %func_model = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %66, i32 0, i32 0
  %call47 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %63, %struct.btf_type* noundef %64, i8* noundef %65, %struct.btf_func_model* noundef %func_model) #14
  store i32 %call47, i32* %err, align 4
  %67 = load i32, i32* %err, align 4
  %tobool48 = icmp ne i32 %67, 0
  br i1 %tobool48, label %if.end53, label %if.then49

if.then49:                                        ; preds = %if.end44
  %68 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs50 = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %68, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs50, i64 0, i64 0
  %69 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %70 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs51 = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %70, i32 0, i32 1
  %71 = load i32, i32* %nr_descs51, align 4
  %conv52 = zext i32 %71 to i64
  call void @sort(i8* noundef %69, i64 noundef %conv52, i64 noundef 24, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_id, void (i8*, i8*, i32)* noundef null) #14
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %if.end44
  %72 = load i32, i32* %err, align 4
  store i32 %72, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end53, %if.then43, %if.then38, %if.then32, %if.then27, %if.then25, %if.then18, %if.then14, %if.then7, %if.then5, %if.then2
  %73 = load i32, i32* %retval, align 4
  ret i32 %73
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @find_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %p = alloca %struct.bpf_subprog_info*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = bitcast i32* %off.addr to i8*
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %2 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 31
  %4 = load i32, i32* %subprog_cnt, align 4
  %conv = zext i32 %4 to i64
  %call = call i8* @bsearch(i8* noundef %0, i8* noundef %2, i64 noundef %conv, i64 noundef 16, i32 (i8*, i8*)* noundef @cmp_subprogs) #14
  %5 = bitcast i8* %call to %struct.bpf_subprog_info*
  store %struct.bpf_subprog_info* %5, %struct.bpf_subprog_info** %p, align 8
  %6 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %tobool = icmp ne %struct.bpf_subprog_info* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 27
  %arraydecay2 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_subprog_info* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_subprog_info* %arraydecay2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv3 = trunc i64 %sub.ptr.div to i32
  store i32 %conv3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @sort(i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef, void (i8*, i8*, i32)* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @cmp_subprogs(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_subprog_info*
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %1, i32 0, i32 0
  %2 = load i32, i32* %start, align 4
  %3 = load i8*, i8** %b.addr, align 8
  %4 = bitcast i8* %3 to %struct.bpf_subprog_info*
  %start1 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i32 0, i32 0
  %5 = load i32, i32* %start1, align 4
  %sub = sub i32 %2, %5
  ret i32 %sub
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_supports_kfunc_call() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_kfunc_desc* @find_kfunc_desc(%struct.bpf_prog* noundef %prog, i32 noundef %func_id) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %func_id.addr = alloca i32, align 4
  %desc = alloca %struct.bpf_kfunc_desc, align 4
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %0, i8 0, i64 24, i1 false)
  %func_id1 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %desc, i32 0, i32 1
  %1 = load i32, i32* %func_id.addr, align 4
  store i32 %1, i32* %func_id1, align 4
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 33
  %4 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %4, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %5 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  %6 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 0
  %7 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %8 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %8, i32 0, i32 1
  %9 = load i32, i32* %nr_descs, align 4
  %conv = zext i32 %9 to i64
  %call = call i8* @bsearch(i8* noundef %5, i8* noundef %7, i64 noundef %conv, i64 noundef 24, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_id) #14
  %10 = bitcast i8* %call to %struct.bpf_kfunc_desc*
  ret %struct.bpf_kfunc_desc* %10
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__bpf_call_base(i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @kfunc_desc_cmp_by_id(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %d0 = alloca %struct.bpf_kfunc_desc*, align 8
  %d1 = alloca %struct.bpf_kfunc_desc*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %1, %struct.bpf_kfunc_desc** %d0, align 8
  %2 = load i8*, i8** %b.addr, align 8
  %3 = bitcast i8* %2 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %3, %struct.bpf_kfunc_desc** %d1, align 8
  %4 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %func_id = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %4, i32 0, i32 1
  %5 = load i32, i32* %func_id, align 4
  %6 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %func_id1 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %6, i32 0, i32 1
  %7 = load i32, i32* %func_id1, align 4
  %sub = sub i32 %5, %7
  ret i32 %sub
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 31
  %2 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 27
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 5
  %5 = load i8, i8* %has_ld_abs, align 4
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.146, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 27
  %9 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %9 to i64
  %arrayidx3 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 %idxprom2
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx3, i32 0, i32 3
  %10 = load i8, i8* %has_tail_call, align 2
  %tobool4 = trunc i8 %10 to i1
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.147, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %13 = load i32, i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_get_by_fd(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_is_kernel(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @btf_put(%struct.btf* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_func(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %type = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %ret_type = alloca %struct.btf_type*, align 8
  %i = alloca i32, align 4
  %nfuncs = alloca i32, align 4
  %urec_size = alloca i32, align 4
  %min_size = alloca i32, align 4
  %krec_size = alloca i32, align 4
  %krecord = alloca %struct.bpf_func_info*, align 8
  %info_aux = alloca %struct.bpf_func_info_aux*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %urecord = alloca %struct.sockptr_t, align 8
  %prev_offset = alloca i32, align 4
  %scalar_return = alloca i8, align 1
  %ret = alloca i32, align 4
  %tmp = alloca %struct.sockptr_t, align 8
  %__UNIQUE_ID___x541 = alloca i32, align 4
  %__UNIQUE_ID___y542 = alloca i32, align 4
  %tmp15 = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store i32 8, i32* %krec_size, align 4
  store %struct.bpf_func_info_aux* null, %struct.bpf_func_info_aux** %info_aux, align 8
  store i32 0, i32* %prev_offset, align 4
  store i32 -12, i32* %ret, align 4
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.130*
  %func_info_cnt = getelementptr inbounds %struct.anon.130, %struct.anon.130* %4, i32 0, i32 15
  %5 = load i32, i32* %func_info_cnt, align 8
  store i32 %5, i32* %nfuncs, align 4
  %6 = load i32, i32* %nfuncs, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end3, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %7) #14
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %entry
  %8 = load i32, i32* %nfuncs, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 31
  %10 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ne i32 %8, %10
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end3
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.148, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end3
  %13 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %14 = bitcast %union.bpf_attr* %13 to %struct.anon.130*
  %func_info_rec_size = getelementptr inbounds %struct.anon.130, %struct.anon.130* %14, i32 0, i32 13
  %15 = load i32, i32* %func_info_rec_size, align 4
  store i32 %15, i32* %urec_size, align 4
  %16 = load i32, i32* %urec_size, align 4
  %cmp6 = icmp ult i32 %16, 8
  br i1 %cmp6, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %17 = load i32, i32* %urec_size, align 4
  %cmp7 = icmp ugt i32 %17, 252
  br i1 %cmp7, label %if.then10, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %18 = load i32, i32* %urec_size, align 4
  %conv = zext i32 %18 to i64
  %rem = urem i64 %conv, 4
  %tobool9 = icmp ne i64 %rem, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false8, %lor.lhs.false, %if.end5
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %urec_size, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.149, i64 0, i64 0), i32 noundef %21) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %lor.lhs.false8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog12, align 8
  store %struct.bpf_prog* %23, %struct.bpf_prog** %prog, align 8
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %24, i32 0, i32 10
  %25 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %25, i32 0, i32 47
  %26 = load %struct.btf*, %struct.btf** %btf13, align 8
  store %struct.btf* %26, %struct.btf** %btf, align 8
  %27 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %28 = bitcast %union.bpf_attr* %27 to %struct.anon.130*
  %func_info = getelementptr inbounds %struct.anon.130, %struct.anon.130* %28, i32 0, i32 14
  %29 = load i64, i64* %func_info, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call14 = call { i8*, i8 } @make_bpfptr(i64 noundef %29, i1 noundef zeroext %bf.cast) #14
  %30 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %31 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %30, i32 0, i32 0
  %32 = extractvalue { i8*, i8 } %call14, 0
  store i8* %32, i8** %31, align 8
  %33 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %30, i32 0, i32 1
  %34 = extractvalue { i8*, i8 } %call14, 1
  store i8 %34, i8* %33, align 8
  %35 = bitcast %struct.sockptr_t* %urecord to i8*
  %36 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 16, i1 false)
  %37 = load i32, i32* %krec_size, align 4
  store i32 %37, i32* %__UNIQUE_ID___x541, align 4
  %38 = load i32, i32* %urec_size, align 4
  store i32 %38, i32* %__UNIQUE_ID___y542, align 4
  %39 = load i32, i32* %__UNIQUE_ID___x541, align 4
  %40 = load i32, i32* %__UNIQUE_ID___y542, align 4
  %cmp16 = icmp ult i32 %39, %40
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end11
  %41 = load i32, i32* %__UNIQUE_ID___x541, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end11
  %42 = load i32, i32* %__UNIQUE_ID___y542, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %41, %cond.true ], [ %42, %cond.false ]
  store i32 %cond, i32* %tmp15, align 4
  %43 = load i32, i32* %tmp15, align 4
  store i32 %43, i32* %min_size, align 4
  %44 = load i32, i32* %nfuncs, align 4
  %conv18 = zext i32 %44 to i64
  %45 = load i32, i32* %krec_size, align 4
  %conv19 = zext i32 %45 to i64
  %call20 = call i8* @kvcalloc(i64 noundef %conv18, i64 noundef %conv19, i32 noundef 11456) #14
  %46 = bitcast i8* %call20 to %struct.bpf_func_info*
  store %struct.bpf_func_info* %46, %struct.bpf_func_info** %krecord, align 8
  %47 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %tobool21 = icmp ne %struct.bpf_func_info* %47, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %cond.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %cond.end
  %48 = load i32, i32* %nfuncs, align 4
  %conv24 = zext i32 %48 to i64
  %call25 = call i8* @kcalloc(i64 noundef %conv24, i64 noundef 4, i32 noundef 11456) #14
  %49 = bitcast i8* %call25 to %struct.bpf_func_info_aux*
  store %struct.bpf_func_info_aux* %49, %struct.bpf_func_info_aux** %info_aux, align 8
  %50 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %tobool26 = icmp ne %struct.bpf_func_info_aux* %50, null
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end23
  br label %err_free

if.end28:                                         ; preds = %if.end23
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %51 = load i32, i32* %i, align 4
  %52 = load i32, i32* %nfuncs, align 4
  %cmp29 = icmp ult i32 %51, %52
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %53 = load i32, i32* %krec_size, align 4
  %conv31 = zext i32 %53 to i64
  %54 = load i32, i32* %urec_size, align 4
  %conv32 = zext i32 %54 to i64
  %55 = bitcast %struct.sockptr_t* %urecord to { i8*, i8 }*
  %56 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %55, i32 0, i32 0
  %57 = load i8*, i8** %56, align 8
  %58 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %55, i32 0, i32 1
  %59 = load i8, i8* %58, align 8
  %call33 = call i32 @bpf_check_uarg_tail_zero(i8* %57, i8 %59, i64 noundef %conv31, i64 noundef %conv32) #14
  store i32 %call33, i32* %ret, align 4
  %60 = load i32, i32* %ret, align 4
  %tobool34 = icmp ne i32 %60, 0
  br i1 %tobool34, label %if.then35, label %if.end44

if.then35:                                        ; preds = %for.body
  %61 = load i32, i32* %ret, align 4
  %cmp36 = icmp eq i32 %61, -7
  br i1 %cmp36, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.then35
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = bitcast %struct.bpf_verifier_env* %62 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %63, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.150, i64 0, i64 0)) #14
  %64 = bitcast i32* %min_size to i8*
  %65 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %66 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %65, i32 0, i32 0
  %67 = load i8*, i8** %66, align 8
  %68 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %65, i32 0, i32 1
  %69 = load i8, i8* %68, align 8
  %call39 = call i32 @copy_to_bpfptr_offset(i8* %67, i8 %69, i64 noundef 76, i8* noundef %64, i64 noundef 4) #14
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.then38
  store i32 -14, i32* %ret, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.then38
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.then35
  br label %err_free

if.end44:                                         ; preds = %for.body
  %70 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %71 = load i32, i32* %i, align 4
  %idxprom = zext i32 %71 to i64
  %arrayidx = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %70, i64 %idxprom
  %72 = bitcast %struct.bpf_func_info* %arrayidx to i8*
  %73 = load i32, i32* %min_size, align 4
  %conv45 = zext i32 %73 to i64
  %74 = bitcast %struct.sockptr_t* %urecord to { i8*, i8 }*
  %75 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %74, i32 0, i32 0
  %76 = load i8*, i8** %75, align 8
  %77 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %74, i32 0, i32 1
  %78 = load i8, i8* %77, align 8
  %call46 = call i32 @copy_from_bpfptr(i8* noundef %72, i8* %76, i8 %78, i64 noundef %conv45) #14
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end44
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end49:                                         ; preds = %if.end44
  store i32 -22, i32* %ret, align 4
  %79 = load i32, i32* %i, align 4
  %cmp50 = icmp eq i32 %79, 0
  br i1 %cmp50, label %if.then52, label %if.else

if.then52:                                        ; preds = %if.end49
  %80 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %81 = load i32, i32* %i, align 4
  %idxprom53 = zext i32 %81 to i64
  %arrayidx54 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %80, i64 %idxprom53
  %insn_off = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx54, i32 0, i32 0
  %82 = load i32, i32* %insn_off, align 4
  %tobool55 = icmp ne i32 %82, 0
  br i1 %tobool55, label %if.then56, label %if.end60

if.then56:                                        ; preds = %if.then52
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = bitcast %struct.bpf_verifier_env* %83 to i8*
  %85 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %86 = load i32, i32* %i, align 4
  %idxprom57 = zext i32 %86 to i64
  %arrayidx58 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %85, i64 %idxprom57
  %insn_off59 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx58, i32 0, i32 0
  %87 = load i32, i32* %insn_off59, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %84, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.151, i64 0, i64 0), i32 noundef %87) #14
  br label %err_free

if.end60:                                         ; preds = %if.then52
  br label %if.end71

if.else:                                          ; preds = %if.end49
  %88 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %89 = load i32, i32* %i, align 4
  %idxprom61 = zext i32 %89 to i64
  %arrayidx62 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %88, i64 %idxprom61
  %insn_off63 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx62, i32 0, i32 0
  %90 = load i32, i32* %insn_off63, align 4
  %91 = load i32, i32* %prev_offset, align 4
  %cmp64 = icmp ule i32 %90, %91
  br i1 %cmp64, label %if.then66, label %if.end70

if.then66:                                        ; preds = %if.else
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  %94 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %95 = load i32, i32* %i, align 4
  %idxprom67 = zext i32 %95 to i64
  %arrayidx68 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %94, i64 %idxprom67
  %insn_off69 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx68, i32 0, i32 0
  %96 = load i32, i32* %insn_off69, align 4
  %97 = load i32, i32* %prev_offset, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %93, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.152, i64 0, i64 0), i32 noundef %96, i32 noundef %97) #14
  br label %err_free

if.end70:                                         ; preds = %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.end60
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 27
  %99 = load i32, i32* %i, align 4
  %idxprom72 = zext i32 %99 to i64
  %arrayidx73 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom72
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx73, i32 0, i32 0
  %100 = load i32, i32* %start, align 8
  %101 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %102 = load i32, i32* %i, align 4
  %idxprom74 = zext i32 %102 to i64
  %arrayidx75 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %101, i64 %idxprom74
  %insn_off76 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx75, i32 0, i32 0
  %103 = load i32, i32* %insn_off76, align 4
  %cmp77 = icmp ne i32 %100, %103
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.end71
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %105 = bitcast %struct.bpf_verifier_env* %104 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %105, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.153, i64 0, i64 0)) #14
  br label %err_free

if.end80:                                         ; preds = %if.end71
  %106 = load %struct.btf*, %struct.btf** %btf, align 8
  %107 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %108 = load i32, i32* %i, align 4
  %idxprom81 = zext i32 %108 to i64
  %arrayidx82 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %107, i64 %idxprom81
  %type_id = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx82, i32 0, i32 1
  %109 = load i32, i32* %type_id, align 4
  %call83 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %106, i32 noundef %109) #14
  store %struct.btf_type* %call83, %struct.btf_type** %type, align 8
  %110 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %tobool84 = icmp ne %struct.btf_type* %110, null
  br i1 %tobool84, label %lor.lhs.false85, label %if.then87

lor.lhs.false85:                                  ; preds = %if.end80
  %111 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %call86 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %111) #14
  br i1 %call86, label %if.end91, label %if.then87

if.then87:                                        ; preds = %lor.lhs.false85, %if.end80
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = bitcast %struct.bpf_verifier_env* %112 to i8*
  %114 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %115 = load i32, i32* %i, align 4
  %idxprom88 = zext i32 %115 to i64
  %arrayidx89 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %114, i64 %idxprom88
  %type_id90 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx89, i32 0, i32 1
  %116 = load i32, i32* %type_id90, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %113, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.154, i64 0, i64 0), i32 noundef %116) #14
  br label %err_free

if.end91:                                         ; preds = %lor.lhs.false85
  %117 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %117, i32 0, i32 1
  %118 = load i32, i32* %info, align 4
  %and = and i32 %118, 65535
  %conv92 = trunc i32 %and to i16
  %119 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %120 = load i32, i32* %i, align 4
  %idxprom93 = zext i32 %120 to i64
  %arrayidx94 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %119, i64 %idxprom93
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx94, i32 0, i32 0
  store i16 %conv92, i16* %linkage, align 2
  %121 = load %struct.btf*, %struct.btf** %btf, align 8
  %122 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %123 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %122, i32 0, i32 2
  %type95 = bitcast %union.anon.123* %123 to i32*
  %124 = load i32, i32* %type95, align 4
  %call96 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %121, i32 noundef %124) #14
  store %struct.btf_type* %call96, %struct.btf_type** %func_proto, align 8
  %125 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool97 = icmp ne %struct.btf_type* %125, null
  br i1 %tobool97, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end91
  %126 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call98 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %126) #14
  %lnot = xor i1 %call98, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end91
  %127 = phi i1 [ true, %if.end91 ], [ %lnot, %lor.rhs ]
  %lnot99 = xor i1 %127, true
  %lnot100 = xor i1 %lnot99, true
  %lnot.ext = zext i1 %lnot100 to i32
  %conv101 = sext i32 %lnot.ext to i64
  %tobool102 = icmp ne i64 %conv101, 0
  br i1 %tobool102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.end
  br label %err_free

if.end104:                                        ; preds = %lor.end
  %128 = load %struct.btf*, %struct.btf** %btf, align 8
  %129 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %130 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %129, i32 0, i32 2
  %type105 = bitcast %union.anon.123* %130 to i32*
  %131 = load i32, i32* %type105, align 4
  %call106 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %128, i32 noundef %131, i32* noundef null) #14
  store %struct.btf_type* %call106, %struct.btf_type** %ret_type, align 8
  %132 = load %struct.btf_type*, %struct.btf_type** %ret_type, align 8
  %call107 = call zeroext i1 @btf_type_is_small_int(%struct.btf_type* noundef %132) #14
  br i1 %call107, label %lor.end112, label %lor.rhs109

lor.rhs109:                                       ; preds = %if.end104
  %133 = load %struct.btf_type*, %struct.btf_type** %ret_type, align 8
  %call110 = call zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %133) #14
  br label %lor.end112

lor.end112:                                       ; preds = %lor.rhs109, %if.end104
  %134 = phi i1 [ true, %if.end104 ], [ %call110, %lor.rhs109 ]
  %frombool = zext i1 %134 to i8
  store i8 %frombool, i8* %scalar_return, align 1
  %135 = load i32, i32* %i, align 4
  %tobool113 = icmp ne i32 %135, 0
  br i1 %tobool113, label %land.lhs.true, label %if.end122

land.lhs.true:                                    ; preds = %lor.end112
  %136 = load i8, i8* %scalar_return, align 1
  %tobool114 = trunc i8 %136 to i1
  br i1 %tobool114, label %if.end122, label %land.lhs.true115

land.lhs.true115:                                 ; preds = %land.lhs.true
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info116 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %137, i32 0, i32 27
  %138 = load i32, i32* %i, align 4
  %idxprom117 = zext i32 %138 to i64
  %arrayidx118 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info116, i64 0, i64 %idxprom117
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx118, i32 0, i32 5
  %139 = load i8, i8* %has_ld_abs, align 4
  %tobool119 = trunc i8 %139 to i1
  br i1 %tobool119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %land.lhs.true115
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.155, i64 0, i64 0)) #14
  br label %err_free

if.end122:                                        ; preds = %land.lhs.true115, %land.lhs.true, %lor.end112
  %142 = load i32, i32* %i, align 4
  %tobool123 = icmp ne i32 %142, 0
  br i1 %tobool123, label %land.lhs.true124, label %if.end133

land.lhs.true124:                                 ; preds = %if.end122
  %143 = load i8, i8* %scalar_return, align 1
  %tobool125 = trunc i8 %143 to i1
  br i1 %tobool125, label %if.end133, label %land.lhs.true126

land.lhs.true126:                                 ; preds = %land.lhs.true124
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info127 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %144, i32 0, i32 27
  %145 = load i32, i32* %i, align 4
  %idxprom128 = zext i32 %145 to i64
  %arrayidx129 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info127, i64 0, i64 %idxprom128
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx129, i32 0, i32 3
  %146 = load i8, i8* %has_tail_call, align 2
  %tobool130 = trunc i8 %146 to i1
  br i1 %tobool130, label %if.then132, label %if.end133

if.then132:                                       ; preds = %land.lhs.true126
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %148 = bitcast %struct.bpf_verifier_env* %147 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %148, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.156, i64 0, i64 0)) #14
  br label %err_free

if.end133:                                        ; preds = %land.lhs.true126, %land.lhs.true124, %if.end122
  %149 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %150 = load i32, i32* %i, align 4
  %idxprom134 = zext i32 %150 to i64
  %arrayidx135 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %149, i64 %idxprom134
  %insn_off136 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx135, i32 0, i32 0
  %151 = load i32, i32* %insn_off136, align 4
  store i32 %151, i32* %prev_offset, align 4
  %152 = load i32, i32* %urec_size, align 4
  %conv137 = zext i32 %152 to i64
  call void @bpfptr_add(%struct.sockptr_t* noundef %urecord, i64 noundef %conv137) #14
  br label %for.inc

for.inc:                                          ; preds = %if.end133
  %153 = load i32, i32* %i, align 4
  %inc = add i32 %153, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %154 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %155 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux138 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %155, i32 0, i32 10
  %156 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux138, align 8
  %func_info139 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %156, i32 0, i32 48
  store %struct.bpf_func_info* %154, %struct.bpf_func_info** %func_info139, align 8
  %157 = load i32, i32* %nfuncs, align 4
  %158 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux140 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %158, i32 0, i32 10
  %159 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux140, align 8
  %func_info_cnt141 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %159, i32 0, i32 52
  store i32 %157, i32* %func_info_cnt141, align 8
  %160 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux142 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 10
  %162 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux142, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %162, i32 0, i32 49
  store %struct.bpf_func_info_aux* %160, %struct.bpf_func_info_aux** %func_info_aux, align 8
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then132, %if.then121, %if.then103, %if.then87, %if.then79, %if.then66, %if.then56, %if.then48, %if.end43, %if.then27
  %163 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %164 = bitcast %struct.bpf_func_info* %163 to i8*
  call void @kvfree(i8* noundef %164) #14
  %165 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %166 = bitcast %struct.bpf_func_info_aux* %165 to i8*
  call void @kfree(i8* noundef %166) #14
  %167 = load i32, i32* %ret, align 4
  store i32 %167, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %for.end, %if.then22, %if.then10, %if.then4, %if.end, %if.then2
  %168 = load i32, i32* %retval, align 4
  ret i32 %168
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_line(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %i = alloca i32, align 4
  %s = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %ncopy = alloca i32, align 4
  %expected_size = alloca i32, align 4
  %rec_size = alloca i32, align 4
  %prev_offset = alloca i32, align 4
  %sub = alloca %struct.bpf_subprog_info*, align 8
  %linfo = alloca %struct.bpf_line_info*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %ulinfo = alloca %struct.sockptr_t, align 8
  %err = alloca i32, align 4
  %tmp = alloca %struct.sockptr_t, align 8
  %__UNIQUE_ID___x543 = alloca i32, align 4
  %__UNIQUE_ID___y544 = alloca i32, align 4
  %tmp21 = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store i32 0, i32* %prev_offset, align 4
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.130*
  %line_info_cnt = getelementptr inbounds %struct.anon.130, %struct.anon.130* %4, i32 0, i32 18
  %5 = load i32, i32* %line_info_cnt, align 8
  store i32 %5, i32* %nr_linfo, align 4
  %6 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %nr_linfo, align 4
  %conv = zext i32 %7 to i64
  %cmp = icmp ugt i64 %conv, 134217727
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %8 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %9 = bitcast %union.bpf_attr* %8 to %struct.anon.130*
  %line_info_rec_size = getelementptr inbounds %struct.anon.130, %struct.anon.130* %9, i32 0, i32 16
  %10 = load i32, i32* %line_info_rec_size, align 4
  store i32 %10, i32* %rec_size, align 4
  %11 = load i32, i32* %rec_size, align 4
  %conv4 = zext i32 %11 to i64
  %cmp5 = icmp ult i64 %conv4, 16
  br i1 %cmp5, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end3
  %12 = load i32, i32* %rec_size, align 4
  %cmp7 = icmp ugt i32 %12, 252
  br i1 %cmp7, label %if.then12, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %13 = load i32, i32* %rec_size, align 4
  %conv10 = zext i32 %13 to i64
  %and = and i64 %conv10, 3
  %tobool11 = icmp ne i64 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false9, %lor.lhs.false, %if.end3
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false9
  %14 = load i32, i32* %nr_linfo, align 4
  %conv14 = zext i32 %14 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv14, i64 noundef 16, i32 noundef 11456) #14
  %15 = bitcast i8* %call to %struct.bpf_line_info*
  store %struct.bpf_line_info* %15, %struct.bpf_line_info** %linfo, align 8
  %16 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %tobool15 = icmp ne %struct.bpf_line_info* %16, null
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end13
  store i32 -12, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end13
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog18, align 8
  store %struct.bpf_prog* %18, %struct.bpf_prog** %prog, align 8
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 10
  %20 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf19 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %20, i32 0, i32 47
  %21 = load %struct.btf*, %struct.btf** %btf19, align 8
  store %struct.btf* %21, %struct.btf** %btf, align 8
  store i32 0, i32* %s, align 4
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %sub, align 8
  %23 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %24 = bitcast %union.bpf_attr* %23 to %struct.anon.130*
  %line_info = getelementptr inbounds %struct.anon.130, %struct.anon.130* %24, i32 0, i32 17
  %25 = load i64, i64* %line_info, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call20 = call { i8*, i8 } @make_bpfptr(i64 noundef %25, i1 noundef zeroext %bf.cast) #14
  %26 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %27 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %26, i32 0, i32 0
  %28 = extractvalue { i8*, i8 } %call20, 0
  store i8* %28, i8** %27, align 8
  %29 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %26, i32 0, i32 1
  %30 = extractvalue { i8*, i8 } %call20, 1
  store i8 %30, i8* %29, align 8
  %31 = bitcast %struct.sockptr_t* %ulinfo to i8*
  %32 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %31, i8* align 8 %32, i64 16, i1 false)
  store i32 16, i32* %expected_size, align 4
  %33 = load i32, i32* %expected_size, align 4
  store i32 %33, i32* %__UNIQUE_ID___x543, align 4
  %34 = load i32, i32* %rec_size, align 4
  store i32 %34, i32* %__UNIQUE_ID___y544, align 4
  %35 = load i32, i32* %__UNIQUE_ID___x543, align 4
  %36 = load i32, i32* %__UNIQUE_ID___y544, align 4
  %cmp22 = icmp ult i32 %35, %36
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %37 = load i32, i32* %__UNIQUE_ID___x543, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  %38 = load i32, i32* %__UNIQUE_ID___y544, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %37, %cond.true ], [ %38, %cond.false ]
  store i32 %cond, i32* %tmp21, align 4
  %39 = load i32, i32* %tmp21, align 4
  store i32 %39, i32* %ncopy, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %40 = load i32, i32* %i, align 4
  %41 = load i32, i32* %nr_linfo, align 4
  %cmp24 = icmp ult i32 %40, %41
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %42 = load i32, i32* %expected_size, align 4
  %conv26 = zext i32 %42 to i64
  %43 = load i32, i32* %rec_size, align 4
  %conv27 = zext i32 %43 to i64
  %44 = bitcast %struct.sockptr_t* %ulinfo to { i8*, i8 }*
  %45 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %44, i32 0, i32 0
  %46 = load i8*, i8** %45, align 8
  %47 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %44, i32 0, i32 1
  %48 = load i8, i8* %47, align 8
  %call28 = call i32 @bpf_check_uarg_tail_zero(i8* %46, i8 %48, i64 noundef %conv26, i64 noundef %conv27) #14
  store i32 %call28, i32* %err, align 4
  %49 = load i32, i32* %err, align 4
  %tobool29 = icmp ne i32 %49, 0
  br i1 %tobool29, label %if.then30, label %if.end39

if.then30:                                        ; preds = %for.body
  %50 = load i32, i32* %err, align 4
  %cmp31 = icmp eq i32 %50, -7
  br i1 %cmp31, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.then30
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.157, i64 0, i64 0)) #14
  %53 = bitcast i32* %expected_size to i8*
  %54 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %55 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %54, i32 0, i32 0
  %56 = load i8*, i8** %55, align 8
  %57 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %54, i32 0, i32 1
  %58 = load i8, i8* %57, align 8
  %call34 = call i32 @copy_to_bpfptr_offset(i8* %56, i8 %58, i64 noundef 92, i8* noundef %53, i64 noundef 4) #14
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.then33
  store i32 -14, i32* %err, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.then33
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then30
  br label %err_free

if.end39:                                         ; preds = %for.body
  %59 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom = zext i32 %60 to i64
  %arrayidx = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %59, i64 %idxprom
  %61 = bitcast %struct.bpf_line_info* %arrayidx to i8*
  %62 = load i32, i32* %ncopy, align 4
  %conv40 = zext i32 %62 to i64
  %63 = bitcast %struct.sockptr_t* %ulinfo to { i8*, i8 }*
  %64 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %63, i32 0, i32 0
  %65 = load i8*, i8** %64, align 8
  %66 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %63, i32 0, i32 1
  %67 = load i8, i8* %66, align 8
  %call41 = call i32 @copy_from_bpfptr(i8* noundef %61, i8* %65, i8 %67, i64 noundef %conv40) #14
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end39
  store i32 -14, i32* %err, align 4
  br label %err_free

if.end44:                                         ; preds = %if.end39
  %68 = load i32, i32* %i, align 4
  %tobool45 = icmp ne i32 %68, 0
  br i1 %tobool45, label %land.lhs.true, label %lor.lhs.false50

land.lhs.true:                                    ; preds = %if.end44
  %69 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %70 = load i32, i32* %i, align 4
  %idxprom46 = zext i32 %70 to i64
  %arrayidx47 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %69, i64 %idxprom46
  %insn_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx47, i32 0, i32 0
  %71 = load i32, i32* %insn_off, align 4
  %72 = load i32, i32* %prev_offset, align 4
  %cmp48 = icmp ule i32 %71, %72
  br i1 %cmp48, label %if.then56, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true, %if.end44
  %73 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %74 = load i32, i32* %i, align 4
  %idxprom51 = zext i32 %74 to i64
  %arrayidx52 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %73, i64 %idxprom51
  %insn_off53 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx52, i32 0, i32 0
  %75 = load i32, i32* %insn_off53, align 4
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 4
  %77 = load i32, i32* %len, align 4
  %cmp54 = icmp uge i32 %75, %77
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %lor.lhs.false50, %land.lhs.true
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = bitcast %struct.bpf_verifier_env* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %82 = load i32, i32* %i, align 4
  %idxprom57 = zext i32 %82 to i64
  %arrayidx58 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %81, i64 %idxprom57
  %insn_off59 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx58, i32 0, i32 0
  %83 = load i32, i32* %insn_off59, align 4
  %84 = load i32, i32* %prev_offset, align 4
  %85 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len60 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %85, i32 0, i32 4
  %86 = load i32, i32* %len60, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %79, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.158, i64 0, i64 0), i32 noundef %80, i32 noundef %83, i32 noundef %84, i32 noundef %86) #14
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end61:                                         ; preds = %lor.lhs.false50
  %87 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %87, i32 0, i32 13
  %88 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %89 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %89 to i64
  %arrayidx63 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %88, i64 %idxprom62
  %insn_off64 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx63, i32 0, i32 0
  %90 = load i32, i32* %insn_off64, align 4
  %idxprom65 = zext i32 %90 to i64
  %arrayidx66 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom65
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx66, i32 0, i32 0
  %91 = load i8, i8* %code, align 8
  %tobool67 = icmp ne i8 %91, 0
  br i1 %tobool67, label %if.end69, label %if.then68

if.then68:                                        ; preds = %if.end61
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  %94 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %93, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.159, i64 0, i64 0), i32 noundef %94) #14
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end69:                                         ; preds = %if.end61
  %95 = load %struct.btf*, %struct.btf** %btf, align 8
  %96 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %97 = load i32, i32* %i, align 4
  %idxprom70 = zext i32 %97 to i64
  %arrayidx71 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %96, i64 %idxprom70
  %line_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx71, i32 0, i32 2
  %98 = load i32, i32* %line_off, align 4
  %call72 = call i8* @btf_name_by_offset(%struct.btf* noundef %95, i32 noundef %98) #14
  %tobool73 = icmp ne i8* %call72, null
  br i1 %tobool73, label %lor.lhs.false74, label %if.then79

lor.lhs.false74:                                  ; preds = %if.end69
  %99 = load %struct.btf*, %struct.btf** %btf, align 8
  %100 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %101 = load i32, i32* %i, align 4
  %idxprom75 = zext i32 %101 to i64
  %arrayidx76 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %100, i64 %idxprom75
  %file_name_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx76, i32 0, i32 1
  %102 = load i32, i32* %file_name_off, align 4
  %call77 = call i8* @btf_name_by_offset(%struct.btf* noundef %99, i32 noundef %102) #14
  %tobool78 = icmp ne i8* %call77, null
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %lor.lhs.false74, %if.end69
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %104 = bitcast %struct.bpf_verifier_env* %103 to i8*
  %105 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %104, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.160, i64 0, i64 0), i32 noundef %105) #14
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end80:                                         ; preds = %lor.lhs.false74
  %106 = load i32, i32* %s, align 4
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %107, i32 0, i32 31
  %108 = load i32, i32* %subprog_cnt, align 4
  %cmp81 = icmp ne i32 %106, %108
  br i1 %cmp81, label %if.then83, label %if.end105

if.then83:                                        ; preds = %if.end80
  %109 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %110 = load i32, i32* %i, align 4
  %idxprom84 = zext i32 %110 to i64
  %arrayidx85 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %109, i64 %idxprom84
  %insn_off86 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx85, i32 0, i32 0
  %111 = load i32, i32* %insn_off86, align 4
  %112 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %113 = load i32, i32* %s, align 4
  %idxprom87 = zext i32 %113 to i64
  %arrayidx88 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %112, i64 %idxprom87
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx88, i32 0, i32 0
  %114 = load i32, i32* %start, align 4
  %cmp89 = icmp eq i32 %111, %114
  br i1 %cmp89, label %if.then91, label %if.else

if.then91:                                        ; preds = %if.then83
  %115 = load i32, i32* %i, align 4
  %116 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %117 = load i32, i32* %s, align 4
  %idxprom92 = zext i32 %117 to i64
  %arrayidx93 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %116, i64 %idxprom92
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx93, i32 0, i32 1
  store i32 %115, i32* %linfo_idx, align 4
  %118 = load i32, i32* %s, align 4
  %inc = add i32 %118, 1
  store i32 %inc, i32* %s, align 4
  br label %if.end104

if.else:                                          ; preds = %if.then83
  %119 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %120 = load i32, i32* %s, align 4
  %idxprom94 = zext i32 %120 to i64
  %arrayidx95 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %119, i64 %idxprom94
  %start96 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx95, i32 0, i32 0
  %121 = load i32, i32* %start96, align 4
  %122 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %123 = load i32, i32* %i, align 4
  %idxprom97 = zext i32 %123 to i64
  %arrayidx98 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %122, i64 %idxprom97
  %insn_off99 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx98, i32 0, i32 0
  %124 = load i32, i32* %insn_off99, align 4
  %cmp100 = icmp ult i32 %121, %124
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.else
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %126 = bitcast %struct.bpf_verifier_env* %125 to i8*
  %127 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %126, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.161, i64 0, i64 0), i32 noundef %127) #14
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end103:                                        ; preds = %if.else
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.then91
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.end80
  %128 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %129 = load i32, i32* %i, align 4
  %idxprom106 = zext i32 %129 to i64
  %arrayidx107 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %128, i64 %idxprom106
  %insn_off108 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx107, i32 0, i32 0
  %130 = load i32, i32* %insn_off108, align 4
  store i32 %130, i32* %prev_offset, align 4
  %131 = load i32, i32* %rec_size, align 4
  %conv109 = zext i32 %131 to i64
  call void @bpfptr_add(%struct.sockptr_t* noundef %ulinfo, i64 noundef %conv109) #14
  br label %for.inc

for.inc:                                          ; preds = %if.end105
  %132 = load i32, i32* %i, align 4
  %inc110 = add i32 %132, 1
  store i32 %inc110, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %133 = load i32, i32* %s, align 4
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt111 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %134, i32 0, i32 31
  %135 = load i32, i32* %subprog_cnt111, align 4
  %cmp112 = icmp ne i32 %133, %135
  br i1 %cmp112, label %if.then114, label %if.end117

if.then114:                                       ; preds = %for.end
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %137 = bitcast %struct.bpf_verifier_env* %136 to i8*
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt115 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %138, i32 0, i32 31
  %139 = load i32, i32* %subprog_cnt115, align 4
  %140 = load i32, i32* %s, align 4
  %sub116 = sub i32 %139, %140
  %141 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %137, i8* noundef getelementptr inbounds ([58 x i8], [58 x i8]* @.str.162, i64 0, i64 0), i32 noundef %sub116, i32 noundef %141) #14
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end117:                                        ; preds = %for.end
  %142 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %143 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux118 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %143, i32 0, i32 10
  %144 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux118, align 8
  %linfo119 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %144, i32 0, i32 50
  store %struct.bpf_line_info* %142, %struct.bpf_line_info** %linfo119, align 8
  %145 = load i32, i32* %nr_linfo, align 4
  %146 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux120 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %146, i32 0, i32 10
  %147 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux120, align 8
  %nr_linfo121 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %147, i32 0, i32 53
  store i32 %145, i32* %nr_linfo121, align 4
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then114, %if.then102, %if.then79, %if.then68, %if.then56, %if.then43, %if.end38
  %148 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %149 = bitcast %struct.bpf_line_info* %148 to i8*
  call void @kvfree(i8* noundef %149) #14
  %150 = load i32, i32* %err, align 4
  store i32 %150, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.end117, %if.then16, %if.then12, %if.then2, %if.then
  %151 = load i32, i32* %retval, align 4
  ret i32 %151
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call i8* @kmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #14
  ret i8* %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_check_uarg_tail_zero(i8*, i8, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_to_bpfptr_offset(i8* %dst.coerce0, i8 %dst.coerce1, i64 noundef %offset, i8* noundef %src, i64 noundef %size) #0 {
entry:
  %dst = alloca %struct.sockptr_t, align 8
  %offset.addr = alloca i64, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %agg.tmp = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %dst to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %dst.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %dst.coerce1, i8* %2, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = bitcast %struct.sockptr_t* %agg.tmp to i8*
  %4 = bitcast %struct.sockptr_t* %dst to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 16, i1 false)
  %5 = load i64, i64* %offset.addr, align 8
  %6 = load i8*, i8** %src.addr, align 8
  %7 = load i64, i64* %size.addr, align 8
  %8 = bitcast %struct.sockptr_t* %agg.tmp to { i8*, i8 }*
  %9 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %8, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %8, i32 0, i32 1
  %12 = load i8, i8* %11, align 8
  %call = call i32 @copy_to_sockptr_offset(i8* %10, i8 %12, i64 noundef %5, i8* noundef %6, i64 noundef %7) #14
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_from_bpfptr(i8* noundef %dst, i8* %src.coerce0, i8 %src.coerce1, i64 noundef %size) #0 {
entry:
  %src = alloca %struct.sockptr_t, align 8
  %dst.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %src.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %src.coerce1, i8* %2, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i8*, i8** %dst.addr, align 8
  %4 = load i64, i64* %size.addr, align 8
  %5 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %5, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %5, i32 0, i32 1
  %9 = load i8, i8* %8, align 8
  %call = call i32 @copy_from_bpfptr_offset(i8* noundef %3, i8* %7, i8 %9, i64 noundef 0, i64 noundef %4) #14
  ret i32 %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_small_int(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call = call zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %0) #14
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %2 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %1, i32 0, i32 2
  %size = bitcast %union.anon.123* %2 to i32*
  %3 = load i32, i32* %size, align 4
  %conv = zext i32 %3 to i64
  %cmp = icmp ule i64 %conv, 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 6
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpfptr_add(%struct.sockptr_t* noundef %bpfptr, i64 noundef %val) #0 {
entry:
  %bpfptr.addr = alloca %struct.sockptr_t*, align 8
  %val.addr = alloca i64, align 8
  store %struct.sockptr_t* %bpfptr, %struct.sockptr_t** %bpfptr.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load %struct.sockptr_t*, %struct.sockptr_t** %bpfptr.addr, align 8
  %1 = bitcast %struct.sockptr_t* %0 to { i8*, i8 }*
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %1, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %1, i32 0, i32 1
  %5 = load i8, i8* %4, align 8
  %call = call zeroext i1 @bpfptr_is_kernel(i8* %3, i8 %5) #14
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i64, i64* %val.addr, align 8
  %7 = load %struct.sockptr_t*, %struct.sockptr_t** %bpfptr.addr, align 8
  %8 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %7, i32 0, i32 0
  %kernel = bitcast %union.anon.169* %8 to i8**
  %9 = load i8*, i8** %kernel, align 8
  %add.ptr = getelementptr i8, i8* %9, i64 %6
  store i8* %add.ptr, i8** %kernel, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %10 = load i64, i64* %val.addr, align 8
  %11 = load %struct.sockptr_t*, %struct.sockptr_t** %bpfptr.addr, align 8
  %12 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %11, i32 0, i32 0
  %user = bitcast %union.anon.169* %12 to i8**
  %13 = load i8*, i8** %user, align 8
  %add.ptr1 = getelementptr i8, i8* %13, i64 %10
  store i8* %add.ptr1, i8** %user, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_to_sockptr_offset(i8* %dst.coerce0, i8 %dst.coerce1, i64 noundef %offset, i8* noundef %src, i64 noundef %size) #0 {
entry:
  %retval.i = alloca i1, align 1
  %addr.addr.i = alloca i8*, align 8
  %bytes.addr.i = alloca i64, align 8
  %is_source.addr.i = alloca i8, align 1
  %sz.i = alloca i32, align 4
  %__ret_warn_on.i = alloca i32, align 4
  %tmp.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %dst = alloca %struct.sockptr_t, align 8
  %offset.addr = alloca i64, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.sockptr_t* %dst to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %dst.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %dst.coerce1, i8* %2, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = bitcast %struct.sockptr_t* %dst to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = load i8, i8* %6, align 8
  %call = call zeroext i1 @sockptr_is_kernel(i8* %5, i8 %7) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %dst, i32 0, i32 0
  %user = bitcast %union.anon.169* %8 to i8**
  %9 = load i8*, i8** %user, align 8
  %10 = load i64, i64* %offset.addr, align 8
  %add.ptr = getelementptr i8, i8* %9, i64 %10
  %11 = load i8*, i8** %src.addr, align 8
  %12 = load i64, i64* %size.addr, align 8
  store i8* %add.ptr, i8** %to.addr.i, align 8
  store i8* %11, i8** %from.addr.i, align 8
  store i64 %12, i64* %n.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  store i8* %13, i8** %addr.addr.i, align 8
  store i64 %14, i64* %bytes.addr.i, align 8
  store i8 1, i8* %is_source.addr.i, align 1
  store i32 -1, i32* %sz.i, align 4
  %15 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp sge i32 %15, 0
  br i1 %cmp.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %if.then
  %16 = load i32, i32* %sz.i, align 4
  %conv.i3 = sext i32 %16 to i64
  %17 = load i64, i64* %bytes.addr.i, align 8
  %cmp1.i = icmp ult i64 %conv.i3, %17
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %if.then
  %18 = phi i1 [ false, %if.then ], [ %cmp1.i, %land.rhs.i ]
  %lnot.i4 = xor i1 %18, true
  %lnot.ext.i5 = zext i1 %18 to i32
  %conv4.i = sext i32 %lnot.ext.i5 to i64
  br i1 %18, label %if.then.i6, label %if.end10.i

if.then.i6:                                       ; preds = %land.end.i
  %19 = load i64, i64* %bytes.addr.i, align 8
  %20 = call i1 @llvm.is.constant.i64(i64 %19) #13
  br i1 %20, label %if.else.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.then.i6
  %21 = load i32, i32* %sz.i, align 4
  %22 = load i64, i64* %bytes.addr.i, align 8
  call void @copy_overflow(i32 noundef %21, i64 noundef %22) #16
  br label %if.end9.i

if.else.i:                                        ; preds = %if.then.i6
  %23 = load i8, i8* %is_source.addr.i, align 1
  %tobool6.i = trunc i8 %23 to i1
  br i1 %tobool6.i, label %if.then7.i, label %if.else8.i

if.then7.i:                                       ; preds = %if.else.i
  call void @__bad_copy_from() #16, !srcloc !8
  br label %if.end.i

if.else8.i:                                       ; preds = %if.else.i
  call void @__bad_copy_to() #16, !srcloc !9
  br label %if.end.i

if.end.i:                                         ; preds = %if.else8.i, %if.then7.i
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.end.i, %if.then5.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end10.i:                                       ; preds = %land.end.i
  %24 = load i64, i64* %bytes.addr.i, align 8
  %cmp11.i = icmp ugt i64 %24, 2147483647
  %lnot13.i = xor i1 %cmp11.i, true
  %lnot.ext16.i = zext i1 %cmp11.i to i32
  store i32 %lnot.ext16.i, i32* %__ret_warn_on.i, align 4
  %25 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool17.i = icmp ne i32 %25, 0
  %lnot18.i = xor i1 %tobool17.i, true
  %lnot.ext21.i = zext i1 %tobool17.i to i32
  %conv22.i = sext i32 %lnot.ext21.i to i64
  br i1 %tobool17.i, label %if.then24.i, label %if.end31.i

if.then24.i:                                      ; preds = %if.end10.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 216, i32 2307, i64 12) #13, !srcloc !10
  call void asm sideeffect "33:\0A\09.pushsection .discard.reachable\0A\09.long 33b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !11
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then24.i, %if.end10.i
  %26 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool32.i = icmp ne i32 %26, 0
  %lnot33.i = xor i1 %tobool32.i, true
  %lnot.ext36.i = zext i1 %tobool32.i to i32
  %conv37.i = sext i32 %lnot.ext36.i to i64
  store i64 %conv37.i, i64* %tmp.i, align 8
  %27 = load i64, i64* %tmp.i, align 8
  %tobool38.i = icmp ne i64 %27, 0
  br i1 %tobool38.i, label %if.then39.i, label %if.end40.i

if.then39.i:                                      ; preds = %if.end31.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end40.i:                                       ; preds = %if.end31.i
  %28 = load i8*, i8** %addr.addr.i, align 8
  %29 = load i64, i64* %bytes.addr.i, align 8
  %30 = load i8, i8* %is_source.addr.i, align 1
  %tobool41.i = trunc i8 %30 to i1
  call void @check_object_size(i8* noundef %28, i64 noundef %29, i1 noundef zeroext %tobool41.i) #16
  store i1 true, i1* %retval.i, align 1
  br label %check_copy_size.exit

check_copy_size.exit:                             ; preds = %if.end9.i, %if.then39.i, %if.end40.i
  %31 = load i1, i1* %retval.i, align 1
  %lnot.i = xor i1 %31, true
  %lnot.ext.i = zext i1 %31 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %31, label %if.then.i, label %copy_to_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit
  %32 = load i8*, i8** %to.addr.i, align 8
  %33 = load i8*, i8** %from.addr.i, align 8
  %34 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_to_user(i8* noundef %32, i8* noundef %33, i64 noundef %34) #16
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %check_copy_size.exit, %if.then.i
  %35 = load i64, i64* %n.addr.i, align 8
  %conv = trunc i64 %35 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %36 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %dst, i32 0, i32 0
  %kernel = bitcast %union.anon.169* %36 to i8**
  %37 = load i8*, i8** %kernel, align 8
  %38 = load i64, i64* %offset.addr, align 8
  %add.ptr2 = getelementptr i8, i8* %37, i64 %38
  %39 = load i8*, i8** %src.addr, align 8
  %40 = load i64, i64* %size.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %add.ptr2, i8* align 1 %39, i64 %40, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %copy_to_user.exit
  %41 = load i32, i32* %retval, align 4
  ret i32 %41
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @sockptr_is_kernel(i8* %sockptr.coerce0, i8 %sockptr.coerce1) #0 {
entry:
  %sockptr = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %sockptr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %sockptr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %sockptr.coerce1, i8* %2, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %sockptr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  ret i1 %bf.cast
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_from_bpfptr_offset(i8* noundef %dst, i8* %src.coerce0, i8 %src.coerce1, i64 noundef %offset, i64 noundef %size) #0 {
entry:
  %src = alloca %struct.sockptr_t, align 8
  %dst.addr = alloca i8*, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %agg.tmp = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %src.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %src.coerce1, i8* %2, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i8*, i8** %dst.addr, align 8
  %4 = bitcast %struct.sockptr_t* %agg.tmp to i8*
  %5 = bitcast %struct.sockptr_t* %src to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 16, i1 false)
  %6 = load i64, i64* %offset.addr, align 8
  %7 = load i64, i64* %size.addr, align 8
  %8 = bitcast %struct.sockptr_t* %agg.tmp to { i8*, i8 }*
  %9 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %8, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %8, i32 0, i32 1
  %12 = load i8, i8* %11, align 8
  %call = call i32 @copy_from_sockptr_offset(i8* noundef %3, i8* %10, i8 %12, i64 noundef %6, i64 noundef %7) #14
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_from_sockptr_offset(i8* noundef %dst, i8* %src.coerce0, i8 %src.coerce1, i64 noundef %offset, i64 noundef %size) #0 {
entry:
  %retval.i.i = alloca i1, align 1
  %addr.addr.i.i = alloca i8*, align 8
  %bytes.addr.i.i = alloca i64, align 8
  %is_source.addr.i.i = alloca i8, align 1
  %sz.i.i = alloca i32, align 4
  %__ret_warn_on.i.i = alloca i32, align 4
  %tmp.i.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %src = alloca %struct.sockptr_t, align 8
  %dst.addr = alloca i8*, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %src.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %src.coerce1, i8* %2, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = load i8, i8* %6, align 8
  %call = call zeroext i1 @sockptr_is_kernel(i8* %5, i8 %7) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load i8*, i8** %dst.addr, align 8
  %9 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %src, i32 0, i32 0
  %user = bitcast %union.anon.169* %9 to i8**
  %10 = load i8*, i8** %user, align 8
  %11 = load i64, i64* %offset.addr, align 8
  %add.ptr = getelementptr i8, i8* %10, i64 %11
  %12 = load i64, i64* %size.addr, align 8
  store i8* %8, i8** %to.addr.i, align 8
  store i8* %add.ptr, i8** %from.addr.i, align 8
  store i64 %12, i64* %n.addr.i, align 8
  %13 = load i8*, i8** %to.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  store i8* %13, i8** %addr.addr.i.i, align 8
  store i64 %14, i64* %bytes.addr.i.i, align 8
  store i8 0, i8* %is_source.addr.i.i, align 1
  store i32 -1, i32* %sz.i.i, align 4
  %15 = load i32, i32* %sz.i.i, align 4
  %cmp.i.i = icmp sge i32 %15, 0
  br i1 %cmp.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %if.then
  %16 = load i32, i32* %sz.i.i, align 4
  %conv.i.i = sext i32 %16 to i64
  %17 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp1.i.i = icmp ult i64 %conv.i.i, %17
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %if.then
  %18 = phi i1 [ false, %if.then ], [ %cmp1.i.i, %land.rhs.i.i ]
  %lnot.i.i = xor i1 %18, true
  %lnot.ext.i.i = zext i1 %18 to i32
  %conv4.i.i = sext i32 %lnot.ext.i.i to i64
  br i1 %18, label %if.then.i.i, label %if.end10.i.i

if.then.i.i:                                      ; preds = %land.end.i.i
  %19 = load i64, i64* %bytes.addr.i.i, align 8
  %20 = call i1 @llvm.is.constant.i64(i64 %19) #13
  br i1 %20, label %if.else.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.then.i.i
  %21 = load i32, i32* %sz.i.i, align 4
  %22 = load i64, i64* %bytes.addr.i.i, align 8
  call void @copy_overflow(i32 noundef %21, i64 noundef %22) #16
  br label %if.end9.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %23 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool6.i.i = trunc i8 %23 to i1
  br i1 %tobool6.i.i, label %if.then7.i.i, label %if.else8.i.i

if.then7.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_from() #16, !srcloc !8
  br label %if.end.i.i

if.else8.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_to() #16, !srcloc !9
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.else8.i.i, %if.then7.i.i
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.end.i.i, %if.then5.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end10.i.i:                                     ; preds = %land.end.i.i
  %24 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp11.i.i = icmp ugt i64 %24, 2147483647
  %lnot13.i.i = xor i1 %cmp11.i.i, true
  %lnot.ext16.i.i = zext i1 %cmp11.i.i to i32
  store i32 %lnot.ext16.i.i, i32* %__ret_warn_on.i.i, align 4
  %25 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool17.i.i = icmp ne i32 %25, 0
  %lnot18.i.i = xor i1 %tobool17.i.i, true
  %lnot.ext21.i.i = zext i1 %tobool17.i.i to i32
  %conv22.i.i = sext i32 %lnot.ext21.i.i to i64
  br i1 %tobool17.i.i, label %if.then24.i.i, label %if.end31.i.i

if.then24.i.i:                                    ; preds = %if.end10.i.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 216, i32 2307, i64 12) #13, !srcloc !10
  call void asm sideeffect "33:\0A\09.pushsection .discard.reachable\0A\09.long 33b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !11
  br label %if.end31.i.i

if.end31.i.i:                                     ; preds = %if.then24.i.i, %if.end10.i.i
  %26 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool32.i.i = icmp ne i32 %26, 0
  %lnot33.i.i = xor i1 %tobool32.i.i, true
  %lnot.ext36.i.i = zext i1 %tobool32.i.i to i32
  %conv37.i.i = sext i32 %lnot.ext36.i.i to i64
  store i64 %conv37.i.i, i64* %tmp.i.i, align 8
  %27 = load i64, i64* %tmp.i.i, align 8
  %tobool38.i.i = icmp ne i64 %27, 0
  br i1 %tobool38.i.i, label %if.then39.i.i, label %if.end40.i.i

if.then39.i.i:                                    ; preds = %if.end31.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end40.i.i:                                     ; preds = %if.end31.i.i
  %28 = load i8*, i8** %addr.addr.i.i, align 8
  %29 = load i64, i64* %bytes.addr.i.i, align 8
  %30 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool41.i.i = trunc i8 %30 to i1
  call void @check_object_size(i8* noundef %28, i64 noundef %29, i1 noundef zeroext %tobool41.i.i) #16
  store i1 true, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

check_copy_size.exit.i:                           ; preds = %if.end40.i.i, %if.then39.i.i, %if.end9.i.i
  %31 = load i1, i1* %retval.i.i, align 1
  %lnot.i = xor i1 %31, true
  %lnot.ext.i = zext i1 %31 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %31, label %if.then.i, label %copy_from_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit.i
  %32 = load i8*, i8** %to.addr.i, align 8
  %33 = load i8*, i8** %from.addr.i, align 8
  %34 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_from_user(i8* noundef %32, i8* noundef %33, i64 noundef %34) #16
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %check_copy_size.exit.i, %if.then.i
  %35 = load i64, i64* %n.addr.i, align 8
  %conv = trunc i64 %35 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %36 = load i8*, i8** %dst.addr, align 8
  %37 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %src, i32 0, i32 0
  %kernel = bitcast %union.anon.169* %37 to i8**
  %38 = load i8*, i8** %kernel, align 8
  %39 = load i64, i64* %offset.addr, align 8
  %add.ptr2 = getelementptr i8, i8* %38, i64 %39
  %40 = load i64, i64* %size.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %36, i8* align 1 %add.ptr2, i64 %40, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %copy_from_user.exit
  %41 = load i32, i32* %retval, align 4
  ret i32 %41
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_from_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 1
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpfptr_is_kernel(i8* %bpfptr.coerce0, i8 %bpfptr.coerce1) #0 {
entry:
  %bpfptr = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %bpfptr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %bpfptr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %bpfptr.coerce1, i8* %2, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %bpfptr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  ret i1 %bf.cast
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_struct_ops_btf_id(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %t = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %st_ops = alloca %struct.bpf_struct_ops*, align 8
  %member = alloca %struct.btf_member*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf_id = alloca i32, align 4
  %member_idx = alloca i32, align 4
  %mname = alloca i8*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 1
  %bf.load = load i16, i16* %gpl_compatible, align 2
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %tobool = icmp ne i16 %bf.clear, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = bitcast %struct.bpf_verifier_env* %3 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %4, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.165, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 10
  %6 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %6, i32 0, i32 10
  %7 = load i32, i32* %attach_btf_id, align 4
  store i32 %7, i32* %btf_id, align 4
  %8 = load i32, i32* %btf_id, align 4
  %call = call %struct.bpf_struct_ops* @bpf_struct_ops_find(i32 noundef %8) #14
  store %struct.bpf_struct_ops* %call, %struct.bpf_struct_ops** %st_ops, align 8
  %9 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %tobool2 = icmp ne %struct.bpf_struct_ops* %9, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i32, i32* %btf_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.166, i64 0, i64 0), i32 noundef %12) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %13 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %type = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %13, i32 0, i32 6
  %14 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  store %struct.btf_type* %14, %struct.btf_type** %t, align 8
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 3
  %16 = load i32, i32* %expected_attach_type, align 8
  store i32 %16, i32* %member_idx, align 4
  %17 = load i32, i32* %member_idx, align 4
  %18 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call5 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %18) #14
  %conv = zext i16 %call5 to i32
  %cmp = icmp uge i32 %17, %conv
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %member_idx, align 4
  %22 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %22, i32 0, i32 8
  %23 = load i8*, i8** %name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.167, i64 0, i64 0), i32 noundef %21, i8* noundef %23) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  %24 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call9 = call %struct.btf_member* @btf_type_member(%struct.btf_type* noundef %24) #14
  %25 = load i32, i32* %member_idx, align 4
  %idxprom = zext i32 %25 to i64
  %arrayidx = getelementptr %struct.btf_member, %struct.btf_member* %call9, i64 %idxprom
  store %struct.btf_member* %arrayidx, %struct.btf_member** %member, align 8
  %26 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %27 = load %struct.btf_member*, %struct.btf_member** %member, align 8
  %name_off = getelementptr inbounds %struct.btf_member, %struct.btf_member* %27, i32 0, i32 0
  %28 = load i32, i32* %name_off, align 4
  %call10 = call i8* @btf_name_by_offset(%struct.btf* noundef %26, i32 noundef %28) #14
  store i8* %call10, i8** %mname, align 8
  %29 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %30 = load %struct.btf_member*, %struct.btf_member** %member, align 8
  %type11 = getelementptr inbounds %struct.btf_member, %struct.btf_member* %30, i32 0, i32 1
  %31 = load i32, i32* %type11, align 4
  %call12 = call %struct.btf_type* @btf_type_resolve_func_ptr(%struct.btf* noundef %29, i32 noundef %31, i32* noundef null) #14
  store %struct.btf_type* %call12, %struct.btf_type** %func_proto, align 8
  %32 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool13 = icmp ne %struct.btf_type* %32, null
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %if.end8
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load i8*, i8** %mname, align 8
  %36 = load i32, i32* %member_idx, align 4
  %37 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name15 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %37, i32 0, i32 8
  %38 = load i8*, i8** %name15, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.168, i64 0, i64 0), i8* noundef %35, i32 noundef %36, i8* noundef %38) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end8
  %39 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %check_member = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %39, i32 0, i32 2
  %40 = load i32 (%struct.btf_type*, %struct.btf_member*)*, i32 (%struct.btf_type*, %struct.btf_member*)** %check_member, align 8
  %tobool17 = icmp ne i32 (%struct.btf_type*, %struct.btf_member*)* %40, null
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end16
  %41 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %check_member19 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %41, i32 0, i32 2
  %42 = load i32 (%struct.btf_type*, %struct.btf_member*)*, i32 (%struct.btf_type*, %struct.btf_member*)** %check_member19, align 8
  %43 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %44 = load %struct.btf_member*, %struct.btf_member** %member, align 8
  %call20 = call i32 %42(%struct.btf_type* noundef %43, %struct.btf_member* noundef %44) #14
  store i32 %call20, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %tobool21 = icmp ne i32 %45, 0
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.then18
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = bitcast %struct.bpf_verifier_env* %46 to i8*
  %48 = load i8*, i8** %mname, align 8
  %49 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name23 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %49, i32 0, i32 8
  %50 = load i8*, i8** %name23, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %47, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.169, i64 0, i64 0), i8* noundef %48, i8* noundef %50) #14
  %51 = load i32, i32* %err, align 4
  store i32 %51, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then18
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end16
  %52 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %53 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %53, i32 0, i32 10
  %54 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux26, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %54, i32 0, i32 28
  store %struct.btf_type* %52, %struct.btf_type** %attach_func_proto, align 8
  %55 = load i8*, i8** %mname, align 8
  %56 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux27 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %56, i32 0, i32 10
  %57 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux27, align 8
  %attach_func_name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %57, i32 0, i32 29
  store i8* %55, i8** %attach_func_name, align 8
  %58 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %verifier_ops = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %58, i32 0, i32 0
  %59 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %verifier_ops, align 8
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 3
  store %struct.bpf_verifier_ops* %59, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then22, %if.then14, %if.then7, %if.then3, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_iter_prog_supported(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_lsm_verify_prog(%struct.bpf_verifier_log* noundef %vlog, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %vlog.addr = alloca %struct.bpf_verifier_log*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_log* %vlog, %struct.bpf_verifier_log** %vlog.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  ret i32 -95
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @bpf_trampoline_compute_key(%struct.bpf_prog* noundef %tgt_prog, %struct.btf* noundef %btf, i32 noundef %btf_id) #0 {
entry:
  %retval = alloca i64, align 8
  %tgt_prog.addr = alloca %struct.bpf_prog*, align 8
  %btf.addr = alloca %struct.btf*, align 8
  %btf_id.addr = alloca i32, align 4
  store %struct.bpf_prog* %tgt_prog, %struct.bpf_prog** %tgt_prog.addr, align 8
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool = icmp ne %struct.bpf_prog* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %2, i32 0, i32 7
  %3 = load i32, i32* %id, align 8
  %conv = zext i32 %3 to i64
  %shl = shl i64 %conv, 32
  %4 = load i32, i32* %btf_id.addr, align 4
  %conv1 = zext i32 %4 to i64
  %or = or i64 %shl, %conv1
  store i64 %or, i64* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %5 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %call = call i32 @btf_obj_id(%struct.btf* noundef %5) #14
  %conv2 = zext i32 %call to i64
  %shl3 = shl i64 %conv2, 32
  %or4 = or i64 %shl3, 2147483648
  %6 = load i32, i32* %btf_id.addr, align 4
  %conv5 = zext i32 %6 to i64
  %or6 = or i64 %or4, %conv5
  store i64 %or6, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load i64, i64* %retval, align 8
  ret i64 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_trampoline* @bpf_trampoline_get(i64 noundef %key, %struct.bpf_attach_target_info* noundef %tgt_info) #0 {
entry:
  %key.addr = alloca i64, align 8
  %tgt_info.addr = alloca %struct.bpf_attach_target_info*, align 8
  store i64 %key, i64* %key.addr, align 8
  store %struct.bpf_attach_target_info* %tgt_info, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %call = call i8* @ERR_PTR(i64 noundef -95) #14
  %0 = bitcast i8* %call to %struct.bpf_trampoline*
  ret %struct.bpf_trampoline* %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_struct_ops* @bpf_struct_ops_find(i32 noundef %type_id) #0 {
entry:
  %type_id.addr = alloca i32, align 4
  store i32 %type_id, i32* %type_id.addr, align 4
  ret %struct.bpf_struct_ops* null
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %and = and i32 %1, 65535
  %conv = trunc i32 %and to i16
  ret i16 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.btf_member* @btf_type_member(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %0, i64 1
  %1 = bitcast %struct.btf_type* %add.ptr to %struct.btf_member*
  ret %struct.btf_member* %1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_resolve_func_ptr(%struct.btf* noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_obj_id(%struct.btf* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ERR_PTR(i64 noundef %error) #0 {
entry:
  %error.addr = alloca i64, align 8
  store i64 %error, i64* %error.addr, align 8
  %0 = load i64, i64* %error.addr, align 8
  %1 = inttoptr i64 %0 to i8*
  ret i8* %1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pseudo_btf_id(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %vsi = alloca %struct.btf_var_secinfo*, align 8
  %datasec = alloca %struct.btf_type*, align 8
  %btf_mod = alloca %struct.btf_mod_pair*, align 8
  %t = alloca %struct.btf_type*, align 8
  %sym_name = alloca i8*, align 8
  %percpu = alloca i8, align 1
  %type = alloca i32, align 4
  %id = alloca i32, align 4
  %btf = alloca %struct.btf*, align 8
  %datasec_id = alloca i32, align 4
  %addr = alloca i64, align 8
  %i = alloca i32, align 4
  %btf_fd = alloca i32, align 4
  %err = alloca i32, align 4
  %ret = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %tsize = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i8 0, i8* %percpu, align 1
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 3
  %1 = load i32, i32* %imm, align 4
  store i32 %1, i32* %id, align 4
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %2, i64 1
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 3
  %3 = load i32, i32* %imm1, align 4
  store i32 %3, i32* %btf_fd, align 4
  %4 = load i32, i32* %btf_fd, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %btf_fd, align 4
  %call = call %struct.btf* @btf_get_by_fd(i32 noundef %5) #14
  store %struct.btf* %call, %struct.btf** %btf, align 8
  %6 = load %struct.btf*, %struct.btf** %btf, align 8
  %7 = bitcast %struct.btf* %6 to i8*
  %call2 = call zeroext i1 @IS_ERR(i8* noundef %7) #14
  br i1 %call2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.180, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  %10 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool4 = icmp ne %struct.btf* %10, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.else
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([83 x i8], [83 x i8]* @.str.181, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.else
  %13 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  store %struct.btf* %13, %struct.btf** %btf, align 8
  %14 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_get(%struct.btf* noundef %14) #14
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = load i32, i32* %id, align 4
  %call8 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %15, i32 noundef %16) #14
  store %struct.btf_type* %call8, %struct.btf_type** %t, align 8
  %17 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %tobool9 = icmp ne %struct.btf_type* %17, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.182, i64 0, i64 0), i32 noundef %20) #14
  store i32 -2, i32* %err, align 4
  br label %err_put

if.end11:                                         ; preds = %if.end7
  %21 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call12 = call zeroext i1 @btf_type_is_var(%struct.btf_type* noundef %21) #14
  br i1 %call12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end11
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.183, i64 0, i64 0), i32 noundef %24) #14
  store i32 -22, i32* %err, align 4
  br label %err_put

if.end14:                                         ; preds = %if.end11
  %25 = load %struct.btf*, %struct.btf** %btf, align 8
  %26 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %26, i32 0, i32 0
  %27 = load i32, i32* %name_off, align 4
  %call15 = call i8* @btf_name_by_offset(%struct.btf* noundef %25, i32 noundef %27) #14
  store i8* %call15, i8** %sym_name, align 8
  %28 = load i8*, i8** %sym_name, align 8
  %call16 = call i64 @kallsyms_lookup_name(i8* noundef %28) #14
  store i64 %call16, i64* %addr, align 8
  %29 = load i64, i64* %addr, align 8
  %tobool17 = icmp ne i64 %29, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end14
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i8*, i8** %sym_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.184, i64 0, i64 0), i8* noundef %32) #14
  store i32 -2, i32* %err, align 4
  br label %err_put

if.end19:                                         ; preds = %if.end14
  %33 = load %struct.btf*, %struct.btf** %btf, align 8
  %call20 = call i32 @find_btf_percpu_datasec(%struct.btf* noundef %33) #14
  store i32 %call20, i32* %datasec_id, align 4
  %34 = load i32, i32* %datasec_id, align 4
  %cmp = icmp sgt i32 %34, 0
  br i1 %cmp, label %if.then21, label %if.end32

if.then21:                                        ; preds = %if.end19
  %35 = load %struct.btf*, %struct.btf** %btf, align 8
  %36 = load i32, i32* %datasec_id, align 4
  %call22 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %35, i32 noundef %36) #14
  store %struct.btf_type* %call22, %struct.btf_type** %datasec, align 8
  store i32 0, i32* %i, align 4
  %37 = load %struct.btf_type*, %struct.btf_type** %datasec, align 8
  %call23 = call %struct.btf_var_secinfo* @btf_type_var_secinfo(%struct.btf_type* noundef %37) #14
  store %struct.btf_var_secinfo* %call23, %struct.btf_var_secinfo** %vsi, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then21
  %38 = load i32, i32* %i, align 4
  %39 = load %struct.btf_type*, %struct.btf_type** %datasec, align 8
  %call24 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %39) #14
  %conv = zext i16 %call24 to i32
  %cmp25 = icmp slt i32 %38, %conv
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %40 = load %struct.btf_var_secinfo*, %struct.btf_var_secinfo** %vsi, align 8
  %type27 = getelementptr inbounds %struct.btf_var_secinfo, %struct.btf_var_secinfo* %40, i32 0, i32 0
  %41 = load i32, i32* %type27, align 4
  %42 = load i32, i32* %id, align 4
  %cmp28 = icmp eq i32 %41, %42
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.body
  store i8 1, i8* %percpu, align 1
  br label %for.end

if.end31:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end31
  %43 = load i32, i32* %i, align 4
  %inc = add i32 %43, 1
  store i32 %inc, i32* %i, align 4
  %44 = load %struct.btf_var_secinfo*, %struct.btf_var_secinfo** %vsi, align 8
  %incdec.ptr = getelementptr %struct.btf_var_secinfo, %struct.btf_var_secinfo* %44, i32 1
  store %struct.btf_var_secinfo* %incdec.ptr, %struct.btf_var_secinfo** %vsi, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then30, %for.cond
  br label %if.end32

if.end32:                                         ; preds = %for.end, %if.end19
  %45 = load i64, i64* %addr, align 8
  %conv33 = trunc i64 %45 to i32
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx34 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %46, i64 0
  %imm35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx34, i32 0, i32 3
  store i32 %conv33, i32* %imm35, align 4
  %47 = load i64, i64* %addr, align 8
  %shr = lshr i64 %47, 32
  %conv36 = trunc i64 %shr to i32
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx37 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %48, i64 1
  %imm38 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx37, i32 0, i32 3
  store i32 %conv36, i32* %imm38, align 4
  %49 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %50 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %49, i32 0, i32 2
  %type39 = bitcast %union.anon.123* %50 to i32*
  %51 = load i32, i32* %type39, align 4
  store i32 %51, i32* %type, align 4
  %52 = load %struct.btf*, %struct.btf** %btf, align 8
  %53 = load i32, i32* %type, align 4
  %call40 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %52, i32 noundef %53, i32* noundef null) #14
  store %struct.btf_type* %call40, %struct.btf_type** %t, align 8
  %54 = load i8, i8* %percpu, align 1
  %tobool41 = trunc i8 %54 to i1
  br i1 %tobool41, label %if.then42, label %if.else46

if.then42:                                        ; preds = %if.end32
  %55 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %56 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %55, i32 0, i32 0
  %btf_var = bitcast %union.anon.163* %56 to %struct.anon.165*
  %reg_type = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var, i32 0, i32 0
  store i32 27, i32* %reg_type, align 8
  %57 = load %struct.btf*, %struct.btf** %btf, align 8
  %58 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %59 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %58, i32 0, i32 0
  %btf_var43 = bitcast %union.anon.163* %59 to %struct.anon.165*
  %60 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var43, i32 0, i32 1
  %61 = bitcast %union.anon.166* %60 to %struct.anon.167*
  %btf44 = getelementptr inbounds %struct.anon.167, %struct.anon.167* %61, i32 0, i32 0
  store %struct.btf* %57, %struct.btf** %btf44, align 8
  %62 = load i32, i32* %type, align 4
  %63 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %64 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %63, i32 0, i32 0
  %btf_var45 = bitcast %union.anon.163* %64 to %struct.anon.165*
  %65 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var45, i32 0, i32 1
  %66 = bitcast %union.anon.166* %65 to %struct.anon.167*
  %btf_id = getelementptr inbounds %struct.anon.167, %struct.anon.167* %66, i32 0, i32 1
  store i32 %62, i32* %btf_id, align 8
  br label %if.end67

if.else46:                                        ; preds = %if.end32
  %67 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call47 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %67) #14
  br i1 %call47, label %if.else59, label %if.then48

if.then48:                                        ; preds = %if.else46
  %68 = load %struct.btf*, %struct.btf** %btf, align 8
  %69 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call49 = call %struct.btf_type* @btf_resolve_size(%struct.btf* noundef %68, %struct.btf_type* noundef %69, i32* noundef %tsize) #14
  store %struct.btf_type* %call49, %struct.btf_type** %ret, align 8
  %70 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %71 = bitcast %struct.btf_type* %70 to i8*
  %call50 = call zeroext i1 @IS_ERR(i8* noundef %71) #14
  br i1 %call50, label %if.then51, label %if.end55

if.then51:                                        ; preds = %if.then48
  %72 = load %struct.btf*, %struct.btf** %btf, align 8
  %73 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off52 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %73, i32 0, i32 0
  %74 = load i32, i32* %name_off52, align 4
  %call53 = call i8* @btf_name_by_offset(%struct.btf* noundef %72, i32 noundef %74) #14
  store i8* %call53, i8** %tname, align 8
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load i8*, i8** %tname, align 8
  %78 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %79 = bitcast %struct.btf_type* %78 to i8*
  %call54 = call i64 @PTR_ERR(i8* noundef %79) #14
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.185, i64 0, i64 0), i8* noundef %77, i64 noundef %call54) #14
  store i32 -22, i32* %err, align 4
  br label %err_put

if.end55:                                         ; preds = %if.then48
  %80 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %81 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %80, i32 0, i32 0
  %btf_var56 = bitcast %union.anon.163* %81 to %struct.anon.165*
  %reg_type57 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var56, i32 0, i32 0
  store i32 21, i32* %reg_type57, align 8
  %82 = load i32, i32* %tsize, align 4
  %83 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %84 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %83, i32 0, i32 0
  %btf_var58 = bitcast %union.anon.163* %84 to %struct.anon.165*
  %85 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var58, i32 0, i32 1
  %mem_size = bitcast %union.anon.166* %85 to i32*
  store i32 %82, i32* %mem_size, align 8
  br label %if.end66

if.else59:                                        ; preds = %if.else46
  %86 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %87 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %86, i32 0, i32 0
  %btf_var60 = bitcast %union.anon.163* %87 to %struct.anon.165*
  %reg_type61 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var60, i32 0, i32 0
  store i32 19, i32* %reg_type61, align 8
  %88 = load %struct.btf*, %struct.btf** %btf, align 8
  %89 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %90 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %89, i32 0, i32 0
  %btf_var62 = bitcast %union.anon.163* %90 to %struct.anon.165*
  %91 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var62, i32 0, i32 1
  %92 = bitcast %union.anon.166* %91 to %struct.anon.167*
  %btf63 = getelementptr inbounds %struct.anon.167, %struct.anon.167* %92, i32 0, i32 0
  store %struct.btf* %88, %struct.btf** %btf63, align 8
  %93 = load i32, i32* %type, align 4
  %94 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %95 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %94, i32 0, i32 0
  %btf_var64 = bitcast %union.anon.163* %95 to %struct.anon.165*
  %96 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var64, i32 0, i32 1
  %97 = bitcast %union.anon.166* %96 to %struct.anon.167*
  %btf_id65 = getelementptr inbounds %struct.anon.167, %struct.anon.167* %97, i32 0, i32 1
  store i32 %93, i32* %btf_id65, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.else59, %if.end55
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %if.then42
  store i32 0, i32* %i, align 4
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc78, %if.end67
  %98 = load i32, i32* %i, align 4
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 14
  %100 = load i32, i32* %used_btf_cnt, align 4
  %cmp69 = icmp ult i32 %98, %100
  br i1 %cmp69, label %for.body71, label %for.end80

for.body71:                                       ; preds = %for.cond68
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btfs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 12
  %102 = load i32, i32* %i, align 4
  %idxprom = sext i32 %102 to i64
  %arrayidx72 = getelementptr [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs, i64 0, i64 %idxprom
  %btf73 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %arrayidx72, i32 0, i32 0
  %103 = load %struct.btf*, %struct.btf** %btf73, align 8
  %104 = load %struct.btf*, %struct.btf** %btf, align 8
  %cmp74 = icmp eq %struct.btf* %103, %104
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %for.body71
  %105 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %105) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %for.body71
  br label %for.inc78

for.inc78:                                        ; preds = %if.end77
  %106 = load i32, i32* %i, align 4
  %inc79 = add i32 %106, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond68

for.end80:                                        ; preds = %for.cond68
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %107, i32 0, i32 14
  %108 = load i32, i32* %used_btf_cnt81, align 4
  %cmp82 = icmp uge i32 %108, 64
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %for.end80
  store i32 -7, i32* %err, align 4
  br label %err_put

if.end85:                                         ; preds = %for.end80
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btfs86 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 12
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %110, i32 0, i32 14
  %111 = load i32, i32* %used_btf_cnt87, align 4
  %idxprom88 = zext i32 %111 to i64
  %arrayidx89 = getelementptr [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs86, i64 0, i64 %idxprom88
  store %struct.btf_mod_pair* %arrayidx89, %struct.btf_mod_pair** %btf_mod, align 8
  %112 = load %struct.btf*, %struct.btf** %btf, align 8
  %113 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %btf90 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %113, i32 0, i32 0
  store %struct.btf* %112, %struct.btf** %btf90, align 8
  %114 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %module = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %114, i32 0, i32 1
  store %struct.module* null, %struct.module** %module, align 8
  %115 = load %struct.btf*, %struct.btf** %btf, align 8
  %call91 = call zeroext i1 @btf_is_module(%struct.btf* noundef %115) #14
  br i1 %call91, label %if.then92, label %if.end99

if.then92:                                        ; preds = %if.end85
  %116 = load %struct.btf*, %struct.btf** %btf, align 8
  %call93 = call %struct.module* @btf_try_get_module(%struct.btf* noundef %116) #14
  %117 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %module94 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %117, i32 0, i32 1
  store %struct.module* %call93, %struct.module** %module94, align 8
  %118 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %module95 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %118, i32 0, i32 1
  %119 = load %struct.module*, %struct.module** %module95, align 8
  %tobool96 = icmp ne %struct.module* %119, null
  br i1 %tobool96, label %if.end98, label %if.then97

if.then97:                                        ; preds = %if.then92
  store i32 -6, i32* %err, align 4
  br label %err_put

if.end98:                                         ; preds = %if.then92
  br label %if.end99

if.end99:                                         ; preds = %if.end98, %if.end85
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt100 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %120, i32 0, i32 14
  %121 = load i32, i32* %used_btf_cnt100, align 4
  %inc101 = add i32 %121, 1
  store i32 %inc101, i32* %used_btf_cnt100, align 4
  store i32 0, i32* %retval, align 4
  br label %return

err_put:                                          ; preds = %if.then97, %if.then84, %if.then51, %if.then18, %if.then13, %if.then10
  %122 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %122) #14
  %123 = load i32, i32* %err, align 4
  store i32 %123, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_put, %if.end99, %if.then76, %if.then5, %if.then3
  %124 = load i32, i32* %retval, align 4
  ret i32 %124
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpfptr_is_null(i8* %bpfptr.coerce0, i8 %bpfptr.coerce1) #0 {
entry:
  %retval = alloca i1, align 1
  %bpfptr = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %bpfptr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %bpfptr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %bpfptr.coerce1, i8* %2, align 8
  %3 = bitcast %struct.sockptr_t* %bpfptr to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = load i8, i8* %6, align 8
  %call = call zeroext i1 @bpfptr_is_kernel(i8* %5, i8 %7) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %bpfptr, i32 0, i32 0
  %kernel = bitcast %union.anon.169* %8 to i8**
  %9 = load i8*, i8** %kernel, align 8
  %tobool = icmp ne i8* %9, null
  %lnot = xor i1 %tobool, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %bpfptr, i32 0, i32 0
  %user = bitcast %union.anon.169* %10 to i8**
  %11 = load i8*, i8** %user, align 8
  %tobool1 = icmp ne i8* %11, null
  %lnot2 = xor i1 %tobool1, true
  store i1 %lnot2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @fdget(i32 noundef %fd) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %call = call i64 @__fdget(i32 noundef %0) #14
  %call1 = call { %struct.file*, i32 } @__to_fd(i64 noundef %call) #14
  %1 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 0
  %3 = extractvalue { %struct.file*, i32 } %call1, 0
  store %struct.file* %3, %struct.file** %2, align 8
  %4 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 1
  %5 = extractvalue { %struct.file*, i32 } %call1, 1
  store i32 %5, i32* %4, align 8
  %6 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %7 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %6, align 8
  ret { %struct.file*, i32 } %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_map* @__bpf_map_get(%struct.file*, i32) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %prog_type = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp37 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %0) #14
  store i32 %call, i32* %prog_type, align 4
  %1 = load i32, i32* %prog_type, align 4
  %call1 = call zeroext i1 @is_tracing_prog_type(i32 noundef %1) #14
  br i1 %call1, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call2 = call zeroext i1 @is_preallocated_map(%struct.bpf_map* noundef %2) #14
  br i1 %call2, label %if.end44, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = load i32, i32* %prog_type, align 4
  %cmp = icmp eq i32 %3, 7
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.187, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i8 1, i8* %__ret_do_once, align 1
  %6 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %7 = load i8, i8* @check_map_prog_compatibility.__already_done, align 1
  %tobool4 = trunc i8 %7 to i1
  %lnot = xor i1 %tobool4, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %8 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %lnot5 = xor i1 %8, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool7 = icmp ne i64 %conv, 0
  br i1 %tobool7, label %if.then8, label %if.end36

if.then8:                                         ; preds = %land.end
  store i8 1, i8* @check_map_prog_compatibility.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %9, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %tobool15 = icmp ne i64 %conv14, 0
  br i1 %tobool15, label %if.then16, label %if.end29

if.then16:                                        ; preds = %if.then8
  br label %do.body

do.body:                                          ; preds = %if.then16
  br label %do.body17

do.body17:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body17
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.188, i64 0, i64 0)) #14
  br label %do.body18

do.body18:                                        ; preds = %do.end
  br label %do.body19

do.body19:                                        ; preds = %do.body18
  br label %do.end20

do.end20:                                         ; preds = %do.body19
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 13361, i32 2313, i64 12) #13, !srcloc !27
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  call void asm sideeffect "551:\0A\09.pushsection .discard.reachable\0A\09.long 551b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !28
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %do.body26

do.body26:                                        ; preds = %do.end25
  br label %do.end27

do.end27:                                         ; preds = %do.body26
  br label %do.end28

do.end28:                                         ; preds = %do.end27
  br label %if.end29

if.end29:                                         ; preds = %do.end28, %if.then8
  %10 = load i32, i32* %__ret_warn_on, align 4
  %tobool30 = icmp ne i32 %10, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  store i64 %conv35, i64* %tmp, align 8
  %11 = load i64, i64* %tmp, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end29, %land.end
  %12 = load i8, i8* %__ret_do_once, align 1
  %tobool38 = trunc i8 %12 to i1
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  store i64 %conv43, i64* %tmp37, align 8
  %13 = load i64, i64* %tmp37, align 8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([101 x i8], [101 x i8]* @.str.189, i64 0, i64 0)) #14
  br label %if.end44

if.end44:                                         ; preds = %if.end36, %land.lhs.true, %entry
  %16 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call45 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %16) #14
  br i1 %call45, label %if.then46, label %if.end57

if.then46:                                        ; preds = %if.end44
  %17 = load i32, i32* %prog_type, align 4
  %cmp47 = icmp eq i32 %17, 1
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.then46
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.190, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end50:                                         ; preds = %if.then46
  %20 = load i32, i32* %prog_type, align 4
  %call51 = call zeroext i1 @is_tracing_prog_type(i32 noundef %20) #14
  br i1 %call51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end50
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.191, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.end50
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 10
  %24 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %24, i32 0, i32 25
  %25 = load i8, i8* %sleepable, align 4
  %tobool54 = trunc i8 %25 to i1
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end53
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.192, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end53
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %if.end44
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux58 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 10
  %29 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux58, align 8
  %call59 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %29) #14
  br i1 %call59, label %land.lhs.true63, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end57
  %30 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call61 = call zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %30) #14
  br i1 %call61, label %land.lhs.true63, label %if.end66

land.lhs.true63:                                  ; preds = %lor.lhs.false, %if.end57
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %32 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call64 = call zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef %31, %struct.bpf_map* noundef %32) #14
  br i1 %call64, label %if.end66, label %if.then65

if.then65:                                        ; preds = %land.lhs.true63
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.193, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %land.lhs.true63, %lor.lhs.false
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %35, i32 0, i32 3
  %36 = load i32, i32* %map_type, align 8
  %cmp67 = icmp eq i32 %36, 26
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end66
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.194, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.end66
  %39 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux71 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %39, i32 0, i32 10
  %40 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux71, align 8
  %sleepable72 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %40, i32 0, i32 25
  %41 = load i8, i8* %sleepable72, align 4
  %tobool73 = trunc i8 %41 to i1
  br i1 %tobool73, label %if.then74, label %if.end80

if.then74:                                        ; preds = %if.end70
  %42 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type75 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %42, i32 0, i32 3
  %43 = load i32, i32* %map_type75, align 8
  switch i32 %43, label %sw.default [
    i32 1, label %sw.bb
    i32 9, label %sw.bb
    i32 2, label %sw.bb
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 10, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 27, label %sw.bb79
  ]

sw.bb:                                            ; preds = %if.then74, %if.then74, %if.then74, %if.then74, %if.then74, %if.then74, %if.then74, %if.then74
  %44 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call76 = call zeroext i1 @is_preallocated_map(%struct.bpf_map* noundef %44) #14
  br i1 %call76, label %if.end78, label %if.then77

if.then77:                                        ; preds = %sw.bb
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = bitcast %struct.bpf_verifier_env* %45 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %46, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.195, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end78:                                         ; preds = %sw.bb
  br label %sw.epilog

sw.bb79:                                          ; preds = %if.then74
  br label %sw.epilog

sw.default:                                       ; preds = %if.then74
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.196, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb79, %if.end78
  br label %if.end80

if.end80:                                         ; preds = %sw.epilog, %if.end70
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end80, %sw.default, %if.then77, %if.then69, %if.then65, %if.then55, %if.then52, %if.then49, %if.then3
  %49 = load i32, i32* %retval, align 4
  ret i32 %49
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @fdput(%struct.file* %fd.coerce0, i32 %fd.coerce1) #0 {
entry:
  %fd = alloca %struct.fd, align 8
  %0 = bitcast %struct.fd* %fd to { %struct.file*, i32 }*
  %1 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 0
  store %struct.file* %fd.coerce0, %struct.file** %1, align 8
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 1
  store i32 %fd.coerce1, i32* %2, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 1
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %file = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 0
  %4 = load %struct.file*, %struct.file** %file, align 8
  call void @fput(%struct.file* noundef %4) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_map_inc(%struct.bpf_map* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp eq i32 %1, 19
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp eq i32 %3, 21
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_cgroup_storage_assign(%struct.bpf_prog_aux* noundef %aux, %struct.bpf_map* noundef %map) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  ret i32 0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @btf_get(%struct.btf* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_var(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 14
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @find_btf_percpu_datasec(%struct.btf* noundef %btf) #0 {
entry:
  %retval = alloca i32, align 4
  %btf.addr = alloca %struct.btf*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  %0 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %call = call i32 @btf_nr_types(%struct.btf* noundef %0) #14
  store i32 %call, i32* %n, align 4
  %1 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %call1 = call zeroext i1 @btf_is_module(%struct.btf* noundef %1) #14
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %call2 = call i32 @btf_nr_types(%struct.btf* noundef %2) #14
  store i32 %call2, i32* %i, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 1, i32* %i, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %6 = load i32, i32* %i, align 4
  %call3 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %5, i32 noundef %6) #14
  store %struct.btf_type* %call3, %struct.btf_type** %t, align 8
  %7 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %7, i32 0, i32 1
  %8 = load i32, i32* %info, align 4
  %shr = lshr i32 %8, 24
  %and = and i32 %shr, 31
  %cmp4 = icmp ne i32 %and, 15
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %for.body
  br label %for.inc

if.end6:                                          ; preds = %for.body
  %9 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %10 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %10, i32 0, i32 0
  %11 = load i32, i32* %name_off, align 4
  %call7 = call i8* @btf_name_by_offset(%struct.btf* noundef %9, i32 noundef %11) #14
  store i8* %call7, i8** %tname, align 8
  %12 = load i8*, i8** %tname, align 8
  %call8 = call i32 @strcmp(i8* noundef %12, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.186, i64 0, i64 0)) #14
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  %13 = load i32, i32* %i, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  br label %for.inc

for.inc:                                          ; preds = %if.end10, %if.then5
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then9
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.btf_var_secinfo* @btf_type_var_secinfo(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %0, i64 1
  %1 = bitcast %struct.btf_type* %add.ptr to %struct.btf_var_secinfo*
  ret %struct.btf_var_secinfo* %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  %kind = alloca i8, align 1
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %kind, align 1
  %2 = load i8, i8* %kind, align 1
  %conv1 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv1, 4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load i8, i8* %kind, align 1
  %conv3 = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 5
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_resolve_size(%struct.btf* noundef, %struct.btf_type* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_is_module(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.module* @btf_try_get_module(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_nr_types(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @strcmp(i8* noundef, i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @__to_fd(i64 noundef %v) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %v.addr = alloca i64, align 8
  store i64 %v, i64* %v.addr, align 8
  %file = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 0
  %0 = load i64, i64* %v.addr, align 8
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to %struct.file*
  store %struct.file* %1, %struct.file** %file, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 1
  %2 = load i64, i64* %v.addr, align 8
  %and1 = and i64 %2, 3
  %conv = trunc i64 %and1 to i32
  store i32 %conv, i32* %flags, align 8
  %3 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %4 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %3, align 8
  ret { %struct.file*, i32 } %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__fdget(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_prog_type(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %dst_prog = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 17
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog, align 8
  %tobool = icmp ne %struct.bpf_prog* %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  %dst_prog2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 17
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog2, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 2
  %6 = load i32, i32* %type, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 2
  %8 = load i32, i32* %type3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %6, %cond.true ], [ %8, %cond.false ]
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_tracing_prog_type(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 5, label %sw.bb
    i32 7, label %sw.bb
    i32 17, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_preallocated_map(%struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i1, align 1
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call = call i32 @check_map_prealloc(%struct.bpf_map* noundef %0) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 1
  %2 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool1 = icmp ne %struct.bpf_map* %2, null
  br i1 %tobool1, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %inner_map_meta2 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %3, i32 0, i32 1
  %4 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta2, align 8
  %call3 = call i32 @check_map_prealloc(%struct.bpf_map* noundef %4) #14
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %if.end
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %5 = load i1, i1* %retval, align 1
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %cmp = icmp eq %struct.bpf_map_ops* %1, @bpf_map_offload_ops
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef, %struct.bpf_map* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prealloc(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp ne i32 %3, 5
  br i1 %cmp2, label %land.lhs.true3, label %lor.rhs

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type4 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %4, i32 0, i32 3
  %5 = load i32, i32* %map_type4, align 8
  %cmp5 = icmp ne i32 %5, 13
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %6, i32 0, i32 7
  %7 = load i32, i32* %map_flags, align 8
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true3
  %8 = phi i1 [ true, %land.lhs.true3 ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %8 to i32
  ret i32 %lor.ext
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @fput(%struct.file* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @visit_insn(i32 noundef %t, i32 noundef %insn_cnt, %struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %insn_cnt.addr = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %ret = alloca i32, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %insn_cnt, i32* %insn_cnt.addr, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %3 = load i32, i32* %t.addr, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %2, i64 %idx.ext
  %call = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %add.ptr) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %t.addr, align 4
  %5 = load i32, i32* %insn_cnt.addr, align 4
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call1 = call i32 @visit_func_call_insn(i32 noundef %4, i32 noundef %5, %struct.bpf_insn* noundef %6, %struct.bpf_verifier_env* noundef %7, i1 noundef zeroext true) #14
  store i32 %call1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %9 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %8, i64 %idxprom
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %10 = load i8, i8* %code, align 4
  %conv = zext i8 %10 to i32
  %and = and i32 %conv, 7
  %cmp = icmp ne i32 %and, 5
  br i1 %cmp, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %12 = load i32, i32* %t.addr, align 4
  %idxprom3 = sext i32 %12 to i64
  %arrayidx4 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %11, i64 %idxprom3
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx4, i32 0, i32 0
  %13 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %13 to i32
  %and7 = and i32 %conv6, 7
  %cmp8 = icmp ne i32 %and7, 6
  br i1 %cmp8, label %if.then10, label %if.end12

if.then10:                                        ; preds = %land.lhs.true
  %14 = load i32, i32* %t.addr, align 4
  %15 = load i32, i32* %t.addr, align 4
  %add = add i32 %15, 1
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call11 = call i32 @push_insn(i32 noundef %14, i32 noundef %add, i32 noundef 1, %struct.bpf_verifier_env* noundef %16, i1 noundef zeroext false) #14
  store i32 %call11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %land.lhs.true, %if.end
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %18 = load i32, i32* %t.addr, align 4
  %idxprom13 = sext i32 %18 to i64
  %arrayidx14 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %17, i64 %idxprom13
  %code15 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx14, i32 0, i32 0
  %19 = load i8, i8* %code15, align 4
  %conv16 = zext i8 %19 to i32
  %and17 = and i32 %conv16, 240
  switch i32 %and17, label %sw.default [
    i32 144, label %sw.bb
    i32 128, label %sw.bb18
    i32 0, label %sw.bb31
  ]

sw.bb:                                            ; preds = %if.end12
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb18:                                          ; preds = %if.end12
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %21 = load i32, i32* %t.addr, align 4
  %idxprom19 = sext i32 %21 to i64
  %arrayidx20 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %20, i64 %idxprom19
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx20, i32 0, i32 3
  %22 = load i32, i32* %imm, align 4
  %cmp21 = icmp eq i32 %22, 170
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %sw.bb18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load i32, i32* %t.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %23, i32 noundef %24) #14
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %sw.bb18
  %25 = load i32, i32* %t.addr, align 4
  %26 = load i32, i32* %insn_cnt.addr, align 4
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %30 = load i32, i32* %t.addr, align 4
  %idxprom25 = sext i32 %30 to i64
  %arrayidx26 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %29, i64 %idxprom25
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx26, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv27 = zext i8 %bf.lshr to i32
  %cmp28 = icmp eq i32 %conv27, 1
  %call30 = call i32 @visit_func_call_insn(i32 noundef %25, i32 noundef %26, %struct.bpf_insn* noundef %27, %struct.bpf_verifier_env* noundef %28, i1 noundef zeroext %cmp28) #14
  store i32 %call30, i32* %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %if.end12
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %32 = load i32, i32* %t.addr, align 4
  %idxprom32 = sext i32 %32 to i64
  %arrayidx33 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %31, i64 %idxprom32
  %code34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx33, i32 0, i32 0
  %33 = load i8, i8* %code34, align 4
  %conv35 = zext i8 %33 to i32
  %and36 = and i32 %conv35, 8
  %cmp37 = icmp ne i32 %and36, 0
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %sw.bb31
  store i32 -22, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %sw.bb31
  %34 = load i32, i32* %t.addr, align 4
  %35 = load i32, i32* %t.addr, align 4
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %37 = load i32, i32* %t.addr, align 4
  %idxprom41 = sext i32 %37 to i64
  %arrayidx42 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %36, i64 %idxprom41
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx42, i32 0, i32 2
  %38 = load i16, i16* %off, align 2
  %conv43 = sext i16 %38 to i32
  %add44 = add i32 %35, %conv43
  %add45 = add i32 %add44, 1
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call46 = call i32 @push_insn(i32 noundef %34, i32 noundef %add45, i32 noundef 1, %struct.bpf_verifier_env* noundef %39, i1 noundef zeroext true) #14
  store i32 %call46, i32* %ret, align 4
  %40 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %40, 0
  br i1 %tobool, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end40
  %41 = load i32, i32* %ret, align 4
  store i32 %41, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end40
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = load i32, i32* %t.addr, align 4
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %45 = load i32, i32* %t.addr, align 4
  %idxprom49 = sext i32 %45 to i64
  %arrayidx50 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %44, i64 %idxprom49
  %off51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx50, i32 0, i32 2
  %46 = load i16, i16* %off51, align 2
  %conv52 = sext i16 %46 to i32
  %add53 = add i32 %43, %conv52
  %add54 = add i32 %add53, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %42, i32 noundef %add54) #14
  %47 = load i32, i32* %t.addr, align 4
  %add55 = add i32 %47, 1
  %48 = load i32, i32* %insn_cnt.addr, align 4
  %cmp56 = icmp slt i32 %add55, %48
  br i1 %cmp56, label %if.then58, label %if.end60

if.then58:                                        ; preds = %if.end48
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load i32, i32* %t.addr, align 4
  %add59 = add i32 %50, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %49, i32 noundef %add59) #14
  br label %if.end60

if.end60:                                         ; preds = %if.then58, %if.end48
  %51 = load i32, i32* %ret, align 4
  store i32 %51, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end12
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %t.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %52, i32 noundef %53) #14
  %54 = load i32, i32* %t.addr, align 4
  %55 = load i32, i32* %t.addr, align 4
  %add61 = add i32 %55, 1
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call62 = call i32 @push_insn(i32 noundef %54, i32 noundef %add61, i32 noundef 1, %struct.bpf_verifier_env* noundef %56, i1 noundef zeroext true) #14
  store i32 %call62, i32* %ret, align 4
  %57 = load i32, i32* %ret, align 4
  %tobool63 = icmp ne i32 %57, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %sw.default
  %58 = load i32, i32* %ret, align 4
  store i32 %58, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %sw.default
  %59 = load i32, i32* %t.addr, align 4
  %60 = load i32, i32* %t.addr, align 4
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %62 = load i32, i32* %t.addr, align 4
  %idxprom66 = sext i32 %62 to i64
  %arrayidx67 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %61, i64 %idxprom66
  %off68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx67, i32 0, i32 2
  %63 = load i16, i16* %off68, align 2
  %conv69 = sext i16 %63 to i32
  %add70 = add i32 %60, %conv69
  %add71 = add i32 %add70, 1
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call72 = call i32 @push_insn(i32 noundef %59, i32 noundef %add71, i32 noundef 2, %struct.bpf_verifier_env* noundef %64, i1 noundef zeroext true) #14
  store i32 %call72, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end65, %if.then64, %if.end60, %if.then47, %if.then39, %if.end24, %sw.bb, %if.then10, %if.then
  %65 = load i32, i32* %retval, align 4
  ret i32 %65
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @visit_func_call_insn(i32 noundef %t, i32 noundef %insn_cnt, %struct.bpf_insn* noundef %insns, %struct.bpf_verifier_env* noundef %env, i1 noundef zeroext %visit_callee) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %insn_cnt.addr = alloca i32, align 4
  %insns.addr = alloca %struct.bpf_insn*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %visit_callee.addr = alloca i8, align 1
  %ret = alloca i32, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %insn_cnt, i32* %insn_cnt.addr, align 4
  store %struct.bpf_insn* %insns, %struct.bpf_insn** %insns.addr, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %frombool = zext i1 %visit_callee to i8
  store i8 %frombool, i8* %visit_callee.addr, align 1
  %0 = load i32, i32* %t.addr, align 4
  %1 = load i32, i32* %t.addr, align 4
  %add = add i32 %1, 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @push_insn(i32 noundef %0, i32 noundef %add, i32 noundef 1, %struct.bpf_verifier_env* noundef %2, i1 noundef zeroext false) #14
  store i32 %call, i32* %ret, align 4
  %3 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %ret, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %t.addr, align 4
  %add1 = add i32 %5, 1
  %6 = load i32, i32* %insn_cnt.addr, align 4
  %cmp = icmp slt i32 %add1, %6
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = load i32, i32* %t.addr, align 4
  %add3 = add i32 %8, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %7, i32 noundef %add3) #14
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %9 = load i8, i8* %visit_callee.addr, align 1
  %tobool5 = trunc i8 %9 to i1
  br i1 %tobool5, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load i32, i32* %t.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %10, i32 noundef %11) #14
  %12 = load i32, i32* %t.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insns.addr, align 8
  %15 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %14, i64 %idxprom
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %add7 = add i32 %13, %16
  %add8 = add i32 %add7, 1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insns.addr, align 8
  %19 = load i32, i32* %t.addr, align 4
  %idx.ext = sext i32 %19 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %18, i64 %idx.ext
  %call9 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %add.ptr) #14
  %call10 = call i32 @push_insn(i32 noundef %12, i32 noundef %add8, i32 noundef 2, %struct.bpf_verifier_env* noundef %17, i1 noundef zeroext %call9) #14
  store i32 %call10, i32* %ret, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then6, %if.end4
  %20 = load i32, i32* %ret, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_insn(i32 noundef %t, i32 noundef %w, i32 noundef %e, %struct.bpf_verifier_env* noundef %env, i1 noundef zeroext %loop_ok) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %e.addr = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %loop_ok.addr = alloca i8, align 1
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  store i32 %t, i32* %t.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %e, i32* %e.addr, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %frombool = zext i1 %loop_ok to i8
  store i8 %frombool, i8* %loop_ok.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 29
  %insn_stack1 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg, i32 0, i32 1
  %1 = load i32*, i32** %insn_stack1, align 8
  store i32* %1, i32** %insn_stack, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 29
  %insn_state3 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg2, i32 0, i32 0
  %3 = load i32*, i32** %insn_state3, align 8
  store i32* %3, i32** %insn_state, align 8
  %4 = load i32, i32* %e.addr, align 4
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32*, i32** %insn_state, align 8
  %6 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr i32, i32* %5, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4
  %cmp4 = icmp sge i32 %7, 17
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %8 = load i32, i32* %e.addr, align 4
  %cmp5 = icmp eq i32 %8, 2
  br i1 %cmp5, label %land.lhs.true6, label %if.end11

land.lhs.true6:                                   ; preds = %if.end
  %9 = load i32*, i32** %insn_state, align 8
  %10 = load i32, i32* %t.addr, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr i32, i32* %9, i64 %idxprom7
  %11 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp sge i32 %11, 18
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true6
  store i32 0, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true6, %if.end
  %12 = load i32, i32* %w.addr, align 4
  %cmp12 = icmp slt i32 %12, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %13 = load i32, i32* %w.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 4
  %16 = load i32, i32* %len, align 4
  %cmp13 = icmp uge i32 %13, %16
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false, %if.end11
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %t.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.200, i64 0, i64 0), i32 noundef %19) #14
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %t.addr, align 4
  %23 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.144, i64 0, i64 0), i32 noundef %22, i32 noundef %23) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %lor.lhs.false
  %24 = load i32, i32* %e.addr, align 4
  %cmp16 = icmp eq i32 %24, 2
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %w.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #14
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  %27 = load i32*, i32** %insn_state, align 8
  %28 = load i32, i32* %w.addr, align 4
  %idxprom19 = sext i32 %28 to i64
  %arrayidx20 = getelementptr i32, i32* %27, i64 %idxprom19
  %29 = load i32, i32* %arrayidx20, align 4
  %cmp21 = icmp eq i32 %29, 0
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end18
  %30 = load i32, i32* %e.addr, align 4
  %or = or i32 16, %30
  %31 = load i32*, i32** %insn_state, align 8
  %32 = load i32, i32* %t.addr, align 4
  %idxprom23 = sext i32 %32 to i64
  %arrayidx24 = getelementptr i32, i32* %31, i64 %idxprom23
  store i32 %or, i32* %arrayidx24, align 4
  %33 = load i32*, i32** %insn_state, align 8
  %34 = load i32, i32* %w.addr, align 4
  %idxprom25 = sext i32 %34 to i64
  %arrayidx26 = getelementptr i32, i32* %33, i64 %idxprom25
  store i32 16, i32* %arrayidx26, align 4
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 29
  %cur_stack = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg27, i32 0, i32 2
  %36 = load i32, i32* %cur_stack, align 8
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 2
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog28, align 8
  %len29 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %38, i32 0, i32 4
  %39 = load i32, i32* %len29, align 4
  %cmp30 = icmp uge i32 %36, %39
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then22
  store i32 -7, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then22
  %40 = load i32, i32* %w.addr, align 4
  %41 = load i32*, i32** %insn_stack, align 8
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg33 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 29
  %cur_stack34 = getelementptr inbounds %struct.anon.168, %struct.anon.168* %cfg33, i32 0, i32 2
  %43 = load i32, i32* %cur_stack34, align 8
  %inc = add i32 %43, 1
  store i32 %inc, i32* %cur_stack34, align 8
  %idxprom35 = sext i32 %43 to i64
  %arrayidx36 = getelementptr i32, i32* %41, i64 %idxprom35
  store i32 %40, i32* %arrayidx36, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end18
  %44 = load i32*, i32** %insn_state, align 8
  %45 = load i32, i32* %w.addr, align 4
  %idxprom37 = sext i32 %45 to i64
  %arrayidx38 = getelementptr i32, i32* %44, i64 %idxprom37
  %46 = load i32, i32* %arrayidx38, align 4
  %and = and i32 %46, 240
  %cmp39 = icmp eq i32 %and, 16
  br i1 %cmp39, label %if.then40, label %if.else45

if.then40:                                        ; preds = %if.else
  %47 = load i8, i8* %loop_ok.addr, align 1
  %tobool = trunc i8 %47 to i1
  br i1 %tobool, label %land.lhs.true41, label %if.end44

land.lhs.true41:                                  ; preds = %if.then40
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 20
  %49 = load i8, i8* %bpf_capable, align 8
  %tobool42 = trunc i8 %49 to i1
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true41
  store i32 0, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %land.lhs.true41, %if.then40
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load i32, i32* %t.addr, align 4
  %52 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %50, i32 noundef %51, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.200, i64 0, i64 0), i32 noundef %52) #14
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load i32, i32* %w.addr, align 4
  %55 = load i32, i32* %w.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %53, i32 noundef %54, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.200, i64 0, i64 0), i32 noundef %55) #14
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32, i32* %t.addr, align 4
  %59 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.201, i64 0, i64 0), i32 noundef %58, i32 noundef %59) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.else45:                                        ; preds = %if.else
  %60 = load i32*, i32** %insn_state, align 8
  %61 = load i32, i32* %w.addr, align 4
  %idxprom46 = sext i32 %61 to i64
  %arrayidx47 = getelementptr i32, i32* %60, i64 %idxprom46
  %62 = load i32, i32* %arrayidx47, align 4
  %cmp48 = icmp eq i32 %62, 32
  br i1 %cmp48, label %if.then49, label %if.else53

if.then49:                                        ; preds = %if.else45
  %63 = load i32, i32* %e.addr, align 4
  %or50 = or i32 16, %63
  %64 = load i32*, i32** %insn_state, align 8
  %65 = load i32, i32* %t.addr, align 4
  %idxprom51 = sext i32 %65 to i64
  %arrayidx52 = getelementptr i32, i32* %64, i64 %idxprom51
  store i32 %or50, i32* %arrayidx52, align 4
  br label %if.end54

if.else53:                                        ; preds = %if.else45
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.202, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then49
  br label %if.end55

if.end55:                                         ; preds = %if.end54
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.else53, %if.end44, %if.then43, %if.end32, %if.then31, %if.then14, %if.then10, %if.then
  %68 = load i32, i32* %retval, align 4
  ret i32 %68
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 8
  store i8 1, i8* %prune_point, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off, i8* noundef %prefix_fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %prefix_fmt.addr = alloca i8*, align 8
  %linfo = alloca %struct.bpf_line_info*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  store i8* %prefix_fmt, i8** %prefix_fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load i32, i32* %insn_off.addr, align 4
  %call1 = call %struct.bpf_line_info* @find_linfo(%struct.bpf_verifier_env* noundef %1, i32 noundef %2) #14
  store %struct.bpf_line_info* %call1, %struct.bpf_line_info** %linfo, align 8
  %3 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %tobool = icmp ne %struct.bpf_line_info* %3, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %4 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 25
  %6 = load %struct.bpf_line_info*, %struct.bpf_line_info** %prev_linfo, align 8
  %cmp = icmp eq %struct.bpf_line_info* %4, %6
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %7 = load i8*, i8** %prefix_fmt.addr, align 8
  %tobool4 = icmp ne i8* %7, null
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end3
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay6 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay6)
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 26
  %9 = load i8*, i8** %prefix_fmt.addr, align 8
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log7, i8* noundef %9, %struct.__va_list_tag* noundef %arraydecay8) #14
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay910 = bitcast %struct.__va_list_tag* %arraydecay9 to i8*
  call void @llvm.va_end(i8* %arraydecay910)
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end3
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 2
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 10
  %14 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %14, i32 0, i32 47
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %line_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %16, i32 0, i32 2
  %17 = load i32, i32* %line_off, align 4
  %call12 = call i8* @btf_name_by_offset(%struct.btf* noundef %15, i32 noundef %17) #14
  %call13 = call i8* @ltrim(i8* noundef %call12) #14
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.203, i64 0, i64 0), i8* noundef %call13) #14
  %18 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 25
  store %struct.bpf_line_info* %18, %struct.bpf_line_info** %prev_linfo14, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then2, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_line_info* @find_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off) #0 {
entry:
  %retval = alloca %struct.bpf_line_info*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %linfo = alloca %struct.bpf_line_info*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 53
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, i32* %insn_off.addr, align 4
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  %cmp = icmp uge i32 %6, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.bpf_line_info* null, %struct.bpf_line_info** %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 10
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 50
  %11 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo4, align 8
  store %struct.bpf_line_info* %11, %struct.bpf_line_info** %linfo, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %nr_linfo, align 4
  %cmp5 = icmp ult i32 %12, %13
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, i32* %insn_off.addr, align 4
  %15 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = zext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %15, i64 %idxprom
  %insn_off6 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx, i32 0, i32 0
  %17 = load i32, i32* %insn_off6, align 4
  %cmp7 = icmp ult i32 %14, %17
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  br label %for.end

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then8, %for.cond
  %19 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %sub = sub i32 %20, 1
  %idxprom10 = zext i32 %sub to i64
  %arrayidx11 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %19, i64 %idxprom10
  store %struct.bpf_line_info* %arrayidx11, %struct.bpf_line_info** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %21 = load %struct.bpf_line_info*, %struct.bpf_line_info** %retval, align 8
  ret %struct.bpf_line_info* %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ltrim(i8* noundef %s) #0 {
entry:
  %s.addr = alloca i8*, align 8
  store i8* %s, i8** %s.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %s.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = zext i8 %1 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, 32
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %s.addr, align 8
  %incdec.ptr = getelementptr i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load i8*, i8** %s.addr, align 8
  ret i8* %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_common(%struct.bpf_verifier_env* noundef %env, i32 noundef %subprog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprog.addr = alloca i32, align 4
  %pop_log = alloca i8, align 1
  %state = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %mem_size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %subprog, i32* %subprog.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %pop_log, align 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 25
  store %struct.bpf_line_info* null, %struct.bpf_line_info** %prev_linfo, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 30
  %4 = load i32, i32* %pass_cnt, align 8
  %inc = add i32 %4, 1
  store i32 %inc, i32* %pass_cnt, align 8
  %call = call i8* @kzalloc(i64 noundef 120, i32 noundef 3264) #14
  %5 = bitcast i8* %call to %struct.bpf_verifier_state*
  store %struct.bpf_verifier_state* %5, %struct.bpf_verifier_state** %state, align 8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %tobool1 = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  store i32 0, i32* %curframe, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 6
  store i8 0, i8* %speculative, align 8
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 2
  store i32 1, i32* %branches, align 8
  %call2 = call i8* @kzalloc(i64 noundef 1368, i32 noundef 3264) #14
  %10 = bitcast i8* %call2 to %struct.bpf_func_state*
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %arrayidx, align 8
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 0
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  %tobool5 = icmp ne %struct.bpf_func_state* %13, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %15 = bitcast %struct.bpf_verifier_state* %14 to i8*
  call void @kfree(i8* noundef %15) #14
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 8
  store %struct.bpf_verifier_state* %16, %struct.bpf_verifier_state** %cur_state, align 8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %arrayidx9 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame8, i64 0, i64 0
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx9, align 8
  %21 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %18, %struct.bpf_func_state* noundef %20, i32 noundef -1, i32 noundef 0, i32 noundef %21) #14
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %22, i32 0, i32 0
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe11, align 8
  %idxprom = zext i32 %24 to i64
  %arrayidx12 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame10, i64 0, i64 %idxprom
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx12, align 8
  %regs13 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs13, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %26 = load i32, i32* %subprog.addr, align 4
  %tobool14 = icmp ne i32 %26, 0
  br i1 %tobool14, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 2
  %29 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %29, 28
  br i1 %cmp, label %if.then15, label %if.else50

if.then15:                                        ; preds = %lor.lhs.false, %if.end7
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %subprog.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call16 = call i32 @btf_prepare_func_args(%struct.bpf_verifier_env* noundef %30, i32 noundef %31, %struct.bpf_reg_state* noundef %32) #14
  store i32 %call16, i32* %ret, align 4
  %33 = load i32, i32* %ret, align 4
  %tobool17 = icmp ne i32 %33, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then15
  br label %out

if.end19:                                         ; preds = %if.then15
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %34 = load i32, i32* %i, align 4
  %cmp20 = icmp sle i32 %34, 5
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom21 = sext i32 %36 to i64
  %arrayidx22 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i64 %idxprom21
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx22, i32 0, i32 0
  %37 = load i32, i32* %type23, align 8
  %cmp24 = icmp eq i32 %37, 2
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %for.body
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %40 = load i32, i32* %i, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %38, %struct.bpf_reg_state* noundef %39, i32 noundef %40) #14
  br label %if.end48

if.else:                                          ; preds = %for.body
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %42 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %42 to i64
  %arrayidx27 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i64 %idxprom26
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx27, i32 0, i32 0
  %43 = load i32, i32* %type28, align 8
  %cmp29 = icmp eq i32 %43, 1
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %46 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45, i32 noundef %46) #14
  br label %if.end47

if.else31:                                        ; preds = %if.else
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %48 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %48 to i64
  %arrayidx33 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i64 %idxprom32
  %type34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx33, i32 0, i32 0
  %49 = load i32, i32* %type34, align 8
  %cmp35 = icmp eq i32 %49, 22
  br i1 %cmp35, label %if.then36, label %if.end46

if.then36:                                        ; preds = %if.else31
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom37 = sext i32 %51 to i64
  %arrayidx38 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i64 %idxprom37
  %52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx38, i32 0, i32 2
  %mem_size39 = bitcast %union.anon.152* %52 to i32*
  %53 = load i32, i32* %mem_size39, align 8
  store i32 %53, i32* %mem_size, align 4
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %56 = load i32, i32* %i, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %54, %struct.bpf_reg_state* noundef %55, i32 noundef %56) #14
  %57 = load i32, i32* %mem_size, align 4
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %59 = load i32, i32* %i, align 4
  %idxprom40 = sext i32 %59 to i64
  %arrayidx41 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i64 %idxprom40
  %60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx41, i32 0, i32 2
  %mem_size42 = bitcast %union.anon.152* %60 to i32*
  store i32 %57, i32* %mem_size42, align 8
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 15
  %62 = load i32, i32* %id_gen, align 8
  %inc43 = add i32 %62, 1
  store i32 %inc43, i32* %id_gen, align 8
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %64 = load i32, i32* %i, align 4
  %idxprom44 = sext i32 %64 to i64
  %arrayidx45 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i64 %idxprom44
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx45, i32 0, i32 3
  store i32 %inc43, i32* %id, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.then36, %if.else31
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then30
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then25
  br label %for.inc

for.inc:                                          ; preds = %if.end48
  %65 = load i32, i32* %i, align 4
  %inc49 = add i32 %65, 1
  store i32 %inc49, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end57

if.else50:                                        ; preds = %lor.lhs.false
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx51 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i64 1
  %type52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx51, i32 0, i32 0
  store i32 2, i32* %type52, align 8
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %67, %struct.bpf_reg_state* noundef %68, i32 noundef 1) #14
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load i32, i32* %subprog.addr, align 4
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call53 = call i32 @btf_check_subprog_arg_match(%struct.bpf_verifier_env* noundef %69, i32 noundef %70, %struct.bpf_reg_state* noundef %71) #14
  store i32 %call53, i32* %ret, align 4
  %72 = load i32, i32* %ret, align 4
  %cmp54 = icmp eq i32 %72, -14
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.else50
  br label %out

if.end56:                                         ; preds = %if.else50
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %for.end
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call58 = call i32 @do_check(%struct.bpf_verifier_env* noundef %73) #14
  store i32 %call58, i32* %ret, align 4
  br label %out

out:                                              ; preds = %if.end57, %if.then55, %if.then18
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state59 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 8
  %75 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state59, align 8
  %tobool60 = icmp ne %struct.bpf_verifier_state* %75, null
  br i1 %tobool60, label %if.then61, label %if.end64

if.then61:                                        ; preds = %out
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 8
  %77 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state62, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %77, i1 noundef zeroext true) #14
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state63 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state63, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.then61, %out
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end64
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call65 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %79, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #14
  %tobool66 = icmp ne i32 %call65, 0
  %lnot67 = xor i1 %tobool66, true
  br i1 %lnot67, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %80 = load i32, i32* %ret, align 4
  %tobool68 = icmp ne i32 %80, 0
  br i1 %tobool68, label %if.end72, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.end
  %81 = load i8, i8* %pop_log, align 1
  %tobool69 = trunc i8 %81 to i1
  br i1 %tobool69, label %if.then70, label %if.end72

if.then70:                                        ; preds = %land.lhs.true
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log71 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 26
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log71, i32 noundef 0) #14
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %land.lhs.true, %while.end
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @free_states(%struct.bpf_verifier_env* noundef %83) #14
  %84 = load i32, i32* %ret, align 4
  store i32 %84, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end72, %if.then6, %if.then
  %85 = load i32, i32* %retval, align 4
  ret i32 %85
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %callsite, i32 noundef %frameno, i32 noundef %subprogno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %callsite.addr = alloca i32, align 4
  %frameno.addr = alloca i32, align 4
  %subprogno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %callsite, i32* %callsite.addr, align 4
  store i32 %frameno, i32* %frameno.addr, align 4
  store i32 %subprogno, i32* %subprogno.addr, align 4
  %0 = load i32, i32* %callsite.addr, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %callsite1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 1
  store i32 %0, i32* %callsite1, align 8
  %2 = load i32, i32* %frameno.addr, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 2
  store i32 %2, i32* %frameno2, align 4
  %4 = load i32, i32* %subprogno.addr, align 4
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %subprogno3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 3
  store i32 %4, i32* %subprogno3, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  call void @init_reg_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %7) #14
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_prepare_func_args(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1208, i32 2305, i64 12) #13, !srcloc !29
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  call void asm sideeffect "433:\0A\09.pushsection .discard.reachable\0A\09.long 433b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !30
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %2, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %3, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.206, i64 0, i64 0), i32 noundef %6) #14
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %7 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %7, 11
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %add.ptr) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %13 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %13 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 %idx.ext24
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %add.ptr25) #14
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1550, i32 2305, i64 12) #13, !srcloc !31
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  call void asm sideeffect "467:\0A\09.pushsection .discard.reachable\0A\09.long 467b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !32
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %2, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %3, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.207, i64 0, i64 0), i32 noundef %6) #14
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %7 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %7, 10
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %add.ptr) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %14 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %14 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i64 %idx.ext24
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %add.ptr25) #14
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_subprog_arg_match(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %pscr_ret__.i.i = alloca %struct.task_struct*, align 8
  %__vpp_verify.i.i = alloca i8*, align 8
  %pfo_val__.i.i = alloca i64, align 8
  %tmp.i.i = alloca %struct.task_struct*, align 8
  %tmp1.i.i = alloca %struct.task_struct*, align 8
  %pscr_ret__.i = alloca %struct.task_struct*, align 8
  %__vpp_verify.i = alloca i8*, align 8
  %pfo_val__.i = alloca i64, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %tmp1.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %pop_log = alloca i8, align 1
  %state = alloca %struct.bpf_verifier_state*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %insn_cnt = alloca i32, align 4
  %do_print_state = alloca i8, align 1
  %prev_insn_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %err = alloca i32, align 4
  %tmp = alloca i32, align 4
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %prev_src_type = alloca i32*, align 8
  %src_reg_type = alloca i32, align 4
  %prev_dst_type = alloca i32*, align 8
  %dst_reg_type = alloca i32, align 4
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %pop_log, align 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %3, %struct.bpf_verifier_state** %state, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  store i32 %8, i32* %insn_cnt, align 4
  store i8 0, i8* %do_print_state, align 1
  store i32 -1, i32* %prev_insn_idx, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end558, %if.else506, %if.end485, %if.end434, %if.end171, %entry
  %9 = load i32, i32* %prev_insn_idx, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 1
  store i32 %9, i32* %prev_insn_idx2, align 4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 0
  %12 = load i32, i32* %insn_idx, align 8
  %13 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp uge i32 %12, %13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 0
  %17 = load i32, i32* %insn_idx3, align 8
  %18 = load i32, i32* %insn_cnt, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.208, i64 0, i64 0), i32 noundef %17, i32 noundef %18) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.cond
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 0
  %21 = load i32, i32* %insn_idx4, align 8
  %idxprom = zext i32 %21 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %19, i64 %idxprom
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %insn, align 8
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 0
  %23 = load i8, i8* %code, align 4
  %conv = zext i8 %23 to i32
  %and5 = and i32 %conv, 7
  %conv6 = trunc i32 %and5 to i8
  store i8 %conv6, i8* %class, align 1
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 33
  %25 = load i32, i32* %insn_processed, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %insn_processed, align 4
  %cmp7 = icmp ugt i32 %inc, 1000000
  br i1 %cmp7, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 33
  %29 = load i32, i32* %insn_processed10, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.209, i64 0, i64 0), i32 noundef %29) #14
  store i32 -7, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 0
  %32 = load i32, i32* %insn_idx12, align 8
  %call = call i32 @is_state_visited(%struct.bpf_verifier_env* noundef %30, i32 noundef %32) #14
  store i32 %call, i32* %err, align 4
  %33 = load i32, i32* %err, align 4
  %cmp13 = icmp slt i32 %33, 0
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  %34 = load i32, i32* %err, align 4
  store i32 %34, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end11
  %35 = load i32, i32* %err, align 4
  %cmp17 = icmp eq i32 %35, 1
  br i1 %cmp17, label %if.then19, label %if.end35

if.then19:                                        ; preds = %if.end16
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 26
  %level21 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log20, i32 0, i32 0
  %37 = load i32, i32* %level21, align 8
  %and22 = and i32 %37, 3
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end34

if.then24:                                        ; preds = %if.then19
  %38 = load i8, i8* %do_print_state, align 1
  %tobool25 = trunc i8 %38 to i1
  br i1 %tobool25, label %if.then26, label %if.else

if.then26:                                        ; preds = %if.then24
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 1
  %42 = load i32, i32* %prev_insn_idx27, align 4
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 0
  %44 = load i32, i32* %insn_idx28, align 8
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 8
  %46 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %46, i32 0, i32 6
  %47 = load i8, i8* %speculative, align 8
  %tobool30 = trunc i8 %47 to i1
  %48 = zext i1 %tobool30 to i64
  %cond = select i1 %tobool30, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.211, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.79, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.210, i64 0, i64 0), i32 noundef %42, i32 noundef %44, i8* noundef %cond) #14
  br label %if.end33

if.else:                                          ; preds = %if.then24
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = bitcast %struct.bpf_verifier_env* %49 to i8*
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx32 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 0
  %52 = load i32, i32* %insn_idx32, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %50, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.212, i64 0, i64 0), i32 noundef %52) #14
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.then26
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.then19
  br label %process_bpf_exit

if.end35:                                         ; preds = %if.end16
  store i8* null, i8** %__vpp_verify.i, align 8
  %53 = load i8*, i8** %__vpp_verify.i, align 8
  %54 = call i64 asm "movq %gs:${1:P}, $0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #18, !srcloc !33
  store i64 %54, i64* %pfo_val__.i, align 8
  %55 = load i64, i64* %pfo_val__.i, align 8
  %56 = inttoptr i64 %55 to %struct.task_struct*
  store %struct.task_struct* %56, %struct.task_struct** %tmp.i, align 8
  %57 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  store %struct.task_struct* %57, %struct.task_struct** %pscr_ret__.i, align 8
  %58 = load %struct.task_struct*, %struct.task_struct** %pscr_ret__.i, align 8
  store %struct.task_struct* %58, %struct.task_struct** %tmp1.i, align 8
  %59 = load %struct.task_struct*, %struct.task_struct** %tmp1.i, align 8
  %call37 = call i32 @signal_pending(%struct.task_struct* noundef %59) #14
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  store i32 -11, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end35
  store i8* null, i8** %__vpp_verify.i.i, align 8
  %60 = load i8*, i8** %__vpp_verify.i.i, align 8
  %61 = call i64 asm "movq %gs:${1:P}, $0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #18, !srcloc !33
  store i64 %61, i64* %pfo_val__.i.i, align 8
  %62 = load i64, i64* %pfo_val__.i.i, align 8
  %63 = inttoptr i64 %62 to %struct.task_struct*
  store %struct.task_struct* %63, %struct.task_struct** %tmp.i.i, align 8
  %64 = load %struct.task_struct*, %struct.task_struct** %tmp.i.i, align 8
  store %struct.task_struct* %64, %struct.task_struct** %pscr_ret__.i.i, align 8
  %65 = load %struct.task_struct*, %struct.task_struct** %pscr_ret__.i.i, align 8
  store %struct.task_struct* %65, %struct.task_struct** %tmp1.i.i, align 8
  %66 = load %struct.task_struct*, %struct.task_struct** %tmp1.i.i, align 8
  %67 = bitcast %struct.task_struct* %66 to %struct.thread_info*
  %call1.i = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %67, i32 noundef 3) #16
  %tobool.i = icmp ne i32 %call1.i, 0
  %lnot.i = xor i1 %tobool.i, true
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %tobool.i, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end40
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 12860, i32 noundef 0) #14
  %call43 = call i32 @_cond_resched() #14
  store i32 %call43, i32* %tmp, align 4
  %68 = load i32, i32* %tmp, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end40
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log45 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 26
  %level46 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log45, i32 0, i32 0
  %70 = load i32, i32* %level46, align 8
  %and47 = and i32 %70, 2
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then55, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end44
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log49 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %71, i32 0, i32 26
  %level50 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log49, i32 0, i32 0
  %72 = load i32, i32* %level50, align 8
  %and51 = and i32 %72, 3
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %land.lhs.true, label %if.end73

land.lhs.true:                                    ; preds = %lor.lhs.false
  %73 = load i8, i8* %do_print_state, align 1
  %tobool53 = trunc i8 %73 to i1
  br i1 %tobool53, label %if.then55, label %if.end73

if.then55:                                        ; preds = %land.lhs.true, %if.end44
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log56 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 26
  %level57 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log56, i32 0, i32 0
  %75 = load i32, i32* %level57, align 8
  %and58 = and i32 %75, 2
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then60, label %if.else62

if.then60:                                        ; preds = %if.then55
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = bitcast %struct.bpf_verifier_env* %76 to i8*
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx61 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 0
  %79 = load i32, i32* %insn_idx61, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %77, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.213, i64 0, i64 0), i32 noundef %79) #14
  br label %if.end70

if.else62:                                        ; preds = %if.then55
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = bitcast %struct.bpf_verifier_env* %80 to i8*
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx63 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 1
  %83 = load i32, i32* %prev_insn_idx63, align 4
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx64 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %84, i32 0, i32 0
  %85 = load i32, i32* %insn_idx64, align 8
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state65 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %86, i32 0, i32 8
  %87 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state65, align 8
  %speculative66 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %87, i32 0, i32 6
  %88 = load i8, i8* %speculative66, align 8
  %tobool67 = trunc i8 %88 to i1
  %89 = zext i1 %tobool67 to i64
  %cond69 = select i1 %tobool67, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.211, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.79, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %81, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.214, i64 0, i64 0), i32 noundef %83, i32 noundef %85, i8* noundef %cond69) #14
  br label %if.end70

if.end70:                                         ; preds = %if.else62, %if.then60
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %91, i32 0, i32 0
  %92 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %92, i32 0, i32 4
  %93 = load i32, i32* %curframe, align 8
  %idxprom71 = zext i32 %93 to i64
  %arrayidx72 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom71
  %94 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx72, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %90, %struct.bpf_func_state* noundef %94) #14
  store i8 0, i8* %do_print_state, align 1
  br label %if.end73

if.end73:                                         ; preds = %if.end70, %land.lhs.true, %lor.lhs.false
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log74 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %95, i32 0, i32 26
  %level75 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log74, i32 0, i32 0
  %96 = load i32, i32* %level75, align 8
  %and76 = and i32 %96, 3
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.end82

if.then78:                                        ; preds = %if.end73
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* @disasm_kfunc_name, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = bitcast %struct.bpf_verifier_env* %97 to i8*
  store i8* %98, i8** %private_data, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx79 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %100, i32 0, i32 0
  %101 = load i32, i32* %insn_idx79, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %99, i32 noundef %101, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.215, i64 0, i64 0)) #14
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = bitcast %struct.bpf_verifier_env* %102 to i8*
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx80 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %104, i32 0, i32 0
  %105 = load i32, i32* %insn_idx80, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %103, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.200, i64 0, i64 0), i32 noundef %105) #14
  %106 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %107, i32 0, i32 17
  %108 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool81 = trunc i8 %108 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %106, i1 noundef zeroext %tobool81) #14
  br label %if.end82

if.end82:                                         ; preds = %if.then78, %if.end73
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog83 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 2
  %110 = load %struct.bpf_prog*, %struct.bpf_prog** %prog83, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %110, i32 0, i32 10
  %111 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call84 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %111) #14
  br i1 %call84, label %if.then85, label %if.end92

if.then85:                                        ; preds = %if.end82
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx86 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 0
  %114 = load i32, i32* %insn_idx86, align 8
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 1
  %116 = load i32, i32* %prev_insn_idx87, align 4
  %call88 = call i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef %112, i32 noundef %114, i32 noundef %116) #14
  store i32 %call88, i32* %err, align 4
  %117 = load i32, i32* %err, align 4
  %tobool89 = icmp ne i32 %117, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.then85
  %118 = load i32, i32* %err, align 4
  store i32 %118, i32* %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.then85
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.end82
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call93 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %119) #14
  store %struct.bpf_reg_state* %call93, %struct.bpf_reg_state** %regs, align 8
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @sanitize_mark_insn_seen(%struct.bpf_verifier_env* noundef %120) #14
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx94 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 0
  %122 = load i32, i32* %insn_idx94, align 8
  store i32 %122, i32* %prev_insn_idx, align 4
  %123 = load i8, i8* %class, align 1
  %conv95 = zext i8 %123 to i32
  %cmp96 = icmp eq i32 %conv95, 4
  br i1 %cmp96, label %if.then102, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.end92
  %124 = load i8, i8* %class, align 1
  %conv99 = zext i8 %124 to i32
  %cmp100 = icmp eq i32 %conv99, 7
  br i1 %cmp100, label %if.then102, label %if.else107

if.then102:                                       ; preds = %lor.lhs.false98, %if.end92
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %126 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call103 = call i32 @check_alu_op(%struct.bpf_verifier_env* noundef %125, %struct.bpf_insn* noundef %126) #14
  store i32 %call103, i32* %err, align 4
  %127 = load i32, i32* %err, align 4
  %tobool104 = icmp ne i32 %127, 0
  br i1 %tobool104, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.then102
  %128 = load i32, i32* %err, align 4
  store i32 %128, i32* %retval, align 4
  br label %return

if.end106:                                        ; preds = %if.then102
  br label %if.end558

if.else107:                                       ; preds = %lor.lhs.false98
  %129 = load i8, i8* %class, align 1
  %conv108 = zext i8 %129 to i32
  %cmp109 = icmp eq i32 %conv108, 1
  br i1 %cmp109, label %if.then111, label %if.else156

if.then111:                                       ; preds = %if.else107
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %131, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv112 = zext i8 %bf.lshr to i32
  %call113 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %130, i32 noundef %conv112, i32 noundef 0) #14
  store i32 %call113, i32* %err, align 4
  %132 = load i32, i32* %err, align 4
  %tobool114 = icmp ne i32 %132, 0
  br i1 %tobool114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.then111
  %133 = load i32, i32* %err, align 4
  store i32 %133, i32* %retval, align 4
  br label %return

if.end116:                                        ; preds = %if.then111
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %135 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %135, i32 0, i32 1
  %bf.load117 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load117, 15
  %conv118 = zext i8 %bf.clear to i32
  %call119 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %134, i32 noundef %conv118, i32 noundef 2) #14
  store i32 %call119, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool120 = icmp ne i32 %136, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end116
  %137 = load i32, i32* %err, align 4
  store i32 %137, i32* %retval, align 4
  br label %return

if.end122:                                        ; preds = %if.end116
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %139 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg123 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %139, i32 0, i32 1
  %bf.load124 = load i8, i8* %src_reg123, align 1
  %bf.lshr125 = lshr i8 %bf.load124, 4
  %idxprom126 = zext i8 %bf.lshr125 to i64
  %arrayidx127 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i64 %idxprom126
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx127, i32 0, i32 0
  %140 = load i32, i32* %type, align 8
  store i32 %140, i32* %src_reg_type, align 4
  %141 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx128 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %142, i32 0, i32 0
  %143 = load i32, i32* %insn_idx128, align 8
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg129 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %144, i32 0, i32 1
  %bf.load130 = load i8, i8* %src_reg129, align 1
  %bf.lshr131 = lshr i8 %bf.load130, 4
  %conv132 = zext i8 %bf.lshr131 to i32
  %145 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %145, i32 0, i32 2
  %146 = load i16, i16* %off, align 2
  %conv133 = sext i16 %146 to i32
  %147 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code134 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %147, i32 0, i32 0
  %148 = load i8, i8* %code134, align 4
  %conv135 = zext i8 %148 to i32
  %and136 = and i32 %conv135, 24
  %149 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg137 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %149, i32 0, i32 1
  %bf.load138 = load i8, i8* %dst_reg137, align 1
  %bf.clear139 = and i8 %bf.load138, 15
  %conv140 = zext i8 %bf.clear139 to i32
  %call141 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %141, i32 noundef %143, i32 noundef %conv132, i32 noundef %conv133, i32 noundef %and136, i32 noundef 1, i32 noundef %conv140, i1 noundef zeroext false) #14
  store i32 %call141, i32* %err, align 4
  %150 = load i32, i32* %err, align 4
  %tobool142 = icmp ne i32 %150, 0
  br i1 %tobool142, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.end122
  %151 = load i32, i32* %err, align 4
  store i32 %151, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %if.end122
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %152, i32 0, i32 24
  %153 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx145 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 0
  %155 = load i32, i32* %insn_idx145, align 8
  %idxprom146 = zext i32 %155 to i64
  %arrayidx147 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %153, i64 %idxprom146
  %156 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx147, i32 0, i32 0
  %ptr_type = bitcast %union.anon.163* %156 to i32*
  store i32* %ptr_type, i32** %prev_src_type, align 8
  %157 = load i32*, i32** %prev_src_type, align 8
  %158 = load i32, i32* %157, align 4
  %cmp148 = icmp eq i32 %158, 0
  br i1 %cmp148, label %if.then150, label %if.else151

if.then150:                                       ; preds = %if.end144
  %159 = load i32, i32* %src_reg_type, align 4
  %160 = load i32*, i32** %prev_src_type, align 8
  store i32 %159, i32* %160, align 4
  br label %if.end155

if.else151:                                       ; preds = %if.end144
  %161 = load i32, i32* %src_reg_type, align 4
  %162 = load i32*, i32** %prev_src_type, align 8
  %163 = load i32, i32* %162, align 4
  %call152 = call zeroext i1 @reg_type_mismatch(i32 noundef %161, i32 noundef %163) #14
  br i1 %call152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.else151
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %165 = bitcast %struct.bpf_verifier_env* %164 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %165, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.216, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end154:                                        ; preds = %if.else151
  br label %if.end155

if.end155:                                        ; preds = %if.end154, %if.then150
  br label %if.end557

if.else156:                                       ; preds = %if.else107
  %166 = load i8, i8* %class, align 1
  %conv157 = zext i8 %166 to i32
  %cmp158 = icmp eq i32 %conv157, 3
  br i1 %cmp158, label %if.then160, label %if.else238

if.then160:                                       ; preds = %if.else156
  %167 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code161 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %167, i32 0, i32 0
  %168 = load i8, i8* %code161, align 4
  %conv162 = zext i8 %168 to i32
  %and163 = and i32 %conv162, 224
  %cmp164 = icmp eq i32 %and163, 192
  br i1 %cmp164, label %if.then166, label %if.end174

if.then166:                                       ; preds = %if.then160
  %169 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %170 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx167 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %170, i32 0, i32 0
  %171 = load i32, i32* %insn_idx167, align 8
  %172 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call168 = call i32 @check_atomic(%struct.bpf_verifier_env* noundef %169, i32 noundef %171, %struct.bpf_insn* noundef %172) #14
  store i32 %call168, i32* %err, align 4
  %173 = load i32, i32* %err, align 4
  %tobool169 = icmp ne i32 %173, 0
  br i1 %tobool169, label %if.then170, label %if.end171

if.then170:                                       ; preds = %if.then166
  %174 = load i32, i32* %err, align 4
  store i32 %174, i32* %retval, align 4
  br label %return

if.end171:                                        ; preds = %if.then166
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx172 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %175, i32 0, i32 0
  %176 = load i32, i32* %insn_idx172, align 8
  %inc173 = add i32 %176, 1
  store i32 %inc173, i32* %insn_idx172, align 8
  br label %for.cond

if.end174:                                        ; preds = %if.then160
  %177 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code175 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %177, i32 0, i32 0
  %178 = load i8, i8* %code175, align 4
  %conv176 = zext i8 %178 to i32
  %and177 = and i32 %conv176, 224
  %cmp178 = icmp ne i32 %and177, 96
  br i1 %cmp178, label %if.then183, label %lor.lhs.false180

lor.lhs.false180:                                 ; preds = %if.end174
  %179 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %179, i32 0, i32 3
  %180 = load i32, i32* %imm, align 4
  %cmp181 = icmp ne i32 %180, 0
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %lor.lhs.false180, %if.end174
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %182 = bitcast %struct.bpf_verifier_env* %181 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %182, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.217, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %lor.lhs.false180
  %183 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %184 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg185 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %184, i32 0, i32 1
  %bf.load186 = load i8, i8* %src_reg185, align 1
  %bf.lshr187 = lshr i8 %bf.load186, 4
  %conv188 = zext i8 %bf.lshr187 to i32
  %call189 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %183, i32 noundef %conv188, i32 noundef 0) #14
  store i32 %call189, i32* %err, align 4
  %185 = load i32, i32* %err, align 4
  %tobool190 = icmp ne i32 %185, 0
  br i1 %tobool190, label %if.then191, label %if.end192

if.then191:                                       ; preds = %if.end184
  %186 = load i32, i32* %err, align 4
  store i32 %186, i32* %retval, align 4
  br label %return

if.end192:                                        ; preds = %if.end184
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %188 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg193 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %188, i32 0, i32 1
  %bf.load194 = load i8, i8* %dst_reg193, align 1
  %bf.clear195 = and i8 %bf.load194, 15
  %conv196 = zext i8 %bf.clear195 to i32
  %call197 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %187, i32 noundef %conv196, i32 noundef 0) #14
  store i32 %call197, i32* %err, align 4
  %189 = load i32, i32* %err, align 4
  %tobool198 = icmp ne i32 %189, 0
  br i1 %tobool198, label %if.then199, label %if.end200

if.then199:                                       ; preds = %if.end192
  %190 = load i32, i32* %err, align 4
  store i32 %190, i32* %retval, align 4
  br label %return

if.end200:                                        ; preds = %if.end192
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %192 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg201 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %192, i32 0, i32 1
  %bf.load202 = load i8, i8* %dst_reg201, align 1
  %bf.clear203 = and i8 %bf.load202, 15
  %idxprom204 = zext i8 %bf.clear203 to i64
  %arrayidx205 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %191, i64 %idxprom204
  %type206 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx205, i32 0, i32 0
  %193 = load i32, i32* %type206, align 8
  store i32 %193, i32* %dst_reg_type, align 4
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %195 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx207 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %195, i32 0, i32 0
  %196 = load i32, i32* %insn_idx207, align 8
  %197 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg208 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %197, i32 0, i32 1
  %bf.load209 = load i8, i8* %dst_reg208, align 1
  %bf.clear210 = and i8 %bf.load209, 15
  %conv211 = zext i8 %bf.clear210 to i32
  %198 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off212 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %198, i32 0, i32 2
  %199 = load i16, i16* %off212, align 2
  %conv213 = sext i16 %199 to i32
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code214 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 0
  %201 = load i8, i8* %code214, align 4
  %conv215 = zext i8 %201 to i32
  %and216 = and i32 %conv215, 24
  %202 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg217 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %202, i32 0, i32 1
  %bf.load218 = load i8, i8* %src_reg217, align 1
  %bf.lshr219 = lshr i8 %bf.load218, 4
  %conv220 = zext i8 %bf.lshr219 to i32
  %call221 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %194, i32 noundef %196, i32 noundef %conv211, i32 noundef %conv213, i32 noundef %and216, i32 noundef 2, i32 noundef %conv220, i1 noundef zeroext false) #14
  store i32 %call221, i32* %err, align 4
  %203 = load i32, i32* %err, align 4
  %tobool222 = icmp ne i32 %203, 0
  br i1 %tobool222, label %if.then223, label %if.end224

if.then223:                                       ; preds = %if.end200
  %204 = load i32, i32* %err, align 4
  store i32 %204, i32* %retval, align 4
  br label %return

if.end224:                                        ; preds = %if.end200
  %205 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data225 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %205, i32 0, i32 24
  %206 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data225, align 8
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx226 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %207, i32 0, i32 0
  %208 = load i32, i32* %insn_idx226, align 8
  %idxprom227 = zext i32 %208 to i64
  %arrayidx228 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %206, i64 %idxprom227
  %209 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx228, i32 0, i32 0
  %ptr_type229 = bitcast %union.anon.163* %209 to i32*
  store i32* %ptr_type229, i32** %prev_dst_type, align 8
  %210 = load i32*, i32** %prev_dst_type, align 8
  %211 = load i32, i32* %210, align 4
  %cmp230 = icmp eq i32 %211, 0
  br i1 %cmp230, label %if.then232, label %if.else233

if.then232:                                       ; preds = %if.end224
  %212 = load i32, i32* %dst_reg_type, align 4
  %213 = load i32*, i32** %prev_dst_type, align 8
  store i32 %212, i32* %213, align 4
  br label %if.end237

if.else233:                                       ; preds = %if.end224
  %214 = load i32, i32* %dst_reg_type, align 4
  %215 = load i32*, i32** %prev_dst_type, align 8
  %216 = load i32, i32* %215, align 4
  %call234 = call zeroext i1 @reg_type_mismatch(i32 noundef %214, i32 noundef %216) #14
  br i1 %call234, label %if.then235, label %if.end236

if.then235:                                       ; preds = %if.else233
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %218 = bitcast %struct.bpf_verifier_env* %217 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %218, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.216, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end236:                                        ; preds = %if.else233
  br label %if.end237

if.end237:                                        ; preds = %if.end236, %if.then232
  br label %if.end556

if.else238:                                       ; preds = %if.else156
  %219 = load i8, i8* %class, align 1
  %conv239 = zext i8 %219 to i32
  %cmp240 = icmp eq i32 %conv239, 2
  br i1 %cmp240, label %if.then242, label %if.else298

if.then242:                                       ; preds = %if.else238
  %220 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code243 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %220, i32 0, i32 0
  %221 = load i8, i8* %code243, align 4
  %conv244 = zext i8 %221 to i32
  %and245 = and i32 %conv244, 224
  %cmp246 = icmp ne i32 %and245, 96
  br i1 %cmp246, label %if.then255, label %lor.lhs.false248

lor.lhs.false248:                                 ; preds = %if.then242
  %222 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg249 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %222, i32 0, i32 1
  %bf.load250 = load i8, i8* %src_reg249, align 1
  %bf.lshr251 = lshr i8 %bf.load250, 4
  %conv252 = zext i8 %bf.lshr251 to i32
  %cmp253 = icmp ne i32 %conv252, 0
  br i1 %cmp253, label %if.then255, label %if.end256

if.then255:                                       ; preds = %lor.lhs.false248, %if.then242
  %223 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %224 = bitcast %struct.bpf_verifier_env* %223 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %224, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.218, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end256:                                        ; preds = %lor.lhs.false248
  %225 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %226 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg257 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %226, i32 0, i32 1
  %bf.load258 = load i8, i8* %dst_reg257, align 1
  %bf.clear259 = and i8 %bf.load258, 15
  %conv260 = zext i8 %bf.clear259 to i32
  %call261 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %225, i32 noundef %conv260, i32 noundef 0) #14
  store i32 %call261, i32* %err, align 4
  %227 = load i32, i32* %err, align 4
  %tobool262 = icmp ne i32 %227, 0
  br i1 %tobool262, label %if.then263, label %if.end264

if.then263:                                       ; preds = %if.end256
  %228 = load i32, i32* %err, align 4
  store i32 %228, i32* %retval, align 4
  br label %return

if.end264:                                        ; preds = %if.end256
  %229 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %230 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg265 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %230, i32 0, i32 1
  %bf.load266 = load i8, i8* %dst_reg265, align 1
  %bf.clear267 = and i8 %bf.load266, 15
  %conv268 = zext i8 %bf.clear267 to i32
  %call269 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %229, i32 noundef %conv268) #14
  br i1 %call269, label %if.then270, label %if.end283

if.then270:                                       ; preds = %if.end264
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %232 = bitcast %struct.bpf_verifier_env* %231 to i8*
  %233 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %233, i32 0, i32 1
  %bf.load272 = load i8, i8* %dst_reg271, align 1
  %bf.clear273 = and i8 %bf.load272, 15
  %conv274 = zext i8 %bf.clear273 to i32
  %234 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %235 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg275 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %235, i32 0, i32 1
  %bf.load276 = load i8, i8* %dst_reg275, align 1
  %bf.clear277 = and i8 %bf.load276, 15
  %conv278 = zext i8 %bf.clear277 to i32
  %call279 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %234, i32 noundef %conv278) #14
  %type280 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call279, i32 0, i32 0
  %236 = load i32, i32* %type280, align 8
  %idxprom281 = zext i32 %236 to i64
  %arrayidx282 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom281
  %237 = load i8*, i8** %arrayidx282, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %232, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.219, i64 0, i64 0), i32 noundef %conv274, i8* noundef %237) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end283:                                        ; preds = %if.end264
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %239 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx284 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %239, i32 0, i32 0
  %240 = load i32, i32* %insn_idx284, align 8
  %241 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %241, i32 0, i32 1
  %bf.load286 = load i8, i8* %dst_reg285, align 1
  %bf.clear287 = and i8 %bf.load286, 15
  %conv288 = zext i8 %bf.clear287 to i32
  %242 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off289 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %242, i32 0, i32 2
  %243 = load i16, i16* %off289, align 2
  %conv290 = sext i16 %243 to i32
  %244 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %244, i32 0, i32 0
  %245 = load i8, i8* %code291, align 4
  %conv292 = zext i8 %245 to i32
  %and293 = and i32 %conv292, 24
  %call294 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %238, i32 noundef %240, i32 noundef %conv288, i32 noundef %conv290, i32 noundef %and293, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #14
  store i32 %call294, i32* %err, align 4
  %246 = load i32, i32* %err, align 4
  %tobool295 = icmp ne i32 %246, 0
  br i1 %tobool295, label %if.then296, label %if.end297

if.then296:                                       ; preds = %if.end283
  %247 = load i32, i32* %err, align 4
  store i32 %247, i32* %retval, align 4
  br label %return

if.end297:                                        ; preds = %if.end283
  br label %if.end555

if.else298:                                       ; preds = %if.else238
  %248 = load i8, i8* %class, align 1
  %conv299 = zext i8 %248 to i32
  %cmp300 = icmp eq i32 %conv299, 5
  br i1 %cmp300, label %if.then306, label %lor.lhs.false302

lor.lhs.false302:                                 ; preds = %if.else298
  %249 = load i8, i8* %class, align 1
  %conv303 = zext i8 %249 to i32
  %cmp304 = icmp eq i32 %conv303, 6
  br i1 %cmp304, label %if.then306, label %if.else516

if.then306:                                       ; preds = %lor.lhs.false302, %if.else298
  %250 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code307 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %250, i32 0, i32 0
  %251 = load i8, i8* %code307, align 4
  %conv308 = zext i8 %251 to i32
  %and309 = and i32 %conv308, 240
  %conv310 = trunc i32 %and309 to i8
  store i8 %conv310, i8* %opcode, align 1
  %252 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %252, i32 0, i32 35
  %253 = load i32, i32* %jmps_processed, align 4
  %inc311 = add i32 %253, 1
  store i32 %inc311, i32* %jmps_processed, align 4
  %254 = load i8, i8* %opcode, align 1
  %conv312 = zext i8 %254 to i32
  %cmp313 = icmp eq i32 %conv312, 128
  br i1 %cmp313, label %if.then315, label %if.else401

if.then315:                                       ; preds = %if.then306
  %255 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code316 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %255, i32 0, i32 0
  %256 = load i8, i8* %code316, align 4
  %conv317 = zext i8 %256 to i32
  %and318 = and i32 %conv317, 8
  %cmp319 = icmp ne i32 %and318, 0
  br i1 %cmp319, label %if.then358, label %lor.lhs.false321

lor.lhs.false321:                                 ; preds = %if.then315
  %257 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off322 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %257, i32 0, i32 2
  %258 = load i16, i16* %off322, align 2
  %conv323 = sext i16 %258 to i32
  %cmp324 = icmp ne i32 %conv323, 0
  br i1 %cmp324, label %if.then358, label %lor.lhs.false326

lor.lhs.false326:                                 ; preds = %lor.lhs.false321
  %259 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg327 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %259, i32 0, i32 1
  %bf.load328 = load i8, i8* %src_reg327, align 1
  %bf.lshr329 = lshr i8 %bf.load328, 4
  %conv330 = zext i8 %bf.lshr329 to i32
  %cmp331 = icmp ne i32 %conv330, 0
  br i1 %cmp331, label %land.lhs.true333, label %lor.lhs.false347

land.lhs.true333:                                 ; preds = %lor.lhs.false326
  %260 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg334 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %260, i32 0, i32 1
  %bf.load335 = load i8, i8* %src_reg334, align 1
  %bf.lshr336 = lshr i8 %bf.load335, 4
  %conv337 = zext i8 %bf.lshr336 to i32
  %cmp338 = icmp ne i32 %conv337, 1
  br i1 %cmp338, label %land.lhs.true340, label %lor.lhs.false347

land.lhs.true340:                                 ; preds = %land.lhs.true333
  %261 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg341 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %261, i32 0, i32 1
  %bf.load342 = load i8, i8* %src_reg341, align 1
  %bf.lshr343 = lshr i8 %bf.load342, 4
  %conv344 = zext i8 %bf.lshr343 to i32
  %cmp345 = icmp ne i32 %conv344, 2
  br i1 %cmp345, label %if.then358, label %lor.lhs.false347

lor.lhs.false347:                                 ; preds = %land.lhs.true340, %land.lhs.true333, %lor.lhs.false326
  %262 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg348 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %262, i32 0, i32 1
  %bf.load349 = load i8, i8* %dst_reg348, align 1
  %bf.clear350 = and i8 %bf.load349, 15
  %conv351 = zext i8 %bf.clear350 to i32
  %cmp352 = icmp ne i32 %conv351, 0
  br i1 %cmp352, label %if.then358, label %lor.lhs.false354

lor.lhs.false354:                                 ; preds = %lor.lhs.false347
  %263 = load i8, i8* %class, align 1
  %conv355 = zext i8 %263 to i32
  %cmp356 = icmp eq i32 %conv355, 6
  br i1 %cmp356, label %if.then358, label %if.end359

if.then358:                                       ; preds = %lor.lhs.false354, %lor.lhs.false347, %land.lhs.true340, %lor.lhs.false321, %if.then315
  %264 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %265 = bitcast %struct.bpf_verifier_env* %264 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %265, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.220, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end359:                                        ; preds = %lor.lhs.false354
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state360 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %266, i32 0, i32 8
  %267 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state360, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %267, i32 0, i32 5
  %268 = load i32, i32* %active_spin_lock, align 4
  %tobool361 = icmp ne i32 %268, 0
  br i1 %tobool361, label %land.lhs.true362, label %if.end374

land.lhs.true362:                                 ; preds = %if.end359
  %269 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg363 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %269, i32 0, i32 1
  %bf.load364 = load i8, i8* %src_reg363, align 1
  %bf.lshr365 = lshr i8 %bf.load364, 4
  %conv366 = zext i8 %bf.lshr365 to i32
  %cmp367 = icmp eq i32 %conv366, 1
  br i1 %cmp367, label %if.then373, label %lor.lhs.false369

lor.lhs.false369:                                 ; preds = %land.lhs.true362
  %270 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm370 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %270, i32 0, i32 3
  %271 = load i32, i32* %imm370, align 4
  %cmp371 = icmp ne i32 %271, 94
  br i1 %cmp371, label %if.then373, label %if.end374

if.then373:                                       ; preds = %lor.lhs.false369, %land.lhs.true362
  %272 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %273 = bitcast %struct.bpf_verifier_env* %272 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %273, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.221, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end374:                                        ; preds = %lor.lhs.false369, %if.end359
  %274 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg375 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %274, i32 0, i32 1
  %bf.load376 = load i8, i8* %src_reg375, align 1
  %bf.lshr377 = lshr i8 %bf.load376, 4
  %conv378 = zext i8 %bf.lshr377 to i32
  %cmp379 = icmp eq i32 %conv378, 1
  br i1 %cmp379, label %if.then381, label %if.else384

if.then381:                                       ; preds = %if.end374
  %275 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %276 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %277 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx382 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %277, i32 0, i32 0
  %call383 = call i32 @check_func_call(%struct.bpf_verifier_env* noundef %275, %struct.bpf_insn* noundef %276, i32* noundef %insn_idx382) #14
  store i32 %call383, i32* %err, align 4
  br label %if.end397

if.else384:                                       ; preds = %if.end374
  %278 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg385 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %278, i32 0, i32 1
  %bf.load386 = load i8, i8* %src_reg385, align 1
  %bf.lshr387 = lshr i8 %bf.load386, 4
  %conv388 = zext i8 %bf.lshr387 to i32
  %cmp389 = icmp eq i32 %conv388, 2
  br i1 %cmp389, label %if.then391, label %if.else393

if.then391:                                       ; preds = %if.else384
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %280 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call392 = call i32 @check_kfunc_call(%struct.bpf_verifier_env* noundef %279, %struct.bpf_insn* noundef %280) #14
  store i32 %call392, i32* %err, align 4
  br label %if.end396

if.else393:                                       ; preds = %if.else384
  %281 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %282 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %283 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx394 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %283, i32 0, i32 0
  %call395 = call i32 @check_helper_call(%struct.bpf_verifier_env* noundef %281, %struct.bpf_insn* noundef %282, i32* noundef %insn_idx394) #14
  store i32 %call395, i32* %err, align 4
  br label %if.end396

if.end396:                                        ; preds = %if.else393, %if.then391
  br label %if.end397

if.end397:                                        ; preds = %if.end396, %if.then381
  %284 = load i32, i32* %err, align 4
  %tobool398 = icmp ne i32 %284, 0
  br i1 %tobool398, label %if.then399, label %if.end400

if.then399:                                       ; preds = %if.end397
  %285 = load i32, i32* %err, align 4
  store i32 %285, i32* %retval, align 4
  br label %return

if.end400:                                        ; preds = %if.end397
  br label %if.end515

if.else401:                                       ; preds = %if.then306
  %286 = load i8, i8* %opcode, align 1
  %conv402 = zext i8 %286 to i32
  %cmp403 = icmp eq i32 %conv402, 0
  br i1 %cmp403, label %if.then405, label %if.else439

if.then405:                                       ; preds = %if.else401
  %287 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code406 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %287, i32 0, i32 0
  %288 = load i8, i8* %code406, align 4
  %conv407 = zext i8 %288 to i32
  %and408 = and i32 %conv407, 8
  %cmp409 = icmp ne i32 %and408, 0
  br i1 %cmp409, label %if.then433, label %lor.lhs.false411

lor.lhs.false411:                                 ; preds = %if.then405
  %289 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm412 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %289, i32 0, i32 3
  %290 = load i32, i32* %imm412, align 4
  %cmp413 = icmp ne i32 %290, 0
  br i1 %cmp413, label %if.then433, label %lor.lhs.false415

lor.lhs.false415:                                 ; preds = %lor.lhs.false411
  %291 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg416 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %291, i32 0, i32 1
  %bf.load417 = load i8, i8* %src_reg416, align 1
  %bf.lshr418 = lshr i8 %bf.load417, 4
  %conv419 = zext i8 %bf.lshr418 to i32
  %cmp420 = icmp ne i32 %conv419, 0
  br i1 %cmp420, label %if.then433, label %lor.lhs.false422

lor.lhs.false422:                                 ; preds = %lor.lhs.false415
  %292 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg423 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %292, i32 0, i32 1
  %bf.load424 = load i8, i8* %dst_reg423, align 1
  %bf.clear425 = and i8 %bf.load424, 15
  %conv426 = zext i8 %bf.clear425 to i32
  %cmp427 = icmp ne i32 %conv426, 0
  br i1 %cmp427, label %if.then433, label %lor.lhs.false429

lor.lhs.false429:                                 ; preds = %lor.lhs.false422
  %293 = load i8, i8* %class, align 1
  %conv430 = zext i8 %293 to i32
  %cmp431 = icmp eq i32 %conv430, 6
  br i1 %cmp431, label %if.then433, label %if.end434

if.then433:                                       ; preds = %lor.lhs.false429, %lor.lhs.false422, %lor.lhs.false415, %lor.lhs.false411, %if.then405
  %294 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %295 = bitcast %struct.bpf_verifier_env* %294 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %295, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.222, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end434:                                        ; preds = %lor.lhs.false429
  %296 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off435 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %296, i32 0, i32 2
  %297 = load i16, i16* %off435, align 2
  %conv436 = sext i16 %297 to i32
  %add = add i32 %conv436, 1
  %298 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx437 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %298, i32 0, i32 0
  %299 = load i32, i32* %insn_idx437, align 8
  %add438 = add i32 %299, %add
  store i32 %add438, i32* %insn_idx437, align 8
  br label %for.cond

if.else439:                                       ; preds = %if.else401
  %300 = load i8, i8* %opcode, align 1
  %conv440 = zext i8 %300 to i32
  %cmp441 = icmp eq i32 %conv440, 144
  br i1 %cmp441, label %if.then443, label %if.else507

if.then443:                                       ; preds = %if.else439
  %301 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code444 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %301, i32 0, i32 0
  %302 = load i8, i8* %code444, align 4
  %conv445 = zext i8 %302 to i32
  %and446 = and i32 %conv445, 8
  %cmp447 = icmp ne i32 %and446, 0
  br i1 %cmp447, label %if.then471, label %lor.lhs.false449

lor.lhs.false449:                                 ; preds = %if.then443
  %303 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm450 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %303, i32 0, i32 3
  %304 = load i32, i32* %imm450, align 4
  %cmp451 = icmp ne i32 %304, 0
  br i1 %cmp451, label %if.then471, label %lor.lhs.false453

lor.lhs.false453:                                 ; preds = %lor.lhs.false449
  %305 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg454 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %305, i32 0, i32 1
  %bf.load455 = load i8, i8* %src_reg454, align 1
  %bf.lshr456 = lshr i8 %bf.load455, 4
  %conv457 = zext i8 %bf.lshr456 to i32
  %cmp458 = icmp ne i32 %conv457, 0
  br i1 %cmp458, label %if.then471, label %lor.lhs.false460

lor.lhs.false460:                                 ; preds = %lor.lhs.false453
  %306 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg461 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %306, i32 0, i32 1
  %bf.load462 = load i8, i8* %dst_reg461, align 1
  %bf.clear463 = and i8 %bf.load462, 15
  %conv464 = zext i8 %bf.clear463 to i32
  %cmp465 = icmp ne i32 %conv464, 0
  br i1 %cmp465, label %if.then471, label %lor.lhs.false467

lor.lhs.false467:                                 ; preds = %lor.lhs.false460
  %307 = load i8, i8* %class, align 1
  %conv468 = zext i8 %307 to i32
  %cmp469 = icmp eq i32 %conv468, 6
  br i1 %cmp469, label %if.then471, label %if.end472

if.then471:                                       ; preds = %lor.lhs.false467, %lor.lhs.false460, %lor.lhs.false453, %lor.lhs.false449, %if.then443
  %308 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %309 = bitcast %struct.bpf_verifier_env* %308 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %309, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.223, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end472:                                        ; preds = %lor.lhs.false467
  %310 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state473 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %310, i32 0, i32 8
  %311 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state473, align 8
  %active_spin_lock474 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %311, i32 0, i32 5
  %312 = load i32, i32* %active_spin_lock474, align 4
  %tobool475 = icmp ne i32 %312, 0
  br i1 %tobool475, label %if.then476, label %if.end477

if.then476:                                       ; preds = %if.end472
  %313 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %314 = bitcast %struct.bpf_verifier_env* %313 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %314, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.224, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end477:                                        ; preds = %if.end472
  %315 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe478 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %315, i32 0, i32 4
  %316 = load i32, i32* %curframe478, align 8
  %tobool479 = icmp ne i32 %316, 0
  br i1 %tobool479, label %if.then480, label %if.end486

if.then480:                                       ; preds = %if.end477
  %317 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %318 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx481 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %318, i32 0, i32 0
  %call482 = call i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %317, i32* noundef %insn_idx481) #14
  store i32 %call482, i32* %err, align 4
  %319 = load i32, i32* %err, align 4
  %tobool483 = icmp ne i32 %319, 0
  br i1 %tobool483, label %if.then484, label %if.end485

if.then484:                                       ; preds = %if.then480
  %320 = load i32, i32* %err, align 4
  store i32 %320, i32* %retval, align 4
  br label %return

if.end485:                                        ; preds = %if.then480
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.end486:                                        ; preds = %if.end477
  %321 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call487 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %321) #14
  store i32 %call487, i32* %err, align 4
  %322 = load i32, i32* %err, align 4
  %tobool488 = icmp ne i32 %322, 0
  br i1 %tobool488, label %if.then489, label %if.end490

if.then489:                                       ; preds = %if.end486
  %323 = load i32, i32* %err, align 4
  store i32 %323, i32* %retval, align 4
  br label %return

if.end490:                                        ; preds = %if.end486
  %324 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call491 = call i32 @check_return_code(%struct.bpf_verifier_env* noundef %324) #14
  store i32 %call491, i32* %err, align 4
  %325 = load i32, i32* %err, align 4
  %tobool492 = icmp ne i32 %325, 0
  br i1 %tobool492, label %if.then493, label %if.end494

if.then493:                                       ; preds = %if.end490
  %326 = load i32, i32* %err, align 4
  store i32 %326, i32* %retval, align 4
  br label %return

if.end494:                                        ; preds = %if.end490
  br label %process_bpf_exit

process_bpf_exit:                                 ; preds = %if.end494, %if.end34
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %328 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state495 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %328, i32 0, i32 8
  %329 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state495, align 8
  call void @update_branch_counts(%struct.bpf_verifier_env* noundef %327, %struct.bpf_verifier_state* noundef %329) #14
  %330 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %331 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx496 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %331, i32 0, i32 0
  %332 = load i8, i8* %pop_log, align 1
  %tobool497 = trunc i8 %332 to i1
  %call498 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %330, i32* noundef %prev_insn_idx, i32* noundef %insn_idx496, i1 noundef zeroext %tobool497) #14
  store i32 %call498, i32* %err, align 4
  %333 = load i32, i32* %err, align 4
  %cmp499 = icmp slt i32 %333, 0
  br i1 %cmp499, label %if.then501, label %if.else506

if.then501:                                       ; preds = %process_bpf_exit
  %334 = load i32, i32* %err, align 4
  %cmp502 = icmp ne i32 %334, -2
  br i1 %cmp502, label %if.then504, label %if.end505

if.then504:                                       ; preds = %if.then501
  %335 = load i32, i32* %err, align 4
  store i32 %335, i32* %retval, align 4
  br label %return

if.end505:                                        ; preds = %if.then501
  br label %for.end

if.else506:                                       ; preds = %process_bpf_exit
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.else507:                                       ; preds = %if.else439
  %336 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %337 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %338 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx508 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %338, i32 0, i32 0
  %call509 = call i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %336, %struct.bpf_insn* noundef %337, i32* noundef %insn_idx508) #14
  store i32 %call509, i32* %err, align 4
  %339 = load i32, i32* %err, align 4
  %tobool510 = icmp ne i32 %339, 0
  br i1 %tobool510, label %if.then511, label %if.end512

if.then511:                                       ; preds = %if.else507
  %340 = load i32, i32* %err, align 4
  store i32 %340, i32* %retval, align 4
  br label %return

if.end512:                                        ; preds = %if.else507
  br label %if.end513

if.end513:                                        ; preds = %if.end512
  br label %if.end514

if.end514:                                        ; preds = %if.end513
  br label %if.end515

if.end515:                                        ; preds = %if.end514, %if.end400
  br label %if.end554

if.else516:                                       ; preds = %lor.lhs.false302
  %341 = load i8, i8* %class, align 1
  %conv517 = zext i8 %341 to i32
  %cmp518 = icmp eq i32 %conv517, 0
  br i1 %cmp518, label %if.then520, label %if.else551

if.then520:                                       ; preds = %if.else516
  %342 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code521 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %342, i32 0, i32 0
  %343 = load i8, i8* %code521, align 4
  %conv522 = zext i8 %343 to i32
  %and523 = and i32 %conv522, 224
  %conv524 = trunc i32 %and523 to i8
  store i8 %conv524, i8* %mode, align 1
  %344 = load i8, i8* %mode, align 1
  %conv525 = zext i8 %344 to i32
  %cmp526 = icmp eq i32 %conv525, 32
  br i1 %cmp526, label %if.then532, label %lor.lhs.false528

lor.lhs.false528:                                 ; preds = %if.then520
  %345 = load i8, i8* %mode, align 1
  %conv529 = zext i8 %345 to i32
  %cmp530 = icmp eq i32 %conv529, 64
  br i1 %cmp530, label %if.then532, label %if.else537

if.then532:                                       ; preds = %lor.lhs.false528, %if.then520
  %346 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %347 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call533 = call i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %346, %struct.bpf_insn* noundef %347) #14
  store i32 %call533, i32* %err, align 4
  %348 = load i32, i32* %err, align 4
  %tobool534 = icmp ne i32 %348, 0
  br i1 %tobool534, label %if.then535, label %if.end536

if.then535:                                       ; preds = %if.then532
  %349 = load i32, i32* %err, align 4
  store i32 %349, i32* %retval, align 4
  br label %return

if.end536:                                        ; preds = %if.then532
  br label %if.end550

if.else537:                                       ; preds = %lor.lhs.false528
  %350 = load i8, i8* %mode, align 1
  %conv538 = zext i8 %350 to i32
  %cmp539 = icmp eq i32 %conv538, 0
  br i1 %cmp539, label %if.then541, label %if.else548

if.then541:                                       ; preds = %if.else537
  %351 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %352 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call542 = call i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %351, %struct.bpf_insn* noundef %352) #14
  store i32 %call542, i32* %err, align 4
  %353 = load i32, i32* %err, align 4
  %tobool543 = icmp ne i32 %353, 0
  br i1 %tobool543, label %if.then544, label %if.end545

if.then544:                                       ; preds = %if.then541
  %354 = load i32, i32* %err, align 4
  store i32 %354, i32* %retval, align 4
  br label %return

if.end545:                                        ; preds = %if.then541
  %355 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx546 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %355, i32 0, i32 0
  %356 = load i32, i32* %insn_idx546, align 8
  %inc547 = add i32 %356, 1
  store i32 %inc547, i32* %insn_idx546, align 8
  %357 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @sanitize_mark_insn_seen(%struct.bpf_verifier_env* noundef %357) #14
  br label %if.end549

if.else548:                                       ; preds = %if.else537
  %358 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %359 = bitcast %struct.bpf_verifier_env* %358 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %359, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.225, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end549:                                        ; preds = %if.end545
  br label %if.end550

if.end550:                                        ; preds = %if.end549, %if.end536
  br label %if.end553

if.else551:                                       ; preds = %if.else516
  %360 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %361 = bitcast %struct.bpf_verifier_env* %360 to i8*
  %362 = load i8, i8* %class, align 1
  %conv552 = zext i8 %362 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %361, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.226, i64 0, i64 0), i32 noundef %conv552) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end553:                                        ; preds = %if.end550
  br label %if.end554

if.end554:                                        ; preds = %if.end553, %if.end515
  br label %if.end555

if.end555:                                        ; preds = %if.end554, %if.end297
  br label %if.end556

if.end556:                                        ; preds = %if.end555, %if.end237
  br label %if.end557

if.end557:                                        ; preds = %if.end556, %if.end155
  br label %if.end558

if.end558:                                        ; preds = %if.end557, %if.end106
  %363 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx559 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %363, i32 0, i32 0
  %364 = load i32, i32* %insn_idx559, align 8
  %inc560 = add i32 %364, 1
  store i32 %inc560, i32* %insn_idx559, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end505
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.else551, %if.else548, %if.then544, %if.then535, %if.then511, %if.then504, %if.then493, %if.then489, %if.then484, %if.then476, %if.then471, %if.then433, %if.then399, %if.then373, %if.then358, %if.then296, %if.then270, %if.then263, %if.then255, %if.then235, %if.then223, %if.then199, %if.then191, %if.then183, %if.then170, %if.then153, %if.then143, %if.then121, %if.then115, %if.then105, %if.then90, %if.then39, %if.then15, %if.then9, %if.then
  %365 = load i32, i32* %retval, align 4
  ret i32 %365
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext %free_self) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  %free_self.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %frombool = zext i1 %free_self to i8
  store i8 %frombool, i8* %free_self.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %5) #14
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame1, i64 0, i64 %idxprom2
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %9) #14
  %10 = load i8, i8* %free_self.addr, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %12 = bitcast %struct.bpf_verifier_state* %11 to i8*
  call void @kfree(i8* noundef %12) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @pop_stack(%struct.bpf_verifier_env* noundef %env, i32* noundef %prev_insn_idx, i32* noundef %insn_idx, i1 noundef zeroext %pop_log) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prev_insn_idx.addr = alloca i32*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %pop_log.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %head = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %prev_insn_idx, i32** %prev_insn_idx.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %frombool = zext i1 %pop_log to i8
  store i8 %frombool, i8* %pop_log.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 4
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head1, align 8
  store %struct.bpf_verifier_stack_elem* %3, %struct.bpf_verifier_stack_elem** %head, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head2, align 8
  %cmp = icmp eq %struct.bpf_verifier_stack_elem* %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %8 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %8, i32 0, i32 0
  %call = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %7, %struct.bpf_verifier_state* noundef %st) #14
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then3
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %11 = load i8, i8* %pop_log.addr, align 1
  %tobool8 = trunc i8 %11 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 26
  %13 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %13, i32 0, i32 4
  %14 = load i32, i32* %log_pos, align 8
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log, i32 noundef %14) #14
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %15 = load i32*, i32** %insn_idx.addr, align 8
  %tobool11 = icmp ne i32* %15, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %16 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %insn_idx13 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %16, i32 0, i32 1
  %17 = load i32, i32* %insn_idx13, align 8
  %18 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %17, i32* %18, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %19 = load i32*, i32** %prev_insn_idx.addr, align 8
  %tobool15 = icmp ne i32* %19, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %20 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %prev_insn_idx17 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %20, i32 0, i32 2
  %21 = load i32, i32* %prev_insn_idx17, align 4
  %22 = load i32*, i32** %prev_insn_idx.addr, align 8
  store i32 %21, i32* %22, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  %23 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %23, i32 0, i32 3
  %24 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %next, align 8
  store %struct.bpf_verifier_stack_elem* %24, %struct.bpf_verifier_stack_elem** %elem, align 8
  %25 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st19 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %25, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %st19, i1 noundef zeroext false) #14
  %26 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %27 = bitcast %struct.bpf_verifier_stack_elem* %26 to i8*
  call void @kfree(i8* noundef %27) #14
  %28 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %28, %struct.bpf_verifier_stack_elem** %head20, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 5
  %31 = load i32, i32* %stack_size, align 8
  %dec = add i32 %31, -1
  store i32 %dec, i32* %stack_size, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then5, %if.then
  %32 = load i32, i32* %retval, align 4
  ret i32 %32
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log, i32 noundef %new_pos) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %new_pos.addr = alloca i32, align 4
  %zero = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__ptr_pu = alloca i8*, align 8
  %__val_pu = alloca i8, align 1
  %tmp2 = alloca i64, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i32 %new_pos, i32* %new_pos.addr, align 4
  store i8 0, i8* %zero, align 1
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %0) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end5

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %new_pos.addr, align 4
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 3
  store i32 %1, i32* %len_used, align 8
  call void @might_fault() #14
  %3 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %3, i32 0, i32 2
  %4 = load i8*, i8** %ubuf, align 8
  %5 = load i32, i32* %new_pos.addr, align 4
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr i8, i8* %4, i64 %idx.ext
  store i8* %add.ptr, i8** %__ptr_pu, align 8
  %6 = load i8, i8* %zero, align 1
  store i8 %6, i8* %__val_pu, align 1
  %7 = call i64 @llvm.read_register.i64(metadata !0)
  %8 = load i8*, i8** %__ptr_pu, align 8
  %9 = load i8, i8* %__val_pu, align 1
  %10 = call { i8*, i64 } asm sideeffect "call __put_user_${4:P}", "={cx},={rsp},0,{rax},i,{rsp},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %8, i8 %9, i64 1, i64 %7) #13, !srcloc !34
  %asmresult = extractvalue { i8*, i64 } %10, 0
  %asmresult1 = extractvalue { i8*, i64 } %10, 1
  %11 = ptrtoint i8* %asmresult to i64
  %12 = trunc i64 %11 to i32
  store i32 %12, i32* %__ret_pu, align 4
  call void @llvm.write_register.i64(metadata !0, i64 %asmresult1)
  %13 = load i32, i32* %__ret_pu, align 4
  %conv = sext i32 %13 to i64
  store i64 %conv, i64* %tmp2, align 8
  %14 = load i64, i64* %tmp2, align 8
  store i64 %14, i64* %tmp, align 8
  %15 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %15, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf4 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %16, i32 0, i32 2
  store i8* null, i8** %ubuf4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then, %if.then3, %if.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_states(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sln = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 10
  %1 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  store %struct.bpf_verifier_state_list* %1, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %3, i32 0, i32 1
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  store %struct.bpf_verifier_state_list* %4, %struct.bpf_verifier_state_list** %sln, align 8
  %5 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %5, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext false) #14
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %7 = bitcast %struct.bpf_verifier_state_list* %6 to i8*
  call void @kfree(i8* noundef %7) #14
  %8 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %8, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 10
  store %struct.bpf_verifier_state_list* null, %struct.bpf_verifier_state_list** %free_list1, align 8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 9
  %11 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %tobool2 = icmp ne %struct.bpf_verifier_state_list** %11, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.end

if.end:                                           ; preds = %while.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %13) #14
  %cmp = icmp ult i32 %12, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 9
  %15 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states3, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %15, i64 %idxprom
  %17 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %arrayidx, align 8
  store %struct.bpf_verifier_state_list* %17, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond4

while.cond4:                                      ; preds = %while.body6, %for.body
  %18 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool5 = icmp ne %struct.bpf_verifier_state_list* %18, null
  br i1 %tobool5, label %while.body6, label %while.end9

while.body6:                                      ; preds = %while.cond4
  %19 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next7 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %19, i32 0, i32 1
  %20 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next7, align 8
  store %struct.bpf_verifier_state_list* %20, %struct.bpf_verifier_state_list** %sln, align 8
  %21 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state8 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %21, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state8, i1 noundef zeroext false) #14
  %22 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %23 = bitcast %struct.bpf_verifier_state_list* %22 to i8*
  call void @kfree(i8* noundef %23) #14
  %24 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %24, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond4

while.end9:                                       ; preds = %while.cond4
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 9
  %26 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states10, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %27 to i64
  %arrayidx12 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %26, i64 %idxprom11
  store %struct.bpf_verifier_state_list* null, %struct.bpf_verifier_state_list** %arrayidx12, align 8
  br label %for.inc

for.inc:                                          ; preds = %while.end9
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_reg_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %4 = load i32, i32* %i, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3, i32 noundef %4) #14
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 17
  store i32 0, i32* %live, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i64 %idxprom2
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 14
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %parent, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idxprom4
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx5, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 10
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 0
  store i32 6, i32* %type, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef 10) #14
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 2
  %16 = load i32, i32* %frameno, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx7 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i64 10
  %frameno8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx7, i32 0, i32 15
  store i32 %16, i32* %frameno8, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1570, i32 2305, i64 12) #13, !srcloc !35
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  call void asm sideeffect "468:\0A\09.pushsection .discard.reachable\0A\09.long 468b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !36
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %2, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %3, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.205, i64 0, i64 0), i32 noundef %6) #14
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %7 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %7, 10
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %add.ptr) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %14 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %14 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i64 %idx.ext24
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %add.ptr25) #14
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_state_visited(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %new_sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %pprev = alloca %struct.bpf_verifier_state_list**, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %new = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %states_cnt = alloca i32, align 4
  %add_new_state = alloca i8, align 1
  %frame = alloca %struct.bpf_func_state*, align 8
  %br = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp123 = alloca i64, align 8
  %__ret_do_once171 = alloca i8, align 1
  %__ret_warn_on194 = alloca i32, align 4
  %tmp219 = alloca i64, align 8
  %tmp227 = alloca i64, align 8
  %frame284 = alloca %struct.bpf_func_state*, align 8
  %newframe = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  store i32 0, i32* %states_cnt, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 7
  %3 = load i8, i8* %test_state_freq, align 1
  %tobool = trunc i8 %3 to i1
  %4 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %tobool1 = icmp ne i32 %cond, 0
  %frombool = zext i1 %tobool1 to i8
  store i8 %frombool, i8* %add_new_state, align 1
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 1
  %6 = load i32, i32* %prev_insn_idx, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 8
  store i32 %6, i32* %last_insn_idx, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 24
  %9 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %10 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %9, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 8
  %11 = load i8, i8* %prune_point, align 8
  %tobool2 = trunc i8 %11 to i1
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 35
  %13 = load i32, i32* %jmps_processed, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 34
  %15 = load i32, i32* %prev_jmps_processed, align 8
  %sub = sub i32 %13, %15
  %cmp = icmp uge i32 %sub, 2
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 33
  %17 = load i32, i32* %insn_processed, align 4
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 32
  %19 = load i32, i32* %prev_insn_processed, align 8
  %sub3 = sub i32 %17, %19
  %cmp4 = icmp uge i32 %sub3, 8
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  store i8 1, i8* %add_new_state, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load i32, i32* %insn_idx.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %20, i32 noundef %21) #14
  store %struct.bpf_verifier_state_list** %call, %struct.bpf_verifier_state_list*** %pprev, align 8
  %22 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %23 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %22, align 8
  store %struct.bpf_verifier_state_list* %23, %struct.bpf_verifier_state_list** %sl, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %insn_idx.addr, align 4
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clean_live_states(%struct.bpf_verifier_env* noundef %24, i32 noundef %25, %struct.bpf_verifier_state* noundef %26) #14
  br label %while.cond

while.cond:                                       ; preds = %next136, %if.end134, %if.end6
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool7 = icmp ne %struct.bpf_verifier_state_list* %27, null
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %28 = load i32, i32* %states_cnt, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %states_cnt, align 4
  %29 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %29, i32 0, i32 0
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 3
  %30 = load i32, i32* %insn_idx8, align 4
  %31 = load i32, i32* %insn_idx.addr, align 4
  %cmp9 = icmp ne i32 %30, %31
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  br label %next136

if.end11:                                         ; preds = %while.body
  %32 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state12 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %32, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state12, i32 0, i32 2
  %33 = load i32, i32* %branches, align 8
  %tobool13 = icmp ne i32 %33, 0
  br i1 %tobool13, label %if.then14, label %if.end48

if.then14:                                        ; preds = %if.end11
  %34 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state15 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %34, i32 0, i32 0
  %frame16 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state15, i32 0, i32 0
  %35 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state17 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %35, i32 0, i32 0
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state17, i32 0, i32 4
  %36 = load i32, i32* %curframe, align 8
  %idxprom18 = zext i32 %36 to i64
  %arrayidx19 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame16, i64 0, i64 %idxprom18
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx19, align 8
  store %struct.bpf_func_state* %37, %struct.bpf_func_state** %frame, align 8
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 6
  %39 = load i8, i8* %in_async_callback_fn, align 1
  %tobool20 = trunc i8 %39 to i1
  br i1 %tobool20, label %land.lhs.true21, label %if.else

land.lhs.true21:                                  ; preds = %if.then14
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %async_entry_cnt = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 4
  %41 = load i32, i32* %async_entry_cnt, align 4
  %42 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %42, i32 0, i32 0
  %43 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe23 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %43, i32 0, i32 4
  %44 = load i32, i32* %curframe23, align 8
  %idxprom24 = zext i32 %44 to i64
  %arrayidx25 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame22, i64 0, i64 %idxprom24
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx25, align 8
  %async_entry_cnt26 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 4
  %46 = load i32, i32* %async_entry_cnt26, align 4
  %cmp27 = icmp ne i32 %41, %46
  br i1 %cmp27, label %if.then28, label %if.else

if.then28:                                        ; preds = %land.lhs.true21
  br label %if.end36

if.else:                                          ; preds = %land.lhs.true21, %if.then14
  %47 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state29 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %47, i32 0, i32 0
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call30 = call zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %state29, %struct.bpf_verifier_state* noundef %48) #14
  br i1 %call30, label %land.lhs.true31, label %if.end35

land.lhs.true31:                                  ; preds = %if.else
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state32 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %50, i32 0, i32 0
  %51 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call33 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %49, %struct.bpf_verifier_state* noundef %state32, %struct.bpf_verifier_state* noundef %51) #14
  br i1 %call33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %land.lhs.true31
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %52, i32 noundef %53, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.215, i64 0, i64 0)) #14
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.227, i64 0, i64 0), i32 noundef %56) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %land.lhs.true31, %if.else
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then28
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed37 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 35
  %58 = load i32, i32* %jmps_processed37, align 4
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed38 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %59, i32 0, i32 34
  %60 = load i32, i32* %prev_jmps_processed38, align 8
  %sub39 = sub i32 %58, %60
  %cmp40 = icmp ult i32 %sub39, 20
  br i1 %cmp40, label %land.lhs.true41, label %if.end47

land.lhs.true41:                                  ; preds = %if.end36
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed42 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 33
  %62 = load i32, i32* %insn_processed42, align 4
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %63, i32 0, i32 32
  %64 = load i32, i32* %prev_insn_processed43, align 8
  %sub44 = sub i32 %62, %64
  %cmp45 = icmp ult i32 %sub44, 100
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %land.lhs.true41
  store i8 0, i8* %add_new_state, align 1
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %land.lhs.true41, %if.end36
  br label %miss

if.end48:                                         ; preds = %if.end11
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state49 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %66, i32 0, i32 0
  %67 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call50 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %65, %struct.bpf_verifier_state* noundef %state49, %struct.bpf_verifier_state* noundef %67) #14
  br i1 %call50, label %if.then51, label %if.end68

if.then51:                                        ; preds = %if.end48
  %68 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %68, i32 0, i32 3
  %69 = load i32, i32* %hit_cnt, align 4
  %inc52 = add i32 %69, 1
  store i32 %inc52, i32* %hit_cnt, align 4
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state53 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %71, i32 0, i32 0
  %72 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call54 = call i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %70, %struct.bpf_verifier_state* noundef %state53, %struct.bpf_verifier_state* noundef %72) #14
  store i32 %call54, i32* %err, align 4
  %73 = load i32, i32* %err, align 4
  %tobool55 = icmp ne i32 %73, 0
  br i1 %tobool55, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then51
  br label %cond.end

cond.false:                                       ; preds = %if.then51
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call56 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %74, %struct.bpf_verifier_state* noundef %75) #14
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond57 = phi i32 [ %73, %cond.true ], [ %call56, %cond.false ]
  store i32 %cond57, i32* %err, align 4
  %76 = load i32, i32* %err, align 4
  %tobool58 = icmp ne i32 %76, 0
  br i1 %tobool58, label %cond.true59, label %cond.false60

cond.true59:                                      ; preds = %cond.end
  br label %cond.end63

cond.false60:                                     ; preds = %cond.end
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state61 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %78, i32 0, i32 0
  %call62 = call i32 @propagate_precision(%struct.bpf_verifier_env* noundef %77, %struct.bpf_verifier_state* noundef %state61) #14
  br label %cond.end63

cond.end63:                                       ; preds = %cond.false60, %cond.true59
  %cond64 = phi i32 [ %76, %cond.true59 ], [ %call62, %cond.false60 ]
  store i32 %cond64, i32* %err, align 4
  %79 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %79, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %cond.end63
  %80 = load i32, i32* %err, align 4
  store i32 %80, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %cond.end63
  store i32 1, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end48
  br label %miss

miss:                                             ; preds = %if.end68, %if.end47
  %81 = load i8, i8* %add_new_state, align 1
  %tobool69 = trunc i8 %81 to i1
  br i1 %tobool69, label %if.then70, label %if.end72

if.then70:                                        ; preds = %miss
  %82 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %82, i32 0, i32 2
  %83 = load i32, i32* %miss_cnt, align 8
  %inc71 = add i32 %83, 1
  store i32 %inc71, i32* %miss_cnt, align 8
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %miss
  %84 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt73 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %84, i32 0, i32 2
  %85 = load i32, i32* %miss_cnt73, align 8
  %86 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt74 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %86, i32 0, i32 3
  %87 = load i32, i32* %hit_cnt74, align 4
  %mul = mul i32 %87, 3
  %add = add i32 %mul, 3
  %cmp75 = icmp sgt i32 %85, %add
  br i1 %cmp75, label %if.then76, label %if.end135

if.then76:                                        ; preds = %if.end72
  %88 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %88, i32 0, i32 1
  %89 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  %90 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  store %struct.bpf_verifier_state_list* %89, %struct.bpf_verifier_state_list** %90, align 8
  %91 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state77 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %91, i32 0, i32 0
  %frame78 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state77, i32 0, i32 0
  %arrayidx79 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame78, i64 0, i64 0
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx79, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %92, i32 0, i32 0
  %arrayidx80 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx80, i32 0, i32 17
  %93 = load i32, i32* %live, align 8
  %and = and i32 %93, 8
  %tobool81 = icmp ne i32 %and, 0
  br i1 %tobool81, label %if.then82, label %if.else131

if.then82:                                        ; preds = %if.then76
  %94 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state83 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %94, i32 0, i32 0
  %branches84 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state83, i32 0, i32 2
  %95 = load i32, i32* %branches84, align 8
  store i32 %95, i32* %br, align 4
  %96 = load i32, i32* %br, align 4
  %tobool85 = icmp ne i32 %96, 0
  %lnot = xor i1 %tobool85, true
  %lnot86 = xor i1 %lnot, true
  %frombool87 = zext i1 %lnot86 to i8
  store i8 %frombool87, i8* %__ret_do_once, align 1
  %97 = load i8, i8* %__ret_do_once, align 1
  %tobool88 = trunc i8 %97 to i1
  br i1 %tobool88, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then82
  %98 = load i8, i8* @is_state_visited.__already_done, align 1
  %tobool89 = trunc i8 %98 to i1
  %lnot90 = xor i1 %tobool89, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then82
  %99 = phi i1 [ false, %if.then82 ], [ %lnot90, %land.rhs ]
  %lnot91 = xor i1 %99, true
  %lnot92 = xor i1 %lnot91, true
  %lnot.ext = zext i1 %lnot92 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool93 = icmp ne i64 %conv, 0
  br i1 %tobool93, label %if.then94, label %if.end122

if.then94:                                        ; preds = %land.end
  store i8 1, i8* @is_state_visited.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %100 = load i32, i32* %__ret_warn_on, align 4
  %tobool95 = icmp ne i32 %100, 0
  %lnot96 = xor i1 %tobool95, true
  %lnot98 = xor i1 %lnot96, true
  %lnot.ext99 = zext i1 %lnot98 to i32
  %conv100 = sext i32 %lnot.ext99 to i64
  %tobool101 = icmp ne i64 %conv100, 0
  br i1 %tobool101, label %if.then102, label %if.end115

if.then102:                                       ; preds = %if.then94
  br label %do.body

do.body:                                          ; preds = %if.then102
  br label %do.body103

do.body103:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body103
  %101 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.228, i64 0, i64 0), i32 noundef %101) #14
  br label %do.body104

do.body104:                                       ; preds = %do.end
  br label %do.body105

do.body105:                                       ; preds = %do.body104
  br label %do.end106

do.end106:                                        ; preds = %do.body105
  br label %do.body107

do.body107:                                       ; preds = %do.end106
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 12672, i32 2313, i64 12) #13, !srcloc !37
  br label %do.end108

do.end108:                                        ; preds = %do.body107
  call void asm sideeffect "549:\0A\09.pushsection .discard.reachable\0A\09.long 549b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !38
  br label %do.body109

do.body109:                                       ; preds = %do.end108
  br label %do.end110

do.end110:                                        ; preds = %do.body109
  br label %do.end111

do.end111:                                        ; preds = %do.end110
  br label %do.body112

do.body112:                                       ; preds = %do.end111
  br label %do.end113

do.end113:                                        ; preds = %do.body112
  br label %do.end114

do.end114:                                        ; preds = %do.end113
  br label %if.end115

if.end115:                                        ; preds = %do.end114, %if.then94
  %102 = load i32, i32* %__ret_warn_on, align 4
  %tobool116 = icmp ne i32 %102, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  store i64 %conv121, i64* %tmp, align 8
  %103 = load i64, i64* %tmp, align 8
  br label %if.end122

if.end122:                                        ; preds = %if.end115, %land.end
  %104 = load i8, i8* %__ret_do_once, align 1
  %tobool124 = trunc i8 %104 to i1
  %lnot125 = xor i1 %tobool124, true
  %lnot127 = xor i1 %lnot125, true
  %lnot.ext128 = zext i1 %lnot127 to i32
  %conv129 = sext i32 %lnot.ext128 to i64
  store i64 %conv129, i64* %tmp123, align 8
  %105 = load i64, i64* %tmp123, align 8
  %106 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state130 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %106, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state130, i1 noundef zeroext false) #14
  %107 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %108 = bitcast %struct.bpf_verifier_state_list* %107 to i8*
  call void @kfree(i8* noundef %108) #14
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 39
  %110 = load i32, i32* %peak_states, align 8
  %dec = add i32 %110, -1
  store i32 %dec, i32* %peak_states, align 8
  br label %if.end134

if.else131:                                       ; preds = %if.then76
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %111, i32 0, i32 10
  %112 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  %113 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next132 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %113, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %112, %struct.bpf_verifier_state_list** %next132, align 8
  %114 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list133 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 10
  store %struct.bpf_verifier_state_list* %114, %struct.bpf_verifier_state_list** %free_list133, align 8
  br label %if.end134

if.end134:                                        ; preds = %if.else131, %if.end122
  %116 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %117 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %116, align 8
  store %struct.bpf_verifier_state_list* %117, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

if.end135:                                        ; preds = %if.end72
  br label %next136

next136:                                          ; preds = %if.end135, %if.then10
  %118 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next137 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %118, i32 0, i32 1
  store %struct.bpf_verifier_state_list** %next137, %struct.bpf_verifier_state_list*** %pprev, align 8
  %119 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %120 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %119, align 8
  store %struct.bpf_verifier_state_list* %120, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 37
  %122 = load i32, i32* %max_states_per_insn, align 8
  %123 = load i32, i32* %states_cnt, align 4
  %cmp138 = icmp ult i32 %122, %123
  br i1 %cmp138, label %if.then140, label %if.end142

if.then140:                                       ; preds = %while.end
  %124 = load i32, i32* %states_cnt, align 4
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn141 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %125, i32 0, i32 37
  store i32 %124, i32* %max_states_per_insn141, align 8
  br label %if.end142

if.end142:                                        ; preds = %if.then140, %while.end
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %126, i32 0, i32 20
  %127 = load i8, i8* %bpf_capable, align 8
  %tobool143 = trunc i8 %127 to i1
  br i1 %tobool143, label %if.end149, label %land.lhs.true144

land.lhs.true144:                                 ; preds = %if.end142
  %128 = load i32, i32* %states_cnt, align 4
  %cmp145 = icmp sgt i32 %128, 64
  br i1 %cmp145, label %if.then147, label %if.end149

if.then147:                                       ; preds = %land.lhs.true144
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %130 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call148 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %129, %struct.bpf_verifier_state* noundef %130) #14
  store i32 %call148, i32* %retval, align 4
  br label %return

if.end149:                                        ; preds = %land.lhs.true144, %if.end142
  %131 = load i8, i8* %add_new_state, align 1
  %tobool150 = trunc i8 %131 to i1
  br i1 %tobool150, label %if.end153, label %if.then151

if.then151:                                       ; preds = %if.end149
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %133 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call152 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %132, %struct.bpf_verifier_state* noundef %133) #14
  store i32 %call152, i32* %retval, align 4
  br label %return

if.end153:                                        ; preds = %if.end149
  %call154 = call i8* @kzalloc(i64 noundef 136, i32 noundef 3264) #14
  %134 = bitcast i8* %call154 to %struct.bpf_verifier_state_list*
  store %struct.bpf_verifier_state_list* %134, %struct.bpf_verifier_state_list** %new_sl, align 8
  %135 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %tobool155 = icmp ne %struct.bpf_verifier_state_list* %135, null
  br i1 %tobool155, label %if.end157, label %if.then156

if.then156:                                       ; preds = %if.end153
  store i32 -12, i32* %retval, align 4
  br label %return

if.end157:                                        ; preds = %if.end153
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %136, i32 0, i32 38
  %137 = load i32, i32* %total_states, align 4
  %inc158 = add i32 %137, 1
  store i32 %inc158, i32* %total_states, align 4
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states159 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %138, i32 0, i32 39
  %139 = load i32, i32* %peak_states159, align 8
  %inc160 = add i32 %139, 1
  store i32 %inc160, i32* %peak_states159, align 8
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed161 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %140, i32 0, i32 35
  %141 = load i32, i32* %jmps_processed161, align 4
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed162 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %142, i32 0, i32 34
  store i32 %141, i32* %prev_jmps_processed162, align 8
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed163 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %143, i32 0, i32 33
  %144 = load i32, i32* %insn_processed163, align 4
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed164 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %145, i32 0, i32 32
  store i32 %144, i32* %prev_insn_processed164, align 8
  %146 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %state165 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %146, i32 0, i32 0
  store %struct.bpf_verifier_state* %state165, %struct.bpf_verifier_state** %new, align 8
  %147 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %148 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call166 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %147, %struct.bpf_verifier_state* noundef %148) #14
  store i32 %call166, i32* %err, align 4
  %149 = load i32, i32* %err, align 4
  %tobool167 = icmp ne i32 %149, 0
  br i1 %tobool167, label %if.then168, label %if.end169

if.then168:                                       ; preds = %if.end157
  %150 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %150, i1 noundef zeroext false) #14
  %151 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %152 = bitcast %struct.bpf_verifier_state_list* %151 to i8*
  call void @kfree(i8* noundef %152) #14
  %153 = load i32, i32* %err, align 4
  store i32 %153, i32* %retval, align 4
  br label %return

if.end169:                                        ; preds = %if.end157
  %154 = load i32, i32* %insn_idx.addr, align 4
  %155 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %insn_idx170 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %155, i32 0, i32 3
  store i32 %154, i32* %insn_idx170, align 4
  %156 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches172 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %156, i32 0, i32 2
  %157 = load i32, i32* %branches172, align 8
  %cmp173 = icmp ne i32 %157, 1
  %lnot175 = xor i1 %cmp173, true
  %lnot177 = xor i1 %lnot175, true
  %frombool179 = zext i1 %lnot177 to i8
  store i8 %frombool179, i8* %__ret_do_once171, align 1
  %158 = load i8, i8* %__ret_do_once171, align 1
  %tobool180 = trunc i8 %158 to i1
  br i1 %tobool180, label %land.rhs182, label %land.end186

land.rhs182:                                      ; preds = %if.end169
  %159 = load i8, i8* @is_state_visited.__already_done.229, align 1
  %tobool183 = trunc i8 %159 to i1
  %lnot184 = xor i1 %tobool183, true
  br label %land.end186

land.end186:                                      ; preds = %land.rhs182, %if.end169
  %160 = phi i1 [ false, %if.end169 ], [ %lnot184, %land.rhs182 ]
  %lnot187 = xor i1 %160, true
  %lnot189 = xor i1 %lnot187, true
  %lnot.ext190 = zext i1 %lnot189 to i32
  %conv191 = sext i32 %lnot.ext190 to i64
  %tobool192 = icmp ne i64 %conv191, 0
  br i1 %tobool192, label %if.then193, label %if.end226

if.then193:                                       ; preds = %land.end186
  store i8 1, i8* @is_state_visited.__already_done.229, align 1
  store i32 1, i32* %__ret_warn_on194, align 4
  %161 = load i32, i32* %__ret_warn_on194, align 4
  %tobool195 = icmp ne i32 %161, 0
  %lnot196 = xor i1 %tobool195, true
  %lnot198 = xor i1 %lnot196, true
  %lnot.ext199 = zext i1 %lnot198 to i32
  %conv200 = sext i32 %lnot.ext199 to i64
  %tobool201 = icmp ne i64 %conv200, 0
  br i1 %tobool201, label %if.then202, label %if.end218

if.then202:                                       ; preds = %if.then193
  br label %do.body203

do.body203:                                       ; preds = %if.then202
  br label %do.body204

do.body204:                                       ; preds = %do.body203
  br label %do.end205

do.end205:                                        ; preds = %do.body204
  %162 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches206 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %162, i32 0, i32 2
  %163 = load i32, i32* %branches206, align 8
  %164 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.230, i64 0, i64 0), i32 noundef %163, i32 noundef %164) #14
  br label %do.body207

do.body207:                                       ; preds = %do.end205
  br label %do.body208

do.body208:                                       ; preds = %do.body207
  br label %do.end209

do.end209:                                        ; preds = %do.body208
  br label %do.body210

do.body210:                                       ; preds = %do.end209
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 12728, i32 2313, i64 12) #13, !srcloc !39
  br label %do.end211

do.end211:                                        ; preds = %do.body210
  call void asm sideeffect "550:\0A\09.pushsection .discard.reachable\0A\09.long 550b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !40
  br label %do.body212

do.body212:                                       ; preds = %do.end211
  br label %do.end213

do.end213:                                        ; preds = %do.body212
  br label %do.end214

do.end214:                                        ; preds = %do.end213
  br label %do.body215

do.body215:                                       ; preds = %do.end214
  br label %do.end216

do.end216:                                        ; preds = %do.body215
  br label %do.end217

do.end217:                                        ; preds = %do.end216
  br label %if.end218

if.end218:                                        ; preds = %do.end217, %if.then193
  %165 = load i32, i32* %__ret_warn_on194, align 4
  %tobool220 = icmp ne i32 %165, 0
  %lnot221 = xor i1 %tobool220, true
  %lnot223 = xor i1 %lnot221, true
  %lnot.ext224 = zext i1 %lnot223 to i32
  %conv225 = sext i32 %lnot.ext224 to i64
  store i64 %conv225, i64* %tmp219, align 8
  %166 = load i64, i64* %tmp219, align 8
  br label %if.end226

if.end226:                                        ; preds = %if.end218, %land.end186
  %167 = load i8, i8* %__ret_do_once171, align 1
  %tobool228 = trunc i8 %167 to i1
  %lnot229 = xor i1 %tobool228, true
  %lnot231 = xor i1 %lnot229, true
  %lnot.ext232 = zext i1 %lnot231 to i32
  %conv233 = sext i32 %lnot.ext232 to i64
  store i64 %conv233, i64* %tmp227, align 8
  %168 = load i64, i64* %tmp227, align 8
  %169 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %170 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %170, i32 0, i32 1
  store %struct.bpf_verifier_state* %169, %struct.bpf_verifier_state** %parent, align 8
  %171 = load i32, i32* %insn_idx.addr, align 4
  %172 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %172, i32 0, i32 7
  store i32 %171, i32* %first_insn_idx, align 4
  %173 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %173) #14
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %175 = load i32, i32* %insn_idx.addr, align 4
  %call234 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %174, i32 noundef %175) #14
  %176 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call234, align 8
  %177 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %next235 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %177, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %176, %struct.bpf_verifier_state_list** %next235, align 8
  %178 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %180 = load i32, i32* %insn_idx.addr, align 4
  %call236 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %179, i32 noundef %180) #14
  store %struct.bpf_verifier_state_list* %178, %struct.bpf_verifier_state_list** %call236, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc276, %if.end226
  %181 = load i32, i32* %j, align 4
  %182 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe237 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %182, i32 0, i32 4
  %183 = load i32, i32* %curframe237, align 8
  %cmp238 = icmp ule i32 %181, %183
  br i1 %cmp238, label %for.body, label %for.end278

for.body:                                         ; preds = %for.cond
  %184 = load i32, i32* %j, align 4
  %185 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe240 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %185, i32 0, i32 4
  %186 = load i32, i32* %curframe240, align 8
  %cmp241 = icmp ult i32 %184, %186
  %187 = zext i1 %cmp241 to i64
  %cond243 = select i1 %cmp241, i32 6, i32 0
  store i32 %cond243, i32* %i, align 4
  br label %for.cond244

for.cond244:                                      ; preds = %for.inc, %for.body
  %188 = load i32, i32* %i, align 4
  %cmp245 = icmp slt i32 %188, 10
  br i1 %cmp245, label %for.body247, label %for.end

for.body247:                                      ; preds = %for.cond244
  %189 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame248 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %189, i32 0, i32 0
  %190 = load i32, i32* %j, align 4
  %idxprom249 = sext i32 %190 to i64
  %arrayidx250 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame248, i64 0, i64 %idxprom249
  %191 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx250, align 8
  %regs251 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %191, i32 0, i32 0
  %192 = load i32, i32* %i, align 4
  %idxprom252 = sext i32 %192 to i64
  %arrayidx253 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs251, i64 0, i64 %idxprom252
  %193 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame254 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %193, i32 0, i32 0
  %194 = load i32, i32* %j, align 4
  %idxprom255 = sext i32 %194 to i64
  %arrayidx256 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame254, i64 0, i64 %idxprom255
  %195 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx256, align 8
  %regs257 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %195, i32 0, i32 0
  %196 = load i32, i32* %i, align 4
  %idxprom258 = sext i32 %196 to i64
  %arrayidx259 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs257, i64 0, i64 %idxprom258
  %parent260 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx259, i32 0, i32 14
  store %struct.bpf_reg_state* %arrayidx253, %struct.bpf_reg_state** %parent260, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body247
  %197 = load i32, i32* %i, align 4
  %inc261 = add i32 %197, 1
  store i32 %inc261, i32* %i, align 4
  br label %for.cond244

for.end:                                          ; preds = %for.cond244
  store i32 0, i32* %i, align 4
  br label %for.cond262

for.cond262:                                      ; preds = %for.inc273, %for.end
  %198 = load i32, i32* %i, align 4
  %cmp263 = icmp slt i32 %198, 10
  br i1 %cmp263, label %for.body265, label %for.end275

for.body265:                                      ; preds = %for.cond262
  %199 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame266 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %199, i32 0, i32 0
  %200 = load i32, i32* %j, align 4
  %idxprom267 = sext i32 %200 to i64
  %arrayidx268 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame266, i64 0, i64 %idxprom267
  %201 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx268, align 8
  %regs269 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %201, i32 0, i32 0
  %202 = load i32, i32* %i, align 4
  %idxprom270 = sext i32 %202 to i64
  %arrayidx271 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs269, i64 0, i64 %idxprom270
  %live272 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx271, i32 0, i32 17
  store i32 0, i32* %live272, align 8
  br label %for.inc273

for.inc273:                                       ; preds = %for.body265
  %203 = load i32, i32* %i, align 4
  %inc274 = add i32 %203, 1
  store i32 %inc274, i32* %i, align 4
  br label %for.cond262

for.end275:                                       ; preds = %for.cond262
  br label %for.inc276

for.inc276:                                       ; preds = %for.end275
  %204 = load i32, i32* %j, align 4
  %inc277 = add i32 %204, 1
  store i32 %inc277, i32* %j, align 4
  br label %for.cond

for.end278:                                       ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond279

for.cond279:                                      ; preds = %for.inc310, %for.end278
  %205 = load i32, i32* %j, align 4
  %206 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe280 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %206, i32 0, i32 4
  %207 = load i32, i32* %curframe280, align 8
  %cmp281 = icmp ule i32 %205, %207
  br i1 %cmp281, label %for.body283, label %for.end312

for.body283:                                      ; preds = %for.cond279
  %208 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame285 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %208, i32 0, i32 0
  %209 = load i32, i32* %j, align 4
  %idxprom286 = sext i32 %209 to i64
  %arrayidx287 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame285, i64 0, i64 %idxprom286
  %210 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx287, align 8
  store %struct.bpf_func_state* %210, %struct.bpf_func_state** %frame284, align 8
  %211 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame288 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %211, i32 0, i32 0
  %212 = load i32, i32* %j, align 4
  %idxprom289 = sext i32 %212 to i64
  %arrayidx290 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame288, i64 0, i64 %idxprom289
  %213 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx290, align 8
  store %struct.bpf_func_state* %213, %struct.bpf_func_state** %newframe, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond291

for.cond291:                                      ; preds = %for.inc307, %for.body283
  %214 = load i32, i32* %i, align 4
  %215 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame284, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %215, i32 0, i32 9
  %216 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %216, 8
  %cmp292 = icmp slt i32 %214, %div
  br i1 %cmp292, label %for.body294, label %for.end309

for.body294:                                      ; preds = %for.cond291
  %217 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame284, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %217, i32 0, i32 10
  %218 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %219 = load i32, i32* %i, align 4
  %idxprom295 = sext i32 %219 to i64
  %arrayidx296 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %218, i64 %idxprom295
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx296, i32 0, i32 0
  %live297 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  store i32 0, i32* %live297, align 8
  %220 = load %struct.bpf_func_state*, %struct.bpf_func_state** %newframe, align 8
  %stack298 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %220, i32 0, i32 10
  %221 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack298, align 8
  %222 = load i32, i32* %i, align 4
  %idxprom299 = sext i32 %222 to i64
  %arrayidx300 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %221, i64 %idxprom299
  %spilled_ptr301 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx300, i32 0, i32 0
  %223 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame284, align 8
  %stack302 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %223, i32 0, i32 10
  %224 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack302, align 8
  %225 = load i32, i32* %i, align 4
  %idxprom303 = sext i32 %225 to i64
  %arrayidx304 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %224, i64 %idxprom303
  %spilled_ptr305 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx304, i32 0, i32 0
  %parent306 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr305, i32 0, i32 14
  store %struct.bpf_reg_state* %spilled_ptr301, %struct.bpf_reg_state** %parent306, align 8
  br label %for.inc307

for.inc307:                                       ; preds = %for.body294
  %226 = load i32, i32* %i, align 4
  %inc308 = add i32 %226, 1
  store i32 %inc308, i32* %i, align 4
  br label %for.cond291

for.end309:                                       ; preds = %for.cond291
  br label %for.inc310

for.inc310:                                       ; preds = %for.end309
  %227 = load i32, i32* %j, align 4
  %inc311 = add i32 %227, 1
  store i32 %inc311, i32* %j, align 4
  br label %for.cond279

for.end312:                                       ; preds = %for.cond279
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end312, %if.then168, %if.then156, %if.then151, %if.then147, %if.end67, %if.then66, %if.then34, %if.then
  %228 = load i32, i32* %retval, align 4
  ret i32 %228
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @signal_pending(%struct.task_struct* noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* noundef %0, i32 noundef 17) #14
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call3 = call i32 @task_sigpending(%struct.task_struct* noundef %1) #14
  store i32 %call3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @___might_sleep(i8* noundef %file, i32 noundef %line, i32 noundef %preempt_offset) #0 {
entry:
  %file.addr = alloca i8*, align 8
  %line.addr = alloca i32, align 4
  %preempt_offset.addr = alloca i32, align 4
  store i8* %file, i8** %file.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  store i32 %preempt_offset, i32* %preempt_offset.addr, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @_cond_resched() #0 {
entry:
  %call = call i32 @__cond_resched() #14
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @disasm_kfunc_name(i8* noundef %data, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i8*, align 8
  %data.addr = alloca i8*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %func = alloca %struct.btf_type*, align 8
  store i8* %data, i8** %data.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv = zext i8 %bf.lshr to i32
  %cmp = icmp ne i32 %conv, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 3
  %3 = load i32, i32* %imm, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %1, i32 noundef %3) #14
  store %struct.btf_type* %call, %struct.btf_type** %func, align 8
  %4 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %5 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %5, i32 0, i32 0
  %6 = load i32, i32* %name_off, align 4
  %call2 = call i8* @btf_name_by_offset(%struct.btf* noundef %4, i32 noundef %6) #14
  store i8* %call2, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i8*, i8** %retval, align 8
  ret i8* %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @print_bpf_insn(%struct.bpf_insn_cbs* noundef, %struct.bpf_insn* noundef, i1 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_mark_insn_seen(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 6
  %3 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 30
  %5 = load i32, i32* %pass_cnt, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 24
  %7 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 0
  %9 = load i32, i32* %insn_idx, align 8
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %7, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  store i32 %5, i32* %seen, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_alu_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %src_reg141 = alloca %struct.bpf_reg_state*, align 8
  %dst_reg146 = alloca %struct.bpf_reg_state*, align 8
  %size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load i8, i8* %opcode, align 1
  %conv2 = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv2, 208
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i8, i8* %opcode, align 1
  %conv4 = zext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, 128
  br i1 %cmp5, label %if.then, label %if.else83

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i8, i8* %opcode, align 1
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 128
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code11 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code11, align 4
  %conv12 = zext i8 %7 to i32
  %and13 = and i32 %conv12, 8
  %cmp14 = icmp ne i32 %and13, 0
  br i1 %cmp14, label %if.then27, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.then10
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp ne i32 %conv17, 0
  br i1 %cmp18, label %if.then27, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false16
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 2
  %10 = load i16, i16* %off, align 2
  %conv21 = sext i16 %10 to i32
  %cmp22 = icmp ne i32 %conv21, 0
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %lor.lhs.false20
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 3
  %12 = load i32, i32* %imm, align 4
  %cmp25 = icmp ne i32 %12, 0
  br i1 %cmp25, label %if.then27, label %if.end

if.then27:                                        ; preds = %lor.lhs.false24, %lor.lhs.false20, %lor.lhs.false16, %if.then10
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.247, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false24
  br label %if.end58

if.else:                                          ; preds = %if.then
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load29 = load i8, i8* %src_reg28, align 1
  %bf.lshr30 = lshr i8 %bf.load29, 4
  %conv31 = zext i8 %bf.lshr30 to i32
  %cmp32 = icmp ne i32 %conv31, 0
  br i1 %cmp32, label %if.then56, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %if.else
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 2
  %17 = load i16, i16* %off35, align 2
  %conv36 = sext i16 %17 to i32
  %cmp37 = icmp ne i32 %conv36, 0
  br i1 %cmp37, label %if.then56, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 3
  %19 = load i32, i32* %imm40, align 4
  %cmp41 = icmp ne i32 %19, 16
  br i1 %cmp41, label %land.lhs.true, label %lor.lhs.false50

land.lhs.true:                                    ; preds = %lor.lhs.false39
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 3
  %21 = load i32, i32* %imm43, align 4
  %cmp44 = icmp ne i32 %21, 32
  br i1 %cmp44, label %land.lhs.true46, label %lor.lhs.false50

land.lhs.true46:                                  ; preds = %land.lhs.true
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 3
  %23 = load i32, i32* %imm47, align 4
  %cmp48 = icmp ne i32 %23, 64
  br i1 %cmp48, label %if.then56, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true46, %land.lhs.true, %lor.lhs.false39
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 0
  %25 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %25 to i32
  %and53 = and i32 %conv52, 7
  %cmp54 = icmp eq i32 %and53, 7
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %lor.lhs.false50, %land.lhs.true46, %lor.lhs.false34, %if.else
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.248, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %lor.lhs.false50
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load59 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load59, 15
  %conv60 = zext i8 %bf.clear to i32
  %call61 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %28, i32 noundef %conv60, i32 noundef 0) #14
  store i32 %call61, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end58
  %31 = load i32, i32* %err, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.end58
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load65 = load i8, i8* %dst_reg64, align 1
  %bf.clear66 = and i8 %bf.load65, 15
  %conv67 = zext i8 %bf.clear66 to i32
  %call68 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv67) #14
  br i1 %call68, label %if.then69, label %if.end74

if.then69:                                        ; preds = %if.end63
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load71 = load i8, i8* %dst_reg70, align 1
  %bf.clear72 = and i8 %bf.load71, 15
  %conv73 = zext i8 %bf.clear72 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.249, i64 0, i64 0), i32 noundef %conv73) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end63
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load76 = load i8, i8* %dst_reg75, align 1
  %bf.clear77 = and i8 %bf.load76, 15
  %conv78 = zext i8 %bf.clear77 to i32
  %call79 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %37, i32 noundef %conv78, i32 noundef 1) #14
  store i32 %call79, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool80 = icmp ne i32 %39, 0
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end74
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.end74
  br label %if.end345

if.else83:                                        ; preds = %lor.lhs.false
  %41 = load i8, i8* %opcode, align 1
  %conv84 = zext i8 %41 to i32
  %cmp85 = icmp eq i32 %conv84, 176
  br i1 %cmp85, label %if.then87, label %if.else228

if.then87:                                        ; preds = %if.else83
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code88 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code88, align 4
  %conv89 = zext i8 %43 to i32
  %and90 = and i32 %conv89, 8
  %cmp91 = icmp eq i32 %and90, 8
  br i1 %cmp91, label %if.then93, label %if.else112

if.then93:                                        ; preds = %if.then87
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm94, align 4
  %cmp95 = icmp ne i32 %45, 0
  br i1 %cmp95, label %if.then102, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.then93
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 2
  %47 = load i16, i16* %off98, align 2
  %conv99 = sext i16 %47 to i32
  %cmp100 = icmp ne i32 %conv99, 0
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %lor.lhs.false97, %if.then93
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.250, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %lor.lhs.false97
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg104, align 1
  %bf.lshr106 = lshr i8 %bf.load105, 4
  %conv107 = zext i8 %bf.lshr106 to i32
  %call108 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %50, i32 noundef %conv107, i32 noundef 0) #14
  store i32 %call108, i32* %err, align 4
  %52 = load i32, i32* %err, align 4
  %tobool109 = icmp ne i32 %52, 0
  br i1 %tobool109, label %if.then110, label %if.end111

if.then110:                                       ; preds = %if.end103
  %53 = load i32, i32* %err, align 4
  store i32 %53, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %if.end103
  br label %if.end126

if.else112:                                       ; preds = %if.then87
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %54, i32 0, i32 1
  %bf.load114 = load i8, i8* %src_reg113, align 1
  %bf.lshr115 = lshr i8 %bf.load114, 4
  %conv116 = zext i8 %bf.lshr115 to i32
  %cmp117 = icmp ne i32 %conv116, 0
  br i1 %cmp117, label %if.then124, label %lor.lhs.false119

lor.lhs.false119:                                 ; preds = %if.else112
  %55 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off120 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %55, i32 0, i32 2
  %56 = load i16, i16* %off120, align 2
  %conv121 = sext i16 %56 to i32
  %cmp122 = icmp ne i32 %conv121, 0
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %lor.lhs.false119, %if.else112
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.250, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end125:                                        ; preds = %lor.lhs.false119
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.end111
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg127 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 1
  %bf.load128 = load i8, i8* %dst_reg127, align 1
  %bf.clear129 = and i8 %bf.load128, 15
  %conv130 = zext i8 %bf.clear129 to i32
  %call131 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %59, i32 noundef %conv130, i32 noundef 2) #14
  store i32 %call131, i32* %err, align 4
  %61 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %61, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end126
  %62 = load i32, i32* %err, align 4
  store i32 %62, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end126
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %63, i32 0, i32 0
  %64 = load i8, i8* %code135, align 4
  %conv136 = zext i8 %64 to i32
  %and137 = and i32 %conv136, 8
  %cmp138 = icmp eq i32 %and137, 8
  br i1 %cmp138, label %if.then140, label %if.else194

if.then140:                                       ; preds = %if.end134
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg142 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %66, i32 0, i32 1
  %bf.load143 = load i8, i8* %src_reg142, align 1
  %bf.lshr144 = lshr i8 %bf.load143, 4
  %conv145 = zext i8 %bf.lshr144 to i32
  %idx.ext = sext i32 %conv145 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %src_reg141, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg147 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %68, i32 0, i32 1
  %bf.load148 = load i8, i8* %dst_reg147, align 1
  %bf.clear149 = and i8 %bf.load148, 15
  %conv150 = zext i8 %bf.clear149 to i32
  %idx.ext151 = sext i32 %conv150 to i64
  %add.ptr152 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i64 %idx.ext151
  store %struct.bpf_reg_state* %add.ptr152, %struct.bpf_reg_state** %dst_reg146, align 8
  %69 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %69, i32 0, i32 0
  %70 = load i8, i8* %code153, align 4
  %conv154 = zext i8 %70 to i32
  %and155 = and i32 %conv154, 7
  %cmp156 = icmp eq i32 %and155, 7
  br i1 %cmp156, label %if.then158, label %if.else166

if.then158:                                       ; preds = %if.then140
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 0
  %72 = load i32, i32* %type, align 8
  %cmp159 = icmp eq i32 %72, 1
  br i1 %cmp159, label %land.lhs.true161, label %if.end165

land.lhs.true161:                                 ; preds = %if.then158
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 3
  %74 = load i32, i32* %id, align 8
  %tobool162 = icmp ne i32 %74, 0
  br i1 %tobool162, label %if.end165, label %if.then163

if.then163:                                       ; preds = %land.lhs.true161
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 15
  %76 = load i32, i32* %id_gen, align 8
  %inc = add i32 %76, 1
  store i32 %inc, i32* %id_gen, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %id164 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 3
  store i32 %inc, i32* %id164, align 8
  br label %if.end165

if.end165:                                        ; preds = %if.then163, %land.lhs.true161, %if.then158
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %80 = bitcast %struct.bpf_reg_state* %78 to i8*
  %81 = bitcast %struct.bpf_reg_state* %79 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %80, i8* align 8 %81, i64 120, i1 false)
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 17
  %83 = load i32, i32* %live, align 8
  %or = or i32 %83, 4
  store i32 %or, i32* %live, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  br label %if.end193

if.else166:                                       ; preds = %if.then140
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %86, i32 0, i32 1
  %bf.load168 = load i8, i8* %src_reg167, align 1
  %bf.lshr169 = lshr i8 %bf.load168, 4
  %conv170 = zext i8 %bf.lshr169 to i32
  %call171 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %85, i32 noundef %conv170) #14
  br i1 %call171, label %if.then172, label %if.else177

if.then172:                                       ; preds = %if.else166
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = bitcast %struct.bpf_verifier_env* %87 to i8*
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg173 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %89, i32 0, i32 1
  %bf.load174 = load i8, i8* %src_reg173, align 1
  %bf.lshr175 = lshr i8 %bf.load174, 4
  %conv176 = zext i8 %bf.lshr175 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %88, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.251, i64 0, i64 0), i32 noundef %conv176) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.else177:                                       ; preds = %if.else166
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 0
  %91 = load i32, i32* %type178, align 8
  %cmp179 = icmp eq i32 %91, 1
  br i1 %cmp179, label %if.then181, label %if.else186

if.then181:                                       ; preds = %if.else177
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %94 = bitcast %struct.bpf_reg_state* %92 to i8*
  %95 = bitcast %struct.bpf_reg_state* %93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %94, i8* align 8 %95, i64 120, i1 false)
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %id182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 3
  store i32 0, i32* %id182, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live183 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 17
  %98 = load i32, i32* %live183, align 8
  %or184 = or i32 %98, 4
  store i32 %or184, i32* %live183, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 0
  %100 = load i32, i32* %insn_idx, align 8
  %add = add i32 %100, 1
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def185 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 16
  store i32 %add, i32* %subreg_def185, align 4
  br label %if.end191

if.else186:                                       ; preds = %if.else177
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg187 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %104, i32 0, i32 1
  %bf.load188 = load i8, i8* %dst_reg187, align 1
  %bf.clear189 = and i8 %bf.load188, 15
  %conv190 = zext i8 %bf.clear189 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %102, %struct.bpf_reg_state* noundef %103, i32 noundef %conv190) #14
  br label %if.end191

if.end191:                                        ; preds = %if.else186, %if.then181
  br label %if.end192

if.end192:                                        ; preds = %if.end191
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  call void @zext_32_to_64(%struct.bpf_reg_state* noundef %105) #14
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.end165
  br label %if.end227

if.else194:                                       ; preds = %if.end134
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %108 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg195 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %108, i32 0, i32 1
  %bf.load196 = load i8, i8* %dst_reg195, align 1
  %bf.clear197 = and i8 %bf.load196, 15
  %conv198 = zext i8 %bf.clear197 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %106, %struct.bpf_reg_state* noundef %107, i32 noundef %conv198) #14
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %110 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg199 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %110, i32 0, i32 1
  %bf.load200 = load i8, i8* %dst_reg199, align 1
  %bf.clear201 = and i8 %bf.load200, 15
  %idxprom = zext i8 %bf.clear201 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i64 %idxprom
  %type202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type202, align 8
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 0
  %112 = load i8, i8* %code203, align 4
  %conv204 = zext i8 %112 to i32
  %and205 = and i32 %conv204, 7
  %cmp206 = icmp eq i32 %and205, 7
  br i1 %cmp206, label %if.then208, label %if.else217

if.then208:                                       ; preds = %if.else194
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %114 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %114, i32 0, i32 1
  %bf.load210 = load i8, i8* %dst_reg209, align 1
  %bf.clear211 = and i8 %bf.load210, 15
  %conv212 = zext i8 %bf.clear211 to i32
  %idx.ext213 = sext i32 %conv212 to i64
  %add.ptr214 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i64 %idx.ext213
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm215 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %115, i32 0, i32 3
  %116 = load i32, i32* %imm215, align 4
  %conv216 = sext i32 %116 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr214, i64 noundef %conv216) #14
  br label %if.end226

if.else217:                                       ; preds = %if.else194
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %118 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %118, i32 0, i32 1
  %bf.load219 = load i8, i8* %dst_reg218, align 1
  %bf.clear220 = and i8 %bf.load219, 15
  %conv221 = zext i8 %bf.clear220 to i32
  %idx.ext222 = sext i32 %conv221 to i64
  %add.ptr223 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i64 %idx.ext222
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm224 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 3
  %120 = load i32, i32* %imm224, align 4
  %conv225 = zext i32 %120 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr223, i64 noundef %conv225) #14
  br label %if.end226

if.end226:                                        ; preds = %if.else217, %if.then208
  br label %if.end227

if.end227:                                        ; preds = %if.end226, %if.end193
  br label %if.end344

if.else228:                                       ; preds = %if.else83
  %121 = load i8, i8* %opcode, align 1
  %conv229 = zext i8 %121 to i32
  %cmp230 = icmp sgt i32 %conv229, 208
  br i1 %cmp230, label %if.then232, label %if.else234

if.then232:                                       ; preds = %if.else228
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = bitcast %struct.bpf_verifier_env* %122 to i8*
  %124 = load i8, i8* %opcode, align 1
  %conv233 = zext i8 %124 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %123, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.252, i64 0, i64 0), i32 noundef %conv233) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.else234:                                       ; preds = %if.else228
  %125 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code235 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %125, i32 0, i32 0
  %126 = load i8, i8* %code235, align 4
  %conv236 = zext i8 %126 to i32
  %and237 = and i32 %conv236, 8
  %cmp238 = icmp eq i32 %and237, 8
  br i1 %cmp238, label %if.then240, label %if.else259

if.then240:                                       ; preds = %if.else234
  %127 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm241 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %127, i32 0, i32 3
  %128 = load i32, i32* %imm241, align 4
  %cmp242 = icmp ne i32 %128, 0
  br i1 %cmp242, label %if.then249, label %lor.lhs.false244

lor.lhs.false244:                                 ; preds = %if.then240
  %129 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %129, i32 0, i32 2
  %130 = load i16, i16* %off245, align 2
  %conv246 = sext i16 %130 to i32
  %cmp247 = icmp ne i32 %conv246, 0
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %lor.lhs.false244, %if.then240
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = bitcast %struct.bpf_verifier_env* %131 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %132, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.253, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end250:                                        ; preds = %lor.lhs.false244
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %134, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %conv254 = zext i8 %bf.lshr253 to i32
  %call255 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %133, i32 noundef %conv254, i32 noundef 0) #14
  store i32 %call255, i32* %err, align 4
  %135 = load i32, i32* %err, align 4
  %tobool256 = icmp ne i32 %135, 0
  br i1 %tobool256, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.end250
  %136 = load i32, i32* %err, align 4
  store i32 %136, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.end250
  br label %if.end273

if.else259:                                       ; preds = %if.else234
  %137 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg260 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %137, i32 0, i32 1
  %bf.load261 = load i8, i8* %src_reg260, align 1
  %bf.lshr262 = lshr i8 %bf.load261, 4
  %conv263 = zext i8 %bf.lshr262 to i32
  %cmp264 = icmp ne i32 %conv263, 0
  br i1 %cmp264, label %if.then271, label %lor.lhs.false266

lor.lhs.false266:                                 ; preds = %if.else259
  %138 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off267 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %138, i32 0, i32 2
  %139 = load i16, i16* %off267, align 2
  %conv268 = sext i16 %139 to i32
  %cmp269 = icmp ne i32 %conv268, 0
  br i1 %cmp269, label %if.then271, label %if.end272

if.then271:                                       ; preds = %lor.lhs.false266, %if.else259
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.253, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end272:                                        ; preds = %lor.lhs.false266
  br label %if.end273

if.end273:                                        ; preds = %if.end272, %if.end258
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg274 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %143, i32 0, i32 1
  %bf.load275 = load i8, i8* %dst_reg274, align 1
  %bf.clear276 = and i8 %bf.load275, 15
  %conv277 = zext i8 %bf.clear276 to i32
  %call278 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %142, i32 noundef %conv277, i32 noundef 0) #14
  store i32 %call278, i32* %err, align 4
  %144 = load i32, i32* %err, align 4
  %tobool279 = icmp ne i32 %144, 0
  br i1 %tobool279, label %if.then280, label %if.end281

if.then280:                                       ; preds = %if.end273
  %145 = load i32, i32* %err, align 4
  store i32 %145, i32* %retval, align 4
  br label %return

if.end281:                                        ; preds = %if.end273
  %146 = load i8, i8* %opcode, align 1
  %conv282 = zext i8 %146 to i32
  %cmp283 = icmp eq i32 %conv282, 144
  br i1 %cmp283, label %land.lhs.true289, label %lor.lhs.false285

lor.lhs.false285:                                 ; preds = %if.end281
  %147 = load i8, i8* %opcode, align 1
  %conv286 = zext i8 %147 to i32
  %cmp287 = icmp eq i32 %conv286, 48
  br i1 %cmp287, label %land.lhs.true289, label %if.end300

land.lhs.true289:                                 ; preds = %lor.lhs.false285, %if.end281
  %148 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code290 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %148, i32 0, i32 0
  %149 = load i8, i8* %code290, align 4
  %conv291 = zext i8 %149 to i32
  %and292 = and i32 %conv291, 8
  %cmp293 = icmp eq i32 %and292, 0
  br i1 %cmp293, label %land.lhs.true295, label %if.end300

land.lhs.true295:                                 ; preds = %land.lhs.true289
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm296 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %150, i32 0, i32 3
  %151 = load i32, i32* %imm296, align 4
  %cmp297 = icmp eq i32 %151, 0
  br i1 %cmp297, label %if.then299, label %if.end300

if.then299:                                       ; preds = %land.lhs.true295
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %153 = bitcast %struct.bpf_verifier_env* %152 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %153, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.254, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end300:                                        ; preds = %land.lhs.true295, %land.lhs.true289, %lor.lhs.false285
  %154 = load i8, i8* %opcode, align 1
  %conv301 = zext i8 %154 to i32
  %cmp302 = icmp eq i32 %conv301, 96
  br i1 %cmp302, label %land.lhs.true312, label %lor.lhs.false304

lor.lhs.false304:                                 ; preds = %if.end300
  %155 = load i8, i8* %opcode, align 1
  %conv305 = zext i8 %155 to i32
  %cmp306 = icmp eq i32 %conv305, 112
  br i1 %cmp306, label %land.lhs.true312, label %lor.lhs.false308

lor.lhs.false308:                                 ; preds = %lor.lhs.false304
  %156 = load i8, i8* %opcode, align 1
  %conv309 = zext i8 %156 to i32
  %cmp310 = icmp eq i32 %conv309, 192
  br i1 %cmp310, label %land.lhs.true312, label %if.end334

land.lhs.true312:                                 ; preds = %lor.lhs.false308, %lor.lhs.false304, %if.end300
  %157 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %157, i32 0, i32 0
  %158 = load i8, i8* %code313, align 4
  %conv314 = zext i8 %158 to i32
  %and315 = and i32 %conv314, 8
  %cmp316 = icmp eq i32 %and315, 0
  br i1 %cmp316, label %if.then318, label %if.end334

if.then318:                                       ; preds = %land.lhs.true312
  %159 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %159, i32 0, i32 0
  %160 = load i8, i8* %code319, align 4
  %conv320 = zext i8 %160 to i32
  %and321 = and i32 %conv320, 7
  %cmp322 = icmp eq i32 %and321, 7
  %161 = zext i1 %cmp322 to i64
  %cond = select i1 %cmp322, i32 64, i32 32
  store i32 %cond, i32* %size, align 4
  %162 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %162, i32 0, i32 3
  %163 = load i32, i32* %imm324, align 4
  %cmp325 = icmp slt i32 %163, 0
  br i1 %cmp325, label %if.then331, label %lor.lhs.false327

lor.lhs.false327:                                 ; preds = %if.then318
  %164 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %164, i32 0, i32 3
  %165 = load i32, i32* %imm328, align 4
  %166 = load i32, i32* %size, align 4
  %cmp329 = icmp sge i32 %165, %166
  br i1 %cmp329, label %if.then331, label %if.end333

if.then331:                                       ; preds = %lor.lhs.false327, %if.then318
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %168 = bitcast %struct.bpf_verifier_env* %167 to i8*
  %169 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm332 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %169, i32 0, i32 3
  %170 = load i32, i32* %imm332, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %168, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.255, i64 0, i64 0), i32 noundef %170) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end333:                                        ; preds = %lor.lhs.false327
  br label %if.end334

if.end334:                                        ; preds = %if.end333, %land.lhs.true312, %lor.lhs.false308
  %171 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %172 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %172, i32 0, i32 1
  %bf.load336 = load i8, i8* %dst_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %conv338 = zext i8 %bf.clear337 to i32
  %call339 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %171, i32 noundef %conv338, i32 noundef 2) #14
  store i32 %call339, i32* %err, align 4
  %173 = load i32, i32* %err, align 4
  %tobool340 = icmp ne i32 %173, 0
  br i1 %tobool340, label %if.then341, label %if.end342

if.then341:                                       ; preds = %if.end334
  %174 = load i32, i32* %err, align 4
  store i32 %174, i32* %retval, align 4
  br label %return

if.end342:                                        ; preds = %if.end334
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %176 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call343 = call i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %175, %struct.bpf_insn* noundef %176) #14
  store i32 %call343, i32* %retval, align 4
  br label %return

if.end344:                                        ; preds = %if.end227
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.end82
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end345, %if.end342, %if.then341, %if.then331, %if.then299, %if.then280, %if.then271, %if.then257, %if.then249, %if.then232, %if.then172, %if.then133, %if.then124, %if.then110, %if.then102, %if.then81, %if.then69, %if.then62, %if.then56, %if.then27
  %177 = load i32, i32* %retval, align 4
  ret i32 %177
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %rw64 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 0
  %9 = load i32, i32* %insn_idx, align 8
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay2, %struct.bpf_reg_state** %regs, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %11, 11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.274, i64 0, i64 0), i32 noundef %14) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %idxprom3 = zext i32 %16 to i64
  %arrayidx4 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i64 %idxprom3
  store %struct.bpf_reg_state* %arrayidx4, %struct.bpf_reg_state** %reg, align 8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %19 = load i32, i32* %regno.addr, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %21 = load i32, i32* %t.addr, align 4
  %call = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %17, %struct.bpf_insn* noundef %18, i32 noundef %19, %struct.bpf_reg_state* noundef %20, i32 noundef %21) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %rw64, align 1
  %22 = load i32, i32* %t.addr, align 4
  %cmp5 = icmp eq i32 %22, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 0
  %24 = load i32, i32* %type, align 8
  %cmp7 = icmp eq i32 %24, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.275, i64 0, i64 0), i32 noundef %27) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then6
  %28 = load i32, i32* %regno.addr, align 4
  %cmp10 = icmp eq i32 %28, 10
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  store i32 0, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %29 = load i8, i8* %rw64, align 1
  %tobool = trunc i8 %29 to i1
  br i1 %tobool, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %30, %struct.bpf_reg_state* noundef %31) #14
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end12
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 14
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %36 = load i8, i8* %rw64, align 1
  %tobool15 = trunc i8 %36 to i1
  %37 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 2, i32 1
  %conv = trunc i32 %cond to i8
  %call16 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %32, %struct.bpf_reg_state* noundef %33, %struct.bpf_reg_state* noundef %35, i8 noundef zeroext %conv) #14
  store i32 %call16, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %38 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp eq i32 %38, 10
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.else
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.276, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.else
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 17
  %42 = load i32, i32* %live, align 8
  %or = or i32 %42, 4
  store i32 %or, i32* %live, align 8
  %43 = load i8, i8* %rw64, align 1
  %tobool21 = trunc i8 %43 to i1
  br i1 %tobool21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end20
  br label %cond.end

cond.false:                                       ; preds = %if.end20
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 0
  %45 = load i32, i32* %insn_idx23, align 8
  %add = add i32 %45, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond24 = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 16
  store i32 %cond24, i32* %subreg_def, align 4
  %47 = load i32, i32* %t.addr, align 4
  %cmp25 = icmp eq i32 %47, 1
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %cond.end
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %50 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %48, %struct.bpf_reg_state* noundef %49, i32 noundef %50) #14
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %cond.end
  br label %if.end29

if.end29:                                         ; preds = %if.end28
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then19, %if.end14, %if.then11, %if.then8, %if.then
  %51 = load i32, i32* %retval, align 4
  ret i32 %51
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %bpf_size, i32 noundef %t, i32 noundef %value_regno, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %bpf_size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %size = alloca i32, align 4
  %err = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %map = alloca %struct.bpf_map*, align 8
  %map_off = alloca i32, align 4
  %val = alloca i64, align 8
  %reg_type = alloca i32, align 4
  %btf = alloca %struct.btf*, align 8
  %btf_id = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %bpf_size, i32* %bpf_size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  store i32 0, i32* %err, align 4
  store i32 -22, i32* %bytes, align 4
  %3 = load i32, i32* %bpf_size.addr, align 4
  %cmp = icmp eq i32 %3, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %bytes, align 4
  br label %if.end11

if.else:                                          ; preds = %entry
  %4 = load i32, i32* %bpf_size.addr, align 4
  %cmp1 = icmp eq i32 %4, 8
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i32 2, i32* %bytes, align 4
  br label %if.end10

if.else3:                                         ; preds = %if.else
  %5 = load i32, i32* %bpf_size.addr, align 4
  %cmp4 = icmp eq i32 %5, 0
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else3
  store i32 4, i32* %bytes, align 4
  br label %if.end9

if.else6:                                         ; preds = %if.else3
  %6 = load i32, i32* %bpf_size.addr, align 4
  %cmp7 = icmp eq i32 %6, 24
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else6
  store i32 8, i32* %bytes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.else6
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then2
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  %7 = load i32, i32* %bytes, align 4
  store i32 %7, i32* %tmp, align 4
  %8 = load i32, i32* %tmp, align 4
  store i32 %8, i32* %size, align 4
  %9 = load i32, i32* %size, align 4
  %cmp12 = icmp slt i32 %9, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %10 = load i32, i32* %size, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size, align 4
  %15 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool = trunc i8 %15 to i1
  %call15 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i32 noundef %13, i32 noundef %14, i1 noundef zeroext %tobool) #14
  store i32 %call15, i32* %err, align 4
  %16 = load i32, i32* %err, align 4
  %tobool16 = icmp ne i32 %16, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %17 = load i32, i32* %err, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end14
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 1
  %19 = load i32, i32* %off19, align 4
  %20 = load i32, i32* %off.addr, align 4
  %add = add i32 %20, %19
  store i32 %add, i32* %off.addr, align 4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type, align 8
  %cmp20 = icmp eq i32 %22, 29
  br i1 %cmp20, label %if.then21, label %if.else32

if.then21:                                        ; preds = %if.end18
  %23 = load i32, i32* %t.addr, align 4
  %cmp22 = icmp eq i32 %23, 2
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then21
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.277, i64 0, i64 0), i32 noundef %26) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then21
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %regno.addr, align 4
  %29 = load i32, i32* %off.addr, align 4
  %30 = load i32, i32* %size, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 2
  %33 = bitcast %union.anon.152* %32 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %33, i32 0, i32 0
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %34, i32 0, i32 4
  %35 = load i32, i32* %key_size, align 4
  %call25 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %27, i32 noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %35, i1 noundef zeroext false) #14
  store i32 %call25, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %36, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  %37 = load i32, i32* %err, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end24
  %38 = load i32, i32* %value_regno.addr, align 4
  %cmp29 = icmp sge i32 %38, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end28
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %41 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %39, %struct.bpf_reg_state* noundef %40, i32 noundef %41) #14
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end28
  br label %if.end330

if.else32:                                        ; preds = %if.end18
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 0
  %43 = load i32, i32* %type33, align 8
  %cmp34 = icmp eq i32 %43, 4
  br i1 %cmp34, label %if.then35, label %if.else73

if.then35:                                        ; preds = %if.else32
  %44 = load i32, i32* %t.addr, align 4
  %cmp36 = icmp eq i32 %44, 2
  br i1 %cmp36, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %if.then35
  %45 = load i32, i32* %value_regno.addr, align 4
  %cmp37 = icmp sge i32 %45, 0
  br i1 %cmp37, label %land.lhs.true38, label %if.end41

land.lhs.true38:                                  ; preds = %land.lhs.true
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %value_regno.addr, align 4
  %call39 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %46, i32 noundef %47) #14
  br i1 %call39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true38
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  %50 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.278, i64 0, i64 0), i32 noundef %50) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %land.lhs.true38, %land.lhs.true, %if.then35
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load i32, i32* %regno.addr, align 4
  %53 = load i32, i32* %off.addr, align 4
  %54 = load i32, i32* %size, align 4
  %55 = load i32, i32* %t.addr, align 4
  %call42 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %51, i32 noundef %52, i32 noundef %53, i32 noundef %54, i32 noundef %55) #14
  store i32 %call42, i32* %err, align 4
  %56 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %56, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end41
  %57 = load i32, i32* %err, align 4
  store i32 %57, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.end41
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load i32, i32* %regno.addr, align 4
  %60 = load i32, i32* %off.addr, align 4
  %61 = load i32, i32* %size, align 4
  %call46 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %58, i32 noundef %59, i32 noundef %60, i32 noundef %61, i1 noundef zeroext false) #14
  store i32 %call46, i32* %err, align 4
  %62 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %62, 0
  br i1 %tobool47, label %if.end72, label %land.lhs.true48

land.lhs.true48:                                  ; preds = %if.end45
  %63 = load i32, i32* %t.addr, align 4
  %cmp49 = icmp eq i32 %63, 1
  br i1 %cmp49, label %land.lhs.true50, label %if.end72

land.lhs.true50:                                  ; preds = %land.lhs.true48
  %64 = load i32, i32* %value_regno.addr, align 4
  %cmp51 = icmp sge i32 %64, 0
  br i1 %cmp51, label %if.then52, label %if.end72

if.then52:                                        ; preds = %land.lhs.true50
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 2
  %67 = bitcast %union.anon.152* %66 to %struct.anon.153*
  %map_ptr53 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %67, i32 0, i32 0
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr53, align 8
  store %struct.bpf_map* %68, %struct.bpf_map** %map, align 8
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 5
  %70 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %71 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %70, i32 0, i32 0
  %72 = load i64, i64* %71, align 8
  %73 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %70, i32 0, i32 1
  %74 = load i64, i64* %73, align 8
  %call54 = call zeroext i1 @tnum_is_const(i64 %72, i64 %74) #14
  br i1 %call54, label %land.lhs.true55, label %if.else70

land.lhs.true55:                                  ; preds = %if.then52
  %75 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call56 = call zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %75) #14
  br i1 %call56, label %land.lhs.true57, label %if.else70

land.lhs.true57:                                  ; preds = %land.lhs.true55
  %76 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %76, i32 0, i32 0
  %77 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %77, i32 0, i32 27
  %78 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool58 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %78, null
  br i1 %tobool58, label %if.then59, label %if.else70

if.then59:                                        ; preds = %land.lhs.true57
  %79 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %79 to i64
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off60, i32 0, i32 0
  %81 = load i64, i64* %value, align 8
  %add61 = add i64 %conv, %81
  %conv62 = trunc i64 %add61 to i32
  store i32 %conv62, i32* %map_off, align 4
  store i64 0, i64* %val, align 8
  %82 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %83 = load i32, i32* %map_off, align 4
  %84 = load i32, i32* %size, align 4
  %call63 = call i32 @bpf_map_direct_read(%struct.bpf_map* noundef %82, i32 noundef %83, i32 noundef %84, i64* noundef %val) #14
  store i32 %call63, i32* %err, align 4
  %85 = load i32, i32* %err, align 4
  %tobool64 = icmp ne i32 %85, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.then59
  %86 = load i32, i32* %err, align 4
  store i32 %86, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.then59
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %88 = load i32, i32* %value_regno.addr, align 4
  %idxprom = sext i32 %88 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i64 %idxprom
  %type67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type67, align 8
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %90 = load i32, i32* %value_regno.addr, align 4
  %idxprom68 = sext i32 %90 to i64
  %arrayidx69 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i64 %idxprom68
  %91 = load i64, i64* %val, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx69, i64 noundef %91) #14
  br label %if.end71

if.else70:                                        ; preds = %land.lhs.true57, %land.lhs.true55, %if.then52
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %94 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %92, %struct.bpf_reg_state* noundef %93, i32 noundef %94) #14
  br label %if.end71

if.end71:                                         ; preds = %if.else70, %if.end66
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %land.lhs.true50, %land.lhs.true48, %if.end45
  br label %if.end329

if.else73:                                        ; preds = %if.else32
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type74, align 8
  %cmp75 = icmp eq i32 %96, 21
  br i1 %cmp75, label %if.then77, label %if.else98

if.then77:                                        ; preds = %if.else73
  %97 = load i32, i32* %t.addr, align 4
  %cmp78 = icmp eq i32 %97, 2
  br i1 %cmp78, label %land.lhs.true80, label %if.end87

land.lhs.true80:                                  ; preds = %if.then77
  %98 = load i32, i32* %value_regno.addr, align 4
  %cmp81 = icmp sge i32 %98, 0
  br i1 %cmp81, label %land.lhs.true83, label %if.end87

land.lhs.true83:                                  ; preds = %land.lhs.true80
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load i32, i32* %value_regno.addr, align 4
  %call84 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %99, i32 noundef %100) #14
  br i1 %call84, label %if.then86, label %if.end87

if.then86:                                        ; preds = %land.lhs.true83
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %102 = bitcast %struct.bpf_verifier_env* %101 to i8*
  %103 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %102, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.279, i64 0, i64 0), i32 noundef %103) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end87:                                         ; preds = %land.lhs.true83, %land.lhs.true80, %if.then77
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %105 = load i32, i32* %regno.addr, align 4
  %106 = load i32, i32* %off.addr, align 4
  %107 = load i32, i32* %size, align 4
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %108, i32 0, i32 2
  %mem_size = bitcast %union.anon.152* %109 to i32*
  %110 = load i32, i32* %mem_size, align 8
  %call88 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %107, i32 noundef %110, i1 noundef zeroext false) #14
  store i32 %call88, i32* %err, align 4
  %111 = load i32, i32* %err, align 4
  %tobool89 = icmp ne i32 %111, 0
  br i1 %tobool89, label %if.end97, label %land.lhs.true90

land.lhs.true90:                                  ; preds = %if.end87
  %112 = load i32, i32* %t.addr, align 4
  %cmp91 = icmp eq i32 %112, 1
  br i1 %cmp91, label %land.lhs.true93, label %if.end97

land.lhs.true93:                                  ; preds = %land.lhs.true90
  %113 = load i32, i32* %value_regno.addr, align 4
  %cmp94 = icmp sge i32 %113, 0
  br i1 %cmp94, label %if.then96, label %if.end97

if.then96:                                        ; preds = %land.lhs.true93
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %116 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %114, %struct.bpf_reg_state* noundef %115, i32 noundef %116) #14
  br label %if.end97

if.end97:                                         ; preds = %if.then96, %land.lhs.true93, %land.lhs.true90, %if.end87
  br label %if.end328

if.else98:                                        ; preds = %if.else73
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i32 0, i32 0
  %118 = load i32, i32* %type99, align 8
  %cmp100 = icmp eq i32 %118, 2
  br i1 %cmp100, label %if.then102, label %if.else158

if.then102:                                       ; preds = %if.else98
  store i32 1, i32* %reg_type, align 4
  store %struct.btf* null, %struct.btf** %btf, align 8
  store i32 0, i32* %btf_id, align 4
  %119 = load i32, i32* %t.addr, align 4
  %cmp103 = icmp eq i32 %119, 2
  br i1 %cmp103, label %land.lhs.true105, label %if.end112

land.lhs.true105:                                 ; preds = %if.then102
  %120 = load i32, i32* %value_regno.addr, align 4
  %cmp106 = icmp sge i32 %120, 0
  br i1 %cmp106, label %land.lhs.true108, label %if.end112

land.lhs.true108:                                 ; preds = %land.lhs.true105
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %122 = load i32, i32* %value_regno.addr, align 4
  %call109 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %121, i32 noundef %122) #14
  br i1 %call109, label %if.then111, label %if.end112

if.then111:                                       ; preds = %land.lhs.true108
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %124 = bitcast %struct.bpf_verifier_env* %123 to i8*
  %125 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %124, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.280, i64 0, i64 0), i32 noundef %125) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end112:                                        ; preds = %land.lhs.true108, %land.lhs.true105, %if.then102
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %128 = load i32, i32* %regno.addr, align 4
  %call113 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %126, %struct.bpf_reg_state* noundef %127, i32 noundef %128) #14
  store i32 %call113, i32* %err, align 4
  %129 = load i32, i32* %err, align 4
  %cmp114 = icmp slt i32 %129, 0
  br i1 %cmp114, label %if.then116, label %if.end117

if.then116:                                       ; preds = %if.end112
  %130 = load i32, i32* %err, align 4
  store i32 %130, i32* %retval, align 4
  br label %return

if.end117:                                        ; preds = %if.end112
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = load i32, i32* %insn_idx.addr, align 4
  %133 = load i32, i32* %off.addr, align 4
  %134 = load i32, i32* %size, align 4
  %135 = load i32, i32* %t.addr, align 4
  %call118 = call i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %131, i32 noundef %132, i32 noundef %133, i32 noundef %134, i32 noundef %135, i32* noundef %reg_type, %struct.btf** noundef %btf, i32* noundef %btf_id) #14
  store i32 %call118, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool119 = icmp ne i32 %136, 0
  br i1 %tobool119, label %if.then120, label %if.end121

if.then120:                                       ; preds = %if.end117
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %138 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %137, i32 noundef %138, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.215, i64 0, i64 0)) #14
  br label %if.end121

if.end121:                                        ; preds = %if.then120, %if.end117
  %139 = load i32, i32* %err, align 4
  %tobool122 = icmp ne i32 %139, 0
  br i1 %tobool122, label %if.end157, label %land.lhs.true123

land.lhs.true123:                                 ; preds = %if.end121
  %140 = load i32, i32* %t.addr, align 4
  %cmp124 = icmp eq i32 %140, 1
  br i1 %cmp124, label %land.lhs.true126, label %if.end157

land.lhs.true126:                                 ; preds = %land.lhs.true123
  %141 = load i32, i32* %value_regno.addr, align 4
  %cmp127 = icmp sge i32 %141, 0
  br i1 %cmp127, label %if.then129, label %if.end157

if.then129:                                       ; preds = %land.lhs.true126
  %142 = load i32, i32* %reg_type, align 4
  %cmp130 = icmp eq i32 %142, 1
  br i1 %cmp130, label %if.then132, label %if.else133

if.then132:                                       ; preds = %if.then129
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %144 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %145 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %143, %struct.bpf_reg_state* noundef %144, i32 noundef %145) #14
  br label %if.end153

if.else133:                                       ; preds = %if.then129
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %148 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %146, %struct.bpf_reg_state* noundef %147, i32 noundef %148) #14
  %149 = load i32, i32* %reg_type, align 4
  %call134 = call zeroext i1 @reg_type_may_be_null(i32 noundef %149) #14
  br i1 %call134, label %if.then135, label %if.end138

if.then135:                                       ; preds = %if.else133
  %150 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %150, i32 0, i32 15
  %151 = load i32, i32* %id_gen, align 8
  %inc = add i32 %151, 1
  store i32 %inc, i32* %id_gen, align 8
  %152 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %153 = load i32, i32* %value_regno.addr, align 4
  %idxprom136 = sext i32 %153 to i64
  %arrayidx137 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %152, i64 %idxprom136
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx137, i32 0, i32 3
  store i32 %inc, i32* %id, align 8
  br label %if.end138

if.end138:                                        ; preds = %if.then135, %if.else133
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %155 = load i32, i32* %value_regno.addr, align 4
  %idxprom139 = sext i32 %155 to i64
  %arrayidx140 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i64 %idxprom139
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx140, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  %156 = load i32, i32* %reg_type, align 4
  %cmp141 = icmp eq i32 %156, 19
  br i1 %cmp141, label %if.then145, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end138
  %157 = load i32, i32* %reg_type, align 4
  %cmp143 = icmp eq i32 %157, 20
  br i1 %cmp143, label %if.then145, label %if.end152

if.then145:                                       ; preds = %lor.lhs.false, %if.end138
  %158 = load %struct.btf*, %struct.btf** %btf, align 8
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %160 = load i32, i32* %value_regno.addr, align 4
  %idxprom146 = sext i32 %160 to i64
  %arrayidx147 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i64 %idxprom146
  %161 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx147, i32 0, i32 2
  %162 = bitcast %union.anon.152* %161 to %struct.anon.154*
  %btf148 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %162, i32 0, i32 0
  store %struct.btf* %158, %struct.btf** %btf148, align 8
  %163 = load i32, i32* %btf_id, align 4
  %164 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %165 = load i32, i32* %value_regno.addr, align 4
  %idxprom149 = sext i32 %165 to i64
  %arrayidx150 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %164, i64 %idxprom149
  %166 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx150, i32 0, i32 2
  %167 = bitcast %union.anon.152* %166 to %struct.anon.154*
  %btf_id151 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %167, i32 0, i32 1
  store i32 %163, i32* %btf_id151, align 8
  br label %if.end152

if.end152:                                        ; preds = %if.then145, %lor.lhs.false
  br label %if.end153

if.end153:                                        ; preds = %if.end152, %if.then132
  %168 = load i32, i32* %reg_type, align 4
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %170 = load i32, i32* %value_regno.addr, align 4
  %idxprom154 = sext i32 %170 to i64
  %arrayidx155 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %169, i64 %idxprom154
  %type156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx155, i32 0, i32 0
  store i32 %168, i32* %type156, align 8
  br label %if.end157

if.end157:                                        ; preds = %if.end153, %land.lhs.true126, %land.lhs.true123, %if.end121
  br label %if.end327

if.else158:                                       ; preds = %if.else98
  %171 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type159 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %171, i32 0, i32 0
  %172 = load i32, i32* %type159, align 8
  %cmp160 = icmp eq i32 %172, 6
  br i1 %cmp160, label %if.then162, label %if.else179

if.then162:                                       ; preds = %if.else158
  %173 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %174 = load i32, i32* %regno.addr, align 4
  %175 = load i32, i32* %off.addr, align 4
  %176 = load i32, i32* %size, align 4
  %177 = load i32, i32* %t.addr, align 4
  %call163 = call i32 @check_stack_access_within_bounds(%struct.bpf_verifier_env* noundef %173, i32 noundef %174, i32 noundef %175, i32 noundef %176, i32 noundef 1, i32 noundef %177) #14
  store i32 %call163, i32* %err, align 4
  %178 = load i32, i32* %err, align 4
  %tobool164 = icmp ne i32 %178, 0
  br i1 %tobool164, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.then162
  %179 = load i32, i32* %err, align 4
  store i32 %179, i32* %retval, align 4
  br label %return

if.end166:                                        ; preds = %if.then162
  %180 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call167 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %180, %struct.bpf_reg_state* noundef %181) #14
  store %struct.bpf_func_state* %call167, %struct.bpf_func_state** %state, align 8
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %183 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %184 = load i32, i32* %off.addr, align 4
  %call168 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %182, %struct.bpf_func_state* noundef %183, i32 noundef %184) #14
  store i32 %call168, i32* %err, align 4
  %185 = load i32, i32* %err, align 4
  %tobool169 = icmp ne i32 %185, 0
  br i1 %tobool169, label %if.then170, label %if.end171

if.then170:                                       ; preds = %if.end166
  %186 = load i32, i32* %err, align 4
  store i32 %186, i32* %retval, align 4
  br label %return

if.end171:                                        ; preds = %if.end166
  %187 = load i32, i32* %t.addr, align 4
  %cmp172 = icmp eq i32 %187, 1
  br i1 %cmp172, label %if.then174, label %if.else176

if.then174:                                       ; preds = %if.end171
  %188 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %189 = load i32, i32* %regno.addr, align 4
  %190 = load i32, i32* %off.addr, align 4
  %191 = load i32, i32* %size, align 4
  %192 = load i32, i32* %value_regno.addr, align 4
  %call175 = call i32 @check_stack_read(%struct.bpf_verifier_env* noundef %188, i32 noundef %189, i32 noundef %190, i32 noundef %191, i32 noundef %192) #14
  store i32 %call175, i32* %err, align 4
  br label %if.end178

if.else176:                                       ; preds = %if.end171
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = load i32, i32* %regno.addr, align 4
  %195 = load i32, i32* %off.addr, align 4
  %196 = load i32, i32* %size, align 4
  %197 = load i32, i32* %value_regno.addr, align 4
  %198 = load i32, i32* %insn_idx.addr, align 4
  %call177 = call i32 @check_stack_write(%struct.bpf_verifier_env* noundef %193, i32 noundef %194, i32 noundef %195, i32 noundef %196, i32 noundef %197, i32 noundef %198) #14
  store i32 %call177, i32* %err, align 4
  br label %if.end178

if.end178:                                        ; preds = %if.else176, %if.then174
  br label %if.end326

if.else179:                                       ; preds = %if.else158
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call180 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %199) #14
  br i1 %call180, label %if.then181, label %if.else208

if.then181:                                       ; preds = %if.else179
  %200 = load i32, i32* %t.addr, align 4
  %cmp182 = icmp eq i32 %200, 2
  br i1 %cmp182, label %land.lhs.true184, label %if.end187

land.lhs.true184:                                 ; preds = %if.then181
  %201 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %202 = load i32, i32* %t.addr, align 4
  %call185 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %201, %struct.bpf_call_arg_meta* noundef null, i32 noundef %202) #14
  br i1 %call185, label %if.end187, label %if.then186

if.then186:                                       ; preds = %land.lhs.true184
  %203 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %204 = bitcast %struct.bpf_verifier_env* %203 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %204, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.281, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end187:                                        ; preds = %land.lhs.true184, %if.then181
  %205 = load i32, i32* %t.addr, align 4
  %cmp188 = icmp eq i32 %205, 2
  br i1 %cmp188, label %land.lhs.true190, label %if.end197

land.lhs.true190:                                 ; preds = %if.end187
  %206 = load i32, i32* %value_regno.addr, align 4
  %cmp191 = icmp sge i32 %206, 0
  br i1 %cmp191, label %land.lhs.true193, label %if.end197

land.lhs.true193:                                 ; preds = %land.lhs.true190
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %208 = load i32, i32* %value_regno.addr, align 4
  %call194 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %207, i32 noundef %208) #14
  br i1 %call194, label %if.then196, label %if.end197

if.then196:                                       ; preds = %land.lhs.true193
  %209 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %210 = bitcast %struct.bpf_verifier_env* %209 to i8*
  %211 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %210, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.282, i64 0, i64 0), i32 noundef %211) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end197:                                        ; preds = %land.lhs.true193, %land.lhs.true190, %if.end187
  %212 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %213 = load i32, i32* %regno.addr, align 4
  %214 = load i32, i32* %off.addr, align 4
  %215 = load i32, i32* %size, align 4
  %call198 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %212, i32 noundef %213, i32 noundef %214, i32 noundef %215, i1 noundef zeroext false) #14
  store i32 %call198, i32* %err, align 4
  %216 = load i32, i32* %err, align 4
  %tobool199 = icmp ne i32 %216, 0
  br i1 %tobool199, label %if.end207, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %if.end197
  %217 = load i32, i32* %t.addr, align 4
  %cmp201 = icmp eq i32 %217, 1
  br i1 %cmp201, label %land.lhs.true203, label %if.end207

land.lhs.true203:                                 ; preds = %land.lhs.true200
  %218 = load i32, i32* %value_regno.addr, align 4
  %cmp204 = icmp sge i32 %218, 0
  br i1 %cmp204, label %if.then206, label %if.end207

if.then206:                                       ; preds = %land.lhs.true203
  %219 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %221 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %219, %struct.bpf_reg_state* noundef %220, i32 noundef %221) #14
  br label %if.end207

if.end207:                                        ; preds = %if.then206, %land.lhs.true203, %land.lhs.true200, %if.end197
  br label %if.end325

if.else208:                                       ; preds = %if.else179
  %222 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type209 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %222, i32 0, i32 0
  %223 = load i32, i32* %type209, align 8
  %cmp210 = icmp eq i32 %223, 10
  br i1 %cmp210, label %if.then212, label %if.else233

if.then212:                                       ; preds = %if.else208
  %224 = load i32, i32* %t.addr, align 4
  %cmp213 = icmp eq i32 %224, 2
  br i1 %cmp213, label %land.lhs.true215, label %if.end222

land.lhs.true215:                                 ; preds = %if.then212
  %225 = load i32, i32* %value_regno.addr, align 4
  %cmp216 = icmp sge i32 %225, 0
  br i1 %cmp216, label %land.lhs.true218, label %if.end222

land.lhs.true218:                                 ; preds = %land.lhs.true215
  %226 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %227 = load i32, i32* %value_regno.addr, align 4
  %call219 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %226, i32 noundef %227) #14
  br i1 %call219, label %if.then221, label %if.end222

if.then221:                                       ; preds = %land.lhs.true218
  %228 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %229 = bitcast %struct.bpf_verifier_env* %228 to i8*
  %230 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %229, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.283, i64 0, i64 0), i32 noundef %230) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end222:                                        ; preds = %land.lhs.true218, %land.lhs.true215, %if.then212
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %232 = load i32, i32* %off.addr, align 4
  %233 = load i32, i32* %size, align 4
  %call223 = call i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %231, i32 noundef %232, i32 noundef %233) #14
  store i32 %call223, i32* %err, align 4
  %234 = load i32, i32* %err, align 4
  %tobool224 = icmp ne i32 %234, 0
  br i1 %tobool224, label %if.end232, label %land.lhs.true225

land.lhs.true225:                                 ; preds = %if.end222
  %235 = load i32, i32* %t.addr, align 4
  %cmp226 = icmp eq i32 %235, 1
  br i1 %cmp226, label %land.lhs.true228, label %if.end232

land.lhs.true228:                                 ; preds = %land.lhs.true225
  %236 = load i32, i32* %value_regno.addr, align 4
  %cmp229 = icmp sge i32 %236, 0
  br i1 %cmp229, label %if.then231, label %if.end232

if.then231:                                       ; preds = %land.lhs.true228
  %237 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %238 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %239 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %237, %struct.bpf_reg_state* noundef %238, i32 noundef %239) #14
  br label %if.end232

if.end232:                                        ; preds = %if.then231, %land.lhs.true228, %land.lhs.true225, %if.end222
  br label %if.end324

if.else233:                                       ; preds = %if.else208
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type234 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i32 0, i32 0
  %241 = load i32, i32* %type234, align 8
  %call235 = call zeroext i1 @type_is_sk_pointer(i32 noundef %241) #14
  br i1 %call235, label %if.then236, label %if.else251

if.then236:                                       ; preds = %if.else233
  %242 = load i32, i32* %t.addr, align 4
  %cmp237 = icmp eq i32 %242, 2
  br i1 %cmp237, label %if.then239, label %if.end243

if.then239:                                       ; preds = %if.then236
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %244 = bitcast %struct.bpf_verifier_env* %243 to i8*
  %245 = load i32, i32* %regno.addr, align 4
  %246 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type240 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %246, i32 0, i32 0
  %247 = load i32, i32* %type240, align 8
  %idxprom241 = zext i32 %247 to i64
  %arrayidx242 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom241
  %248 = load i8*, i8** %arrayidx242, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %244, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.284, i64 0, i64 0), i32 noundef %245, i8* noundef %248) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end243:                                        ; preds = %if.then236
  %249 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %250 = load i32, i32* %insn_idx.addr, align 4
  %251 = load i32, i32* %regno.addr, align 4
  %252 = load i32, i32* %off.addr, align 4
  %253 = load i32, i32* %size, align 4
  %254 = load i32, i32* %t.addr, align 4
  %call244 = call i32 @check_sock_access(%struct.bpf_verifier_env* noundef %249, i32 noundef %250, i32 noundef %251, i32 noundef %252, i32 noundef %253, i32 noundef %254) #14
  store i32 %call244, i32* %err, align 4
  %255 = load i32, i32* %err, align 4
  %tobool245 = icmp ne i32 %255, 0
  br i1 %tobool245, label %if.end250, label %land.lhs.true246

land.lhs.true246:                                 ; preds = %if.end243
  %256 = load i32, i32* %value_regno.addr, align 4
  %cmp247 = icmp sge i32 %256, 0
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %land.lhs.true246
  %257 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %258 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %259 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %257, %struct.bpf_reg_state* noundef %258, i32 noundef %259) #14
  br label %if.end250

if.end250:                                        ; preds = %if.then249, %land.lhs.true246, %if.end243
  br label %if.end323

if.else251:                                       ; preds = %if.else233
  %260 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type252 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %260, i32 0, i32 0
  %261 = load i32, i32* %type252, align 8
  %cmp253 = icmp eq i32 %261, 17
  br i1 %cmp253, label %if.then255, label %if.else266

if.then255:                                       ; preds = %if.else251
  %262 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %263 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %264 = load i32, i32* %regno.addr, align 4
  %265 = load i32, i32* %off.addr, align 4
  %266 = load i32, i32* %size, align 4
  %call256 = call i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %262, %struct.bpf_reg_state* noundef %263, i32 noundef %264, i32 noundef %265, i32 noundef %266) #14
  store i32 %call256, i32* %err, align 4
  %267 = load i32, i32* %err, align 4
  %tobool257 = icmp ne i32 %267, 0
  br i1 %tobool257, label %if.end265, label %land.lhs.true258

land.lhs.true258:                                 ; preds = %if.then255
  %268 = load i32, i32* %t.addr, align 4
  %cmp259 = icmp eq i32 %268, 1
  br i1 %cmp259, label %land.lhs.true261, label %if.end265

land.lhs.true261:                                 ; preds = %land.lhs.true258
  %269 = load i32, i32* %value_regno.addr, align 4
  %cmp262 = icmp sge i32 %269, 0
  br i1 %cmp262, label %if.then264, label %if.end265

if.then264:                                       ; preds = %land.lhs.true261
  %270 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %271 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %272 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %270, %struct.bpf_reg_state* noundef %271, i32 noundef %272) #14
  br label %if.end265

if.end265:                                        ; preds = %if.then264, %land.lhs.true261, %land.lhs.true258, %if.then255
  br label %if.end322

if.else266:                                       ; preds = %if.else251
  %273 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type267 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %273, i32 0, i32 0
  %274 = load i32, i32* %type267, align 8
  %cmp268 = icmp eq i32 %274, 19
  br i1 %cmp268, label %if.then270, label %if.else272

if.then270:                                       ; preds = %if.else266
  %275 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %276 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %277 = load i32, i32* %regno.addr, align 4
  %278 = load i32, i32* %off.addr, align 4
  %279 = load i32, i32* %size, align 4
  %280 = load i32, i32* %t.addr, align 4
  %281 = load i32, i32* %value_regno.addr, align 4
  %call271 = call i32 @check_ptr_to_btf_access(%struct.bpf_verifier_env* noundef %275, %struct.bpf_reg_state* noundef %276, i32 noundef %277, i32 noundef %278, i32 noundef %279, i32 noundef %280, i32 noundef %281) #14
  store i32 %call271, i32* %err, align 4
  br label %if.end321

if.else272:                                       ; preds = %if.else266
  %282 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type273 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %282, i32 0, i32 0
  %283 = load i32, i32* %type273, align 8
  %cmp274 = icmp eq i32 %283, 3
  br i1 %cmp274, label %if.then276, label %if.else278

if.then276:                                       ; preds = %if.else272
  %284 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %285 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %286 = load i32, i32* %regno.addr, align 4
  %287 = load i32, i32* %off.addr, align 4
  %288 = load i32, i32* %size, align 4
  %289 = load i32, i32* %t.addr, align 4
  %290 = load i32, i32* %value_regno.addr, align 4
  %call277 = call i32 @check_ptr_to_map_access(%struct.bpf_verifier_env* noundef %284, %struct.bpf_reg_state* noundef %285, i32 noundef %286, i32 noundef %287, i32 noundef %288, i32 noundef %289, i32 noundef %290) #14
  store i32 %call277, i32* %err, align 4
  br label %if.end320

if.else278:                                       ; preds = %if.else272
  %291 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type279 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %291, i32 0, i32 0
  %292 = load i32, i32* %type279, align 8
  %cmp280 = icmp eq i32 %292, 23
  br i1 %cmp280, label %if.then282, label %if.else297

if.then282:                                       ; preds = %if.else278
  %293 = load i32, i32* %t.addr, align 4
  %cmp283 = icmp eq i32 %293, 2
  br i1 %cmp283, label %if.then285, label %if.end289

if.then285:                                       ; preds = %if.then282
  %294 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %295 = bitcast %struct.bpf_verifier_env* %294 to i8*
  %296 = load i32, i32* %regno.addr, align 4
  %297 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type286 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %297, i32 0, i32 0
  %298 = load i32, i32* %type286, align 8
  %idxprom287 = zext i32 %298 to i64
  %arrayidx288 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom287
  %299 = load i8*, i8** %arrayidx288, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %295, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.284, i64 0, i64 0), i32 noundef %296, i8* noundef %299) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end289:                                        ; preds = %if.then282
  %300 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %301 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %302 = load i32, i32* %regno.addr, align 4
  %303 = load i32, i32* %off.addr, align 4
  %304 = load i32, i32* %size, align 4
  %305 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %305, i32 0, i32 2
  %306 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %306, i32 0, i32 10
  %307 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_rdonly_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %307, i32 0, i32 12
  %call290 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %300, %struct.bpf_reg_state* noundef %301, i32 noundef %302, i32 noundef %303, i32 noundef %304, i1 noundef zeroext false, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.28, i64 0, i64 0), i32* noundef %max_rdonly_access) #14
  store i32 %call290, i32* %err, align 4
  %308 = load i32, i32* %err, align 4
  %tobool291 = icmp ne i32 %308, 0
  br i1 %tobool291, label %if.end296, label %land.lhs.true292

land.lhs.true292:                                 ; preds = %if.end289
  %309 = load i32, i32* %value_regno.addr, align 4
  %cmp293 = icmp sge i32 %309, 0
  br i1 %cmp293, label %if.then295, label %if.end296

if.then295:                                       ; preds = %land.lhs.true292
  %310 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %311 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %312 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %310, %struct.bpf_reg_state* noundef %311, i32 noundef %312) #14
  br label %if.end296

if.end296:                                        ; preds = %if.then295, %land.lhs.true292, %if.end289
  br label %if.end319

if.else297:                                       ; preds = %if.else278
  %313 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type298 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %313, i32 0, i32 0
  %314 = load i32, i32* %type298, align 8
  %cmp299 = icmp eq i32 %314, 25
  br i1 %cmp299, label %if.then301, label %if.else314

if.then301:                                       ; preds = %if.else297
  %315 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %316 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %317 = load i32, i32* %regno.addr, align 4
  %318 = load i32, i32* %off.addr, align 4
  %319 = load i32, i32* %size, align 4
  %320 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog302 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %320, i32 0, i32 2
  %321 = load %struct.bpf_prog*, %struct.bpf_prog** %prog302, align 8
  %aux303 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %321, i32 0, i32 10
  %322 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux303, align 8
  %max_rdwr_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %322, i32 0, i32 13
  %call304 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %315, %struct.bpf_reg_state* noundef %316, i32 noundef %317, i32 noundef %318, i32 noundef %319, i1 noundef zeroext false, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i64 0, i64 0), i32* noundef %max_rdwr_access) #14
  store i32 %call304, i32* %err, align 4
  %323 = load i32, i32* %err, align 4
  %tobool305 = icmp ne i32 %323, 0
  br i1 %tobool305, label %if.end313, label %land.lhs.true306

land.lhs.true306:                                 ; preds = %if.then301
  %324 = load i32, i32* %t.addr, align 4
  %cmp307 = icmp eq i32 %324, 1
  br i1 %cmp307, label %land.lhs.true309, label %if.end313

land.lhs.true309:                                 ; preds = %land.lhs.true306
  %325 = load i32, i32* %value_regno.addr, align 4
  %cmp310 = icmp sge i32 %325, 0
  br i1 %cmp310, label %if.then312, label %if.end313

if.then312:                                       ; preds = %land.lhs.true309
  %326 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %327 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %328 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %326, %struct.bpf_reg_state* noundef %327, i32 noundef %328) #14
  br label %if.end313

if.end313:                                        ; preds = %if.then312, %land.lhs.true309, %land.lhs.true306, %if.then301
  br label %if.end318

if.else314:                                       ; preds = %if.else297
  %329 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %330 = bitcast %struct.bpf_verifier_env* %329 to i8*
  %331 = load i32, i32* %regno.addr, align 4
  %332 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type315 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %332, i32 0, i32 0
  %333 = load i32, i32* %type315, align 8
  %idxprom316 = zext i32 %333 to i64
  %arrayidx317 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom316
  %334 = load i8*, i8** %arrayidx317, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %330, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.285, i64 0, i64 0), i32 noundef %331, i8* noundef %334) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end318:                                        ; preds = %if.end313
  br label %if.end319

if.end319:                                        ; preds = %if.end318, %if.end296
  br label %if.end320

if.end320:                                        ; preds = %if.end319, %if.then276
  br label %if.end321

if.end321:                                        ; preds = %if.end320, %if.then270
  br label %if.end322

if.end322:                                        ; preds = %if.end321, %if.end265
  br label %if.end323

if.end323:                                        ; preds = %if.end322, %if.end250
  br label %if.end324

if.end324:                                        ; preds = %if.end323, %if.end232
  br label %if.end325

if.end325:                                        ; preds = %if.end324, %if.end207
  br label %if.end326

if.end326:                                        ; preds = %if.end325, %if.end178
  br label %if.end327

if.end327:                                        ; preds = %if.end326, %if.end157
  br label %if.end328

if.end328:                                        ; preds = %if.end327, %if.end97
  br label %if.end329

if.end329:                                        ; preds = %if.end328, %if.end72
  br label %if.end330

if.end330:                                        ; preds = %if.end329, %if.end31
  %335 = load i32, i32* %err, align 4
  %tobool331 = icmp ne i32 %335, 0
  br i1 %tobool331, label %if.end350, label %land.lhs.true332

land.lhs.true332:                                 ; preds = %if.end330
  %336 = load i32, i32* %size, align 4
  %cmp333 = icmp slt i32 %336, 8
  br i1 %cmp333, label %land.lhs.true335, label %if.end350

land.lhs.true335:                                 ; preds = %land.lhs.true332
  %337 = load i32, i32* %value_regno.addr, align 4
  %cmp336 = icmp sge i32 %337, 0
  br i1 %cmp336, label %land.lhs.true338, label %if.end350

land.lhs.true338:                                 ; preds = %land.lhs.true335
  %338 = load i32, i32* %t.addr, align 4
  %cmp339 = icmp eq i32 %338, 1
  br i1 %cmp339, label %land.lhs.true341, label %if.end350

land.lhs.true341:                                 ; preds = %land.lhs.true338
  %339 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %340 = load i32, i32* %value_regno.addr, align 4
  %idxprom342 = sext i32 %340 to i64
  %arrayidx343 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %339, i64 %idxprom342
  %type344 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx343, i32 0, i32 0
  %341 = load i32, i32* %type344, align 8
  %cmp345 = icmp eq i32 %341, 1
  br i1 %cmp345, label %if.then347, label %if.end350

if.then347:                                       ; preds = %land.lhs.true341
  %342 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %343 = load i32, i32* %value_regno.addr, align 4
  %idxprom348 = sext i32 %343 to i64
  %arrayidx349 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %342, i64 %idxprom348
  %344 = load i32, i32* %size, align 4
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %arrayidx349, i32 noundef %344) #14
  br label %if.end350

if.end350:                                        ; preds = %if.then347, %land.lhs.true341, %land.lhs.true338, %land.lhs.true335, %land.lhs.true332, %if.end330
  %345 = load i32, i32* %err, align 4
  store i32 %345, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end350, %if.else314, %if.then285, %if.then239, %if.then221, %if.then196, %if.then186, %if.then170, %if.then165, %if.then116, %if.then111, %if.then86, %if.then65, %if.then44, %if.then40, %if.then27, %if.then23, %if.then17, %if.then13
  %346 = load i32, i32* %retval, align 4
  ret i32 %346
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch(i32 noundef %src, i32 noundef %prev) #0 {
entry:
  %src.addr = alloca i32, align 4
  %prev.addr = alloca i32, align 4
  store i32 %src, i32* %src.addr, align 4
  store i32 %prev, i32* %prev.addr, align 4
  %0 = load i32, i32* %src.addr, align 4
  %1 = load i32, i32* %prev.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i32, i32* %src.addr, align 4
  %call = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %2) #14
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %3 = load i32, i32* %prev.addr, align 4
  %call1 = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %3) #14
  %lnot = xor i1 %call1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %4 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %5 = phi i1 [ false, %entry ], [ %4, %lor.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_atomic(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %load_reg = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 3
  %1 = load i32, i32* %imm, align 4
  switch i32 %1, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 80, label %sw.bb
    i32 81, label %sw.bb
    i32 64, label %sw.bb
    i32 65, label %sw.bb
    i32 160, label %sw.bb
    i32 161, label %sw.bb
    i32 225, label %sw.bb
    i32 241, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.320, i64 0, i64 0), i32 noundef %5) #14
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.epilog
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code3, align 4
  %conv4 = zext i8 %9 to i32
  %and5 = and i32 %conv4, 24
  %cmp6 = icmp ne i32 %and5, 24
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.321, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %sw.epilog
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv8 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %12, i32 noundef %conv8, i32 noundef 0) #14
  store i32 %call, i32* %err, align 4
  %14 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %15 = load i32, i32* %err, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 1
  %bf.load11 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load11, 15
  %conv12 = zext i8 %bf.clear to i32
  %call13 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %16, i32 noundef %conv12, i32 noundef 0) #14
  store i32 %call13, i32* %err, align 4
  %18 = load i32, i32* %err, align 4
  %tobool14 = icmp ne i32 %18, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end10
  %19 = load i32, i32* %err, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end10
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 3
  %21 = load i32, i32* %imm17, align 4
  %cmp18 = icmp eq i32 %21, 241
  br i1 %cmp18, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.end16
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call21 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %22, i32 noundef 0, i32 noundef 0) #14
  store i32 %call21, i32* %err, align 4
  %23 = load i32, i32* %err, align 4
  %tobool22 = icmp ne i32 %23, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then20
  %24 = load i32, i32* %err, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then20
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end16
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 1
  %bf.load27 = load i8, i8* %src_reg26, align 1
  %bf.lshr28 = lshr i8 %bf.load27, 4
  %conv29 = zext i8 %bf.lshr28 to i32
  %call30 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %25, i32 noundef %conv29) #14
  br i1 %call30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end25
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg32 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load33 = load i8, i8* %src_reg32, align 1
  %bf.lshr34 = lshr i8 %bf.load33, 4
  %conv35 = zext i8 %bf.lshr34 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.279, i64 0, i64 0), i32 noundef %conv35) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end25
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg37 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load38 = load i8, i8* %dst_reg37, align 1
  %bf.clear39 = and i8 %bf.load38, 15
  %conv40 = zext i8 %bf.clear39 to i32
  %call41 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %30, i32 noundef %conv40) #14
  br i1 %call41, label %if.then63, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end36
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, 15
  %conv46 = zext i8 %bf.clear45 to i32
  %call47 = call zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv46) #14
  br i1 %call47, label %if.then63, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg50 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %35, i32 0, i32 1
  %bf.load51 = load i8, i8* %dst_reg50, align 1
  %bf.clear52 = and i8 %bf.load51, 15
  %conv53 = zext i8 %bf.clear52 to i32
  %call54 = call zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %34, i32 noundef %conv53) #14
  br i1 %call54, label %if.then63, label %lor.lhs.false56

lor.lhs.false56:                                  ; preds = %lor.lhs.false49
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %37, i32 0, i32 1
  %bf.load58 = load i8, i8* %dst_reg57, align 1
  %bf.clear59 = and i8 %bf.load58, 15
  %conv60 = zext i8 %bf.clear59 to i32
  %call61 = call zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %36, i32 noundef %conv60) #14
  br i1 %call61, label %if.then63, label %if.end73

if.then63:                                        ; preds = %lor.lhs.false56, %lor.lhs.false49, %lor.lhs.false, %if.end36
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = bitcast %struct.bpf_verifier_env* %38 to i8*
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 1
  %bf.load65 = load i8, i8* %dst_reg64, align 1
  %bf.clear66 = and i8 %bf.load65, 15
  %conv67 = zext i8 %bf.clear66 to i32
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 1
  %bf.load69 = load i8, i8* %dst_reg68, align 1
  %bf.clear70 = and i8 %bf.load69, 15
  %conv71 = zext i8 %bf.clear70 to i32
  %call72 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %41, i32 noundef %conv71) #14
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call72, i32 0, i32 0
  %43 = load i32, i32* %type, align 8
  %idxprom = zext i32 %43 to i64
  %arrayidx = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %44 = load i8*, i8** %arrayidx, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %39, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.322, i64 0, i64 0), i32 noundef %conv67, i8* noundef %44) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %lor.lhs.false56
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm74 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 3
  %46 = load i32, i32* %imm74, align 4
  %and75 = and i32 %46, 1
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %if.then77, label %if.else91

if.then77:                                        ; preds = %if.end73
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %47, i32 0, i32 3
  %48 = load i32, i32* %imm78, align 4
  %cmp79 = icmp eq i32 %48, 241
  br i1 %cmp79, label %if.then81, label %if.else

if.then81:                                        ; preds = %if.then77
  store i32 0, i32* %load_reg, align 4
  br label %if.end86

if.else:                                          ; preds = %if.then77
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg82 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %49, i32 0, i32 1
  %bf.load83 = load i8, i8* %src_reg82, align 1
  %bf.lshr84 = lshr i8 %bf.load83, 4
  %conv85 = zext i8 %bf.lshr84 to i32
  store i32 %conv85, i32* %load_reg, align 4
  br label %if.end86

if.end86:                                         ; preds = %if.else, %if.then81
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load i32, i32* %load_reg, align 4
  %call87 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %50, i32 noundef %51, i32 noundef 1) #14
  store i32 %call87, i32* %err, align 4
  %52 = load i32, i32* %err, align 4
  %tobool88 = icmp ne i32 %52, 0
  br i1 %tobool88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.end86
  %53 = load i32, i32* %err, align 4
  store i32 %53, i32* %retval, align 4
  br label %return

if.end90:                                         ; preds = %if.end86
  br label %if.end92

if.else91:                                        ; preds = %if.end73
  store i32 -1, i32* %load_reg, align 4
  br label %if.end92

if.end92:                                         ; preds = %if.else91, %if.end90
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load i32, i32* %insn_idx.addr, align 4
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg93 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %56, i32 0, i32 1
  %bf.load94 = load i8, i8* %dst_reg93, align 1
  %bf.clear95 = and i8 %bf.load94, 15
  %conv96 = zext i8 %bf.clear95 to i32
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %57, i32 0, i32 2
  %58 = load i16, i16* %off, align 2
  %conv97 = sext i16 %58 to i32
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 0
  %60 = load i8, i8* %code98, align 4
  %conv99 = zext i8 %60 to i32
  %and100 = and i32 %conv99, 24
  %61 = load i32, i32* %load_reg, align 4
  %call101 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %54, i32 noundef %55, i32 noundef %conv96, i32 noundef %conv97, i32 noundef %and100, i32 noundef 1, i32 noundef %61, i1 noundef zeroext true) #14
  store i32 %call101, i32* %err, align 4
  %62 = load i32, i32* %err, align 4
  %tobool102 = icmp ne i32 %62, 0
  br i1 %tobool102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.end92
  %63 = load i32, i32* %err, align 4
  store i32 %63, i32* %retval, align 4
  br label %return

if.end104:                                        ; preds = %if.end92
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = load i32, i32* %insn_idx.addr, align 4
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %66, i32 0, i32 1
  %bf.load106 = load i8, i8* %dst_reg105, align 1
  %bf.clear107 = and i8 %bf.load106, 15
  %conv108 = zext i8 %bf.clear107 to i32
  %67 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off109 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %67, i32 0, i32 2
  %68 = load i16, i16* %off109, align 2
  %conv110 = sext i16 %68 to i32
  %69 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code111 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %69, i32 0, i32 0
  %70 = load i8, i8* %code111, align 4
  %conv112 = zext i8 %70 to i32
  %and113 = and i32 %conv112, 24
  %call114 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %64, i32 noundef %65, i32 noundef %conv108, i32 noundef %conv110, i32 noundef %and113, i32 noundef 2, i32 noundef -1, i1 noundef zeroext true) #14
  store i32 %call114, i32* %err, align 4
  %71 = load i32, i32* %err, align 4
  %tobool115 = icmp ne i32 %71, 0
  br i1 %tobool115, label %if.then116, label %if.end117

if.then116:                                       ; preds = %if.end104
  %72 = load i32, i32* %err, align 4
  store i32 %72, i32* %retval, align 4
  br label %return

if.end117:                                        ; preds = %if.end104
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end117, %if.then116, %if.then103, %if.then89, %if.then63, %if.then31, %if.then23, %if.then15, %if.then9, %if.then, %sw.default
  %73 = load i32, i32* %retval, align 4
  ret i32 %73
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %subprog = alloca i32, align 4
  %target_insn = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load i32*, i32** %insn_idx.addr, align 8
  %1 = load i32, i32* %0, align 4
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 3
  %3 = load i32, i32* %imm, align 4
  %add = add i32 %1, %3
  %add1 = add i32 %add, 1
  store i32 %add1, i32* %target_insn, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load i32, i32* %target_insn, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %4, i32 noundef %5) #14
  store i32 %call, i32* %subprog, align 4
  %6 = load i32, i32* %subprog, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  %9 = load i32, i32* %target_insn, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.323, i64 0, i64 0), i32 noundef %9) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %12 = load i32*, i32** %insn_idx.addr, align 8
  %13 = load i32, i32* %subprog, align 4
  %call2 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %10, %struct.bpf_insn* noundef %11, i32* noundef %12, i32 noundef %13, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_callee_state) #14
  store i32 %call2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_kfunc_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %t = alloca %struct.btf_type*, align 8
  %func = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %ptr_type = alloca %struct.btf_type*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %func_name = alloca i8*, align 8
  %ptr_type_name = alloca i8*, align 8
  %i = alloca i32, align 4
  %nargs = alloca i32, align 4
  %func_id = alloca i32, align 4
  %ptr_type_id = alloca i32, align 4
  %args = alloca %struct.btf_param*, align 8
  %err = alloca i32, align 4
  %regno = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm, align 4
  store i32 %2, i32* %func_id, align 4
  %3 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %4 = load i32, i32* %func_id, align 4
  %call1 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %3, i32 noundef %4) #14
  store %struct.btf_type* %call1, %struct.btf_type** %func, align 8
  %5 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %6 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %6, i32 0, i32 0
  %7 = load i32, i32* %name_off, align 4
  %call2 = call i8* @btf_name_by_offset(%struct.btf* noundef %5, i32 noundef %7) #14
  store i8* %call2, i8** %func_name, align 8
  %8 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %9 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %10 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %9, i32 0, i32 2
  %type = bitcast %union.anon.123* %10 to i32*
  %11 = load i32, i32* %type, align 4
  %call3 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %8, i32 noundef %11) #14
  store %struct.btf_type* %call3, %struct.btf_type** %func_proto, align 8
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 3
  %13 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %check_kfunc_call = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %13, i32 0, i32 6
  %14 = load i1 (i32)*, i1 (i32)** %check_kfunc_call, align 8
  %tobool = icmp ne i1 (i32)* %14, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 3
  %16 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops4, align 8
  %check_kfunc_call5 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %16, i32 0, i32 6
  %17 = load i1 (i32)*, i1 (i32)** %check_kfunc_call5, align 8
  %18 = load i32, i32* %func_id, align 4
  %call6 = call zeroext i1 %17(i32 noundef %18) #14
  br i1 %call6, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i8*, i8** %func_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.331, i64 0, i64 0), i8* noundef %21) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %24 = load i32, i32* %func_id, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call7 = call i32 @btf_check_kfunc_arg_match(%struct.bpf_verifier_env* noundef %22, %struct.btf* noundef %23, i32 noundef %24, %struct.bpf_reg_state* noundef %25) #14
  store i32 %call7, i32* %err, align 4
  %26 = load i32, i32* %err, align 4
  %tobool8 = icmp ne i32 %26, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %27 = load i32, i32* %err, align 4
  store i32 %27, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %28 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %28, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom = zext i32 %31 to i64
  %arrayidx = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %32 = load i32, i32* %arrayidx, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %29, %struct.bpf_reg_state* noundef %30, i32 noundef %32) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load i32, i32* %i, align 4
  %inc = add i32 %33, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %35 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %36 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %35, i32 0, i32 2
  %type11 = bitcast %union.anon.123* %36 to i32*
  %37 = load i32, i32* %type11, align 4
  %call12 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %34, i32 noundef %37, i32* noundef null) #14
  store %struct.btf_type* %call12, %struct.btf_type** %t, align 8
  %38 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call13 = call zeroext i1 @btf_type_is_scalar(%struct.btf_type* noundef %38) #14
  br i1 %call13, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.end
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %39, %struct.bpf_reg_state* noundef %40, i32 noundef 0) #14
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %43 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %42, i32 0, i32 2
  %size = bitcast %union.anon.123* %43 to i32*
  %44 = load i32, i32* %size, align 4
  %conv = zext i32 %44 to i64
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %41, i32 noundef 0, i64 noundef %conv) #14
  br label %if.end30

if.else:                                          ; preds = %for.end
  %45 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call15 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %45) #14
  br i1 %call15, label %if.then16, label %if.end29

if.then16:                                        ; preds = %if.else
  %46 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %47 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %48 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %47, i32 0, i32 2
  %type17 = bitcast %union.anon.123* %48 to i32*
  %49 = load i32, i32* %type17, align 4
  %call18 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %46, i32 noundef %49, i32* noundef %ptr_type_id) #14
  store %struct.btf_type* %call18, %struct.btf_type** %ptr_type, align 8
  %50 = load %struct.btf_type*, %struct.btf_type** %ptr_type, align 8
  %call19 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %50) #14
  br i1 %call19, label %if.end24, label %if.then20

if.then20:                                        ; preds = %if.then16
  %51 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %52 = load %struct.btf_type*, %struct.btf_type** %ptr_type, align 8
  %name_off21 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %52, i32 0, i32 0
  %53 = load i32, i32* %name_off21, align 4
  %call22 = call i8* @btf_name_by_offset(%struct.btf* noundef %51, i32 noundef %53) #14
  store i8* %call22, i8** %ptr_type_name, align 8
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load i8*, i8** %func_name, align 8
  %57 = load %struct.btf_type*, %struct.btf_type** %ptr_type, align 8
  %call23 = call i8* @btf_type_str(%struct.btf_type* noundef %57) #14
  %58 = load i8*, i8** %ptr_type_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.332, i64 0, i64 0), i8* noundef %56, i8* noundef %call23, i8* noundef %58) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then16
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %59, %struct.bpf_reg_state* noundef %60, i32 noundef 0) #14
  %61 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i64 0
  %63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx25, i32 0, i32 2
  %64 = bitcast %union.anon.152* %63 to %struct.anon.154*
  %btf = getelementptr inbounds %struct.anon.154, %struct.anon.154* %64, i32 0, i32 0
  store %struct.btf* %61, %struct.btf** %btf, align 8
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx26 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i64 0
  %type27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx26, i32 0, i32 0
  store i32 19, i32* %type27, align 8
  %66 = load i32, i32* %ptr_type_id, align 4
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx28 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i64 0
  %68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx28, i32 0, i32 2
  %69 = bitcast %union.anon.152* %68 to %struct.anon.154*
  %btf_id = getelementptr inbounds %struct.anon.154, %struct.anon.154* %69, i32 0, i32 1
  store i32 %66, i32* %btf_id, align 8
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %70, i32 noundef 0, i64 noundef 8) #14
  br label %if.end29

if.end29:                                         ; preds = %if.end24, %if.else
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.then14
  %71 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call31 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %71) #14
  %conv32 = zext i16 %call31 to i32
  store i32 %conv32, i32* %nargs, align 4
  %72 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %72, i64 1
  %73 = bitcast %struct.btf_type* %add.ptr to %struct.btf_param*
  store %struct.btf_param* %73, %struct.btf_param** %args, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc47, %if.end30
  %74 = load i32, i32* %i, align 4
  %75 = load i32, i32* %nargs, align 4
  %cmp34 = icmp ult i32 %74, %75
  br i1 %cmp34, label %for.body36, label %for.end49

for.body36:                                       ; preds = %for.cond33
  %76 = load i32, i32* %i, align 4
  %add = add i32 %76, 1
  store i32 %add, i32* %regno, align 4
  %77 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %78 = load %struct.btf_param*, %struct.btf_param** %args, align 8
  %79 = load i32, i32* %i, align 4
  %idxprom37 = zext i32 %79 to i64
  %arrayidx38 = getelementptr %struct.btf_param, %struct.btf_param* %78, i64 %idxprom37
  %type39 = getelementptr inbounds %struct.btf_param, %struct.btf_param* %arrayidx38, i32 0, i32 1
  %80 = load i32, i32* %type39, align 4
  %call40 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %77, i32 noundef %80, i32* noundef null) #14
  store %struct.btf_type* %call40, %struct.btf_type** %t, align 8
  %81 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call41 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %81) #14
  br i1 %call41, label %if.then42, label %if.else43

if.then42:                                        ; preds = %for.body36
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = load i32, i32* %regno, align 4
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %82, i32 noundef %83, i64 noundef 8) #14
  br label %if.end46

if.else43:                                        ; preds = %for.body36
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %85 = load i32, i32* %regno, align 4
  %86 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %87 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %86, i32 0, i32 2
  %size44 = bitcast %union.anon.123* %87 to i32*
  %88 = load i32, i32* %size44, align 4
  %conv45 = zext i32 %88 to i64
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %84, i32 noundef %85, i64 noundef %conv45) #14
  br label %if.end46

if.end46:                                         ; preds = %if.else43, %if.then42
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %89 = load i32, i32* %i, align 4
  %inc48 = add i32 %89, 1
  store i32 %inc48, i32* %i, align 4
  br label %for.cond33

for.end49:                                        ; preds = %for.cond33
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end49, %if.then20, %if.then9, %if.then
  %90 = load i32, i32* %retval, align 4
  ret i32 %90
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx_p) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx_p.addr = alloca i32*, align 8
  %fn = alloca %struct.bpf_func_proto*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %meta = alloca %struct.bpf_call_arg_meta, align 8
  %insn_idx = alloca i32, align 4
  %changes_data = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %func_id = alloca i32, align 4
  %t = alloca %struct.btf_type*, align 8
  %tsize = alloca i32, align 4
  %ret = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %ret_btf_id221 = alloca i32, align 4
  %id267 = alloca i32, align 4
  %err_str = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx_p, i32** %insn_idx_p.addr, align 8
  store %struct.bpf_func_proto* null, %struct.bpf_func_proto** %fn, align 8
  %0 = load i32*, i32** %insn_idx_p.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %insn_idx, align 4
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 3
  %3 = load i32, i32* %imm, align 4
  store i32 %3, i32* %func_id, align 4
  %4 = load i32, i32* %func_id, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %func_id, align 4
  %cmp1 = icmp sge i32 %5, 176
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load i32, i32* %func_id, align 4
  %call = call i8* @func_id_name(i32 noundef %8) #14
  %9 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.333, i64 0, i64 0), i8* noundef %call, i32 noundef %9) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 3
  %11 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %11, i32 0, i32 0
  %12 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %tobool = icmp ne %struct.bpf_func_proto* (i32, %struct.bpf_prog*)* %12, null
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 3
  %14 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops3, align 8
  %get_func_proto4 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %14, i32 0, i32 0
  %15 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto4, align 8
  %16 = load i32, i32* %func_id, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call5 = call %struct.bpf_func_proto* %15(i32 noundef %16, %struct.bpf_prog* noundef %18) #14
  store %struct.bpf_func_proto* %call5, %struct.bpf_func_proto** %fn, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then2, %if.end
  %19 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %tobool7 = icmp ne %struct.bpf_func_proto* %19, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end6
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %func_id, align 4
  %call9 = call i8* @func_id_name(i32 noundef %22) #14
  %23 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.334, i64 0, i64 0), i8* noundef %call9, i32 noundef %23) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 2
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog11, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 1
  %bf.load = load i16, i16* %gpl_compatible, align 2
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %tobool12 = icmp ne i16 %bf.clear, 0
  br i1 %tobool12, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %26 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %gpl_only = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %26, i32 0, i32 1
  %27 = load i8, i8* %gpl_only, align 8
  %tobool13 = trunc i8 %27 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.335, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true, %if.end10
  %30 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %allowed = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %30, i32 0, i32 7
  %31 = load i1 (%struct.bpf_prog*)*, i1 (%struct.bpf_prog*)** %allowed, align 8
  %tobool16 = icmp ne i1 (%struct.bpf_prog*)* %31, null
  br i1 %tobool16, label %land.lhs.true17, label %if.end22

land.lhs.true17:                                  ; preds = %if.end15
  %32 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %allowed18 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %32, i32 0, i32 7
  %33 = load i1 (%struct.bpf_prog*)*, i1 (%struct.bpf_prog*)** %allowed18, align 8
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 2
  %35 = load %struct.bpf_prog*, %struct.bpf_prog** %prog19, align 8
  %call20 = call zeroext i1 %33(%struct.bpf_prog* noundef %35) #14
  br i1 %call20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %land.lhs.true17
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.336, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %land.lhs.true17, %if.end15
  %38 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %38, i32 0, i32 0
  %39 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %40 = bitcast i64 (i64, i64, i64, i64, i64)* %39 to i8*
  %call23 = call zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef %40) #14
  %frombool = zext i1 %call23 to i8
  store i8 %frombool, i8* %changes_data, align 1
  %41 = load i8, i8* %changes_data, align 1
  %tobool24 = trunc i8 %41 to i1
  br i1 %tobool24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.end22
  %42 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %43 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %42, i32 0, i32 4
  %44 = bitcast %union.anon.157* %43 to %struct.anon.158*
  %arg1_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %44, i32 0, i32 0
  %45 = load i32, i32* %arg1_type, align 8
  %cmp26 = icmp ne i32 %45, 11
  br i1 %cmp26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %land.lhs.true25
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = bitcast %struct.bpf_verifier_env* %46 to i8*
  %48 = load i32, i32* %func_id, align 4
  %call28 = call i8* @func_id_name(i32 noundef %48) #14
  %49 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %47, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.337, i64 0, i64 0), i8* noundef %call28, i32 noundef %49) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %land.lhs.true25, %if.end22
  %50 = bitcast %struct.bpf_call_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %50, i8 0, i64 80, i1 false)
  %51 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %51, i32 0, i32 2
  %52 = load i8, i8* %pkt_access, align 1
  %tobool30 = trunc i8 %52 to i1
  %pkt_access31 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 2
  %frombool32 = zext i1 %tobool30 to i8
  store i8 %frombool32, i8* %pkt_access31, align 1
  %53 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %54 = load i32, i32* %func_id, align 4
  %call33 = call i32 @check_func_proto(%struct.bpf_func_proto* noundef %53, i32 noundef %54) #14
  store i32 %call33, i32* %err, align 4
  %55 = load i32, i32* %err, align 4
  %tobool34 = icmp ne i32 %55, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end29
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32, i32* %func_id, align 4
  %call36 = call i8* @func_id_name(i32 noundef %58) #14
  %59 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.338, i64 0, i64 0), i8* noundef %call36, i32 noundef %59) #14
  %60 = load i32, i32* %err, align 4
  store i32 %60, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end29
  %61 = load i32, i32* %func_id, align 4
  %func_id38 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 9
  store i32 %61, i32* %func_id38, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end37
  %62 = load i32, i32* %i, align 4
  %cmp39 = icmp slt i32 %62, 5
  br i1 %cmp39, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load i32, i32* %i, align 4
  %65 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %call40 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %63, i32 noundef %64, %struct.bpf_call_arg_meta* noundef %meta, %struct.bpf_func_proto* noundef %65) #14
  store i32 %call40, i32* %err, align 4
  %66 = load i32, i32* %err, align 4
  %tobool41 = icmp ne i32 %66, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %for.body
  %67 = load i32, i32* %err, align 4
  store i32 %67, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end43
  %68 = load i32, i32* %i, align 4
  %inc = add i32 %68, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load i32, i32* %func_id, align 4
  %71 = load i32, i32* %insn_idx, align 4
  %call44 = call i32 @record_func_map(%struct.bpf_verifier_env* noundef %69, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %70, i32 noundef %71) #14
  store i32 %call44, i32* %err, align 4
  %72 = load i32, i32* %err, align 4
  %tobool45 = icmp ne i32 %72, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %for.end
  %73 = load i32, i32* %err, align 4
  store i32 %73, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %for.end
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = load i32, i32* %func_id, align 4
  %76 = load i32, i32* %insn_idx, align 4
  %call48 = call i32 @record_func_key(%struct.bpf_verifier_env* noundef %74, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %75, i32 noundef %76) #14
  store i32 %call48, i32* %err, align 4
  %77 = load i32, i32* %err, align 4
  %tobool49 = icmp ne i32 %77, 0
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end47
  %78 = load i32, i32* %err, align 4
  store i32 %78, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.end47
  store i32 0, i32* %i, align 4
  br label %for.cond52

for.cond52:                                       ; preds = %for.inc59, %if.end51
  %79 = load i32, i32* %i, align 4
  %access_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 4
  %80 = load i32, i32* %access_size, align 8
  %cmp53 = icmp slt i32 %79, %80
  br i1 %cmp53, label %for.body54, label %for.end61

for.body54:                                       ; preds = %for.cond52
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %82 = load i32, i32* %insn_idx, align 4
  %regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %83 = load i32, i32* %regno, align 4
  %84 = load i32, i32* %i, align 4
  %call55 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %81, i32 noundef %82, i32 noundef %83, i32 noundef %84, i32 noundef 16, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #14
  store i32 %call55, i32* %err, align 4
  %85 = load i32, i32* %err, align 4
  %tobool56 = icmp ne i32 %85, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %for.body54
  %86 = load i32, i32* %err, align 4
  store i32 %86, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %for.body54
  br label %for.inc59

for.inc59:                                        ; preds = %if.end58
  %87 = load i32, i32* %i, align 4
  %inc60 = add i32 %87, 1
  store i32 %inc60, i32* %i, align 4
  br label %for.cond52

for.end61:                                        ; preds = %for.cond52
  %88 = load i32, i32* %func_id, align 4
  %cmp62 = icmp eq i32 %88, 12
  br i1 %cmp62, label %if.then63, label %if.else

if.then63:                                        ; preds = %for.end61
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call64 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %89) #14
  store i32 %call64, i32* %err, align 4
  %90 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %90, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then63
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = bitcast %struct.bpf_verifier_env* %91 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %92, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.339, i64 0, i64 0)) #14
  %93 = load i32, i32* %err, align 4
  store i32 %93, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then63
  br label %if.end76

if.else:                                          ; preds = %for.end61
  %94 = load i32, i32* %func_id, align 4
  %call68 = call zeroext i1 @is_release_function(i32 noundef %94) #14
  br i1 %call68, label %if.then69, label %if.end75

if.then69:                                        ; preds = %if.else
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 7
  %96 = load i32, i32* %ref_obj_id, align 8
  %call70 = call i32 @release_reference(%struct.bpf_verifier_env* noundef %95, i32 noundef %96) #14
  store i32 %call70, i32* %err, align 4
  %97 = load i32, i32* %err, align 4
  %tobool71 = icmp ne i32 %97, 0
  br i1 %tobool71, label %if.then72, label %if.end74

if.then72:                                        ; preds = %if.then69
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %99 = bitcast %struct.bpf_verifier_env* %98 to i8*
  %100 = load i32, i32* %func_id, align 4
  %call73 = call i8* @func_id_name(i32 noundef %100) #14
  %101 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %99, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.340, i64 0, i64 0), i8* noundef %call73, i32 noundef %101) #14
  %102 = load i32, i32* %err, align 4
  store i32 %102, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.then69
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end67
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call77 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %103) #14
  store %struct.bpf_reg_state* %call77, %struct.bpf_reg_state** %regs, align 8
  %104 = load i32, i32* %func_id, align 4
  %cmp78 = icmp eq i32 %104, 81
  br i1 %cmp78, label %land.lhs.true79, label %if.end82

land.lhs.true79:                                  ; preds = %if.end76
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i64 2
  %call80 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %arrayidx) #14
  br i1 %call80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %land.lhs.true79
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.341, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %land.lhs.true79, %if.end76
  %108 = load i32, i32* %func_id, align 4
  %cmp83 = icmp eq i32 %108, 164
  br i1 %cmp83, label %if.then84, label %if.end89

if.then84:                                        ; preds = %if.end82
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %110 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %111 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 14
  %112 = load i32, i32* %subprogno, align 4
  %call85 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %109, %struct.bpf_insn* noundef %110, i32* noundef %111, i32 noundef %112, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_map_elem_callback_state) #14
  store i32 %call85, i32* %err, align 4
  %113 = load i32, i32* %err, align 4
  %cmp86 = icmp slt i32 %113, 0
  br i1 %cmp86, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.then84
  store i32 -22, i32* %retval, align 4
  br label %return

if.end88:                                         ; preds = %if.then84
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.end82
  %114 = load i32, i32* %func_id, align 4
  %cmp90 = icmp eq i32 %114, 170
  br i1 %cmp90, label %if.then91, label %if.end97

if.then91:                                        ; preds = %if.end89
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %116 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %117 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno92 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 14
  %118 = load i32, i32* %subprogno92, align 4
  %call93 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %115, %struct.bpf_insn* noundef %116, i32* noundef %117, i32 noundef %118, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_timer_callback_state) #14
  store i32 %call93, i32* %err, align 4
  %119 = load i32, i32* %err, align 4
  %cmp94 = icmp slt i32 %119, 0
  br i1 %cmp94, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.then91
  store i32 -22, i32* %retval, align 4
  br label %return

if.end96:                                         ; preds = %if.then91
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.end89
  %120 = load i32, i32* %func_id, align 4
  %cmp98 = icmp eq i32 %120, 165
  br i1 %cmp98, label %if.then99, label %if.end104

if.then99:                                        ; preds = %if.end97
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call100 = call i32 @check_bpf_snprintf_call(%struct.bpf_verifier_env* noundef %121, %struct.bpf_reg_state* noundef %122) #14
  store i32 %call100, i32* %err, align 4
  %123 = load i32, i32* %err, align 4
  %cmp101 = icmp slt i32 %123, 0
  br i1 %cmp101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.then99
  %124 = load i32, i32* %err, align 4
  store i32 %124, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %if.then99
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.end97
  store i32 0, i32* %i, align 4
  br label %for.cond105

for.cond105:                                      ; preds = %for.inc112, %if.end104
  %125 = load i32, i32* %i, align 4
  %cmp106 = icmp slt i32 %125, 6
  br i1 %cmp106, label %for.body107, label %for.end114

for.body107:                                      ; preds = %for.cond105
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %128 = load i32, i32* %i, align 4
  %idxprom = sext i32 %128 to i64
  %arrayidx108 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %129 = load i32, i32* %arrayidx108, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %126, %struct.bpf_reg_state* noundef %127, i32 noundef %129) #14
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = load i32, i32* %i, align 4
  %idxprom109 = sext i32 %131 to i64
  %arrayidx110 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom109
  %132 = load i32, i32* %arrayidx110, align 4
  %call111 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %130, i32 noundef %132, i32 noundef 2) #14
  br label %for.inc112

for.inc112:                                       ; preds = %for.body107
  %133 = load i32, i32* %i, align 4
  %inc113 = add i32 %133, 1
  store i32 %inc113, i32* %i, align 4
  br label %for.cond105

for.end114:                                       ; preds = %for.cond105
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx115 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %134, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx115, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  %135 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %135, i32 0, i32 3
  %136 = load i32, i32* %ret_type, align 4
  %cmp116 = icmp eq i32 %136, 0
  br i1 %cmp116, label %if.then117, label %if.else118

if.then117:                                       ; preds = %for.end114
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %137, %struct.bpf_reg_state* noundef %138, i32 noundef 0) #14
  br label %if.end248

if.else118:                                       ; preds = %for.end114
  %139 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type119 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %139, i32 0, i32 3
  %140 = load i32, i32* %ret_type119, align 4
  %cmp120 = icmp eq i32 %140, 1
  br i1 %cmp120, label %if.then121, label %if.else123

if.then121:                                       ; preds = %if.else118
  %141 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx122 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %141, i64 0
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx122, i32 0, i32 0
  store i32 0, i32* %type, align 8
  br label %if.end247

if.else123:                                       ; preds = %if.else118
  %142 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type124 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %142, i32 0, i32 3
  %143 = load i32, i32* %ret_type124, align 4
  %cmp125 = icmp eq i32 %143, 3
  br i1 %cmp125, label %if.then129, label %lor.lhs.false126

lor.lhs.false126:                                 ; preds = %if.else123
  %144 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type127 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %144, i32 0, i32 3
  %145 = load i32, i32* %ret_type127, align 4
  %cmp128 = icmp eq i32 %145, 2
  br i1 %cmp128, label %if.then129, label %if.else153

if.then129:                                       ; preds = %lor.lhs.false126, %if.else123
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %146, %struct.bpf_reg_state* noundef %147, i32 noundef 0) #14
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %148 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %cmp130 = icmp eq %struct.bpf_map* %148, null
  br i1 %cmp130, label %if.then131, label %if.end132

if.then131:                                       ; preds = %if.then129
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %150 = bitcast %struct.bpf_verifier_env* %149 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %150, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.342, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end132:                                        ; preds = %if.then129
  %map_ptr133 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %151 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr133, align 8
  %152 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx134 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %152, i64 0
  %153 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx134, i32 0, i32 2
  %154 = bitcast %union.anon.152* %153 to %struct.anon.153*
  %map_ptr135 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %154, i32 0, i32 0
  store %struct.bpf_map* %151, %struct.bpf_map** %map_ptr135, align 8
  %map_uid = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  %155 = load i32, i32* %map_uid, align 4
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx136 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i64 0
  %157 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx136, i32 0, i32 2
  %158 = bitcast %union.anon.152* %157 to %struct.anon.153*
  %map_uid137 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %158, i32 0, i32 1
  store i32 %155, i32* %map_uid137, align 8
  %159 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type138 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %159, i32 0, i32 3
  %160 = load i32, i32* %ret_type138, align 4
  %cmp139 = icmp eq i32 %160, 2
  br i1 %cmp139, label %if.then140, label %if.else149

if.then140:                                       ; preds = %if.end132
  %161 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx141 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %161, i64 0
  %type142 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx141, i32 0, i32 0
  store i32 4, i32* %type142, align 8
  %map_ptr143 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %162 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr143, align 8
  %call144 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %162) #14
  br i1 %call144, label %if.then145, label %if.end148

if.then145:                                       ; preds = %if.then140
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %163, i32 0, i32 15
  %164 = load i32, i32* %id_gen, align 8
  %inc146 = add i32 %164, 1
  store i32 %inc146, i32* %id_gen, align 8
  %165 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx147 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %165, i64 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx147, i32 0, i32 3
  store i32 %inc146, i32* %id, align 8
  br label %if.end148

if.end148:                                        ; preds = %if.then145, %if.then140
  br label %if.end152

if.else149:                                       ; preds = %if.end132
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx150 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i64 0
  %type151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx150, i32 0, i32 0
  store i32 5, i32* %type151, align 8
  br label %if.end152

if.end152:                                        ; preds = %if.else149, %if.end148
  br label %if.end246

if.else153:                                       ; preds = %lor.lhs.false126
  %167 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type154 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %167, i32 0, i32 3
  %168 = load i32, i32* %ret_type154, align 4
  %cmp155 = icmp eq i32 %168, 4
  br i1 %cmp155, label %if.then156, label %if.else159

if.then156:                                       ; preds = %if.else153
  %169 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %169, %struct.bpf_reg_state* noundef %170, i32 noundef 0) #14
  %171 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx157 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %171, i64 0
  %type158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx157, i32 0, i32 0
  store i32 12, i32* %type158, align 8
  br label %if.end245

if.else159:                                       ; preds = %if.else153
  %172 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type160 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %172, i32 0, i32 3
  %173 = load i32, i32* %ret_type160, align 4
  %cmp161 = icmp eq i32 %173, 6
  br i1 %cmp161, label %if.then162, label %if.else165

if.then162:                                       ; preds = %if.else159
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %174, %struct.bpf_reg_state* noundef %175, i32 noundef 0) #14
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx163 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i64 0
  %type164 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx163, i32 0, i32 0
  store i32 14, i32* %type164, align 8
  br label %if.end244

if.else165:                                       ; preds = %if.else159
  %177 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type166 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %177, i32 0, i32 3
  %178 = load i32, i32* %ret_type166, align 4
  %cmp167 = icmp eq i32 %178, 5
  br i1 %cmp167, label %if.then168, label %if.else171

if.then168:                                       ; preds = %if.else165
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %179, %struct.bpf_reg_state* noundef %180, i32 noundef 0) #14
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx169 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %181, i64 0
  %type170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx169, i32 0, i32 0
  store i32 16, i32* %type170, align 8
  br label %if.end243

if.else171:                                       ; preds = %if.else165
  %182 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type172 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %182, i32 0, i32 3
  %183 = load i32, i32* %ret_type172, align 4
  %cmp173 = icmp eq i32 %183, 7
  br i1 %cmp173, label %if.then174, label %if.else179

if.then174:                                       ; preds = %if.else171
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %184, %struct.bpf_reg_state* noundef %185, i32 noundef 0) #14
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx175 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i64 0
  %type176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx175, i32 0, i32 0
  store i32 22, i32* %type176, align 8
  %mem_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 5
  %187 = load i32, i32* %mem_size, align 4
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx177 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i64 0
  %189 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx177, i32 0, i32 2
  %mem_size178 = bitcast %union.anon.152* %189 to i32*
  store i32 %187, i32* %mem_size178, align 8
  br label %if.end242

if.else179:                                       ; preds = %if.else171
  %190 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type180 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %190, i32 0, i32 3
  %191 = load i32, i32* %ret_type180, align 4
  %cmp181 = icmp eq i32 %191, 9
  br i1 %cmp181, label %if.then185, label %lor.lhs.false182

lor.lhs.false182:                                 ; preds = %if.else179
  %192 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type183 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %192, i32 0, i32 3
  %193 = load i32, i32* %ret_type183, align 4
  %cmp184 = icmp eq i32 %193, 10
  br i1 %cmp184, label %if.then185, label %if.else214

if.then185:                                       ; preds = %lor.lhs.false182, %if.else179
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %194, %struct.bpf_reg_state* noundef %195, i32 noundef 0) #14
  %ret_btf = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 12
  %196 = load %struct.btf*, %struct.btf** %ret_btf, align 8
  %ret_btf_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 13
  %197 = load i32, i32* %ret_btf_id, align 8
  %call186 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %196, i32 noundef %197, i32* noundef null) #14
  store %struct.btf_type* %call186, %struct.btf_type** %t, align 8
  %198 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call187 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %198) #14
  br i1 %call187, label %if.else203, label %if.then188

if.then188:                                       ; preds = %if.then185
  %ret_btf189 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 12
  %199 = load %struct.btf*, %struct.btf** %ret_btf189, align 8
  %200 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call190 = call %struct.btf_type* @btf_resolve_size(%struct.btf* noundef %199, %struct.btf_type* noundef %200, i32* noundef %tsize) #14
  store %struct.btf_type* %call190, %struct.btf_type** %ret, align 8
  %201 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %202 = bitcast %struct.btf_type* %201 to i8*
  %call191 = call zeroext i1 @IS_ERR(i8* noundef %202) #14
  br i1 %call191, label %if.then192, label %if.end196

if.then192:                                       ; preds = %if.then188
  %ret_btf193 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 12
  %203 = load %struct.btf*, %struct.btf** %ret_btf193, align 8
  %204 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %204, i32 0, i32 0
  %205 = load i32, i32* %name_off, align 4
  %call194 = call i8* @btf_name_by_offset(%struct.btf* noundef %203, i32 noundef %205) #14
  store i8* %call194, i8** %tname, align 8
  %206 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %207 = bitcast %struct.bpf_verifier_env* %206 to i8*
  %208 = load i8*, i8** %tname, align 8
  %209 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %210 = bitcast %struct.btf_type* %209 to i8*
  %call195 = call i64 @PTR_ERR(i8* noundef %210) #14
  call void (i8*, i8*, ...) @verbose(i8* noundef %207, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.343, i64 0, i64 0), i8* noundef %208, i64 noundef %call195) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end196:                                        ; preds = %if.then188
  %211 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type197 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %211, i32 0, i32 3
  %212 = load i32, i32* %ret_type197, align 4
  %cmp198 = icmp eq i32 %212, 10
  %213 = zext i1 %cmp198 to i64
  %cond = select i1 %cmp198, i32 21, i32 22
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx199 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %214, i64 0
  %type200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx199, i32 0, i32 0
  store i32 %cond, i32* %type200, align 8
  %215 = load i32, i32* %tsize, align 4
  %216 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx201 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %216, i64 0
  %217 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx201, i32 0, i32 2
  %mem_size202 = bitcast %union.anon.152* %217 to i32*
  store i32 %215, i32* %mem_size202, align 8
  br label %if.end213

if.else203:                                       ; preds = %if.then185
  %218 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type204 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %218, i32 0, i32 3
  %219 = load i32, i32* %ret_type204, align 4
  %cmp205 = icmp eq i32 %219, 10
  %220 = zext i1 %cmp205 to i64
  %cond206 = select i1 %cmp205, i32 19, i32 20
  %221 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx207 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %221, i64 0
  %type208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx207, i32 0, i32 0
  store i32 %cond206, i32* %type208, align 8
  %ret_btf209 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 12
  %222 = load %struct.btf*, %struct.btf** %ret_btf209, align 8
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx210 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i64 0
  %224 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx210, i32 0, i32 2
  %225 = bitcast %union.anon.152* %224 to %struct.anon.154*
  %btf = getelementptr inbounds %struct.anon.154, %struct.anon.154* %225, i32 0, i32 0
  store %struct.btf* %222, %struct.btf** %btf, align 8
  %ret_btf_id211 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 13
  %226 = load i32, i32* %ret_btf_id211, align 8
  %227 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx212 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %227, i64 0
  %228 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx212, i32 0, i32 2
  %229 = bitcast %union.anon.152* %228 to %struct.anon.154*
  %btf_id = getelementptr inbounds %struct.anon.154, %struct.anon.154* %229, i32 0, i32 1
  store i32 %226, i32* %btf_id, align 8
  br label %if.end213

if.end213:                                        ; preds = %if.else203, %if.end196
  br label %if.end241

if.else214:                                       ; preds = %lor.lhs.false182
  %230 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type215 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %230, i32 0, i32 3
  %231 = load i32, i32* %ret_type215, align 4
  %cmp216 = icmp eq i32 %231, 8
  br i1 %cmp216, label %if.then220, label %lor.lhs.false217

lor.lhs.false217:                                 ; preds = %if.else214
  %232 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type218 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %232, i32 0, i32 3
  %233 = load i32, i32* %ret_type218, align 4
  %cmp219 = icmp eq i32 %233, 11
  br i1 %cmp219, label %if.then220, label %if.else237

if.then220:                                       ; preds = %lor.lhs.false217, %if.else214
  %234 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %235 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %234, %struct.bpf_reg_state* noundef %235, i32 noundef 0) #14
  %236 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type222 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %236, i32 0, i32 3
  %237 = load i32, i32* %ret_type222, align 4
  %cmp223 = icmp eq i32 %237, 11
  %238 = zext i1 %cmp223 to i64
  %cond224 = select i1 %cmp223, i32 19, i32 20
  %239 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx225 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %239, i64 0
  %type226 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx225, i32 0, i32 0
  store i32 %cond224, i32* %type226, align 8
  %240 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_btf_id227 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %240, i32 0, i32 6
  %241 = load i32*, i32** %ret_btf_id227, align 8
  %242 = load i32, i32* %241, align 4
  store i32 %242, i32* %ret_btf_id221, align 4
  %243 = load i32, i32* %ret_btf_id221, align 4
  %cmp228 = icmp eq i32 %243, 0
  br i1 %cmp228, label %if.then229, label %if.end232

if.then229:                                       ; preds = %if.then220
  %244 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %245 = bitcast %struct.bpf_verifier_env* %244 to i8*
  %246 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type230 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %246, i32 0, i32 3
  %247 = load i32, i32* %ret_type230, align 4
  %248 = load i32, i32* %func_id, align 4
  %call231 = call i8* @func_id_name(i32 noundef %248) #14
  %249 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %245, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.344, i64 0, i64 0), i32 noundef %247, i8* noundef %call231, i32 noundef %249) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end232:                                        ; preds = %if.then220
  %250 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %251 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx233 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %251, i64 0
  %252 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx233, i32 0, i32 2
  %253 = bitcast %union.anon.152* %252 to %struct.anon.154*
  %btf234 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %253, i32 0, i32 0
  store %struct.btf* %250, %struct.btf** %btf234, align 8
  %254 = load i32, i32* %ret_btf_id221, align 4
  %255 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx235 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %255, i64 0
  %256 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx235, i32 0, i32 2
  %257 = bitcast %union.anon.152* %256 to %struct.anon.154*
  %btf_id236 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %257, i32 0, i32 1
  store i32 %254, i32* %btf_id236, align 8
  br label %if.end240

if.else237:                                       ; preds = %lor.lhs.false217
  %258 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %259 = bitcast %struct.bpf_verifier_env* %258 to i8*
  %260 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type238 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %260, i32 0, i32 3
  %261 = load i32, i32* %ret_type238, align 4
  %262 = load i32, i32* %func_id, align 4
  %call239 = call i8* @func_id_name(i32 noundef %262) #14
  %263 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %259, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.345, i64 0, i64 0), i32 noundef %261, i8* noundef %call239, i32 noundef %263) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end240:                                        ; preds = %if.end232
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.end213
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.then174
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.then168
  br label %if.end244

if.end244:                                        ; preds = %if.end243, %if.then162
  br label %if.end245

if.end245:                                        ; preds = %if.end244, %if.then156
  br label %if.end246

if.end246:                                        ; preds = %if.end245, %if.end152
  br label %if.end247

if.end247:                                        ; preds = %if.end246, %if.then121
  br label %if.end248

if.end248:                                        ; preds = %if.end247, %if.then117
  %264 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx249 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %264, i64 0
  %type250 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx249, i32 0, i32 0
  %265 = load i32, i32* %type250, align 8
  %call251 = call zeroext i1 @reg_type_may_be_null(i32 noundef %265) #14
  br i1 %call251, label %if.then252, label %if.end257

if.then252:                                       ; preds = %if.end248
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen253 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %266, i32 0, i32 15
  %267 = load i32, i32* %id_gen253, align 8
  %inc254 = add i32 %267, 1
  store i32 %inc254, i32* %id_gen253, align 8
  %268 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx255 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %268, i64 0
  %id256 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx255, i32 0, i32 3
  store i32 %inc254, i32* %id256, align 8
  br label %if.end257

if.end257:                                        ; preds = %if.then252, %if.end248
  %269 = load i32, i32* %func_id, align 4
  %call258 = call zeroext i1 @is_ptr_cast_function(i32 noundef %269) #14
  br i1 %call258, label %if.then259, label %if.else263

if.then259:                                       ; preds = %if.end257
  %ref_obj_id260 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 7
  %270 = load i32, i32* %ref_obj_id260, align 8
  %271 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx261 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %271, i64 0
  %ref_obj_id262 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx261, i32 0, i32 4
  store i32 %270, i32* %ref_obj_id262, align 4
  br label %if.end277

if.else263:                                       ; preds = %if.end257
  %272 = load i32, i32* %func_id, align 4
  %map_ptr264 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %273 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr264, align 8
  %call265 = call zeroext i1 @is_acquire_function(i32 noundef %272, %struct.bpf_map* noundef %273) #14
  br i1 %call265, label %if.then266, label %if.end276

if.then266:                                       ; preds = %if.else263
  %274 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %275 = load i32, i32* %insn_idx, align 4
  %call268 = call i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %274, i32 noundef %275) #14
  store i32 %call268, i32* %id267, align 4
  %276 = load i32, i32* %id267, align 4
  %cmp269 = icmp slt i32 %276, 0
  br i1 %cmp269, label %if.then270, label %if.end271

if.then270:                                       ; preds = %if.then266
  %277 = load i32, i32* %id267, align 4
  store i32 %277, i32* %retval, align 4
  br label %return

if.end271:                                        ; preds = %if.then266
  %278 = load i32, i32* %id267, align 4
  %279 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx272 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %279, i64 0
  %id273 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx272, i32 0, i32 3
  store i32 %278, i32* %id273, align 8
  %280 = load i32, i32* %id267, align 4
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx274 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i64 0
  %ref_obj_id275 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx274, i32 0, i32 4
  store i32 %280, i32* %ref_obj_id275, align 4
  br label %if.end276

if.end276:                                        ; preds = %if.end271, %if.else263
  br label %if.end277

if.end277:                                        ; preds = %if.end276, %if.then259
  %282 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %283 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type278 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %283, i32 0, i32 3
  %284 = load i32, i32* %ret_type278, align 4
  %285 = load i32, i32* %func_id, align 4
  call void @do_refine_retval_range(%struct.bpf_reg_state* noundef %282, i32 noundef %284, i32 noundef %285, %struct.bpf_call_arg_meta* noundef %meta) #14
  %286 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %map_ptr279 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %287 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr279, align 8
  %288 = load i32, i32* %func_id, align 4
  %call280 = call i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %286, %struct.bpf_map* noundef %287, i32 noundef %288) #14
  store i32 %call280, i32* %err, align 4
  %289 = load i32, i32* %err, align 4
  %tobool281 = icmp ne i32 %289, 0
  br i1 %tobool281, label %if.then282, label %if.end283

if.then282:                                       ; preds = %if.end277
  %290 = load i32, i32* %err, align 4
  store i32 %290, i32* %retval, align 4
  br label %return

if.end283:                                        ; preds = %if.end277
  %291 = load i32, i32* %func_id, align 4
  %cmp284 = icmp eq i32 %291, 67
  br i1 %cmp284, label %land.lhs.true287, label %lor.lhs.false285

lor.lhs.false285:                                 ; preds = %if.end283
  %292 = load i32, i32* %func_id, align 4
  %cmp286 = icmp eq i32 %292, 141
  br i1 %cmp286, label %land.lhs.true287, label %if.end303

land.lhs.true287:                                 ; preds = %lor.lhs.false285, %if.end283
  %293 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog288 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %293, i32 0, i32 2
  %294 = load %struct.bpf_prog*, %struct.bpf_prog** %prog288, align 8
  %has_callchain_buf = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %294, i32 0, i32 1
  %bf.load289 = load i16, i16* %has_callchain_buf, align 2
  %bf.lshr290 = lshr i16 %bf.load289, 8
  %bf.clear291 = and i16 %bf.lshr290, 1
  %tobool292 = icmp ne i16 %bf.clear291, 0
  br i1 %tobool292, label %if.end303, label %if.then293

if.then293:                                       ; preds = %land.lhs.true287
  %295 = load i32, i32* @sysctl_perf_event_max_stack, align 4
  %call294 = call i32 @get_callchain_buffers(i32 noundef %295) #14
  store i32 %call294, i32* %err, align 4
  store i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.346, i64 0, i64 0), i8** %err_str, align 8
  %296 = load i32, i32* %err, align 4
  %tobool295 = icmp ne i32 %296, 0
  br i1 %tobool295, label %if.then296, label %if.end298

if.then296:                                       ; preds = %if.then293
  %297 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %298 = bitcast %struct.bpf_verifier_env* %297 to i8*
  %299 = load i8*, i8** %err_str, align 8
  %300 = load i32, i32* %func_id, align 4
  %call297 = call i8* @func_id_name(i32 noundef %300) #14
  %301 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %298, i8* noundef %299, i8* noundef %call297, i32 noundef %301) #14
  %302 = load i32, i32* %err, align 4
  store i32 %302, i32* %retval, align 4
  br label %return

if.end298:                                        ; preds = %if.then293
  %303 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog299 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %303, i32 0, i32 2
  %304 = load %struct.bpf_prog*, %struct.bpf_prog** %prog299, align 8
  %has_callchain_buf300 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %304, i32 0, i32 1
  %bf.load301 = load i16, i16* %has_callchain_buf300, align 2
  %bf.clear302 = and i16 %bf.load301, -257
  %bf.set = or i16 %bf.clear302, 256
  store i16 %bf.set, i16* %has_callchain_buf300, align 2
  br label %if.end303

if.end303:                                        ; preds = %if.end298, %land.lhs.true287, %lor.lhs.false285
  %305 = load i32, i32* %func_id, align 4
  %cmp304 = icmp eq i32 %305, 27
  br i1 %cmp304, label %if.then307, label %lor.lhs.false305

lor.lhs.false305:                                 ; preds = %if.end303
  %306 = load i32, i32* %func_id, align 4
  %cmp306 = icmp eq i32 %306, 67
  br i1 %cmp306, label %if.then307, label %if.end312

if.then307:                                       ; preds = %lor.lhs.false305, %if.end303
  %307 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog308 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %307, i32 0, i32 2
  %308 = load %struct.bpf_prog*, %struct.bpf_prog** %prog308, align 8
  %call_get_stack = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %308, i32 0, i32 1
  %bf.load309 = load i16, i16* %call_get_stack, align 2
  %bf.clear310 = and i16 %bf.load309, -1025
  %bf.set311 = or i16 %bf.clear310, 1024
  store i16 %bf.set311, i16* %call_get_stack, align 2
  br label %if.end312

if.end312:                                        ; preds = %if.then307, %lor.lhs.false305
  %309 = load i32, i32* %func_id, align 4
  %cmp313 = icmp eq i32 %309, 173
  br i1 %cmp313, label %if.then314, label %if.end323

if.then314:                                       ; preds = %if.end312
  %310 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call315 = call i32 @check_get_func_ip(%struct.bpf_verifier_env* noundef %310) #14
  %tobool316 = icmp ne i32 %call315, 0
  br i1 %tobool316, label %if.then317, label %if.end318

if.then317:                                       ; preds = %if.then314
  store i32 -524, i32* %retval, align 4
  br label %return

if.end318:                                        ; preds = %if.then314
  %311 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog319 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %311, i32 0, i32 2
  %312 = load %struct.bpf_prog*, %struct.bpf_prog** %prog319, align 8
  %call_get_func_ip = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %312, i32 0, i32 1
  %bf.load320 = load i16, i16* %call_get_func_ip, align 2
  %bf.clear321 = and i16 %bf.load320, -2049
  %bf.set322 = or i16 %bf.clear321, 2048
  store i16 %bf.set322, i16* %call_get_func_ip, align 2
  br label %if.end323

if.end323:                                        ; preds = %if.end318, %if.end312
  %313 = load i8, i8* %changes_data, align 1
  %tobool324 = trunc i8 %313 to i1
  br i1 %tobool324, label %if.then325, label %if.end326

if.then325:                                       ; preds = %if.end323
  %314 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %314) #14
  br label %if.end326

if.end326:                                        ; preds = %if.then325, %if.end323
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end326, %if.then317, %if.then296, %if.then282, %if.then270, %if.else237, %if.then229, %if.then192, %if.then131, %if.then102, %if.then95, %if.then87, %if.then81, %if.then72, %if.then66, %if.then57, %if.then50, %if.then46, %if.then42, %if.then35, %if.then27, %if.then21, %if.then14, %if.then8, %if.then
  %315 = load i32, i32* %retval, align 4
  ret i32 %315
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %env, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %r0 = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %range = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %callee, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arrayidx1, %struct.bpf_reg_state** %r0, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 0
  %8 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %8, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.408, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe2, align 8
  %dec = add i32 %12, -1
  store i32 %dec, i32* %curframe2, align 8
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 0
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe4, align 8
  %idxprom5 = zext i32 %15 to i64
  %arrayidx6 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 %idxprom5
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx6, align 8
  store %struct.bpf_func_state* %16, %struct.bpf_func_state** %caller, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 5
  %18 = load i8, i8* %in_callback_fn, align 8
  %tobool = trunc i8 %18 to i1
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #14
  %19 = bitcast %struct.tnum* %range to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = extractvalue { i64, i64 } %call, 0
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = extractvalue { i64, i64 } %call, 1
  store i64 %23, i64* %22, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type8, align 8
  %cmp9 = icmp ne i32 %25, 1
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then7
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.409, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.then7
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %29 = bitcast %struct.tnum* %range to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %34 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %34, i32 0, i32 0
  %36 = load i64, i64* %35, align 8
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %34, i32 0, i32 1
  %38 = load i64, i64* %37, align 8
  %call12 = call zeroext i1 @tnum_in(i64 %31, i64 %33, i64 %36, i64 %38) #14
  br i1 %call12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end11
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  call void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %39, %struct.bpf_reg_state* noundef %40, %struct.tnum* noundef %range, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.410, i64 0, i64 0), i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.411, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  br label %if.end17

if.else:                                          ; preds = %if.end
  %41 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %41, i32 0, i32 0
  %arrayidx16 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs15, i64 0, i64 0
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %43 = bitcast %struct.bpf_reg_state* %arrayidx16 to i8*
  %44 = bitcast %struct.bpf_reg_state* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 %44, i64 120, i1 false)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.end14
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %call18 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %45, %struct.bpf_func_state* noundef %46) #14
  store i32 %call18, i32* %err, align 4
  %47 = load i32, i32* %err, align 4
  %tobool19 = icmp ne i32 %47, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %48 = load i32, i32* %err, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %49 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %49, i32 0, i32 1
  %50 = load i32, i32* %callsite, align 8
  %add = add i32 %50, 1
  %51 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %add, i32* %51, align 4
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %52, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %53 = load i32, i32* %level, align 8
  %and = and i32 %53, 3
  %tobool22 = icmp ne i32 %and, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.412, i64 0, i64 0)) #14
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %56, %struct.bpf_func_state* noundef %57) #14
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  %60 = load i32*, i32** %insn_idx.addr, align 8
  %61 = load i32, i32* %60, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.413, i64 0, i64 0), i32 noundef %61) #14
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %62, %struct.bpf_func_state* noundef %63) #14
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  %64 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %64) #14
  %65 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame25 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %65, i32 0, i32 0
  %66 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe26 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %66, i32 0, i32 4
  %67 = load i32, i32* %curframe26, align 8
  %add27 = add i32 %67, 1
  %idxprom28 = zext i32 %add27 to i64
  %arrayidx29 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame25, i64 0, i64 %idxprom28
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx29, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then13, %if.then10, %if.then
  %68 = load i32, i32* %retval, align 4
  ret i32 %68
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 7
  %3 = load i32, i32* %acquired_refs, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 8
  %7 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %7, i64 %idxprom
  %id = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx, i32 0, i32 0
  %9 = load i32, i32* %id, align 4
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 8
  %11 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs1, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %11, i64 %idxprom2
  %insn_idx = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx3, i32 0, i32 1
  %13 = load i32, i32* %insn_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.418, i64 0, i64 0), i32 noundef %9, i32 noundef %13) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 7
  %16 = load i32, i32* %acquired_refs4, align 4
  %tobool = icmp ne i32 %16, 0
  %17 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 -22, i32 0
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_return_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %enforce_attach_type_range = alloca %struct.tnum, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %range = alloca %struct.tnum, align 8
  %prog_type = alloca i32, align 4
  %err = alloca i32, align 4
  %frame = alloca %struct.bpf_func_state*, align 8
  %is_subprog = alloca i8, align 1
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %tmp73 = alloca %struct.tnum, align 8
  %tmp81 = alloca %struct.tnum, align 8
  %tmp83 = alloca %struct.tnum, align 8
  %tmp93 = alloca %struct.tnum, align 8
  %tmp99 = alloca %struct.tnum, align 8
  %tmp104 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %0, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %2, %struct.bpf_prog** %prog, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #14
  %3 = bitcast %struct.tnum* %range to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 2
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call3 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %9) #14
  store i32 %call3, i32* %prog_type, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame4, i64 0, i64 0
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %12, %struct.bpf_func_state** %frame, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 3
  %14 = load i32, i32* %subprogno, align 8
  %tobool = icmp ne i32 %14, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %is_subprog, align 1
  %15 = load i8, i8* %is_subprog, align 1
  %tobool5 = trunc i8 %15 to i1
  br i1 %tobool5, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %16 = load i32, i32* %prog_type, align 4
  %cmp = icmp eq i32 %16, 27
  br i1 %cmp, label %land.lhs.true7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %17 = load i32, i32* %prog_type, align 4
  %cmp6 = icmp eq i32 %17, 29
  br i1 %cmp6, label %land.lhs.true7, label %if.end

land.lhs.true7:                                   ; preds = %lor.lhs.false, %land.lhs.true
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %18, i32 0, i32 10
  %19 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %19, i32 0, i32 28
  %20 = load %struct.btf_type*, %struct.btf_type** %attach_func_proto, align 8
  %21 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %20, i32 0, i32 2
  %type = bitcast %union.anon.123* %21 to i32*
  %22 = load i32, i32* %type, align 4
  %tobool8 = icmp ne i32 %22, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true7
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true7, %lor.lhs.false, %entry
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call9 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %23, i32 noundef 0, i32 noundef 0) #14
  store i32 %call9, i32* %err, align 4
  %24 = load i32, i32* %err, align 4
  %tobool10 = icmp ne i32 %24, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  %25 = load i32, i32* %err, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call13 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %26, i32 noundef 0) #14
  br i1 %call13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.419, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end12
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call16 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %29) #14
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call16, i64 0
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %30 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %30, i32 0, i32 6
  %31 = load i8, i8* %in_async_callback_fn, align 1
  %tobool17 = trunc i8 %31 to i1
  br i1 %tobool17, label %if.then18, label %if.end29

if.then18:                                        ; preds = %if.end15
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type19, align 8
  %cmp20 = icmp ne i32 %33, 1
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.then18
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type22, align 8
  %idxprom = zext i32 %37 to i64
  %arrayidx23 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %38 = load i8*, i8** %arrayidx23, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([61 x i8], [61 x i8]* @.str.420, i64 0, i64 0), i8* noundef %38) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then18
  %call25 = call { i64, i64 } @tnum_const(i64 noundef 0) #14
  %39 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %40 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %39, i32 0, i32 0
  %41 = extractvalue { i64, i64 } %call25, 0
  store i64 %41, i64* %40, align 8
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %39, i32 0, i32 1
  %43 = extractvalue { i64, i64 } %call25, 1
  store i64 %43, i64* %42, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 5
  %45 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 0
  %47 = load i64, i64* %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %50 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %call26 = call zeroext i1 @tnum_in(i64 %47, i64 %49, i64 %52, i64 %54) #14
  br i1 %call26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end24
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %55, %struct.bpf_reg_state* noundef %56, %struct.tnum* noundef %range, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str.421, i64 0, i64 0), i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.411, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end24
  store i32 0, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end15
  %57 = load i8, i8* %is_subprog, align 1
  %tobool30 = trunc i8 %57 to i1
  br i1 %tobool30, label %if.then31, label %if.end39

if.then31:                                        ; preds = %if.end29
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 0
  %59 = load i32, i32* %type32, align 8
  %cmp33 = icmp ne i32 %59, 1
  br i1 %cmp33, label %if.then34, label %if.end38

if.then34:                                        ; preds = %if.then31
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 0
  %63 = load i32, i32* %type35, align 8
  %idxprom36 = zext i32 %63 to i64
  %arrayidx37 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom36
  %64 = load i8*, i8** %arrayidx37, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.422, i64 0, i64 0), i8* noundef %64) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.then31
  store i32 0, i32* %retval, align 4
  br label %return

if.end39:                                         ; preds = %if.end29
  %65 = load i32, i32* %prog_type, align 4
  switch i32 %65, label %sw.default107 [
    i32 18, label %sw.bb
    i32 8, label %sw.bb76
    i32 9, label %sw.bb86
    i32 13, label %sw.bb86
    i32 15, label %sw.bb86
    i32 23, label %sw.bb86
    i32 25, label %sw.bb86
    i32 17, label %sw.bb87
    i32 26, label %sw.bb95
    i32 30, label %sw.bb103
    i32 28, label %sw.bb106
  ]

sw.bb:                                            ; preds = %if.end39
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog40 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %66, i32 0, i32 2
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog40, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 3
  %68 = load i32, i32* %expected_attach_type, align 8
  %cmp41 = icmp eq i32 %68, 19
  br i1 %cmp41, label %if.then62, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %sw.bb
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 2
  %70 = load %struct.bpf_prog*, %struct.bpf_prog** %prog43, align 8
  %expected_attach_type44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %70, i32 0, i32 3
  %71 = load i32, i32* %expected_attach_type44, align 8
  %cmp45 = icmp eq i32 %71, 20
  br i1 %cmp45, label %if.then62, label %lor.lhs.false46

lor.lhs.false46:                                  ; preds = %lor.lhs.false42
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog47 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %72, i32 0, i32 2
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %prog47, align 8
  %expected_attach_type48 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %73, i32 0, i32 3
  %74 = load i32, i32* %expected_attach_type48, align 8
  %cmp49 = icmp eq i32 %74, 29
  br i1 %cmp49, label %if.then62, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %lor.lhs.false46
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 2
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %prog51, align 8
  %expected_attach_type52 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 3
  %77 = load i32, i32* %expected_attach_type52, align 8
  %cmp53 = icmp eq i32 %77, 30
  br i1 %cmp53, label %if.then62, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %lor.lhs.false50
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog55 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 2
  %79 = load %struct.bpf_prog*, %struct.bpf_prog** %prog55, align 8
  %expected_attach_type56 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %79, i32 0, i32 3
  %80 = load i32, i32* %expected_attach_type56, align 8
  %cmp57 = icmp eq i32 %80, 31
  br i1 %cmp57, label %if.then62, label %lor.lhs.false58

lor.lhs.false58:                                  ; preds = %lor.lhs.false54
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog59 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 2
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %prog59, align 8
  %expected_attach_type60 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %82, i32 0, i32 3
  %83 = load i32, i32* %expected_attach_type60, align 8
  %cmp61 = icmp eq i32 %83, 32
  br i1 %cmp61, label %if.then62, label %if.end64

if.then62:                                        ; preds = %lor.lhs.false58, %lor.lhs.false54, %lor.lhs.false50, %lor.lhs.false46, %lor.lhs.false42, %sw.bb
  %call63 = call { i64, i64 } @tnum_range(i64 noundef 1, i64 noundef 1) #14
  %84 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %85 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 0
  %86 = extractvalue { i64, i64 } %call63, 0
  store i64 %86, i64* %85, align 8
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 1
  %88 = extractvalue { i64, i64 } %call63, 1
  store i64 %88, i64* %87, align 8
  %89 = bitcast %struct.tnum* %range to i8*
  %90 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %89, i8* align 8 %90, i64 16, i1 false)
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %lor.lhs.false58
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog65 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 2
  %92 = load %struct.bpf_prog*, %struct.bpf_prog** %prog65, align 8
  %expected_attach_type66 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %92, i32 0, i32 3
  %93 = load i32, i32* %expected_attach_type66, align 8
  %cmp67 = icmp eq i32 %93, 8
  br i1 %cmp67, label %if.then72, label %lor.lhs.false68

lor.lhs.false68:                                  ; preds = %if.end64
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog69 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %94, i32 0, i32 2
  %95 = load %struct.bpf_prog*, %struct.bpf_prog** %prog69, align 8
  %expected_attach_type70 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %95, i32 0, i32 3
  %96 = load i32, i32* %expected_attach_type70, align 8
  %cmp71 = icmp eq i32 %96, 9
  br i1 %cmp71, label %if.then72, label %if.end75

if.then72:                                        ; preds = %lor.lhs.false68, %if.end64
  %call74 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 3) #14
  %97 = bitcast %struct.tnum* %tmp73 to { i64, i64 }*
  %98 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %97, i32 0, i32 0
  %99 = extractvalue { i64, i64 } %call74, 0
  store i64 %99, i64* %98, align 8
  %100 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %97, i32 0, i32 1
  %101 = extractvalue { i64, i64 } %call74, 1
  store i64 %101, i64* %100, align 8
  %102 = bitcast %struct.tnum* %range to i8*
  %103 = bitcast %struct.tnum* %tmp73 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %102, i8* align 8 %103, i64 16, i1 false)
  br label %if.end75

if.end75:                                         ; preds = %if.then72, %lor.lhs.false68
  br label %sw.epilog108

sw.bb76:                                          ; preds = %if.end39
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog77 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %104, i32 0, i32 2
  %105 = load %struct.bpf_prog*, %struct.bpf_prog** %prog77, align 8
  %expected_attach_type78 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %105, i32 0, i32 3
  %106 = load i32, i32* %expected_attach_type78, align 8
  %cmp79 = icmp eq i32 %106, 1
  br i1 %cmp79, label %if.then80, label %if.end85

if.then80:                                        ; preds = %sw.bb76
  %call82 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 3) #14
  %107 = bitcast %struct.tnum* %tmp81 to { i64, i64 }*
  %108 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 0
  %109 = extractvalue { i64, i64 } %call82, 0
  store i64 %109, i64* %108, align 8
  %110 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 1
  %111 = extractvalue { i64, i64 } %call82, 1
  store i64 %111, i64* %110, align 8
  %112 = bitcast %struct.tnum* %range to i8*
  %113 = bitcast %struct.tnum* %tmp81 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %112, i8* align 8 %113, i64 16, i1 false)
  %call84 = call { i64, i64 } @tnum_range(i64 noundef 2, i64 noundef 3) #14
  %114 = bitcast %struct.tnum* %tmp83 to { i64, i64 }*
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %114, i32 0, i32 0
  %116 = extractvalue { i64, i64 } %call84, 0
  store i64 %116, i64* %115, align 8
  %117 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %114, i32 0, i32 1
  %118 = extractvalue { i64, i64 } %call84, 1
  store i64 %118, i64* %117, align 8
  %119 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  %120 = bitcast %struct.tnum* %tmp83 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %119, i8* align 8 %120, i64 16, i1 false)
  br label %if.end85

if.end85:                                         ; preds = %if.then80, %sw.bb76
  br label %sw.epilog108

sw.bb86:                                          ; preds = %if.end39, %if.end39, %if.end39, %if.end39, %if.end39
  br label %sw.epilog108

sw.bb87:                                          ; preds = %if.end39
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog88 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 2
  %122 = load %struct.bpf_prog*, %struct.bpf_prog** %prog88, align 8
  %aux89 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %122, i32 0, i32 10
  %123 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux89, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %123, i32 0, i32 10
  %124 = load i32, i32* %attach_btf_id, align 4
  %tobool90 = icmp ne i32 %124, 0
  br i1 %tobool90, label %if.end92, label %if.then91

if.then91:                                        ; preds = %sw.bb87
  store i32 0, i32* %retval, align 4
  br label %return

if.end92:                                         ; preds = %sw.bb87
  %call94 = call { i64, i64 } @tnum_const(i64 noundef 0) #14
  %125 = bitcast %struct.tnum* %tmp93 to { i64, i64 }*
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 0
  %127 = extractvalue { i64, i64 } %call94, 0
  store i64 %127, i64* %126, align 8
  %128 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 1
  %129 = extractvalue { i64, i64 } %call94, 1
  store i64 %129, i64* %128, align 8
  %130 = bitcast %struct.tnum* %range to i8*
  %131 = bitcast %struct.tnum* %tmp93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %130, i8* align 8 %131, i64 16, i1 false)
  br label %sw.epilog108

sw.bb95:                                          ; preds = %if.end39
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog96 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %132, i32 0, i32 2
  %133 = load %struct.bpf_prog*, %struct.bpf_prog** %prog96, align 8
  %expected_attach_type97 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %133, i32 0, i32 3
  %134 = load i32, i32* %expected_attach_type97, align 8
  switch i32 %134, label %sw.default [
    i32 24, label %sw.bb98
    i32 25, label %sw.bb98
    i32 23, label %sw.bb101
    i32 26, label %sw.bb101
    i32 28, label %sw.bb102
  ]

sw.bb98:                                          ; preds = %sw.bb95, %sw.bb95
  %call100 = call { i64, i64 } @tnum_const(i64 noundef 0) #14
  %135 = bitcast %struct.tnum* %tmp99 to { i64, i64 }*
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %135, i32 0, i32 0
  %137 = extractvalue { i64, i64 } %call100, 0
  store i64 %137, i64* %136, align 8
  %138 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %135, i32 0, i32 1
  %139 = extractvalue { i64, i64 } %call100, 1
  store i64 %139, i64* %138, align 8
  %140 = bitcast %struct.tnum* %range to i8*
  %141 = bitcast %struct.tnum* %tmp99 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %140, i8* align 8 %141, i64 16, i1 false)
  br label %sw.epilog

sw.bb101:                                         ; preds = %sw.bb95, %sw.bb95
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb102:                                         ; preds = %sw.bb95
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb95
  store i32 -524, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb102, %sw.bb98
  br label %sw.epilog108

sw.bb103:                                         ; preds = %if.end39
  %call105 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #14
  %142 = bitcast %struct.tnum* %tmp104 to { i64, i64 }*
  %143 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %142, i32 0, i32 0
  %144 = extractvalue { i64, i64 } %call105, 0
  store i64 %144, i64* %143, align 8
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %142, i32 0, i32 1
  %146 = extractvalue { i64, i64 } %call105, 1
  store i64 %146, i64* %145, align 8
  %147 = bitcast %struct.tnum* %range to i8*
  %148 = bitcast %struct.tnum* %tmp104 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %147, i8* align 8 %148, i64 16, i1 false)
  br label %sw.epilog108

sw.bb106:                                         ; preds = %if.end39
  br label %sw.default107

sw.default107:                                    ; preds = %if.end39, %sw.bb106
  store i32 0, i32* %retval, align 4
  br label %return

sw.epilog108:                                     ; preds = %sw.bb103, %sw.epilog, %if.end92, %sw.bb86, %if.end85, %if.end75
  %149 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %149, i32 0, i32 0
  %150 = load i32, i32* %type109, align 8
  %cmp110 = icmp ne i32 %150, 1
  br i1 %cmp110, label %if.then111, label %if.end115

if.then111:                                       ; preds = %sw.epilog108
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %152 = bitcast %struct.bpf_verifier_env* %151 to i8*
  %153 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type112 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %153, i32 0, i32 0
  %154 = load i32, i32* %type112, align 8
  %idxprom113 = zext i32 %154 to i64
  %arrayidx114 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom113
  %155 = load i8*, i8** %arrayidx114, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %152, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.423, i64 0, i64 0), i8* noundef %155) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %sw.epilog108
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off116 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 5
  %157 = bitcast %struct.tnum* %range to { i64, i64 }*
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 0
  %159 = load i64, i64* %158, align 8
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 1
  %161 = load i64, i64* %160, align 8
  %162 = bitcast %struct.tnum* %var_off116 to { i64, i64 }*
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = load i64, i64* %163, align 8
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = load i64, i64* %165, align 8
  %call117 = call zeroext i1 @tnum_in(i64 %159, i64 %161, i64 %164, i64 %166) #14
  br i1 %call117, label %if.end119, label %if.then118

if.then118:                                       ; preds = %if.end115
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %168 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %167, %struct.bpf_reg_state* noundef %168, %struct.tnum* noundef %range, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.424, i64 0, i64 0), i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.411, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end119:                                        ; preds = %if.end115
  %169 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %170 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %169, i32 0, i32 0
  %171 = load i64, i64* %170, align 8
  %172 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %169, i32 0, i32 1
  %173 = load i64, i64* %172, align 8
  %call120 = call zeroext i1 @tnum_is_unknown(i64 %171, i64 %173) #14
  br i1 %call120, label %if.end126, label %land.lhs.true121

land.lhs.true121:                                 ; preds = %if.end119
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off122 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %174, i32 0, i32 5
  %175 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %176 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %175, i32 0, i32 0
  %177 = load i64, i64* %176, align 8
  %178 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %175, i32 0, i32 1
  %179 = load i64, i64* %178, align 8
  %180 = bitcast %struct.tnum* %var_off122 to { i64, i64 }*
  %181 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %180, i32 0, i32 0
  %182 = load i64, i64* %181, align 8
  %183 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %180, i32 0, i32 1
  %184 = load i64, i64* %183, align 8
  %call123 = call zeroext i1 @tnum_in(i64 %177, i64 %179, i64 %182, i64 %184) #14
  br i1 %call123, label %if.then124, label %if.end126

if.then124:                                       ; preds = %land.lhs.true121
  %185 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog125 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %185, i32 0, i32 2
  %186 = load %struct.bpf_prog*, %struct.bpf_prog** %prog125, align 8
  %enforce_expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %186, i32 0, i32 1
  %bf.load = load i16, i16* %enforce_expected_attach_type, align 2
  %bf.clear = and i16 %bf.load, -513
  %bf.set = or i16 %bf.clear, 512
  store i16 %bf.set, i16* %enforce_expected_attach_type, align 2
  br label %if.end126

if.end126:                                        ; preds = %if.then124, %land.lhs.true121, %if.end119
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end126, %if.then118, %if.then111, %sw.default107, %sw.default, %sw.bb101, %if.then91, %if.end38, %if.then34, %if.end28, %if.then27, %if.then21, %if.then14, %if.then11, %if.then
  %187 = load i32, i32* %retval, align 4
  ret i32 %187
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @update_branch_counts(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %br = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end44, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 2
  %2 = load i32, i32* %branches, align 8
  %dec = add i32 %2, -1
  store i32 %dec, i32* %branches, align 8
  store i32 %dec, i32* %br, align 4
  %3 = load i32, i32* %br, align 4
  %cmp = icmp slt i32 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %frombool = zext i1 %lnot1 to i8
  store i8 %frombool, i8* %__ret_do_once, align 1
  %4 = load i8, i8* %__ret_do_once, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.body
  %5 = load i8, i8* @update_branch_counts.__already_done, align 1
  %tobool3 = trunc i8 %5 to i1
  %lnot4 = xor i1 %tobool3, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.body
  %6 = phi i1 [ false, %while.body ], [ %lnot4, %land.rhs ]
  %lnot5 = xor i1 %6, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool7 = icmp ne i64 %conv, 0
  br i1 %tobool7, label %if.then, label %if.end34

if.then:                                          ; preds = %land.end
  store i8 1, i8* @update_branch_counts.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool8 = icmp ne i32 %7, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then15
  br label %do.body16

do.body16:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body16
  %8 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.425, i64 0, i64 0), i32 noundef %8) #14
  br label %do.body17

do.body17:                                        ; preds = %do.end
  br label %do.body18

do.body18:                                        ; preds = %do.body17
  br label %do.end19

do.end19:                                         ; preds = %do.body18
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1066, i32 2313, i64 12) #13, !srcloc !41
  br label %do.end21

do.end21:                                         ; preds = %do.body20
  call void asm sideeffect "432:\0A\09.pushsection .discard.reachable\0A\09.long 432b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !42
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  br label %do.end24

do.end24:                                         ; preds = %do.end23
  br label %do.body25

do.body25:                                        ; preds = %do.end24
  br label %do.end26

do.end26:                                         ; preds = %do.body25
  br label %do.end27

do.end27:                                         ; preds = %do.end26
  br label %if.end

if.end:                                           ; preds = %do.end27, %if.then
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool28 = icmp ne i32 %9, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  store i64 %conv33, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.end, %land.end
  %11 = load i8, i8* %__ret_do_once, align 1
  %tobool36 = trunc i8 %11 to i1
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  store i64 %conv41, i64* %tmp35, align 8
  %12 = load i64, i64* %tmp35, align 8
  %13 = load i32, i32* %br, align 4
  %tobool42 = icmp ne i32 %13, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end34
  br label %while.end

if.end44:                                         ; preds = %if.end34
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 1
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %15, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then43, %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %this_branch = alloca %struct.bpf_verifier_state*, align 8
  %other_branch = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %other_branch_regs = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %err = alloca i32, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %src_reg197 = alloca %struct.bpf_reg_state*, align 8
  %agg.tmp218 = alloca %struct.tnum, align 8
  %coerce233 = alloca %struct.tnum, align 8
  %agg.tmp245 = alloca %struct.tnum, align 8
  %coerce260 = alloca %struct.tnum, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on353 = alloca i32, align 4
  %tmp384 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %this_branch, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  store i32 -1, i32* %pred, align 4
  %8 = load i8, i8* %opcode, align 1
  %conv3 = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %9 = load i8, i8* %opcode, align 1
  %conv5 = zext i8 %9 to i32
  %cmp6 = icmp sgt i32 %conv5, 208
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i8, i8* %opcode, align 1
  %conv8 = zext i8 %12 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.426, i64 0, i64 0), i32 noundef %conv8) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %14 to i32
  %and11 = and i32 %conv10, 8
  %cmp12 = icmp eq i32 %and11, 8
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.427, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then14
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg19, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv20 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %19, i32 noundef %conv20, i32 noundef 0) #14
  store i32 %call, i32* %err, align 4
  %21 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %22 = load i32, i32* %err, align 4
  store i32 %22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load24 = load i8, i8* %src_reg23, align 1
  %bf.lshr25 = lshr i8 %bf.load24, 4
  %conv26 = zext i8 %bf.lshr25 to i32
  %call27 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %23, i32 noundef %conv26) #14
  br i1 %call27, label %if.then28, label %if.end33

if.then28:                                        ; preds = %if.end22
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load30 = load i8, i8* %src_reg29, align 1
  %bf.lshr31 = lshr i8 %bf.load30, 4
  %conv32 = zext i8 %bf.lshr31 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.428, i64 0, i64 0), i32 noundef %conv32) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end22
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load35 = load i8, i8* %src_reg34, align 1
  %bf.lshr36 = lshr i8 %bf.load35, 4
  %idxprom37 = zext i8 %bf.lshr36 to i64
  %arrayidx38 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom37
  store %struct.bpf_reg_state* %arrayidx38, %struct.bpf_reg_state** %src_reg, align 8
  br label %if.end47

if.else:                                          ; preds = %if.end
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.lshr41 = lshr i8 %bf.load40, 4
  %conv42 = zext i8 %bf.lshr41 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.else
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.427, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.else
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end33
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 1
  %bf.load49 = load i8, i8* %dst_reg48, align 1
  %bf.clear = and i8 %bf.load49, 15
  %conv50 = zext i8 %bf.clear to i32
  %call51 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %33, i32 noundef %conv50, i32 noundef 0) #14
  store i32 %call51, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %35, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end47
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end47
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load56 = load i8, i8* %dst_reg55, align 1
  %bf.clear57 = and i8 %bf.load56, 15
  %idxprom58 = zext i8 %bf.clear57 to i64
  %arrayidx59 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i64 %idxprom58
  store %struct.bpf_reg_state* %arrayidx59, %struct.bpf_reg_state** %dst_reg, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 0
  %40 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %40 to i32
  %and62 = and i32 %conv61, 7
  %cmp63 = icmp eq i32 %and62, 6
  %frombool = zext i1 %cmp63 to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code65, align 4
  %conv66 = zext i8 %42 to i32
  %and67 = and i32 %conv66, 8
  %cmp68 = icmp eq i32 %and67, 0
  br i1 %cmp68, label %if.then70, label %if.else75

if.then70:                                        ; preds = %if.end54
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm71, align 4
  %conv72 = sext i32 %45 to i64
  %46 = load i8, i8* %opcode, align 1
  %47 = load i8, i8* %is_jmp32, align 1
  %tobool73 = trunc i8 %47 to i1
  %call74 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %43, i64 noundef %conv72, i8 noundef zeroext %46, i1 noundef zeroext %tobool73) #14
  store i32 %call74, i32* %pred, align 4
  br label %if.end117

if.else75:                                        ; preds = %if.end54
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type, align 8
  %cmp76 = icmp eq i32 %49, 1
  br i1 %cmp76, label %land.lhs.true, label %if.else89

land.lhs.true:                                    ; preds = %if.else75
  %50 = load i8, i8* %is_jmp32, align 1
  %tobool78 = trunc i8 %50 to i1
  br i1 %tobool78, label %land.lhs.true80, label %if.else89

land.lhs.true80:                                  ; preds = %land.lhs.true
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 5
  %52 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = load i64, i64* %55, align 8
  %call81 = call { i64, i64 } @tnum_subreg(i64 %54, i64 %56) #14
  %57 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call81, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call81, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call82 = call zeroext i1 @tnum_is_const(i64 %64, i64 %66) #14
  br i1 %call82, label %if.then84, label %if.else89

if.then84:                                        ; preds = %land.lhs.true80
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 5
  %69 = bitcast %struct.tnum* %var_off85 to { i64, i64 }*
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 0
  %71 = load i64, i64* %70, align 8
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 1
  %73 = load i64, i64* %72, align 8
  %call86 = call { i64, i64 } @tnum_subreg(i64 %71, i64 %73) #14
  %74 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %75 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 0
  %76 = extractvalue { i64, i64 } %call86, 0
  store i64 %76, i64* %75, align 8
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 1
  %78 = extractvalue { i64, i64 } %call86, 1
  store i64 %78, i64* %77, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %79 = load i64, i64* %value, align 8
  %80 = load i8, i8* %opcode, align 1
  %81 = load i8, i8* %is_jmp32, align 1
  %tobool87 = trunc i8 %81 to i1
  %call88 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %67, i64 noundef %79, i8 noundef zeroext %80, i1 noundef zeroext %tobool87) #14
  store i32 %call88, i32* %pred, align 4
  br label %if.end116

if.else89:                                        ; preds = %land.lhs.true80, %land.lhs.true, %if.else75
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 0
  %83 = load i32, i32* %type90, align 8
  %cmp91 = icmp eq i32 %83, 1
  br i1 %cmp91, label %land.lhs.true93, label %if.else104

land.lhs.true93:                                  ; preds = %if.else89
  %84 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %84 to i1
  br i1 %tobool94, label %if.else104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %land.lhs.true93
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 5
  %86 = bitcast %struct.tnum* %var_off96 to { i64, i64 }*
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 0
  %88 = load i64, i64* %87, align 8
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 1
  %90 = load i64, i64* %89, align 8
  %call97 = call zeroext i1 @tnum_is_const(i64 %88, i64 %90) #14
  br i1 %call97, label %if.then99, label %if.else104

if.then99:                                        ; preds = %land.lhs.true95
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 5
  %value101 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off100, i32 0, i32 0
  %93 = load i64, i64* %value101, align 8
  %94 = load i8, i8* %opcode, align 1
  %95 = load i8, i8* %is_jmp32, align 1
  %tobool102 = trunc i8 %95 to i1
  %call103 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %91, i64 noundef %93, i8 noundef zeroext %94, i1 noundef zeroext %tobool102) #14
  store i32 %call103, i32* %pred, align 4
  br label %if.end115

if.else104:                                       ; preds = %land.lhs.true95, %land.lhs.true93, %if.else89
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call105 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %96) #14
  br i1 %call105, label %land.lhs.true107, label %if.end114

land.lhs.true107:                                 ; preds = %if.else104
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call108 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %97) #14
  br i1 %call108, label %land.lhs.true110, label %if.end114

land.lhs.true110:                                 ; preds = %land.lhs.true107
  %98 = load i8, i8* %is_jmp32, align 1
  %tobool111 = trunc i8 %98 to i1
  br i1 %tobool111, label %if.end114, label %if.then112

if.then112:                                       ; preds = %land.lhs.true110
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %101 = load i8, i8* %opcode, align 1
  %call113 = call i32 @is_pkt_ptr_branch_taken(%struct.bpf_reg_state* noundef %99, %struct.bpf_reg_state* noundef %100, i8 noundef zeroext %101) #14
  store i32 %call113, i32* %pred, align 4
  br label %if.end114

if.end114:                                        ; preds = %if.then112, %land.lhs.true110, %land.lhs.true107, %if.else104
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.then99
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then84
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.then70
  %102 = load i32, i32* %pred, align 4
  %cmp118 = icmp sge i32 %102, 0
  br i1 %cmp118, label %if.then120, label %if.end148

if.then120:                                       ; preds = %if.end117
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call121 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %103) #14
  br i1 %call121, label %if.end128, label %if.then122

if.then122:                                       ; preds = %if.then120
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %105 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg123 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %105, i32 0, i32 1
  %bf.load124 = load i8, i8* %dst_reg123, align 1
  %bf.clear125 = and i8 %bf.load124, 15
  %conv126 = zext i8 %bf.clear125 to i32
  %call127 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %104, i32 noundef %conv126) #14
  store i32 %call127, i32* %err, align 4
  br label %if.end128

if.end128:                                        ; preds = %if.then122, %if.then120
  %106 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code129 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %106, i32 0, i32 0
  %107 = load i8, i8* %code129, align 4
  %conv130 = zext i8 %107 to i32
  %and131 = and i32 %conv130, 8
  %cmp132 = icmp eq i32 %and131, 8
  br i1 %cmp132, label %land.lhs.true134, label %if.end144

land.lhs.true134:                                 ; preds = %if.end128
  %108 = load i32, i32* %err, align 4
  %tobool135 = icmp ne i32 %108, 0
  br i1 %tobool135, label %if.end144, label %land.lhs.true136

land.lhs.true136:                                 ; preds = %land.lhs.true134
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call137 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %109) #14
  br i1 %call137, label %if.end144, label %if.then138

if.then138:                                       ; preds = %land.lhs.true136
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 1
  %bf.load140 = load i8, i8* %src_reg139, align 1
  %bf.lshr141 = lshr i8 %bf.load140, 4
  %conv142 = zext i8 %bf.lshr141 to i32
  %call143 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %110, i32 noundef %conv142) #14
  store i32 %call143, i32* %err, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.then138, %land.lhs.true136, %land.lhs.true134, %if.end128
  %112 = load i32, i32* %err, align 4
  %tobool145 = icmp ne i32 %112, 0
  br i1 %tobool145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %if.end144
  %113 = load i32, i32* %err, align 4
  store i32 %113, i32* %retval, align 4
  br label %return

if.end147:                                        ; preds = %if.end144
  br label %if.end148

if.end148:                                        ; preds = %if.end147, %if.end117
  %114 = load i32, i32* %pred, align 4
  %cmp149 = icmp eq i32 %114, 1
  br i1 %cmp149, label %if.then151, label %if.else160

if.then151:                                       ; preds = %if.end148
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 21
  %116 = load i8, i8* %bypass_spec_v1, align 1
  %tobool152 = trunc i8 %116 to i1
  br i1 %tobool152, label %if.end157, label %land.lhs.true153

land.lhs.true153:                                 ; preds = %if.then151
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %118 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %119 = load i32*, i32** %insn_idx.addr, align 8
  %120 = load i32, i32* %119, align 4
  %add = add i32 %120, 1
  %121 = load i32*, i32** %insn_idx.addr, align 8
  %122 = load i32, i32* %121, align 4
  %call154 = call %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %117, %struct.bpf_insn* noundef %118, i32 noundef %add, i32 noundef %122) #14
  %tobool155 = icmp ne %struct.bpf_verifier_state* %call154, null
  br i1 %tobool155, label %if.end157, label %if.then156

if.then156:                                       ; preds = %land.lhs.true153
  store i32 -14, i32* %retval, align 4
  br label %return

if.end157:                                        ; preds = %land.lhs.true153, %if.then151
  %123 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %123, i32 0, i32 2
  %124 = load i16, i16* %off, align 2
  %conv158 = sext i16 %124 to i32
  %125 = load i32*, i32** %insn_idx.addr, align 8
  %126 = load i32, i32* %125, align 4
  %add159 = add i32 %126, %conv158
  store i32 %add159, i32* %125, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.else160:                                       ; preds = %if.end148
  %127 = load i32, i32* %pred, align 4
  %cmp161 = icmp eq i32 %127, 0
  br i1 %cmp161, label %if.then163, label %if.end175

if.then163:                                       ; preds = %if.else160
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1164 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %128, i32 0, i32 21
  %129 = load i8, i8* %bypass_spec_v1164, align 1
  %tobool165 = trunc i8 %129 to i1
  br i1 %tobool165, label %if.end174, label %land.lhs.true166

land.lhs.true166:                                 ; preds = %if.then163
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %132 = load i32*, i32** %insn_idx.addr, align 8
  %133 = load i32, i32* %132, align 4
  %134 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %134, i32 0, i32 2
  %135 = load i16, i16* %off167, align 2
  %conv168 = sext i16 %135 to i32
  %add169 = add i32 %133, %conv168
  %add170 = add i32 %add169, 1
  %136 = load i32*, i32** %insn_idx.addr, align 8
  %137 = load i32, i32* %136, align 4
  %call171 = call %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %130, %struct.bpf_insn* noundef %131, i32 noundef %add170, i32 noundef %137) #14
  %tobool172 = icmp ne %struct.bpf_verifier_state* %call171, null
  br i1 %tobool172, label %if.end174, label %if.then173

if.then173:                                       ; preds = %land.lhs.true166
  store i32 -14, i32* %retval, align 4
  br label %return

if.end174:                                        ; preds = %land.lhs.true166, %if.then163
  store i32 0, i32* %retval, align 4
  br label %return

if.end175:                                        ; preds = %if.else160
  br label %if.end176

if.end176:                                        ; preds = %if.end175
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = load i32*, i32** %insn_idx.addr, align 8
  %140 = load i32, i32* %139, align 4
  %141 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off177 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %141, i32 0, i32 2
  %142 = load i16, i16* %off177, align 2
  %conv178 = sext i16 %142 to i32
  %add179 = add i32 %140, %conv178
  %add180 = add i32 %add179, 1
  %143 = load i32*, i32** %insn_idx.addr, align 8
  %144 = load i32, i32* %143, align 4
  %call181 = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %138, i32 noundef %add180, i32 noundef %144, i1 noundef zeroext false) #14
  store %struct.bpf_verifier_state* %call181, %struct.bpf_verifier_state** %other_branch, align 8
  %145 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %tobool182 = icmp ne %struct.bpf_verifier_state* %145, null
  br i1 %tobool182, label %if.end184, label %if.then183

if.then183:                                       ; preds = %if.end176
  store i32 -14, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %if.end176
  %146 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %frame185 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %146, i32 0, i32 0
  %147 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %curframe186 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %147, i32 0, i32 4
  %148 = load i32, i32* %curframe186, align 8
  %idxprom187 = zext i32 %148 to i64
  %arrayidx188 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame185, i64 0, i64 %idxprom187
  %149 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx188, align 8
  %regs189 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %149, i32 0, i32 0
  %arraydecay190 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs189, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay190, %struct.bpf_reg_state** %other_branch_regs, align 8
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code191 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %150, i32 0, i32 0
  %151 = load i8, i8* %code191, align 4
  %conv192 = zext i8 %151 to i32
  %and193 = and i32 %conv192, 8
  %cmp194 = icmp eq i32 %and193, 8
  br i1 %cmp194, label %if.then196, label %if.else330

if.then196:                                       ; preds = %if.end184
  %152 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %153 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg198 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %153, i32 0, i32 1
  %bf.load199 = load i8, i8* %src_reg198, align 1
  %bf.lshr200 = lshr i8 %bf.load199, 4
  %idxprom201 = zext i8 %bf.lshr200 to i64
  %arrayidx202 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %152, i64 %idxprom201
  store %struct.bpf_reg_state* %arrayidx202, %struct.bpf_reg_state** %src_reg197, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type203 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 0
  %155 = load i32, i32* %type203, align 8
  %cmp204 = icmp eq i32 %155, 1
  br i1 %cmp204, label %land.lhs.true206, label %if.end329

land.lhs.true206:                                 ; preds = %if.then196
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %type207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 0
  %157 = load i32, i32* %type207, align 8
  %cmp208 = icmp eq i32 %157, 1
  br i1 %cmp208, label %if.then210, label %if.end329

if.then210:                                       ; preds = %land.lhs.true206
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off211 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 5
  %159 = bitcast %struct.tnum* %var_off211 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = load i64, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = load i64, i64* %162, align 8
  %call212 = call zeroext i1 @tnum_is_const(i64 %161, i64 %163) #14
  br i1 %call212, label %if.then223, label %lor.lhs.false214

lor.lhs.false214:                                 ; preds = %if.then210
  %164 = load i8, i8* %is_jmp32, align 1
  %tobool215 = trunc i8 %164 to i1
  br i1 %tobool215, label %land.lhs.true217, label %if.else237

land.lhs.true217:                                 ; preds = %lor.lhs.false214
  %165 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off219 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %165, i32 0, i32 5
  %166 = bitcast %struct.tnum* %var_off219 to { i64, i64 }*
  %167 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 0
  %168 = load i64, i64* %167, align 8
  %169 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 1
  %170 = load i64, i64* %169, align 8
  %call220 = call { i64, i64 } @tnum_subreg(i64 %168, i64 %170) #14
  %171 = bitcast %struct.tnum* %agg.tmp218 to { i64, i64 }*
  %172 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %171, i32 0, i32 0
  %173 = extractvalue { i64, i64 } %call220, 0
  store i64 %173, i64* %172, align 8
  %174 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %171, i32 0, i32 1
  %175 = extractvalue { i64, i64 } %call220, 1
  store i64 %175, i64* %174, align 8
  %176 = bitcast %struct.tnum* %agg.tmp218 to { i64, i64 }*
  %177 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %176, i32 0, i32 0
  %178 = load i64, i64* %177, align 8
  %179 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %176, i32 0, i32 1
  %180 = load i64, i64* %179, align 8
  %call221 = call zeroext i1 @tnum_is_const(i64 %178, i64 %180) #14
  br i1 %call221, label %if.then223, label %if.else237

if.then223:                                       ; preds = %land.lhs.true217, %if.then210
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %182 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg224 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %182, i32 0, i32 1
  %bf.load225 = load i8, i8* %dst_reg224, align 1
  %bf.clear226 = and i8 %bf.load225, 15
  %idxprom227 = zext i8 %bf.clear226 to i64
  %arrayidx228 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %181, i64 %idxprom227
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %184 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off229 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %184, i32 0, i32 5
  %value230 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off229, i32 0, i32 0
  %185 = load i64, i64* %value230, align 8
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off231 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i32 0, i32 5
  %187 = bitcast %struct.tnum* %var_off231 to { i64, i64 }*
  %188 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %187, i32 0, i32 0
  %189 = load i64, i64* %188, align 8
  %190 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %187, i32 0, i32 1
  %191 = load i64, i64* %190, align 8
  %call232 = call { i64, i64 } @tnum_subreg(i64 %189, i64 %191) #14
  %192 = bitcast %struct.tnum* %coerce233 to { i64, i64 }*
  %193 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %192, i32 0, i32 0
  %194 = extractvalue { i64, i64 } %call232, 0
  store i64 %194, i64* %193, align 8
  %195 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %192, i32 0, i32 1
  %196 = extractvalue { i64, i64 } %call232, 1
  store i64 %196, i64* %195, align 8
  %value234 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce233, i32 0, i32 0
  %197 = load i64, i64* %value234, align 8
  %conv235 = trunc i64 %197 to i32
  %198 = load i8, i8* %opcode, align 1
  %199 = load i8, i8* %is_jmp32, align 1
  %tobool236 = trunc i8 %199 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx228, %struct.bpf_reg_state* noundef %183, i64 noundef %185, i32 noundef %conv235, i8 noundef zeroext %198, i1 noundef zeroext %tobool236) #14
  br label %if.end287

if.else237:                                       ; preds = %land.lhs.true217, %lor.lhs.false214
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off238 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i32 0, i32 5
  %201 = bitcast %struct.tnum* %var_off238 to { i64, i64 }*
  %202 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %201, i32 0, i32 0
  %203 = load i64, i64* %202, align 8
  %204 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %201, i32 0, i32 1
  %205 = load i64, i64* %204, align 8
  %call239 = call zeroext i1 @tnum_is_const(i64 %203, i64 %205) #14
  br i1 %call239, label %if.then250, label %lor.lhs.false241

lor.lhs.false241:                                 ; preds = %if.else237
  %206 = load i8, i8* %is_jmp32, align 1
  %tobool242 = trunc i8 %206 to i1
  br i1 %tobool242, label %land.lhs.true244, label %if.else264

land.lhs.true244:                                 ; preds = %lor.lhs.false241
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off246 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %207, i32 0, i32 5
  %208 = bitcast %struct.tnum* %var_off246 to { i64, i64 }*
  %209 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %208, i32 0, i32 0
  %210 = load i64, i64* %209, align 8
  %211 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %208, i32 0, i32 1
  %212 = load i64, i64* %211, align 8
  %call247 = call { i64, i64 } @tnum_subreg(i64 %210, i64 %212) #14
  %213 = bitcast %struct.tnum* %agg.tmp245 to { i64, i64 }*
  %214 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %213, i32 0, i32 0
  %215 = extractvalue { i64, i64 } %call247, 0
  store i64 %215, i64* %214, align 8
  %216 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %213, i32 0, i32 1
  %217 = extractvalue { i64, i64 } %call247, 1
  store i64 %217, i64* %216, align 8
  %218 = bitcast %struct.tnum* %agg.tmp245 to { i64, i64 }*
  %219 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %218, i32 0, i32 0
  %220 = load i64, i64* %219, align 8
  %221 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %218, i32 0, i32 1
  %222 = load i64, i64* %221, align 8
  %call248 = call zeroext i1 @tnum_is_const(i64 %220, i64 %222) #14
  br i1 %call248, label %if.then250, label %if.else264

if.then250:                                       ; preds = %land.lhs.true244, %if.else237
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %224 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %224, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %idxprom254 = zext i8 %bf.lshr253 to i64
  %arrayidx255 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i64 %idxprom254
  %225 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off256 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 5
  %value257 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off256, i32 0, i32 0
  %227 = load i64, i64* %value257, align 8
  %228 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off258 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %228, i32 0, i32 5
  %229 = bitcast %struct.tnum* %var_off258 to { i64, i64 }*
  %230 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %229, i32 0, i32 0
  %231 = load i64, i64* %230, align 8
  %232 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %229, i32 0, i32 1
  %233 = load i64, i64* %232, align 8
  %call259 = call { i64, i64 } @tnum_subreg(i64 %231, i64 %233) #14
  %234 = bitcast %struct.tnum* %coerce260 to { i64, i64 }*
  %235 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %234, i32 0, i32 0
  %236 = extractvalue { i64, i64 } %call259, 0
  store i64 %236, i64* %235, align 8
  %237 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %234, i32 0, i32 1
  %238 = extractvalue { i64, i64 } %call259, 1
  store i64 %238, i64* %237, align 8
  %value261 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce260, i32 0, i32 0
  %239 = load i64, i64* %value261, align 8
  %conv262 = trunc i64 %239 to i32
  %240 = load i8, i8* %opcode, align 1
  %241 = load i8, i8* %is_jmp32, align 1
  %tobool263 = trunc i8 %241 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %arrayidx255, %struct.bpf_reg_state* noundef %225, i64 noundef %227, i32 noundef %conv262, i8 noundef zeroext %240, i1 noundef zeroext %tobool263) #14
  br label %if.end286

if.else264:                                       ; preds = %land.lhs.true244, %lor.lhs.false241
  %242 = load i8, i8* %is_jmp32, align 1
  %tobool265 = trunc i8 %242 to i1
  br i1 %tobool265, label %if.end285, label %land.lhs.true266

land.lhs.true266:                                 ; preds = %if.else264
  %243 = load i8, i8* %opcode, align 1
  %conv267 = zext i8 %243 to i32
  %cmp268 = icmp eq i32 %conv267, 16
  br i1 %cmp268, label %if.then274, label %lor.lhs.false270

lor.lhs.false270:                                 ; preds = %land.lhs.true266
  %244 = load i8, i8* %opcode, align 1
  %conv271 = zext i8 %244 to i32
  %cmp272 = icmp eq i32 %conv271, 80
  br i1 %cmp272, label %if.then274, label %if.end285

if.then274:                                       ; preds = %lor.lhs.false270, %land.lhs.true266
  %245 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %246 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg275 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %246, i32 0, i32 1
  %bf.load276 = load i8, i8* %src_reg275, align 1
  %bf.lshr277 = lshr i8 %bf.load276, 4
  %idxprom278 = zext i8 %bf.lshr277 to i64
  %arrayidx279 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %245, i64 %idxprom278
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %248 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %248, i32 0, i32 1
  %bf.load281 = load i8, i8* %dst_reg280, align 1
  %bf.clear282 = and i8 %bf.load281, 15
  %idxprom283 = zext i8 %bf.clear282 to i64
  %arrayidx284 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i64 %idxprom283
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %250 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %251 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %arrayidx279, %struct.bpf_reg_state* noundef %arrayidx284, %struct.bpf_reg_state* noundef %249, %struct.bpf_reg_state* noundef %250, i8 noundef zeroext %251) #14
  br label %if.end285

if.end285:                                        ; preds = %if.then274, %lor.lhs.false270, %if.else264
  br label %if.end286

if.end286:                                        ; preds = %if.end285, %if.then250
  br label %if.end287

if.end287:                                        ; preds = %if.end286, %if.then223
  %252 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %252, i32 0, i32 3
  %253 = load i32, i32* %id, align 8
  %tobool288 = icmp ne i32 %253, 0
  br i1 %tobool288, label %land.lhs.true289, label %if.end328

land.lhs.true289:                                 ; preds = %if.end287
  %254 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %id290 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %254, i32 0, i32 3
  %255 = load i32, i32* %id290, align 8
  %256 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %257 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %257, i32 0, i32 1
  %bf.load292 = load i8, i8* %src_reg291, align 1
  %bf.lshr293 = lshr i8 %bf.load292, 4
  %idxprom294 = zext i8 %bf.lshr293 to i64
  %arrayidx295 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %256, i64 %idxprom294
  %id296 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx295, i32 0, i32 3
  %258 = load i32, i32* %id296, align 8
  %cmp297 = icmp ne i32 %255, %258
  %lnot = xor i1 %cmp297, true
  %lnot299 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot299 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %259 = load i32, i32* %__ret_warn_on, align 4
  %tobool300 = icmp ne i32 %259, 0
  %lnot301 = xor i1 %tobool300, true
  %lnot303 = xor i1 %lnot301, true
  %lnot.ext304 = zext i1 %lnot303 to i32
  %conv305 = sext i32 %lnot.ext304 to i64
  %tobool306 = icmp ne i64 %conv305, 0
  br i1 %tobool306, label %if.then307, label %if.end314

if.then307:                                       ; preds = %land.lhs.true289
  br label %do.body

do.body:                                          ; preds = %if.then307
  br label %do.body308

do.body308:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body308
  br label %do.body309

do.body309:                                       ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9395, i32 2307, i64 12) #13, !srcloc !43
  br label %do.end310

do.end310:                                        ; preds = %do.body309
  call void asm sideeffect "539:\0A\09.pushsection .discard.reachable\0A\09.long 539b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !44
  br label %do.body311

do.body311:                                       ; preds = %do.end310
  br label %do.end312

do.end312:                                        ; preds = %do.body311
  br label %do.end313

do.end313:                                        ; preds = %do.end312
  br label %if.end314

if.end314:                                        ; preds = %do.end313, %land.lhs.true289
  %260 = load i32, i32* %__ret_warn_on, align 4
  %tobool315 = icmp ne i32 %260, 0
  %lnot316 = xor i1 %tobool315, true
  %lnot318 = xor i1 %lnot316, true
  %lnot.ext319 = zext i1 %lnot318 to i32
  %conv320 = sext i32 %lnot.ext319 to i64
  store i64 %conv320, i64* %tmp, align 8
  %261 = load i64, i64* %tmp, align 8
  %tobool321 = icmp ne i64 %261, 0
  br i1 %tobool321, label %if.end328, label %if.then322

if.then322:                                       ; preds = %if.end314
  %262 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %263 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %262, %struct.bpf_reg_state* noundef %263) #14
  %264 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %265 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %266 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg323 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %266, i32 0, i32 1
  %bf.load324 = load i8, i8* %src_reg323, align 1
  %bf.lshr325 = lshr i8 %bf.load324, 4
  %idxprom326 = zext i8 %bf.lshr325 to i64
  %arrayidx327 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %265, i64 %idxprom326
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %264, %struct.bpf_reg_state* noundef %arrayidx327) #14
  br label %if.end328

if.end328:                                        ; preds = %if.then322, %if.end314, %if.end287
  br label %if.end329

if.end329:                                        ; preds = %if.end328, %land.lhs.true206, %if.then196
  br label %if.end345

if.else330:                                       ; preds = %if.end184
  %267 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type331 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %267, i32 0, i32 0
  %268 = load i32, i32* %type331, align 8
  %cmp332 = icmp eq i32 %268, 1
  br i1 %cmp332, label %if.then334, label %if.end344

if.then334:                                       ; preds = %if.else330
  %269 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %270 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %270, i32 0, i32 1
  %bf.load336 = load i8, i8* %dst_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %idxprom338 = zext i8 %bf.clear337 to i64
  %arrayidx339 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %269, i64 %idxprom338
  %271 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %272 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm340 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %272, i32 0, i32 3
  %273 = load i32, i32* %imm340, align 4
  %conv341 = sext i32 %273 to i64
  %274 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm342 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %274, i32 0, i32 3
  %275 = load i32, i32* %imm342, align 4
  %276 = load i8, i8* %opcode, align 1
  %277 = load i8, i8* %is_jmp32, align 1
  %tobool343 = trunc i8 %277 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx339, %struct.bpf_reg_state* noundef %271, i64 noundef %conv341, i32 noundef %275, i8 noundef zeroext %276, i1 noundef zeroext %tobool343) #14
  br label %if.end344

if.end344:                                        ; preds = %if.then334, %if.else330
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.end329
  %278 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type346 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %278, i32 0, i32 0
  %279 = load i32, i32* %type346, align 8
  %cmp347 = icmp eq i32 %279, 1
  br i1 %cmp347, label %land.lhs.true349, label %if.end398

land.lhs.true349:                                 ; preds = %if.end345
  %280 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id350 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %280, i32 0, i32 3
  %281 = load i32, i32* %id350, align 8
  %tobool351 = icmp ne i32 %281, 0
  br i1 %tobool351, label %land.lhs.true352, label %if.end398

land.lhs.true352:                                 ; preds = %land.lhs.true349
  %282 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id354 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %282, i32 0, i32 3
  %283 = load i32, i32* %id354, align 8
  %284 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %285 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg355 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %285, i32 0, i32 1
  %bf.load356 = load i8, i8* %dst_reg355, align 1
  %bf.clear357 = and i8 %bf.load356, 15
  %idxprom358 = zext i8 %bf.clear357 to i64
  %arrayidx359 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %284, i64 %idxprom358
  %id360 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx359, i32 0, i32 3
  %286 = load i32, i32* %id360, align 8
  %cmp361 = icmp ne i32 %283, %286
  %lnot363 = xor i1 %cmp361, true
  %lnot365 = xor i1 %lnot363, true
  %lnot.ext366 = zext i1 %lnot365 to i32
  store i32 %lnot.ext366, i32* %__ret_warn_on353, align 4
  %287 = load i32, i32* %__ret_warn_on353, align 4
  %tobool367 = icmp ne i32 %287, 0
  %lnot368 = xor i1 %tobool367, true
  %lnot370 = xor i1 %lnot368, true
  %lnot.ext371 = zext i1 %lnot370 to i32
  %conv372 = sext i32 %lnot.ext371 to i64
  %tobool373 = icmp ne i64 %conv372, 0
  br i1 %tobool373, label %if.then374, label %if.end383

if.then374:                                       ; preds = %land.lhs.true352
  br label %do.body375

do.body375:                                       ; preds = %if.then374
  br label %do.body376

do.body376:                                       ; preds = %do.body375
  br label %do.end377

do.end377:                                        ; preds = %do.body376
  br label %do.body378

do.body378:                                       ; preds = %do.end377
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9408, i32 2307, i64 12) #13, !srcloc !45
  br label %do.end379

do.end379:                                        ; preds = %do.body378
  call void asm sideeffect "540:\0A\09.pushsection .discard.reachable\0A\09.long 540b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !46
  br label %do.body380

do.body380:                                       ; preds = %do.end379
  br label %do.end381

do.end381:                                        ; preds = %do.body380
  br label %do.end382

do.end382:                                        ; preds = %do.end381
  br label %if.end383

if.end383:                                        ; preds = %do.end382, %land.lhs.true352
  %288 = load i32, i32* %__ret_warn_on353, align 4
  %tobool385 = icmp ne i32 %288, 0
  %lnot386 = xor i1 %tobool385, true
  %lnot388 = xor i1 %lnot386, true
  %lnot.ext389 = zext i1 %lnot388 to i32
  %conv390 = sext i32 %lnot.ext389 to i64
  store i64 %conv390, i64* %tmp384, align 8
  %289 = load i64, i64* %tmp384, align 8
  %tobool391 = icmp ne i64 %289, 0
  br i1 %tobool391, label %if.end398, label %if.then392

if.then392:                                       ; preds = %if.end383
  %290 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %291 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %290, %struct.bpf_reg_state* noundef %291) #14
  %292 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %293 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %294 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg393 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %294, i32 0, i32 1
  %bf.load394 = load i8, i8* %dst_reg393, align 1
  %bf.clear395 = and i8 %bf.load394, 15
  %idxprom396 = zext i8 %bf.clear395 to i64
  %arrayidx397 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %293, i64 %idxprom396
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %292, %struct.bpf_reg_state* noundef %arrayidx397) #14
  br label %if.end398

if.end398:                                        ; preds = %if.then392, %if.end383, %land.lhs.true349, %if.end345
  %295 = load i8, i8* %is_jmp32, align 1
  %tobool399 = trunc i8 %295 to i1
  br i1 %tobool399, label %if.else437, label %land.lhs.true400

land.lhs.true400:                                 ; preds = %if.end398
  %296 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code401 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %296, i32 0, i32 0
  %297 = load i8, i8* %code401, align 4
  %conv402 = zext i8 %297 to i32
  %and403 = and i32 %conv402, 8
  %cmp404 = icmp eq i32 %and403, 0
  br i1 %cmp404, label %land.lhs.true406, label %if.else437

land.lhs.true406:                                 ; preds = %land.lhs.true400
  %298 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm407 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %298, i32 0, i32 3
  %299 = load i32, i32* %imm407, align 4
  %cmp408 = icmp eq i32 %299, 0
  br i1 %cmp408, label %land.lhs.true410, label %if.else437

land.lhs.true410:                                 ; preds = %land.lhs.true406
  %300 = load i8, i8* %opcode, align 1
  %conv411 = zext i8 %300 to i32
  %cmp412 = icmp eq i32 %conv411, 16
  br i1 %cmp412, label %land.lhs.true418, label %lor.lhs.false414

lor.lhs.false414:                                 ; preds = %land.lhs.true410
  %301 = load i8, i8* %opcode, align 1
  %conv415 = zext i8 %301 to i32
  %cmp416 = icmp eq i32 %conv415, 80
  br i1 %cmp416, label %land.lhs.true418, label %if.else437

land.lhs.true418:                                 ; preds = %lor.lhs.false414, %land.lhs.true410
  %302 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type419 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %302, i32 0, i32 0
  %303 = load i32, i32* %type419, align 8
  %call420 = call zeroext i1 @reg_type_may_be_null(i32 noundef %303) #14
  br i1 %call420, label %if.then422, label %if.else437

if.then422:                                       ; preds = %land.lhs.true418
  %304 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %305 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg423 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %305, i32 0, i32 1
  %bf.load424 = load i8, i8* %dst_reg423, align 1
  %bf.clear425 = and i8 %bf.load424, 15
  %conv426 = zext i8 %bf.clear425 to i32
  %306 = load i8, i8* %opcode, align 1
  %conv427 = zext i8 %306 to i32
  %cmp428 = icmp eq i32 %conv427, 80
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %304, i32 noundef %conv426, i1 noundef zeroext %cmp428) #14
  %307 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %308 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg430 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %308, i32 0, i32 1
  %bf.load431 = load i8, i8* %dst_reg430, align 1
  %bf.clear432 = and i8 %bf.load431, 15
  %conv433 = zext i8 %bf.clear432 to i32
  %309 = load i8, i8* %opcode, align 1
  %conv434 = zext i8 %309 to i32
  %cmp435 = icmp eq i32 %conv434, 16
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %307, i32 noundef %conv433, i1 noundef zeroext %cmp435) #14
  br label %if.end457

if.else437:                                       ; preds = %land.lhs.true418, %lor.lhs.false414, %land.lhs.true406, %land.lhs.true400, %if.end398
  %310 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %311 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %312 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %313 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg438 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %313, i32 0, i32 1
  %bf.load439 = load i8, i8* %src_reg438, align 1
  %bf.lshr440 = lshr i8 %bf.load439, 4
  %idxprom441 = zext i8 %bf.lshr440 to i64
  %arrayidx442 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %312, i64 %idxprom441
  %314 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %315 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %call443 = call zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %310, %struct.bpf_reg_state* noundef %311, %struct.bpf_reg_state* noundef %arrayidx442, %struct.bpf_verifier_state* noundef %314, %struct.bpf_verifier_state* noundef %315) #14
  br i1 %call443, label %if.end456, label %land.lhs.true444

land.lhs.true444:                                 ; preds = %if.else437
  %316 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %317 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg445 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %317, i32 0, i32 1
  %bf.load446 = load i8, i8* %dst_reg445, align 1
  %bf.clear447 = and i8 %bf.load446, 15
  %conv448 = zext i8 %bf.clear447 to i32
  %call449 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %316, i32 noundef %conv448) #14
  br i1 %call449, label %if.then451, label %if.end456

if.then451:                                       ; preds = %land.lhs.true444
  %318 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %319 = bitcast %struct.bpf_verifier_env* %318 to i8*
  %320 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg452 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %320, i32 0, i32 1
  %bf.load453 = load i8, i8* %dst_reg452, align 1
  %bf.clear454 = and i8 %bf.load453, 15
  %conv455 = zext i8 %bf.clear454 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %319, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.428, i64 0, i64 0), i32 noundef %conv455) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end456:                                        ; preds = %land.lhs.true444, %if.else437
  br label %if.end457

if.end457:                                        ; preds = %if.end456, %if.then422
  %321 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %321, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %322 = load i32, i32* %level, align 8
  %and458 = and i32 %322, 3
  %tobool459 = icmp ne i32 %and458, 0
  br i1 %tobool459, label %if.then460, label %if.end465

if.then460:                                       ; preds = %if.end457
  %323 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %324 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame461 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %324, i32 0, i32 0
  %325 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe462 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %325, i32 0, i32 4
  %326 = load i32, i32* %curframe462, align 8
  %idxprom463 = zext i32 %326 to i64
  %arrayidx464 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame461, i64 0, i64 %idxprom463
  %327 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx464, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %323, %struct.bpf_func_state* noundef %327) #14
  br label %if.end465

if.end465:                                        ; preds = %if.then460, %if.end457
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end465, %if.then451, %if.then183, %if.end174, %if.then173, %if.end157, %if.then156, %if.then146, %if.then53, %if.then45, %if.then28, %if.then21, %if.then17, %if.then
  %328 = load i32, i32* %retval, align 4
  ret i32 %328
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %mode = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 224
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %mode, align 1
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call2 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #14
  %call3 = call zeroext i1 @may_access_skb(i32 noundef %call2) #14
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.429, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 3
  %8 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %8, i32 0, i32 3
  %9 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, %struct.bpf_insn*)* %9, null
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv6 = zext i8 %bf.clear to i32
  %cmp = icmp ne i32 %conv6, 0
  br i1 %cmp, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 2
  %14 = load i16, i16* %off, align 2
  %conv8 = sext i16 %14 to i32
  %cmp9 = icmp ne i32 %conv8, 0
  br i1 %cmp9, label %if.then25, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code12, align 4
  %conv13 = zext i8 %16 to i32
  %and14 = and i32 %conv13, 24
  %cmp15 = icmp eq i32 %and14, 24
  br i1 %cmp15, label %if.then25, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false11
  %17 = load i8, i8* %mode, align 1
  %conv18 = zext i8 %17 to i32
  %cmp19 = icmp eq i32 %conv18, 32
  br i1 %cmp19, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %lor.lhs.false17
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load21 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load21, 4
  %conv22 = zext i8 %bf.lshr to i32
  %cmp23 = icmp ne i32 %conv22, 0
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true, %lor.lhs.false11, %lor.lhs.false, %if.end5
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.431, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %lor.lhs.false17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call27 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %21, i32 noundef 6, i32 noundef 0) #14
  store i32 %call27, i32* %err, align 4
  %22 = load i32, i32* %err, align 4
  %tobool28 = icmp ne i32 %22, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end26
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end26
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %24) #14
  store i32 %call31, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool32 = icmp ne i32 %25, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.432, i64 0, i64 0)) #14
  %28 = load i32, i32* %err, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end30
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 8
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %30, i32 0, i32 5
  %31 = load i32, i32* %active_spin_lock, align 4
  %tobool35 = icmp ne i32 %31, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end34
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.433, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end34
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i64 6
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  %35 = load i32, i32* %type, align 8
  %cmp38 = icmp ne i32 %35, 2
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end37
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.434, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end37
  %38 = load i8, i8* %mode, align 1
  %conv42 = zext i8 %38 to i32
  %cmp43 = icmp eq i32 %conv42, 64
  br i1 %cmp43, label %if.then45, label %if.end54

if.then45:                                        ; preds = %if.end41
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 1
  %bf.load47 = load i8, i8* %src_reg46, align 1
  %bf.lshr48 = lshr i8 %bf.load47, 4
  %conv49 = zext i8 %bf.lshr48 to i32
  %call50 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %39, i32 noundef %conv49, i32 noundef 0) #14
  store i32 %call50, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool51 = icmp ne i32 %41, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then45
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.then45
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end41
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx55 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i64 6
  %call56 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %43, %struct.bpf_reg_state* noundef %arrayidx55, i32 noundef 6) #14
  store i32 %call56, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %cmp57 = icmp slt i32 %45, 0
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end54
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end54
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end60
  %47 = load i32, i32* %i, align 4
  %cmp61 = icmp slt i32 %47, 6
  br i1 %cmp61, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %50 = load i32, i32* %i, align 4
  %idxprom = sext i32 %50 to i64
  %arrayidx63 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %51 = load i32, i32* %arrayidx63, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %48, %struct.bpf_reg_state* noundef %49, i32 noundef %51) #14
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %i, align 4
  %idxprom64 = sext i32 %53 to i64
  %arrayidx65 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom64
  %54 = load i32, i32* %arrayidx65, align 4
  %call66 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %52, i32 noundef %54, i32 noundef 2) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %55 = load i32, i32* %i, align 4
  %inc = add i32 %55, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %57, i32 noundef 0) #14
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 0
  %59 = load i32, i32* %insn_idx, align 8
  %add = add i32 %59, 1
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx67 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx67, i32 0, i32 16
  store i32 %add, i32* %subreg_def, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then59, %if.then52, %if.then40, %if.then36, %if.then33, %if.then29, %if.then25, %if.then4, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %imm = alloca i64, align 8
  %aux59 = alloca %struct.bpf_prog_aux*, align 8
  %subprogno = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call1 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #14
  store %struct.bpf_reg_state* %call1, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.435, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 2
  %7 = load i16, i16* %off, align 2
  %conv3 = sext i16 %7 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.436, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg8, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv9 = zext i8 %bf.clear to i32
  %call10 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %10, i32 noundef %conv9, i32 noundef 1) #14
  store i32 %call10, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end7
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load14 = load i8, i8* %dst_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %idxprom = zext i8 %bf.clear15 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %dst_reg, align 8
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 1
  %bf.load16 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load16, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp eq i32 %conv17, 0
  br i1 %cmp18, label %if.then20, label %if.end30

if.then20:                                        ; preds = %if.end12
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %17, i64 1
  %imm21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i32 0, i32 3
  %18 = load i32, i32* %imm21, align 4
  %conv22 = sext i32 %18 to i64
  %shl = shl i64 %conv22, 32
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 3
  %20 = load i32, i32* %imm23, align 4
  %conv24 = zext i32 %20 to i64
  %or = or i64 %shl, %conv24
  store i64 %or, i64* %imm, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg25 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 1
  %bf.load26 = load i8, i8* %dst_reg25, align 1
  %bf.clear27 = and i8 %bf.load26, 15
  %idxprom28 = zext i8 %bf.clear27 to i64
  %arrayidx29 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i64 %idxprom28
  %24 = load i64, i64* %imm, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx29, i64 noundef %24) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end12
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %25, i32 0, i32 1
  %bf.load32 = load i8, i8* %src_reg31, align 1
  %bf.lshr33 = lshr i8 %bf.load32, 4
  %conv34 = zext i8 %bf.lshr33 to i32
  %cmp35 = icmp eq i32 %conv34, 3
  br i1 %cmp35, label %if.then37, label %if.end51

if.then37:                                        ; preds = %if.end30
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg38 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load39 = load i8, i8* %dst_reg38, align 1
  %bf.clear40 = and i8 %bf.load39, 15
  %conv41 = zext i8 %bf.clear40 to i32
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %27, i32 noundef %conv41) #14
  %29 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %30 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %29, i32 0, i32 0
  %btf_var = bitcast %union.anon.163* %30 to %struct.anon.165*
  %reg_type = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var, i32 0, i32 0
  %31 = load i32, i32* %reg_type, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  store i32 %31, i32* %type42, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 0
  %34 = load i32, i32* %type43, align 8
  switch i32 %34, label %sw.default [
    i32 21, label %sw.bb
    i32 19, label %sw.bb46
    i32 27, label %sw.bb46
  ]

sw.bb:                                            ; preds = %if.then37
  %35 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %36 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %35, i32 0, i32 0
  %btf_var44 = bitcast %union.anon.163* %36 to %struct.anon.165*
  %37 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var44, i32 0, i32 1
  %mem_size = bitcast %union.anon.166* %37 to i32*
  %38 = load i32, i32* %mem_size, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 2
  %mem_size45 = bitcast %union.anon.152* %40 to i32*
  store i32 %38, i32* %mem_size45, align 8
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.then37, %if.then37
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %41, i32 0, i32 0
  %btf_var47 = bitcast %union.anon.163* %42 to %struct.anon.165*
  %43 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var47, i32 0, i32 1
  %44 = bitcast %union.anon.166* %43 to %struct.anon.167*
  %btf = getelementptr inbounds %struct.anon.167, %struct.anon.167* %44, i32 0, i32 0
  %45 = load %struct.btf*, %struct.btf** %btf, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 2
  %48 = bitcast %union.anon.152* %47 to %struct.anon.154*
  %btf48 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %48, i32 0, i32 0
  store %struct.btf* %45, %struct.btf** %btf48, align 8
  %49 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %50 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %49, i32 0, i32 0
  %btf_var49 = bitcast %union.anon.163* %50 to %struct.anon.165*
  %51 = getelementptr inbounds %struct.anon.165, %struct.anon.165* %btf_var49, i32 0, i32 1
  %52 = bitcast %union.anon.166* %51 to %struct.anon.167*
  %btf_id = getelementptr inbounds %struct.anon.167, %struct.anon.167* %52, i32 0, i32 1
  %53 = load i32, i32* %btf_id, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 2
  %56 = bitcast %union.anon.152* %55 to %struct.anon.154*
  %btf_id50 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %56, i32 0, i32 1
  store i32 %53, i32* %btf_id50, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.then37
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb46, %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.end30
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg52 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 1
  %bf.load53 = load i8, i8* %src_reg52, align 1
  %bf.lshr54 = lshr i8 %bf.load53, 4
  %conv55 = zext i8 %bf.lshr54 to i32
  %cmp56 = icmp eq i32 %conv55, 4
  br i1 %cmp56, label %if.then58, label %if.end75

if.then58:                                        ; preds = %if.end51
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 2
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux60 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %61, i32 0, i32 10
  %62 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux60, align 8
  store %struct.bpf_prog_aux* %62, %struct.bpf_prog_aux** %aux59, align 8
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx61 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %63, i64 1
  %imm62 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx61, i32 0, i32 3
  %64 = load i32, i32* %imm62, align 4
  store i32 %64, i32* %subprogno, align 4
  %65 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux59, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %65, i32 0, i32 48
  %66 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool63 = icmp ne %struct.bpf_func_info* %66, null
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %if.then58
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = bitcast %struct.bpf_verifier_env* %67 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %68, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.437, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.then58
  %69 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux59, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %69, i32 0, i32 49
  %70 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %71 = load i32, i32* %subprogno, align 4
  %idxprom66 = zext i32 %71 to i64
  %arrayidx67 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %70, i64 %idxprom66
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx67, i32 0, i32 0
  %72 = load i16, i16* %linkage, align 2
  %conv68 = zext i16 %72 to i32
  %cmp69 = icmp ne i32 %conv68, 0
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end65
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = bitcast %struct.bpf_verifier_env* %73 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %74, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.438, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end72:                                         ; preds = %if.end65
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 0
  store i32 28, i32* %type73, align 8
  %76 = load i32, i32* %subprogno, align 4
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 2
  %subprogno74 = bitcast %union.anon.152* %78 to i32*
  store i32 %76, i32* %subprogno74, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end75:                                         ; preds = %if.end51
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 11
  %80 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %81 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %80, i32 0, i32 0
  %82 = bitcast %union.anon.163* %81 to %struct.anon.164*
  %map_index = getelementptr inbounds %struct.anon.164, %struct.anon.164* %82, i32 0, i32 0
  %83 = load i32, i32* %map_index, align 8
  %idxprom76 = zext i32 %83 to i64
  %arrayidx77 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom76
  %84 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx77, align 8
  store %struct.bpf_map* %84, %struct.bpf_map** %map, align 8
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %87 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %87, i32 0, i32 1
  %bf.load79 = load i8, i8* %dst_reg78, align 1
  %bf.clear80 = and i8 %bf.load79, 15
  %conv81 = zext i8 %bf.clear80 to i32
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %85, %struct.bpf_reg_state* noundef %86, i32 noundef %conv81) #14
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 2
  %91 = bitcast %union.anon.152* %90 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %91, i32 0, i32 0
  store %struct.bpf_map* %88, %struct.bpf_map** %map_ptr, align 8
  %92 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg82 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %92, i32 0, i32 1
  %bf.load83 = load i8, i8* %src_reg82, align 1
  %bf.lshr84 = lshr i8 %bf.load83, 4
  %conv85 = zext i8 %bf.lshr84 to i32
  %cmp86 = icmp eq i32 %conv85, 2
  br i1 %cmp86, label %if.then94, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end75
  %93 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg88 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %93, i32 0, i32 1
  %bf.load89 = load i8, i8* %src_reg88, align 1
  %bf.lshr90 = lshr i8 %bf.load89, 4
  %conv91 = zext i8 %bf.lshr90 to i32
  %cmp92 = icmp eq i32 %conv91, 6
  br i1 %cmp92, label %if.then94, label %if.else

if.then94:                                        ; preds = %lor.lhs.false, %if.end75
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 0
  store i32 4, i32* %type95, align 8
  %95 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %96 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %95, i32 0, i32 0
  %97 = bitcast %union.anon.163* %96 to %struct.anon.164*
  %map_off = getelementptr inbounds %struct.anon.164, %struct.anon.164* %97, i32 0, i32 1
  %98 = load i32, i32* %map_off, align 4
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %99, i32 0, i32 1
  store i32 %98, i32* %off96, align 4
  %100 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call97 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %100) #14
  br i1 %call97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.then94
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 15
  %102 = load i32, i32* %id_gen, align 8
  %inc = add i32 %102, 1
  store i32 %inc, i32* %id_gen, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 3
  store i32 %inc, i32* %id, align 8
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.then94
  br label %if.end117

if.else:                                          ; preds = %lor.lhs.false
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg100 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %104, i32 0, i32 1
  %bf.load101 = load i8, i8* %src_reg100, align 1
  %bf.lshr102 = lshr i8 %bf.load101, 4
  %conv103 = zext i8 %bf.lshr102 to i32
  %cmp104 = icmp eq i32 %conv103, 1
  br i1 %cmp104, label %if.then113, label %lor.lhs.false106

lor.lhs.false106:                                 ; preds = %if.else
  %105 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg107 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %105, i32 0, i32 1
  %bf.load108 = load i8, i8* %src_reg107, align 1
  %bf.lshr109 = lshr i8 %bf.load108, 4
  %conv110 = zext i8 %bf.lshr109 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %if.then113, label %if.else115

if.then113:                                       ; preds = %lor.lhs.false106, %if.else
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type114 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 0
  store i32 3, i32* %type114, align 8
  br label %if.end116

if.else115:                                       ; preds = %lor.lhs.false106
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %108 = bitcast %struct.bpf_verifier_env* %107 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %108, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.430, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end116:                                        ; preds = %if.then113
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end99
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end117, %if.else115, %if.end72, %if.then71, %if.then64, %sw.epilog, %sw.default, %if.then20, %if.then11, %if.then6, %if.then
  %109 = load i32, i32* %retval, align 4
  ret i32 %109
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 9
  %7 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %8 = load i32, i32* %idx.addr, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 1
  %10 = load i32, i32* %callsite, align 8
  %xor = xor i32 %8, %10
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %11) #14
  %rem = urem i32 %xor, %call
  %idxprom1 = zext i32 %rem to i64
  %arrayidx2 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %7, i64 %idxprom1
  ret %struct.bpf_verifier_state_list** %arrayidx2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_live_states(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca i32, align 4
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn, i32* %insn.addr, align 4
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %insn.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call, align 8
  store %struct.bpf_verifier_state_list* %2, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %next, %entry
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %4, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 2
  %5 = load i32, i32* %branches, align 8
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %next

if.end:                                           ; preds = %while.body
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state2 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %6, i32 0, i32 0
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state2, i32 0, i32 3
  %7 = load i32, i32* %insn_idx, align 4
  %8 = load i32, i32* %insn.addr, align 4
  %cmp = icmp ne i32 %7, %8
  br i1 %cmp, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state3 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %9, i32 0, i32 0
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state3, i32 0, i32 4
  %10 = load i32, i32* %curframe, align 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe4, align 8
  %cmp5 = icmp ne i32 %10, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  br label %next

if.end7:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe8, align 8
  %cmp9 = icmp ule i32 %13, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state10 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %16, i32 0, i32 0
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state10, i32 0, i32 0
  %17 = load i32, i32* %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 1
  %19 = load i32, i32* %callsite, align 8
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %21 to i64
  %arrayidx13 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame11, i64 0, i64 %idxprom12
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx13, align 8
  %callsite14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 1
  %23 = load i32, i32* %callsite14, align 8
  %cmp15 = icmp ne i32 %19, %23
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body
  br label %next

if.end17:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state18 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %26, i32 0, i32 0
  call void @clean_verifier_state(%struct.bpf_verifier_env* noundef %25, %struct.bpf_verifier_state* noundef %state18) #14
  br label %next

next:                                             ; preds = %for.end, %if.then16, %if.then6, %if.then
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next19 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %27, i32 0, i32 1
  %28 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next19, align 8
  store %struct.bpf_verifier_state_list* %28, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %fold = alloca %struct.bpf_func_state*, align 8
  %fcur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %fr = alloca i32, align 4
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  store i32 %1, i32* %fr, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %4 = load i32, i32* %fr, align 4
  %cmp = icmp ne i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load i32, i32* %fr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %7, %struct.bpf_func_state** %fold, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 0
  %9 = load i32, i32* %fr, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom3
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %fcur, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %11, 11
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fold, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  %14 = bitcast %struct.bpf_reg_state* %arrayidx7 to i8*
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fcur, align 8
  %regs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs8, i64 0, i64 %idxprom9
  %17 = bitcast %struct.bpf_reg_state* %arrayidx10 to i8*
  %call = call i32 @memcmp(i8* noundef %14, i8* noundef %17, i64 noundef 96) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end12:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then11, %if.then
  %19 = load i1, i1* %retval, align 1
  ret i1 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 6
  %5 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %speculative2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 6
  %7 = load i8, i8* %speculative2, align 8
  %tobool3 = trunc i8 %7 to i1
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 5
  %9 = load i32, i32* %active_spin_lock, align 4
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %active_spin_lock6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 5
  %11 = load i32, i32* %active_spin_lock6, align 4
  %cmp7 = icmp ne i32 %9, %11
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store i1 false, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end5
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe10, align 8
  %cmp11 = icmp ule i32 %12, %14
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 1
  %18 = load i32, i32* %callsite, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame12 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %20 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame12, i64 0, i64 %idxprom13
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx14, align 8
  %callsite15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 1
  %22 = load i32, i32* %callsite15, align 8
  %cmp16 = icmp ne i32 %18, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end18:                                         ; preds = %for.body
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame19 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %24, i32 0, i32 0
  %25 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %25 to i64
  %arrayidx21 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame19, i64 0, i64 %idxprom20
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx21, align 8
  %27 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %27, i32 0, i32 0
  %28 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %28 to i64
  %arrayidx24 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame22, i64 0, i64 %idxprom23
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx24, align 8
  %call = call zeroext i1 @func_states_equal(%struct.bpf_verifier_env* noundef %23, %struct.bpf_func_state* noundef %26, %struct.bpf_func_state* noundef %29) #14
  br i1 %call, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i1 false, i1* %retval, align 1
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %30 = load i32, i32* %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then25, %if.then17, %if.then8, %if.then4, %if.then
  %31 = load i1, i1* %retval, align 1
  ret i1 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %vstate, %struct.bpf_verifier_state* noundef %vparent) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %vparent.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %parent_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %parent = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %frame = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %vparent, %struct.bpf_verifier_state** %vparent.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_on, align 4
  %4 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  br label %do.body5

do.body5:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body5
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 4
  %6 = load i32, i32* %curframe6, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe7 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe7, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.231, i64 0, i64 0), i32 noundef %6, i32 noundef %8) #14
  br label %do.body8

do.body8:                                         ; preds = %do.end
  br label %do.body9

do.body9:                                         ; preds = %do.body8
  br label %do.end10

do.end10:                                         ; preds = %do.body9
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 12454, i32 2313, i64 12) #13, !srcloc !47
  br label %do.end12

do.end12:                                         ; preds = %do.body11
  call void asm sideeffect "547:\0A\09.pushsection .discard.reachable\0A\09.long 547b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !48
  br label %do.body13

do.body13:                                        ; preds = %do.end12
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.end15

do.end15:                                         ; preds = %do.end14
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  br label %do.end17

do.end17:                                         ; preds = %do.body16
  br label %do.end18

do.end18:                                         ; preds = %do.end17
  br label %if.end

if.end:                                           ; preds = %do.end18, %if.then
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %9, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  store i64 %conv24, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %entry
  br label %do.body26

do.body26:                                        ; preds = %if.end25
  br label %do.end27

do.end27:                                         ; preds = %do.body26
  store i32 0, i32* %frame, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc80, %do.end27
  %11 = load i32, i32* %frame, align 4
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 4
  %13 = load i32, i32* %curframe28, align 8
  %cmp29 = icmp ule i32 %11, %13
  br i1 %cmp29, label %for.body, label %for.end82

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %frame31 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 0
  %15 = load i32, i32* %frame, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame31, i64 0, i64 %idxprom
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %16, %struct.bpf_func_state** %parent, align 8
  %17 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame32 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %17, i32 0, i32 0
  %18 = load i32, i32* %frame, align 4
  %idxprom33 = sext i32 %18 to i64
  %arrayidx34 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame32, i64 0, i64 %idxprom33
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx34, align 8
  store %struct.bpf_func_state* %19, %struct.bpf_func_state** %state, align 8
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %20, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %parent_reg, align 8
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs35 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 0
  %arraydecay36 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs35, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay36, %struct.bpf_reg_state** %state_reg, align 8
  %22 = load i32, i32* %frame, align 4
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe37 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe37, align 8
  %cmp38 = icmp ult i32 %22, %24
  %25 = zext i1 %cmp38 to i64
  %cond = select i1 %cmp38, i32 6, i32 0
  store i32 %cond, i32* %i, align 4
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc, %for.body
  %26 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %26, 10
  br i1 %cmp41, label %for.body43, label %for.end

for.body43:                                       ; preds = %for.cond40
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom44 = sext i32 %29 to i64
  %arrayidx45 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom44
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom46 = sext i32 %31 to i64
  %arrayidx47 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i64 %idxprom46
  %call = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %arrayidx45, %struct.bpf_reg_state* noundef %arrayidx47) #14
  store i32 %call, i32* %err, align 4
  %32 = load i32, i32* %err, align 4
  %cmp48 = icmp slt i32 %32, 0
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %for.body43
  %33 = load i32, i32* %err, align 4
  store i32 %33, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %for.body43
  %34 = load i32, i32* %err, align 4
  %cmp52 = icmp eq i32 %34, 2
  br i1 %cmp52, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end51
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %37 = load i32, i32* %i, align 4
  %idxprom55 = sext i32 %37 to i64
  %arrayidx56 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i64 %idxprom55
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %35, %struct.bpf_reg_state* noundef %arrayidx56) #14
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %if.end51
  br label %for.inc

for.inc:                                          ; preds = %if.end57
  %38 = load i32, i32* %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond40

for.end:                                          ; preds = %for.cond40
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc77, %for.end
  %39 = load i32, i32* %i, align 4
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 9
  %41 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %41, 8
  %cmp59 = icmp slt i32 %39, %div
  br i1 %cmp59, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond58
  %42 = load i32, i32* %i, align 4
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %allocated_stack61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %43, i32 0, i32 9
  %44 = load i32, i32* %allocated_stack61, align 8
  %div62 = sdiv i32 %44, 8
  %cmp63 = icmp slt i32 %42, %div62
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond58
  %45 = phi i1 [ false, %for.cond58 ], [ %cmp63, %land.rhs ]
  br i1 %45, label %for.body65, label %for.end79

for.body65:                                       ; preds = %land.end
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 10
  %47 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %48 = load i32, i32* %i, align 4
  %idxprom66 = sext i32 %48 to i64
  %arrayidx67 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %47, i64 %idxprom66
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx67, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %parent_reg, align 8
  %49 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack68 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %49, i32 0, i32 10
  %50 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack68, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom69 = sext i32 %51 to i64
  %arrayidx70 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %50, i64 %idxprom69
  %spilled_ptr71 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx70, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr71, %struct.bpf_reg_state** %state_reg, align 8
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %call72 = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %52, %struct.bpf_reg_state* noundef %53, %struct.bpf_reg_state* noundef %54) #14
  store i32 %call72, i32* %err, align 4
  %55 = load i32, i32* %err, align 4
  %cmp73 = icmp slt i32 %55, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %for.body65
  %56 = load i32, i32* %err, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %for.body65
  br label %for.inc77

for.inc77:                                        ; preds = %if.end76
  %57 = load i32, i32* %i, align 4
  %inc78 = add i32 %57, 1
  store i32 %inc78, i32* %i, align 4
  br label %for.cond58

for.end79:                                        ; preds = %land.end
  br label %for.inc80

for.inc80:                                        ; preds = %for.end79
  %58 = load i32, i32* %frame, align 4
  %inc81 = add i32 %58, 1
  store i32 %inc81, i32* %frame, align 4
  br label %for.cond

for.end82:                                        ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end82, %if.then75, %if.then50, %if.end
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %cnt = alloca i32, align 4
  %p = alloca %struct.bpf_idx_pair*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 10
  %1 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %cnt, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %5 = bitcast %struct.bpf_idx_pair* %4 to i8*
  %6 = load i32, i32* %cnt, align 4
  %conv = zext i32 %6 to i64
  %mul = mul i64 %conv, 8
  %call = call i8* @krealloc(i8* noundef %5, i64 noundef %mul, i32 noundef 1051840) #14
  %7 = bitcast i8* %call to %struct.bpf_idx_pair*
  store %struct.bpf_idx_pair* %7, %struct.bpf_idx_pair** %p, align 8
  %8 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %tobool = icmp ne %struct.bpf_idx_pair* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 0
  %10 = load i32, i32* %insn_idx, align 8
  %11 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %12 = load i32, i32* %cnt, align 4
  %sub = sub i32 %12, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %11, i64 %idxprom
  %idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx, i32 0, i32 1
  store i32 %10, i32* %idx, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 1
  %14 = load i32, i32* %prev_insn_idx, align 4
  %15 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %16 = load i32, i32* %cnt, align 4
  %sub1 = sub i32 %16, 1
  %idxprom2 = zext i32 %sub1 to i64
  %arrayidx3 = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %15, i64 %idxprom2
  %prev_idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx3, i32 0, i32 0
  store i32 %14, i32* %prev_idx, align 4
  %17 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 9
  store %struct.bpf_idx_pair* %17, %struct.bpf_idx_pair** %jmp_history4, align 8
  %19 = load i32, i32* %cnt, align 4
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 10
  store i32 %19, i32* %jmp_history_cnt5, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_precision(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %state_reg, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %5, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp ne i32 %7, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 18
  %9 = load i8, i8* %precise, align 4
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %11 = load i32, i32* %level, align 8
  %and = and i32 %11, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.232, i64 0, i64 0), i32 noundef %14) #14
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load i32, i32* %i, align 4
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %15, i32 noundef %16) #14
  store i32 %call, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %cmp5 = icmp slt i32 %17, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %18 = load i32, i32* %err, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then
  %19 = load i32, i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %incdec.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 1
  store %struct.bpf_reg_state* %incdec.ptr, %struct.bpf_reg_state** %state_reg, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc41, %for.end
  %21 = load i32, i32* %i, align 4
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 9
  %23 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %23, 8
  %cmp9 = icmp slt i32 %21, %div
  br i1 %cmp9, label %for.body10, label %for.end43

for.body10:                                       ; preds = %for.cond8
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %24, i32 0, i32 10
  %25 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %26 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %25, i64 %idxprom11
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 1
  %arrayidx13 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %27 = load i8, i8* %arrayidx13, align 8
  %conv = zext i8 %27 to i32
  %cmp14 = icmp ne i32 %conv, 1
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body10
  br label %for.inc41

if.end17:                                         ; preds = %for.body10
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 10
  %29 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack18, align 8
  %30 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %30 to i64
  %arrayidx20 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %29, i64 %idxprom19
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx20, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %state_reg, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 0
  %32 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %32, 1
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %if.end17
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 18
  %34 = load i8, i8* %precise25, align 4
  %tobool26 = trunc i8 %34 to i1
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %lor.lhs.false24, %if.end17
  br label %for.inc41

if.end28:                                         ; preds = %lor.lhs.false24
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 26
  %level30 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log29, i32 0, i32 0
  %36 = load i32, i32* %level30, align 8
  %and31 = and i32 %36, 2
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end28
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load i32, i32* %i, align 4
  %sub = sub i32 0, %39
  %sub34 = sub i32 %sub, 1
  %mul = mul i32 %sub34, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.233, i64 0, i64 0), i32 noundef %mul) #14
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end28
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load i32, i32* %i, align 4
  %call36 = call i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %40, i32 noundef %41) #14
  store i32 %call36, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %cmp37 = icmp slt i32 %42, 0
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end35
  br label %for.inc41

for.inc41:                                        ; preds = %if.end40, %if.then27, %if.then16
  %44 = load i32, i32* %i, align 4
  %inc42 = add i32 %44, 1
  store i32 %inc42, i32* %i, align 4
  br label %for.cond8

for.end43:                                        ; preds = %for.cond8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end43, %if.then39, %if.then6
  %45 = load i32, i32* %retval, align 4
  ret i32 %45
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %dst_state, %struct.bpf_verifier_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst_state.addr = alloca %struct.bpf_verifier_state*, align 8
  %src.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_state* %dst_state, %struct.bpf_verifier_state** %dst_state.addr, align 8
  store %struct.bpf_verifier_state* %src, %struct.bpf_verifier_state** %src.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 9
  %1 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %2 = bitcast %struct.bpf_idx_pair* %1 to i8*
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history1, align 8
  %5 = bitcast %struct.bpf_idx_pair* %4 to i8*
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 10
  %7 = load i32, i32* %jmp_history_cnt, align 8
  %conv = zext i32 %7 to i64
  %call = call i8* @copy_array(i8* noundef %2, i8* noundef %5, i64 noundef %conv, i64 noundef 8, i32 noundef 1051840) #14
  %8 = bitcast i8* %call to %struct.bpf_idx_pair*
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 9
  store %struct.bpf_idx_pair* %8, %struct.bpf_idx_pair** %jmp_history2, align 8
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 9
  %11 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history3, align 8
  %tobool = icmp ne %struct.bpf_idx_pair* %11, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 10
  %13 = load i32, i32* %jmp_history_cnt4, align 8
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history_cnt5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 10
  store i32 %13, i32* %jmp_history_cnt5, align 8
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 4
  %16 = load i32, i32* %curframe, align 8
  %add = add i32 %16, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %17 = load i32, i32* %i, align 4
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 4
  %19 = load i32, i32* %curframe6, align 8
  %cmp = icmp ule i32 %17, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4
  %idxprom = sext i32 %21 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %22) #14
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %24 to i64
  %arrayidx10 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame8, i64 0, i64 %idxprom9
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx10, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32, i32* %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %26, i32 0, i32 6
  %27 = load i8, i8* %speculative, align 8
  %tobool11 = trunc i8 %27 to i1
  %28 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %speculative12 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %28, i32 0, i32 6
  %frombool = zext i1 %tobool11 to i8
  store i8 %frombool, i8* %speculative12, align 8
  %29 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe13 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %29, i32 0, i32 4
  %30 = load i32, i32* %curframe13, align 8
  %31 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe14 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %31, i32 0, i32 4
  store i32 %30, i32* %curframe14, align 8
  %32 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %32, i32 0, i32 5
  %33 = load i32, i32* %active_spin_lock, align 4
  %34 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %active_spin_lock15 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %34, i32 0, i32 5
  store i32 %33, i32* %active_spin_lock15, align 4
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %35, i32 0, i32 2
  %36 = load i32, i32* %branches, align 8
  %37 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %branches16 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %37, i32 0, i32 2
  store i32 %36, i32* %branches16, align 8
  %38 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %38, i32 0, i32 1
  %39 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %40 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %parent17 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %40, i32 0, i32 1
  store %struct.bpf_verifier_state* %39, %struct.bpf_verifier_state** %parent17, align 8
  %41 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %41, i32 0, i32 7
  %42 = load i32, i32* %first_insn_idx, align 4
  %43 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %first_insn_idx18 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %43, i32 0, i32 7
  store i32 %42, i32* %first_insn_idx18, align 4
  %44 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %44, i32 0, i32 8
  %45 = load i32, i32* %last_insn_idx, align 8
  %46 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %last_insn_idx19 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %46, i32 0, i32 8
  store i32 %45, i32* %last_insn_idx19, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc45, %for.end
  %47 = load i32, i32* %i, align 4
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe21 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %48, i32 0, i32 4
  %49 = load i32, i32* %curframe21, align 8
  %cmp22 = icmp ule i32 %47, %49
  br i1 %cmp22, label %for.body24, label %for.end47

for.body24:                                       ; preds = %for.cond20
  %50 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame25 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %50, i32 0, i32 0
  %51 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %51 to i64
  %arrayidx27 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame25, i64 0, i64 %idxprom26
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx27, align 8
  store %struct.bpf_func_state* %52, %struct.bpf_func_state** %dst, align 8
  %53 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool28 = icmp ne %struct.bpf_func_state* %53, null
  br i1 %tobool28, label %if.end37, label %if.then29

if.then29:                                        ; preds = %for.body24
  %call30 = call i8* @kzalloc(i64 noundef 1368, i32 noundef 3264) #14
  %54 = bitcast i8* %call30 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %54, %struct.bpf_func_state** %dst, align 8
  %55 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool31 = icmp ne %struct.bpf_func_state* %55, null
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then29
  store i32 -12, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then29
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame34 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %57, i32 0, i32 0
  %58 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %58 to i64
  %arrayidx36 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame34, i64 0, i64 %idxprom35
  store %struct.bpf_func_state* %56, %struct.bpf_func_state** %arrayidx36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.end33, %for.body24
  %59 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %60 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %frame38 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %60, i32 0, i32 0
  %61 = load i32, i32* %i, align 4
  %idxprom39 = sext i32 %61 to i64
  %arrayidx40 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame38, i64 0, i64 %idxprom39
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx40, align 8
  %call41 = call i32 @copy_func_state(%struct.bpf_func_state* noundef %59, %struct.bpf_func_state* noundef %62) #14
  store i32 %call41, i32* %err, align 4
  %63 = load i32, i32* %err, align 4
  %tobool42 = icmp ne i32 %63, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end37
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end37
  br label %for.inc45

for.inc45:                                        ; preds = %if.end44
  %65 = load i32, i32* %i, align 4
  %inc46 = add i32 %65, 1
  store i32 %inc46, i32* %i, align 4
  br label %for.cond20

for.end47:                                        ; preds = %for.cond20
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end47, %if.then43, %if.then32, %if.then
  %66 = load i32, i32* %retval, align 4
  ret i32 %66
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_jmp_history(%struct.bpf_verifier_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 9
  %1 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %2 = bitcast %struct.bpf_idx_pair* %1 to i8*
  call void @kfree(i8* noundef %2) #14
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  store %struct.bpf_idx_pair* null, %struct.bpf_idx_pair** %jmp_history1, align 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 10
  store i32 0, i32* %jmp_history_cnt, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx1, i32 0, i32 17
  %2 = load i32, i32* %live, align 8
  %and = and i32 %2, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 4
  %5 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx3, align 8
  call void @clean_func_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %9) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_func_state*, align 8
  %live = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %st, %struct.bpf_func_state** %st.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 17
  %3 = load i32, i32* %live1, align 8
  store i32 %3, i32* %live, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 %idxprom3
  %live5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 17
  %6 = load i32, i32* %live5, align 8
  %or = or i32 %6, 8
  store i32 %or, i32* %live5, align 8
  %7 = load i32, i32* %live, align 4
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 0
  %10 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs6, i64 0, i64 %idxprom7
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %arrayidx8) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc40, %for.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 9
  %14 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %14, 8
  %cmp10 = icmp slt i32 %12, %div
  br i1 %cmp10, label %for.body11, label %for.end42

for.body11:                                       ; preds = %for.cond9
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 10
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom12
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 0
  %live14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %18 = load i32, i32* %live14, align 8
  store i32 %18, i32* %live, align 4
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 10
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %21 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %20, i64 %idxprom16
  %spilled_ptr18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 0
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr18, i32 0, i32 17
  %22 = load i32, i32* %live19, align 8
  %or20 = or i32 %22, 8
  store i32 %or20, i32* %live19, align 8
  %23 = load i32, i32* %live, align 4
  %and21 = and i32 %23, 3
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end39, label %if.then23

if.then23:                                        ; preds = %for.body11
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 10
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack24, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom25 = sext i32 %27 to i64
  %arrayidx26 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom25
  %spilled_ptr27 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx26, i32 0, i32 0
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %24, %struct.bpf_reg_state* noundef %spilled_ptr27) #14
  store i32 0, i32* %j, align 4
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc36, %if.then23
  %28 = load i32, i32* %j, align 4
  %cmp29 = icmp slt i32 %28, 8
  br i1 %cmp29, label %for.body30, label %for.end38

for.body30:                                       ; preds = %for.cond28
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 10
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack31, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %31 to i64
  %arrayidx33 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom32
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx33, i32 0, i32 1
  %32 = load i32, i32* %j, align 4
  %idxprom34 = sext i32 %32 to i64
  %arrayidx35 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom34
  store i8 0, i8* %arrayidx35, align 1
  br label %for.inc36

for.inc36:                                        ; preds = %for.body30
  %33 = load i32, i32* %j, align 4
  %inc37 = add i32 %33, 1
  store i32 %inc37, i32* %j, align 4
  br label %for.cond28

for.end38:                                        ; preds = %for.cond28
  br label %if.end39

if.end39:                                         ; preds = %for.end38, %for.body11
  br label %for.inc40

for.inc40:                                        ; preds = %if.end39
  %34 = load i32, i32* %i, align 4
  %inc41 = add i32 %34, 1
  store i32 %inc41, i32* %i, align 4
  br label %for.cond9

for.end42:                                        ; preds = %for.cond9
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @memcmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @func_states_equal(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %idmap_scratch = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 28
  %arraydecay = getelementptr inbounds [75 x %struct.bpf_id_pair], [75 x %struct.bpf_id_pair]* %idmap_scratch, i64 0, i64 0
  %1 = bitcast %struct.bpf_id_pair* %arraydecay to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %1, i8 0, i64 600, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %2, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 %idxprom2
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %idmap_scratch4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 28
  %arraydecay5 = getelementptr inbounds [75 x %struct.bpf_id_pair], [75 x %struct.bpf_id_pair]* %idmap_scratch4, i64 0, i64 0
  %call = call zeroext i1 @regsafe(%struct.bpf_verifier_env* noundef %3, %struct.bpf_reg_state* noundef %arrayidx, %struct.bpf_reg_state* noundef %arrayidx3, %struct.bpf_id_pair* noundef %arraydecay5) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %idmap_scratch6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 28
  %arraydecay7 = getelementptr inbounds [75 x %struct.bpf_id_pair], [75 x %struct.bpf_id_pair]* %idmap_scratch6, i64 0, i64 0
  %call8 = call zeroext i1 @stacksafe(%struct.bpf_verifier_env* noundef %10, %struct.bpf_func_state* noundef %11, %struct.bpf_func_state* noundef %12, %struct.bpf_id_pair* noundef %arraydecay7) #14
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %for.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end10:                                         ; preds = %for.end
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %call11 = call zeroext i1 @refsafe(%struct.bpf_func_state* noundef %14, %struct.bpf_func_state* noundef %15) #14
  br i1 %call11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end10
  store i1 false, i1* %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end10
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then9, %if.then
  %16 = load i1, i1* %retval, align 1
  ret i1 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @regsafe(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %rold, %struct.bpf_reg_state* noundef %rcur, %struct.bpf_id_pair* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %rold.addr = alloca %struct.bpf_reg_state*, align 8
  %rcur.addr = alloca %struct.bpf_reg_state*, align 8
  %idmap.addr = alloca %struct.bpf_id_pair*, align 8
  %equal = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %rold, %struct.bpf_reg_state** %rold.addr, align 8
  store %struct.bpf_reg_state* %rcur, %struct.bpf_reg_state** %rcur.addr, align 8
  store %struct.bpf_id_pair* %idmap, %struct.bpf_id_pair** %idmap.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 17
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %3 = bitcast %struct.bpf_reg_state* %2 to i8*
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %5 = bitcast %struct.bpf_reg_state* %4 to i8*
  %call = call i32 @memcmp(i8* noundef %3, i8* noundef %5, i64 noundef 96) #14
  %cmp = icmp eq i32 %call, 0
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %equal, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp eq i32 %7, 6
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %8 = load i8, i8* %equal, align 1
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 15
  %10 = load i32, i32* %frameno, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %frameno4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 15
  %12 = load i32, i32* %frameno4, align 8
  %cmp5 = icmp eq i32 %10, %12
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then2
  %13 = phi i1 [ false, %if.then2 ], [ %cmp5, %land.rhs ]
  store i1 %13, i1* %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.end
  %14 = load i8, i8* %equal, align 1
  %tobool7 = trunc i8 %14 to i1
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store i1 true, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end6
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type10, align 8
  %cmp11 = icmp eq i32 %16, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i1 true, i1* %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end9
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %18, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %if.end13
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type18, align 8
  switch i32 %20, label %sw.default [
    i32 1, label %sw.bb
    i32 29, label %sw.bb35
    i32 4, label %sw.bb35
    i32 5, label %sw.bb45
    i32 7, label %sw.bb56
    i32 8, label %sw.bb56
    i32 2, label %sw.bb84
    i32 3, label %sw.bb84
    i32 9, label %sw.bb84
    i32 10, label %sw.bb84
    i32 11, label %sw.bb84
    i32 12, label %sw.bb84
    i32 13, label %sw.bb84
    i32 14, label %sw.bb84
    i32 15, label %sw.bb84
    i32 16, label %sw.bb84
    i32 18, label %sw.bb84
  ]

sw.bb:                                            ; preds = %if.end17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explore_alu_limits = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 16
  %22 = load i8, i8* %explore_alu_limits, align 4
  %tobool19 = trunc i8 %22 to i1
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

if.end21:                                         ; preds = %sw.bb
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 0
  %24 = load i32, i32* %type22, align 8
  %cmp23 = icmp eq i32 %24, 1
  br i1 %cmp23, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.end21
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 18
  %26 = load i8, i8* %precise, align 4
  %tobool25 = trunc i8 %26 to i1
  br i1 %tobool25, label %if.end29, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then24
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %precise26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 18
  %28 = load i8, i8* %precise26, align 4
  %tobool27 = trunc i8 %28 to i1
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end29:                                         ; preds = %land.lhs.true, %if.then24
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call30 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %29, %struct.bpf_reg_state* noundef %30) #14
  br i1 %call30, label %land.rhs31, label %land.end34

land.rhs31:                                       ; preds = %if.end29
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 5
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 5
  %33 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 0
  %35 = load i64, i64* %34, align 8
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 1
  %37 = load i64, i64* %36, align 8
  %38 = bitcast %struct.tnum* %var_off32 to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = load i64, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = load i64, i64* %41, align 8
  %call33 = call zeroext i1 @tnum_in(i64 %35, i64 %37, i64 %40, i64 %42) #14
  br label %land.end34

land.end34:                                       ; preds = %land.rhs31, %if.end29
  %43 = phi i1 [ false, %if.end29 ], [ %call33, %land.rhs31 ]
  store i1 %43, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %if.end21
  store i1 false, i1* %retval, align 1
  br label %return

sw.bb35:                                          ; preds = %if.end17, %if.end17
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %45 = bitcast %struct.bpf_reg_state* %44 to i8*
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %47 = bitcast %struct.bpf_reg_state* %46 to i8*
  %call36 = call i32 @memcmp(i8* noundef %45, i8* noundef %47, i64 noundef 24) #14
  %cmp37 = icmp eq i32 %call36, 0
  br i1 %cmp37, label %land.lhs.true38, label %land.end44

land.lhs.true38:                                  ; preds = %sw.bb35
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call39 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %48, %struct.bpf_reg_state* noundef %49) #14
  br i1 %call39, label %land.rhs40, label %land.end44

land.rhs40:                                       ; preds = %land.lhs.true38
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 5
  %52 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = load i64, i64* %55, align 8
  %57 = bitcast %struct.tnum* %var_off42 to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = load i64, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = load i64, i64* %60, align 8
  %call43 = call zeroext i1 @tnum_in(i64 %54, i64 %56, i64 %59, i64 %61) #14
  br label %land.end44

land.end44:                                       ; preds = %land.rhs40, %land.lhs.true38, %sw.bb35
  %62 = phi i1 [ false, %land.lhs.true38 ], [ false, %sw.bb35 ], [ %call43, %land.rhs40 ]
  store i1 %62, i1* %retval, align 1
  br label %return

sw.bb45:                                          ; preds = %if.end17
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 0
  %64 = load i32, i32* %type46, align 8
  %cmp47 = icmp ne i32 %64, 5
  br i1 %cmp47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %sw.bb45
  store i1 false, i1* %retval, align 1
  br label %return

if.end49:                                         ; preds = %sw.bb45
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %66 = bitcast %struct.bpf_reg_state* %65 to i8*
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %68 = bitcast %struct.bpf_reg_state* %67 to i8*
  %call50 = call i32 @memcmp(i8* noundef %66, i8* noundef %68, i64 noundef 24) #14
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end49
  store i1 false, i1* %retval, align 1
  br label %return

if.end53:                                         ; preds = %if.end49
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 3
  %70 = load i32, i32* %id, align 8
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 3
  %72 = load i32, i32* %id54, align 8
  %73 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %call55 = call zeroext i1 @check_ids(i32 noundef %70, i32 noundef %72, %struct.bpf_id_pair* noundef %73) #14
  store i1 %call55, i1* %retval, align 1
  br label %return

sw.bb56:                                          ; preds = %if.end17, %if.end17
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 0
  %75 = load i32, i32* %type57, align 8
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 0
  %77 = load i32, i32* %type58, align 8
  %cmp59 = icmp ne i32 %75, %77
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %sw.bb56
  store i1 false, i1* %retval, align 1
  br label %return

if.end61:                                         ; preds = %sw.bb56
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 2
  %range = bitcast %union.anon.152* %79 to i32*
  %80 = load i32, i32* %range, align 8
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 2
  %range62 = bitcast %union.anon.152* %82 to i32*
  %83 = load i32, i32* %range62, align 8
  %cmp63 = icmp sgt i32 %80, %83
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end61
  store i1 false, i1* %retval, align 1
  br label %return

if.end65:                                         ; preds = %if.end61
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 1
  %85 = load i32, i32* %off, align 4
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %off66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 1
  %87 = load i32, i32* %off66, align 4
  %cmp67 = icmp ne i32 %85, %87
  br i1 %cmp67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end65
  store i1 false, i1* %retval, align 1
  br label %return

if.end69:                                         ; preds = %if.end65
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 3
  %89 = load i32, i32* %id70, align 8
  %tobool71 = icmp ne i32 %89, 0
  br i1 %tobool71, label %land.lhs.true72, label %if.end77

land.lhs.true72:                                  ; preds = %if.end69
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 3
  %91 = load i32, i32* %id73, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 3
  %93 = load i32, i32* %id74, align 8
  %94 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %call75 = call zeroext i1 @check_ids(i32 noundef %91, i32 noundef %93, %struct.bpf_id_pair* noundef %94) #14
  br i1 %call75, label %if.end77, label %if.then76

if.then76:                                        ; preds = %land.lhs.true72
  store i1 false, i1* %retval, align 1
  br label %return

if.end77:                                         ; preds = %land.lhs.true72, %if.end69
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call78 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %95, %struct.bpf_reg_state* noundef %96) #14
  br i1 %call78, label %land.rhs79, label %land.end83

land.rhs79:                                       ; preds = %if.end77
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %98, i32 0, i32 5
  %99 = bitcast %struct.tnum* %var_off80 to { i64, i64 }*
  %100 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %99, i32 0, i32 0
  %101 = load i64, i64* %100, align 8
  %102 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %99, i32 0, i32 1
  %103 = load i64, i64* %102, align 8
  %104 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %105 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %104, i32 0, i32 0
  %106 = load i64, i64* %105, align 8
  %107 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %104, i32 0, i32 1
  %108 = load i64, i64* %107, align 8
  %call82 = call zeroext i1 @tnum_in(i64 %101, i64 %103, i64 %106, i64 %108) #14
  br label %land.end83

land.end83:                                       ; preds = %land.rhs79, %if.end77
  %109 = phi i1 [ false, %if.end77 ], [ %call82, %land.rhs79 ]
  store i1 %109, i1* %retval, align 1
  br label %return

sw.bb84:                                          ; preds = %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17
  br label %sw.default

sw.default:                                       ; preds = %if.end17, %sw.bb84
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %land.end83, %if.then76, %if.then68, %if.then64, %if.then60, %if.end53, %if.then52, %if.then48, %land.end44, %if.else, %land.end34, %if.then28, %if.then20, %if.then16, %if.then12, %if.then8, %land.end, %if.then
  %110 = load i1, i1* %retval, align 1
  ret i1 %110
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @stacksafe(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur, %struct.bpf_id_pair* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %idmap.addr = alloca %struct.bpf_id_pair*, align 8
  %i = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  store %struct.bpf_id_pair* %idmap, %struct.bpf_id_pair** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 9
  %2 = load i32, i32* %allocated_stack, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %i, align 4
  %div = sdiv i32 %3, 8
  store i32 %div, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 10
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %5, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %7 = load i32, i32* %live, align 8
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add = add i32 %8, 7
  store i32 %add, i32* %i, align 4
  br label %for.inc

if.end:                                           ; preds = %for.body
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 10
  %10 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %11 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %11 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %10, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %12 = load i32, i32* %i, align 4
  %rem = srem i32 %12, 8
  %idxprom4 = sext i32 %rem to i64
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom4
  %13 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %13 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  br label %for.inc

if.end9:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %allocated_stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 9
  %16 = load i32, i32* %allocated_stack10, align 8
  %cmp11 = icmp sge i32 %14, %16
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  store i1 false, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.end9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 10
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %19 = load i32, i32* %spi, align 4
  %idxprom16 = sext i32 %19 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom16
  %slot_type18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 1
  %20 = load i32, i32* %i, align 4
  %rem19 = srem i32 %20, 8
  %idxprom20 = sext i32 %rem19 to i64
  %arrayidx21 = getelementptr [8 x i8], [8 x i8]* %slot_type18, i64 0, i64 %idxprom20
  %21 = load i8, i8* %arrayidx21, align 1
  %conv22 = zext i8 %21 to i32
  %cmp23 = icmp eq i32 %conv22, 2
  br i1 %cmp23, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.end14
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 10
  %23 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %24 = load i32, i32* %spi, align 4
  %idxprom26 = sext i32 %24 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %23, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %25 = load i32, i32* %i, align 4
  %rem29 = srem i32 %25, 8
  %idxprom30 = sext i32 %rem29 to i64
  %arrayidx31 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 %idxprom30
  %26 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %26 to i32
  %cmp33 = icmp eq i32 %conv32, 3
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end36:                                         ; preds = %land.lhs.true, %if.end14
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 10
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack37, align 8
  %29 = load i32, i32* %spi, align 4
  %idxprom38 = sext i32 %29 to i64
  %arrayidx39 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom38
  %slot_type40 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx39, i32 0, i32 1
  %30 = load i32, i32* %i, align 4
  %rem41 = srem i32 %30, 8
  %idxprom42 = sext i32 %rem41 to i64
  %arrayidx43 = getelementptr [8 x i8], [8 x i8]* %slot_type40, i64 0, i64 %idxprom42
  %31 = load i8, i8* %arrayidx43, align 1
  %conv44 = zext i8 %31 to i32
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack45 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 10
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack45, align 8
  %34 = load i32, i32* %spi, align 4
  %idxprom46 = sext i32 %34 to i64
  %arrayidx47 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom46
  %slot_type48 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx47, i32 0, i32 1
  %35 = load i32, i32* %i, align 4
  %rem49 = srem i32 %35, 8
  %idxprom50 = sext i32 %rem49 to i64
  %arrayidx51 = getelementptr [8 x i8], [8 x i8]* %slot_type48, i64 0, i64 %idxprom50
  %36 = load i8, i8* %arrayidx51, align 1
  %conv52 = zext i8 %36 to i32
  %cmp53 = icmp ne i32 %conv44, %conv52
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end36
  store i1 false, i1* %retval, align 1
  br label %return

if.end56:                                         ; preds = %if.end36
  %37 = load i32, i32* %i, align 4
  %rem57 = srem i32 %37, 8
  %tobool58 = icmp ne i32 %rem57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end56
  br label %for.inc

if.end60:                                         ; preds = %if.end56
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 10
  %39 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack61, align 8
  %40 = load i32, i32* %spi, align 4
  %idxprom62 = sext i32 %40 to i64
  %arrayidx63 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %39, i64 %idxprom62
  %slot_type64 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx63, i32 0, i32 1
  %arrayidx65 = getelementptr [8 x i8], [8 x i8]* %slot_type64, i64 0, i64 0
  %41 = load i8, i8* %arrayidx65, align 8
  %conv66 = zext i8 %41 to i32
  %cmp67 = icmp ne i32 %conv66, 1
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end60
  br label %for.inc

if.end70:                                         ; preds = %if.end60
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack71 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %43, i32 0, i32 10
  %44 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack71, align 8
  %45 = load i32, i32* %spi, align 4
  %idxprom72 = sext i32 %45 to i64
  %arrayidx73 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %44, i64 %idxprom72
  %spilled_ptr74 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx73, i32 0, i32 0
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack75 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 10
  %47 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack75, align 8
  %48 = load i32, i32* %spi, align 4
  %idxprom76 = sext i32 %48 to i64
  %arrayidx77 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %47, i64 %idxprom76
  %spilled_ptr78 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx77, i32 0, i32 0
  %49 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %call = call zeroext i1 @regsafe(%struct.bpf_verifier_env* noundef %42, %struct.bpf_reg_state* noundef %spilled_ptr74, %struct.bpf_reg_state* noundef %spilled_ptr78, %struct.bpf_id_pair* noundef %49) #14
  br i1 %call, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.end70
  store i1 false, i1* %retval, align 1
  br label %return

if.end80:                                         ; preds = %if.end70
  br label %for.inc

for.inc:                                          ; preds = %if.end80, %if.then69, %if.then59, %if.then35, %if.then8, %if.then
  %50 = load i32, i32* %i, align 4
  %inc = add i32 %50, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then79, %if.then55, %if.then13
  %51 = load i1, i1* %retval, align 1
  ret i1 %51
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @refsafe(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 7
  %1 = load i32, i32* %acquired_refs, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 7
  %3 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 8
  %5 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %6 = bitcast %struct.bpf_reference_state* %5 to i8*
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 8
  %8 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs2, align 8
  %9 = bitcast %struct.bpf_reference_state* %8 to i8*
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 7
  %11 = load i32, i32* %acquired_refs3, align 4
  %conv = sext i32 %11 to i64
  %mul = mul i64 8, %conv
  %call = call i32 @memcmp(i8* noundef %6, i8* noundef %9, i64 noundef %mul) #14
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @range_within(%struct.bpf_reg_state* noundef %old, %struct.bpf_reg_state* noundef %cur) #0 {
entry:
  %old.addr = alloca %struct.bpf_reg_state*, align 8
  %cur.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %old, %struct.bpf_reg_state** %old.addr, align 8
  store %struct.bpf_reg_state* %cur, %struct.bpf_reg_state** %cur.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  %cmp = icmp ule i64 %1, %3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value2, align 8
  %cmp3 = icmp uge i64 %5, %7
  br i1 %cmp3, label %land.lhs.true4, label %land.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value5, align 8
  %cmp6 = icmp sle i64 %9, %11
  br i1 %cmp6, label %land.lhs.true7, label %land.end

land.lhs.true7:                                   ; preds = %land.lhs.true4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  %15 = load i64, i64* %smax_value8, align 8
  %cmp9 = icmp sge i64 %13, %15
  br i1 %cmp9, label %land.lhs.true10, label %land.end

land.lhs.true10:                                  ; preds = %land.lhs.true7
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 12
  %17 = load i32, i32* %u32_min_value, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %u32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 12
  %19 = load i32, i32* %u32_min_value11, align 8
  %cmp12 = icmp ule i32 %17, %19
  br i1 %cmp12, label %land.lhs.true13, label %land.end

land.lhs.true13:                                  ; preds = %land.lhs.true10
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value, align 4
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %u32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 13
  %23 = load i32, i32* %u32_max_value14, align 4
  %cmp15 = icmp uge i32 %21, %23
  br i1 %cmp15, label %land.lhs.true16, label %land.end

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 10
  %25 = load i32, i32* %s32_min_value, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 10
  %27 = load i32, i32* %s32_min_value17, align 8
  %cmp18 = icmp sle i32 %25, %27
  br i1 %cmp18, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true16
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 11
  %29 = load i32, i32* %s32_max_value, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 11
  %31 = load i32, i32* %s32_max_value19, align 4
  %cmp20 = icmp sge i32 %29, %31
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true16, %land.lhs.true13, %land.lhs.true10, %land.lhs.true7, %land.lhs.true4, %land.lhs.true, %entry
  %32 = phi i1 [ false, %land.lhs.true16 ], [ false, %land.lhs.true13 ], [ false, %land.lhs.true10 ], [ false, %land.lhs.true7 ], [ false, %land.lhs.true4 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp20, %land.rhs ]
  ret i1 %32
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @tnum_in(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_ids(i32 noundef %old_id, i32 noundef %cur_id, %struct.bpf_id_pair* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %old_id.addr = alloca i32, align 4
  %cur_id.addr = alloca i32, align 4
  %idmap.addr = alloca %struct.bpf_id_pair*, align 8
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %old_id, i32* %old_id.addr, align 4
  store i32 %cur_id, i32* %cur_id.addr, align 4
  store %struct.bpf_id_pair* %idmap, %struct.bpf_id_pair** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %0, 75
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %2 = load i32, i32* %i, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %1, i64 %idxprom
  %old = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx, i32 0, i32 0
  %3 = load i32, i32* %old, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %4 = load i32, i32* %old_id.addr, align 4
  %5 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = zext i32 %6 to i64
  %arrayidx2 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %5, i64 %idxprom1
  %old3 = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx2, i32 0, i32 0
  store i32 %4, i32* %old3, align 4
  %7 = load i32, i32* %cur_id.addr, align 4
  %8 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom4 = zext i32 %9 to i64
  %arrayidx5 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %8, i64 %idxprom4
  %cur = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx5, i32 0, i32 1
  store i32 %7, i32* %cur, align 4
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  %10 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom6 = zext i32 %11 to i64
  %arrayidx7 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %10, i64 %idxprom6
  %old8 = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx7, i32 0, i32 0
  %12 = load i32, i32* %old8, align 4
  %13 = load i32, i32* %old_id.addr, align 4
  %cmp9 = icmp eq i32 %12, %13
  br i1 %cmp9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end
  %14 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %15 to i64
  %arrayidx12 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %14, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx12, i32 0, i32 1
  %16 = load i32, i32* %cur13, align 4
  %17 = load i32, i32* %cur_id.addr, align 4
  %cmp14 = icmp eq i32 %16, %17
  store i1 %cmp14, i1* %retval, align 1
  br label %return

if.end15:                                         ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %__ret_warn_on, align 4
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %19, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool18 = icmp ne i64 %conv, 0
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %for.end
  br label %do.body

do.body:                                          ; preds = %if.then19
  br label %do.body20

do.body20:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body20
  br label %do.body21

do.body21:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 12041, i32 2307, i64 12) #13, !srcloc !49
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  call void asm sideeffect "545:\0A\09.pushsection .discard.reachable\0A\09.long 545b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !50
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %if.end26

if.end26:                                         ; preds = %do.end25, %for.end
  %20 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %20, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %21 = load i64, i64* %tmp, align 8
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end26, %if.then10, %if.then
  %22 = load i1, i1* %retval, align 1
  ret i1 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, %struct.bpf_reg_state* noundef %parent_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_flag = alloca i8, align 1
  %flag = alloca i8, align 1
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store %struct.bpf_reg_state* %parent_reg, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 17
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %parent_flag, align 1
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 17
  %3 = load i32, i32* %live1, align 8
  %and2 = and i32 %3, 3
  %conv3 = trunc i32 %and2 to i8
  store i8 %conv3, i8* %flag, align 1
  %4 = load i8, i8* %parent_flag, align 1
  %conv4 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv4, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8, i8* %flag, align 1
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %lor.lhs.false6, label %if.then

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %6 = load i8, i8* %parent_flag, align 1
  %conv7 = zext i8 %6 to i32
  %7 = load i8, i8* %flag, align 1
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp eq i32 %conv7, %conv8
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false6, %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false6
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %11 = load i8, i8* %flag, align 1
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %9, %struct.bpf_reg_state* noundef %10, i8 noundef zeroext %11) #14
  store i32 %call, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end
  %14 = load i8, i8* %flag, align 1
  %conv14 = zext i8 %14 to i32
  store i32 %conv14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_insn_zext(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %def_idx = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 16
  %1 = load i32, i32* %subreg_def, align 4
  store i32 %1, i32* %def_idx, align 4
  %2 = load i32, i32* %def_idx, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 24
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %5 = load i32, i32* %def_idx, align 4
  %sub = sub i32 %5, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i64 %idxprom
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 5
  store i8 1, i8* %zext_dst, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 16
  store i32 0, i32* %subreg_def1, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @krealloc(i8* noundef, i64 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef %1, i32 noundef -1) #14
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %spi) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %spi.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %spi.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef -1, i32 noundef %1) #14
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %spi) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %spi.addr = alloca i32, align 4
  %st = alloca %struct.bpf_verifier_state*, align 8
  %first_idx = alloca i32, align 4
  %last_idx = alloca i32, align 4
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %reg_mask = alloca i32, align 4
  %stack_mask = alloca i64, align 8
  %skip_first = alloca i8, align 1
  %new_marks = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp47 = alloca i64, align 8
  %mask = alloca [1 x i64], align 8
  %history = alloca i32, align 4
  %__ret_do_once120 = alloca i8, align 1
  %__ret_warn_on135 = alloca i32, align 4
  %tmp159 = alloca i64, align 8
  %tmp167 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %st, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 7
  %3 = load i32, i32* %first_insn_idx, align 4
  store i32 %3, i32* %first_idx, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 0
  %5 = load i32, i32* %insn_idx, align 8
  store i32 %5, i32* %last_idx, align 4
  %6 = load i32, i32* %regno.addr, align 4
  %cmp = icmp sge i32 %6, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, i32* %regno.addr, align 4
  %shl = shl i32 1, %7
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shl, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %reg_mask, align 4
  %8 = load i32, i32* %spi.addr, align 4
  %cmp1 = icmp sge i32 %8, 0
  br i1 %cmp1, label %cond.true2, label %cond.false4

cond.true2:                                       ; preds = %cond.end
  %9 = load i32, i32* %spi.addr, align 4
  %sh_prom = zext i32 %9 to i64
  %shl3 = shl i64 1, %sh_prom
  br label %cond.end5

cond.false4:                                      ; preds = %cond.end
  br label %cond.end5

cond.end5:                                        ; preds = %cond.false4, %cond.true2
  %cond6 = phi i64 [ %shl3, %cond.true2 ], [ 0, %cond.false4 ]
  store i64 %cond6, i64* %stack_mask, align 8
  store i8 1, i8* %skip_first, align 1
  store i8 0, i8* %new_marks, align 1
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 20
  %11 = load i8, i8* %bpf_capable, align 8
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end5
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %14 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %15, %struct.bpf_func_state** %func, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %cmp7 = icmp sge i32 %16, 0
  br i1 %cmp7, label %if.then8, label %if.end59

if.then8:                                         ; preds = %if.end
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %18 = load i32, i32* %regno.addr, align 4
  %idxprom9 = sext i32 %18 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom9
  store %struct.bpf_reg_state* %arrayidx10, %struct.bpf_reg_state** %reg, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type, align 8
  %cmp11 = icmp ne i32 %20, 1
  br i1 %cmp11, label %if.then12, label %if.end54

if.then12:                                        ; preds = %if.then8
  store i8 1, i8* %__ret_do_once, align 1
  %21 = load i8, i8* %__ret_do_once, align 1
  %tobool13 = trunc i8 %21 to i1
  br i1 %tobool13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then12
  %22 = load i8, i8* @__mark_chain_precision.__already_done, align 1
  %tobool14 = trunc i8 %22 to i1
  %lnot = xor i1 %tobool14, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then12
  %23 = phi i1 [ false, %if.then12 ], [ %lnot, %land.rhs ]
  %lnot15 = xor i1 %23, true
  %lnot16 = xor i1 %lnot15, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end46

if.then18:                                        ; preds = %land.end
  store i8 1, i8* @__mark_chain_precision.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %24 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %24, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end39

if.then26:                                        ; preds = %if.then18
  br label %do.body

do.body:                                          ; preds = %if.then26
  br label %do.body27

do.body27:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body27
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([19 x i8], [19 x i8]* @.str.234, i64 0, i64 0)) #14
  br label %do.body28

do.body28:                                        ; preds = %do.end
  br label %do.body29

do.body29:                                        ; preds = %do.body28
  br label %do.end30

do.end30:                                         ; preds = %do.body29
  br label %do.body31

do.body31:                                        ; preds = %do.end30
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2499, i32 2313, i64 12) #13, !srcloc !51
  br label %do.end32

do.end32:                                         ; preds = %do.body31
  call void asm sideeffect "472:\0A\09.pushsection .discard.reachable\0A\09.long 472b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !52
  br label %do.body33

do.body33:                                        ; preds = %do.end32
  br label %do.end34

do.end34:                                         ; preds = %do.body33
  br label %do.end35

do.end35:                                         ; preds = %do.end34
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  br label %do.end37

do.end37:                                         ; preds = %do.body36
  br label %do.end38

do.end38:                                         ; preds = %do.end37
  br label %if.end39

if.end39:                                         ; preds = %do.end38, %if.then18
  %25 = load i32, i32* %__ret_warn_on, align 4
  %tobool40 = icmp ne i32 %25, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  store i64 %conv45, i64* %tmp, align 8
  %26 = load i64, i64* %tmp, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.end39, %land.end
  %27 = load i8, i8* %__ret_do_once, align 1
  %tobool48 = trunc i8 %27 to i1
  %lnot49 = xor i1 %tobool48, true
  %lnot51 = xor i1 %lnot49, true
  %lnot.ext52 = zext i1 %lnot51 to i32
  %conv53 = sext i32 %lnot.ext52 to i64
  store i64 %conv53, i64* %tmp47, align 8
  %28 = load i64, i64* %tmp47, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 18
  %30 = load i8, i8* %precise, align 4
  %tobool55 = trunc i8 %30 to i1
  br i1 %tobool55, label %if.else, label %if.then56

if.then56:                                        ; preds = %if.end54
  store i8 1, i8* %new_marks, align 1
  br label %if.end57

if.else:                                          ; preds = %if.end54
  store i32 0, i32* %reg_mask, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.else, %if.then56
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 18
  store i8 1, i8* %precise58, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.end57, %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end59
  %32 = load i32, i32* %spi.addr, align 4
  %cmp60 = icmp sge i32 %32, 0
  br i1 %cmp60, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 10
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %35 = load i32, i32* %spi.addr, align 4
  %idxprom62 = sext i32 %35 to i64
  %arrayidx63 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom62
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx63, i32 0, i32 1
  %arrayidx64 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %36 = load i8, i8* %arrayidx64, align 8
  %conv65 = zext i8 %36 to i32
  %cmp66 = icmp ne i32 %conv65, 1
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %while.body
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end69:                                         ; preds = %while.body
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack70 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 10
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack70, align 8
  %39 = load i32, i32* %spi.addr, align 4
  %idxprom71 = sext i32 %39 to i64
  %arrayidx72 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom71
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx72, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 0
  %41 = load i32, i32* %type73, align 8
  %cmp74 = icmp ne i32 %41, 1
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.end69
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end77:                                         ; preds = %if.end69
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 18
  %43 = load i8, i8* %precise78, align 4
  %tobool79 = trunc i8 %43 to i1
  br i1 %tobool79, label %if.else81, label %if.then80

if.then80:                                        ; preds = %if.end77
  store i8 1, i8* %new_marks, align 1
  br label %if.end82

if.else81:                                        ; preds = %if.end77
  store i64 0, i64* %stack_mask, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.else81, %if.then80
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 18
  store i8 1, i8* %precise83, align 4
  br label %while.end

while.end:                                        ; preds = %if.end82, %if.then76, %if.then68, %while.cond
  %45 = load i8, i8* %new_marks, align 1
  %tobool84 = trunc i8 %45 to i1
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %while.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end86:                                         ; preds = %while.end
  %46 = load i32, i32* %reg_mask, align 4
  %tobool87 = icmp ne i32 %46, 0
  br i1 %tobool87, label %if.end90, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end86
  %47 = load i64, i64* %stack_mask, align 8
  %tobool88 = icmp ne i64 %47, 0
  br i1 %tobool88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end90:                                         ; preds = %land.lhs.true, %if.end86
  br label %for.cond

for.cond:                                         ; preds = %if.end276, %if.end90
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %48, i32 0, i32 10
  %49 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %49, i32* %history, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %51 = load i32, i32* %level, align 8
  %and = and i32 %51, 3
  %tobool91 = icmp ne i32 %and, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %for.cond
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i32, i32* %last_idx, align 4
  %55 = load i32, i32* %first_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.235, i64 0, i64 0), i32 noundef %54, i32 noundef %55) #14
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %for.cond
  %56 = load i32, i32* %last_idx, align 4
  store i32 %56, i32* %i, align 4
  br label %for.cond94

for.cond94:                                       ; preds = %if.end174, %if.end93
  %57 = load i8, i8* %skip_first, align 1
  %tobool95 = trunc i8 %57 to i1
  br i1 %tobool95, label %if.then96, label %if.else97

if.then96:                                        ; preds = %for.cond94
  store i32 0, i32* %err, align 4
  store i8 0, i8* %skip_first, align 1
  br label %if.end98

if.else97:                                        ; preds = %for.cond94
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load i32, i32* %i, align 4
  %call = call i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %58, i32 noundef %59, i32* noundef %reg_mask, i64* noundef %stack_mask) #14
  store i32 %call, i32* %err, align 4
  br label %if.end98

if.end98:                                         ; preds = %if.else97, %if.then96
  %60 = load i32, i32* %err, align 4
  %cmp99 = icmp eq i32 %60, -524
  br i1 %cmp99, label %if.then101, label %if.else102

if.then101:                                       ; preds = %if.end98
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %61, %struct.bpf_verifier_state* noundef %62) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.else102:                                       ; preds = %if.end98
  %63 = load i32, i32* %err, align 4
  %tobool103 = icmp ne i32 %63, 0
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.else102
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %if.else102
  br label %if.end106

if.end106:                                        ; preds = %if.end105
  %65 = load i32, i32* %reg_mask, align 4
  %tobool107 = icmp ne i32 %65, 0
  br i1 %tobool107, label %if.end111, label %land.lhs.true108

land.lhs.true108:                                 ; preds = %if.end106
  %66 = load i64, i64* %stack_mask, align 8
  %tobool109 = icmp ne i64 %66, 0
  br i1 %tobool109, label %if.end111, label %if.then110

if.then110:                                       ; preds = %land.lhs.true108
  store i32 0, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %land.lhs.true108, %if.end106
  %67 = load i32, i32* %i, align 4
  %68 = load i32, i32* %first_idx, align 4
  %cmp112 = icmp eq i32 %67, %68
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.end111
  br label %for.end

if.end115:                                        ; preds = %if.end111
  %69 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %70 = load i32, i32* %i, align 4
  %call116 = call i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %69, i32 noundef %70, i32* noundef %history) #14
  store i32 %call116, i32* %i, align 4
  %71 = load i32, i32* %i, align 4
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %72, i32 0, i32 2
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %73, i32 0, i32 4
  %74 = load i32, i32* %len, align 4
  %cmp117 = icmp uge i32 %71, %74
  br i1 %cmp117, label %if.then119, label %if.end174

if.then119:                                       ; preds = %if.end115
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.236, i64 0, i64 0), i32 noundef %77) #14
  store i8 1, i8* %__ret_do_once120, align 1
  %78 = load i8, i8* %__ret_do_once120, align 1
  %tobool121 = trunc i8 %78 to i1
  br i1 %tobool121, label %land.rhs123, label %land.end127

land.rhs123:                                      ; preds = %if.then119
  %79 = load i8, i8* @__mark_chain_precision.__already_done.237, align 1
  %tobool124 = trunc i8 %79 to i1
  %lnot125 = xor i1 %tobool124, true
  br label %land.end127

land.end127:                                      ; preds = %land.rhs123, %if.then119
  %80 = phi i1 [ false, %if.then119 ], [ %lnot125, %land.rhs123 ]
  %lnot128 = xor i1 %80, true
  %lnot130 = xor i1 %lnot128, true
  %lnot.ext131 = zext i1 %lnot130 to i32
  %conv132 = sext i32 %lnot.ext131 to i64
  %tobool133 = icmp ne i64 %conv132, 0
  br i1 %tobool133, label %if.then134, label %if.end166

if.then134:                                       ; preds = %land.end127
  store i8 1, i8* @__mark_chain_precision.__already_done.237, align 1
  store i32 1, i32* %__ret_warn_on135, align 4
  %81 = load i32, i32* %__ret_warn_on135, align 4
  %tobool136 = icmp ne i32 %81, 0
  %lnot137 = xor i1 %tobool136, true
  %lnot139 = xor i1 %lnot137, true
  %lnot.ext140 = zext i1 %lnot139 to i32
  %conv141 = sext i32 %lnot.ext140 to i64
  %tobool142 = icmp ne i64 %conv141, 0
  br i1 %tobool142, label %if.then143, label %if.end158

if.then143:                                       ; preds = %if.then134
  br label %do.body144

do.body144:                                       ; preds = %if.then143
  br label %do.body145

do.body145:                                       ; preds = %do.body144
  br label %do.end146

do.end146:                                        ; preds = %do.body145
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.238, i64 0, i64 0)) #14
  br label %do.body147

do.body147:                                       ; preds = %do.end146
  br label %do.body148

do.body148:                                       ; preds = %do.body147
  br label %do.end149

do.end149:                                        ; preds = %do.body148
  br label %do.body150

do.body150:                                       ; preds = %do.end149
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2567, i32 2313, i64 12) #13, !srcloc !53
  br label %do.end151

do.end151:                                        ; preds = %do.body150
  call void asm sideeffect "473:\0A\09.pushsection .discard.reachable\0A\09.long 473b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !54
  br label %do.body152

do.body152:                                       ; preds = %do.end151
  br label %do.end153

do.end153:                                        ; preds = %do.body152
  br label %do.end154

do.end154:                                        ; preds = %do.end153
  br label %do.body155

do.body155:                                       ; preds = %do.end154
  br label %do.end156

do.end156:                                        ; preds = %do.body155
  br label %do.end157

do.end157:                                        ; preds = %do.end156
  br label %if.end158

if.end158:                                        ; preds = %do.end157, %if.then134
  %82 = load i32, i32* %__ret_warn_on135, align 4
  %tobool160 = icmp ne i32 %82, 0
  %lnot161 = xor i1 %tobool160, true
  %lnot163 = xor i1 %lnot161, true
  %lnot.ext164 = zext i1 %lnot163 to i32
  %conv165 = sext i32 %lnot.ext164 to i64
  store i64 %conv165, i64* %tmp159, align 8
  %83 = load i64, i64* %tmp159, align 8
  br label %if.end166

if.end166:                                        ; preds = %if.end158, %land.end127
  %84 = load i8, i8* %__ret_do_once120, align 1
  %tobool168 = trunc i8 %84 to i1
  %lnot169 = xor i1 %tobool168, true
  %lnot171 = xor i1 %lnot169, true
  %lnot.ext172 = zext i1 %lnot171 to i32
  %conv173 = sext i32 %lnot.ext172 to i64
  store i64 %conv173, i64* %tmp167, align 8
  %85 = load i64, i64* %tmp167, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end174:                                        ; preds = %if.end115
  br label %for.cond94

for.end:                                          ; preds = %if.then114
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 1
  %87 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %87, %struct.bpf_verifier_state** %st, align 8
  %88 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %tobool175 = icmp ne %struct.bpf_verifier_state* %88, null
  br i1 %tobool175, label %if.end177, label %if.then176

if.then176:                                       ; preds = %for.end
  br label %for.end278

if.end177:                                        ; preds = %for.end
  store i8 0, i8* %new_marks, align 1
  %89 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame178 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %89, i32 0, i32 0
  %90 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe179 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %90, i32 0, i32 4
  %91 = load i32, i32* %curframe179, align 8
  %idxprom180 = zext i32 %91 to i64
  %arrayidx181 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame178, i64 0, i64 %idxprom180
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx181, align 8
  store %struct.bpf_func_state* %92, %struct.bpf_func_state** %func, align 8
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %93 = load i32, i32* %reg_mask, align 4
  %conv182 = zext i32 %93 to i64
  call void @bitmap_from_u64(i64* noundef %arraydecay, i64 noundef %conv182) #14
  %arraydecay183 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %call184 = call i64 @find_first_bit(i64* noundef %arraydecay183, i64 noundef 32) #14
  %conv185 = trunc i64 %call184 to i32
  store i32 %conv185, i32* %i, align 4
  br label %for.cond186

for.cond186:                                      ; preds = %for.inc, %if.end177
  %94 = load i32, i32* %i, align 4
  %cmp187 = icmp slt i32 %94, 32
  br i1 %cmp187, label %for.body, label %for.end208

for.body:                                         ; preds = %for.cond186
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs189 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 0
  %96 = load i32, i32* %i, align 4
  %idxprom190 = sext i32 %96 to i64
  %arrayidx191 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs189, i64 0, i64 %idxprom190
  store %struct.bpf_reg_state* %arrayidx191, %struct.bpf_reg_state** %reg, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 0
  %98 = load i32, i32* %type192, align 8
  %cmp193 = icmp ne i32 %98, 1
  br i1 %cmp193, label %if.then195, label %if.end198

if.then195:                                       ; preds = %for.body
  %99 = load i32, i32* %i, align 4
  %shl196 = shl i32 1, %99
  %neg = xor i32 %shl196, -1
  %100 = load i32, i32* %reg_mask, align 4
  %and197 = and i32 %100, %neg
  store i32 %and197, i32* %reg_mask, align 4
  br label %for.inc

if.end198:                                        ; preds = %for.body
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 18
  %102 = load i8, i8* %precise199, align 4
  %tobool200 = trunc i8 %102 to i1
  br i1 %tobool200, label %if.end202, label %if.then201

if.then201:                                       ; preds = %if.end198
  store i8 1, i8* %new_marks, align 1
  br label %if.end202

if.end202:                                        ; preds = %if.then201, %if.end198
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise203 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 18
  store i8 1, i8* %precise203, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end202, %if.then195
  %arraydecay204 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %104 = load i32, i32* %i, align 4
  %add = add i32 %104, 1
  %conv205 = sext i32 %add to i64
  %call206 = call i64 @find_next_bit(i64* noundef %arraydecay204, i64 noundef 32, i64 noundef %conv205) #14
  %conv207 = trunc i64 %call206 to i32
  store i32 %conv207, i32* %i, align 4
  br label %for.cond186

for.end208:                                       ; preds = %for.cond186
  %arraydecay209 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %105 = load i64, i64* %stack_mask, align 8
  call void @bitmap_from_u64(i64* noundef %arraydecay209, i64 noundef %105) #14
  %arraydecay210 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %call211 = call i64 @find_first_bit(i64* noundef %arraydecay210, i64 noundef 64) #14
  %conv212 = trunc i64 %call211 to i32
  store i32 %conv212, i32* %i, align 4
  br label %for.cond213

for.cond213:                                      ; preds = %for.inc253, %for.end208
  %106 = load i32, i32* %i, align 4
  %cmp214 = icmp slt i32 %106, 64
  br i1 %cmp214, label %for.body216, label %for.end259

for.body216:                                      ; preds = %for.cond213
  %107 = load i32, i32* %i, align 4
  %108 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %108, i32 0, i32 9
  %109 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %109, 8
  %cmp217 = icmp sge i32 %107, %div
  br i1 %cmp217, label %if.then219, label %if.end220

if.then219:                                       ; preds = %for.body216
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %110, %struct.bpf_verifier_state* noundef %111) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end220:                                        ; preds = %for.body216
  %112 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack221 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %112, i32 0, i32 10
  %113 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack221, align 8
  %114 = load i32, i32* %i, align 4
  %idxprom222 = sext i32 %114 to i64
  %arrayidx223 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %113, i64 %idxprom222
  %slot_type224 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx223, i32 0, i32 1
  %arrayidx225 = getelementptr [8 x i8], [8 x i8]* %slot_type224, i64 0, i64 0
  %115 = load i8, i8* %arrayidx225, align 8
  %conv226 = zext i8 %115 to i32
  %cmp227 = icmp ne i32 %conv226, 1
  br i1 %cmp227, label %if.then229, label %if.end234

if.then229:                                       ; preds = %if.end220
  %116 = load i32, i32* %i, align 4
  %sh_prom230 = zext i32 %116 to i64
  %shl231 = shl i64 1, %sh_prom230
  %neg232 = xor i64 %shl231, -1
  %117 = load i64, i64* %stack_mask, align 8
  %and233 = and i64 %117, %neg232
  store i64 %and233, i64* %stack_mask, align 8
  br label %for.inc253

if.end234:                                        ; preds = %if.end220
  %118 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack235 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %118, i32 0, i32 10
  %119 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack235, align 8
  %120 = load i32, i32* %i, align 4
  %idxprom236 = sext i32 %120 to i64
  %arrayidx237 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %119, i64 %idxprom236
  %spilled_ptr238 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx237, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr238, %struct.bpf_reg_state** %reg, align 8
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type239 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %121, i32 0, i32 0
  %122 = load i32, i32* %type239, align 8
  %cmp240 = icmp ne i32 %122, 1
  br i1 %cmp240, label %if.then242, label %if.end247

if.then242:                                       ; preds = %if.end234
  %123 = load i32, i32* %i, align 4
  %sh_prom243 = zext i32 %123 to i64
  %shl244 = shl i64 1, %sh_prom243
  %neg245 = xor i64 %shl244, -1
  %124 = load i64, i64* %stack_mask, align 8
  %and246 = and i64 %124, %neg245
  store i64 %and246, i64* %stack_mask, align 8
  br label %for.inc253

if.end247:                                        ; preds = %if.end234
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise248 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 18
  %126 = load i8, i8* %precise248, align 4
  %tobool249 = trunc i8 %126 to i1
  br i1 %tobool249, label %if.end251, label %if.then250

if.then250:                                       ; preds = %if.end247
  store i8 1, i8* %new_marks, align 1
  br label %if.end251

if.end251:                                        ; preds = %if.then250, %if.end247
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise252 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i32 0, i32 18
  store i8 1, i8* %precise252, align 4
  br label %for.inc253

for.inc253:                                       ; preds = %if.end251, %if.then242, %if.then229
  %arraydecay254 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %128 = load i32, i32* %i, align 4
  %add255 = add i32 %128, 1
  %conv256 = sext i32 %add255 to i64
  %call257 = call i64 @find_next_bit(i64* noundef %arraydecay254, i64 noundef 64, i64 noundef %conv256) #14
  %conv258 = trunc i64 %call257 to i32
  store i32 %conv258, i32* %i, align 4
  br label %for.cond213

for.end259:                                       ; preds = %for.cond213
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log260 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %129, i32 0, i32 26
  %level261 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log260, i32 0, i32 0
  %130 = load i32, i32* %level261, align 8
  %and262 = and i32 %130, 3
  %tobool263 = icmp ne i32 %and262, 0
  br i1 %tobool263, label %if.then264, label %if.end268

if.then264:                                       ; preds = %for.end259
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %131, %struct.bpf_func_state* noundef %132) #14
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = bitcast %struct.bpf_verifier_env* %133 to i8*
  %135 = load i8, i8* %new_marks, align 1
  %tobool265 = trunc i8 %135 to i1
  %136 = zext i1 %tobool265 to i64
  %cond267 = select i1 %tobool265, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.240, i64 0, i64 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.241, i64 0, i64 0)
  %137 = load i32, i32* %reg_mask, align 4
  %138 = load i64, i64* %stack_mask, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %134, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.239, i64 0, i64 0), i8* noundef %cond267, i32 noundef %137, i64 noundef %138) #14
  br label %if.end268

if.end268:                                        ; preds = %if.then264, %for.end259
  %139 = load i32, i32* %reg_mask, align 4
  %tobool269 = icmp ne i32 %139, 0
  br i1 %tobool269, label %if.end273, label %land.lhs.true270

land.lhs.true270:                                 ; preds = %if.end268
  %140 = load i64, i64* %stack_mask, align 8
  %tobool271 = icmp ne i64 %140, 0
  br i1 %tobool271, label %if.end273, label %if.then272

if.then272:                                       ; preds = %land.lhs.true270
  br label %for.end278

if.end273:                                        ; preds = %land.lhs.true270, %if.end268
  %141 = load i8, i8* %new_marks, align 1
  %tobool274 = trunc i8 %141 to i1
  br i1 %tobool274, label %if.end276, label %if.then275

if.then275:                                       ; preds = %if.end273
  br label %for.end278

if.end276:                                        ; preds = %if.end273
  %142 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %142, i32 0, i32 8
  %143 = load i32, i32* %last_insn_idx, align 8
  store i32 %143, i32* %last_idx, align 4
  %144 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx277 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %144, i32 0, i32 7
  %145 = load i32, i32* %first_insn_idx277, align 4
  store i32 %145, i32* %first_idx, align 4
  br label %for.cond

for.end278:                                       ; preds = %if.then275, %if.then272, %if.then176
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end278, %if.then219, %if.end166, %if.then110, %if.then104, %if.then101, %if.then89, %if.then85, %if.end46, %if.then
  %146 = load i32, i32* %retval, align 4
  ret i32 %146
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx, i32* noundef %reg_mask, i64* noundef %stack_mask) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %reg_mask.addr = alloca i32*, align 8
  %stack_mask.addr = alloca i64*, align 8
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  %dreg = alloca i32, align 4
  %sreg = alloca i32, align 4
  %spi = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp123 = alloca i64, align 8
  %__ret_do_once169 = alloca i8, align 1
  %__ret_warn_on184 = alloca i32, align 4
  %tmp208 = alloca i64, align 8
  %tmp216 = alloca i64, align 8
  %__ret_do_once265 = alloca i8, align 1
  %__ret_warn_on280 = alloca i32, align 4
  %tmp304 = alloca i64, align 8
  %tmp312 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %reg_mask, i32** %reg_mask.addr, align 8
  store i64* %stack_mask, i64** %stack_mask.addr, align 8
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* @disasm_kfunc_name, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = bitcast %struct.bpf_verifier_env* %0 to i8*
  store i8* %1, i8** %private_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %4 = load i32, i32* %idx.addr, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %5, i32 0, i32 0
  %6 = load i8, i8* %code, align 4
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %class, align 1
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %8 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %opcode, align 1
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code6, align 4
  %conv7 = zext i8 %10 to i32
  %and8 = and i32 %conv7, 224
  %conv9 = trunc i32 %and8 to i8
  store i8 %conv9, i8* %mode, align 1
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv10 = zext i8 %bf.clear to i32
  %shl = shl i32 1, %conv10
  store i32 %shl, i32* %dreg, align 4
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load11 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load11, 4
  %conv12 = zext i8 %bf.lshr to i32
  %shl13 = shl i32 1, %conv12
  store i32 %shl13, i32* %sreg, align 4
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %14 to i32
  %cmp = icmp eq i32 %conv15, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %16 = load i32, i32* %level, align 8
  %and17 = and i32 %16, 3
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load i32*, i32** %reg_mask.addr, align 8
  %20 = load i32, i32* %19, align 4
  %21 = load i64*, i64** %stack_mask.addr, align 8
  %22 = load i64, i64* %21, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.242, i64 0, i64 0), i32 noundef %20, i64 noundef %22) #14
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load i32, i32* %idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.200, i64 0, i64 0), i32 noundef %25) #14
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 17
  %28 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool19 = trunc i8 %28 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %26, i1 noundef zeroext %tobool19) #14
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end
  %29 = load i8, i8* %class, align 1
  %conv21 = zext i8 %29 to i32
  %cmp22 = icmp eq i32 %conv21, 4
  br i1 %cmp22, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %30 = load i8, i8* %class, align 1
  %conv24 = zext i8 %30 to i32
  %cmp25 = icmp eq i32 %conv24, 7
  br i1 %cmp25, label %if.then27, label %if.else56

if.then27:                                        ; preds = %lor.lhs.false, %if.end20
  %31 = load i32*, i32** %reg_mask.addr, align 8
  %32 = load i32, i32* %31, align 4
  %33 = load i32, i32* %dreg, align 4
  %and28 = and i32 %32, %33
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then27
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.then27
  %34 = load i8, i8* %opcode, align 1
  %conv32 = zext i8 %34 to i32
  %cmp33 = icmp eq i32 %conv32, 176
  br i1 %cmp33, label %if.then35, label %if.else46

if.then35:                                        ; preds = %if.end31
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %35, i32 0, i32 0
  %36 = load i8, i8* %code36, align 4
  %conv37 = zext i8 %36 to i32
  %and38 = and i32 %conv37, 8
  %cmp39 = icmp eq i32 %and38, 8
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.then35
  %37 = load i32, i32* %dreg, align 4
  %neg = xor i32 %37, -1
  %38 = load i32*, i32** %reg_mask.addr, align 8
  %39 = load i32, i32* %38, align 4
  %and42 = and i32 %39, %neg
  store i32 %and42, i32* %38, align 4
  %40 = load i32, i32* %sreg, align 4
  %41 = load i32*, i32** %reg_mask.addr, align 8
  %42 = load i32, i32* %41, align 4
  %or = or i32 %42, %40
  store i32 %or, i32* %41, align 4
  br label %if.end45

if.else:                                          ; preds = %if.then35
  %43 = load i32, i32* %dreg, align 4
  %neg43 = xor i32 %43, -1
  %44 = load i32*, i32** %reg_mask.addr, align 8
  %45 = load i32, i32* %44, align 4
  %and44 = and i32 %45, %neg43
  store i32 %and44, i32* %44, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.else, %if.then41
  br label %if.end55

if.else46:                                        ; preds = %if.end31
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code47, align 4
  %conv48 = zext i8 %47 to i32
  %and49 = and i32 %conv48, 8
  %cmp50 = icmp eq i32 %and49, 8
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.else46
  %48 = load i32, i32* %sreg, align 4
  %49 = load i32*, i32** %reg_mask.addr, align 8
  %50 = load i32, i32* %49, align 4
  %or53 = or i32 %50, %48
  store i32 %or53, i32* %49, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.else46
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end45
  br label %if.end351

if.else56:                                        ; preds = %lor.lhs.false
  %51 = load i8, i8* %class, align 1
  %conv57 = zext i8 %51 to i32
  %cmp58 = icmp eq i32 %conv57, 1
  br i1 %cmp58, label %if.then60, label %if.else133

if.then60:                                        ; preds = %if.else56
  %52 = load i32*, i32** %reg_mask.addr, align 8
  %53 = load i32, i32* %52, align 4
  %54 = load i32, i32* %dreg, align 4
  %and61 = and i32 %53, %54
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %if.then60
  store i32 0, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.then60
  %55 = load i32, i32* %dreg, align 4
  %neg65 = xor i32 %55, -1
  %56 = load i32*, i32** %reg_mask.addr, align 8
  %57 = load i32, i32* %56, align 4
  %and66 = and i32 %57, %neg65
  store i32 %and66, i32* %56, align 4
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %58, i32 0, i32 1
  %bf.load68 = load i8, i8* %src_reg67, align 1
  %bf.lshr69 = lshr i8 %bf.load68, 4
  %conv70 = zext i8 %bf.lshr69 to i32
  %cmp71 = icmp ne i32 %conv70, 10
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end64
  store i32 0, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end64
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 0
  %60 = load i8, i8* %code75, align 4
  %conv76 = zext i8 %60 to i32
  %and77 = and i32 %conv76, 24
  %cmp78 = icmp ne i32 %and77, 24
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end74
  store i32 0, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.end74
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %61, i32 0, i32 2
  %62 = load i16, i16* %off, align 2
  %conv82 = sext i16 %62 to i32
  %sub = sub i32 0, %conv82
  %sub83 = sub i32 %sub, 1
  %div = sdiv i32 %sub83, 8
  store i32 %div, i32* %spi, align 4
  %63 = load i32, i32* %spi, align 4
  %cmp84 = icmp uge i32 %63, 64
  br i1 %cmp84, label %if.then86, label %if.end130

if.then86:                                        ; preds = %if.end81
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  %66 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.243, i64 0, i64 0), i32 noundef %66) #14
  store i8 1, i8* %__ret_do_once, align 1
  %67 = load i8, i8* %__ret_do_once, align 1
  %tobool87 = trunc i8 %67 to i1
  br i1 %tobool87, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then86
  %68 = load i8, i8* @backtrack_insn.__already_done, align 1
  %tobool89 = trunc i8 %68 to i1
  %lnot = xor i1 %tobool89, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then86
  %69 = phi i1 [ false, %if.then86 ], [ %lnot, %land.rhs ]
  %lnot90 = xor i1 %69, true
  %lnot91 = xor i1 %lnot90, true
  %lnot.ext = zext i1 %lnot91 to i32
  %conv92 = sext i32 %lnot.ext to i64
  %tobool93 = icmp ne i64 %conv92, 0
  br i1 %tobool93, label %if.then94, label %if.end122

if.then94:                                        ; preds = %land.end
  store i8 1, i8* @backtrack_insn.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %70 = load i32, i32* %__ret_warn_on, align 4
  %tobool95 = icmp ne i32 %70, 0
  %lnot96 = xor i1 %tobool95, true
  %lnot98 = xor i1 %lnot96, true
  %lnot.ext99 = zext i1 %lnot98 to i32
  %conv100 = sext i32 %lnot.ext99 to i64
  %tobool101 = icmp ne i64 %conv100, 0
  br i1 %tobool101, label %if.then102, label %if.end115

if.then102:                                       ; preds = %if.then94
  br label %do.body

do.body:                                          ; preds = %if.then102
  br label %do.body103

do.body103:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body103
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.238, i64 0, i64 0)) #14
  br label %do.body104

do.body104:                                       ; preds = %do.end
  br label %do.body105

do.body105:                                       ; preds = %do.body104
  br label %do.end106

do.end106:                                        ; preds = %do.body105
  br label %do.body107

do.body107:                                       ; preds = %do.end106
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2337, i32 2313, i64 12) #13, !srcloc !55
  br label %do.end108

do.end108:                                        ; preds = %do.body107
  call void asm sideeffect "469:\0A\09.pushsection .discard.reachable\0A\09.long 469b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !56
  br label %do.body109

do.body109:                                       ; preds = %do.end108
  br label %do.end110

do.end110:                                        ; preds = %do.body109
  br label %do.end111

do.end111:                                        ; preds = %do.end110
  br label %do.body112

do.body112:                                       ; preds = %do.end111
  br label %do.end113

do.end113:                                        ; preds = %do.body112
  br label %do.end114

do.end114:                                        ; preds = %do.end113
  br label %if.end115

if.end115:                                        ; preds = %do.end114, %if.then94
  %71 = load i32, i32* %__ret_warn_on, align 4
  %tobool116 = icmp ne i32 %71, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  store i64 %conv121, i64* %tmp, align 8
  %72 = load i64, i64* %tmp, align 8
  br label %if.end122

if.end122:                                        ; preds = %if.end115, %land.end
  %73 = load i8, i8* %__ret_do_once, align 1
  %tobool124 = trunc i8 %73 to i1
  %lnot125 = xor i1 %tobool124, true
  %lnot127 = xor i1 %lnot125, true
  %lnot.ext128 = zext i1 %lnot127 to i32
  %conv129 = sext i32 %lnot.ext128 to i64
  store i64 %conv129, i64* %tmp123, align 8
  %74 = load i64, i64* %tmp123, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end130:                                        ; preds = %if.end81
  %75 = load i32, i32* %spi, align 4
  %sh_prom = zext i32 %75 to i64
  %shl131 = shl i64 1, %sh_prom
  %76 = load i64*, i64** %stack_mask.addr, align 8
  %77 = load i64, i64* %76, align 8
  %or132 = or i64 %77, %shl131
  store i64 %or132, i64* %76, align 8
  br label %if.end350

if.else133:                                       ; preds = %if.else56
  %78 = load i8, i8* %class, align 1
  %conv134 = zext i8 %78 to i32
  %cmp135 = icmp eq i32 %conv134, 3
  br i1 %cmp135, label %if.then141, label %lor.lhs.false137

lor.lhs.false137:                                 ; preds = %if.else133
  %79 = load i8, i8* %class, align 1
  %conv138 = zext i8 %79 to i32
  %cmp139 = icmp eq i32 %conv138, 2
  br i1 %cmp139, label %if.then141, label %if.else240

if.then141:                                       ; preds = %lor.lhs.false137, %if.else133
  %80 = load i32*, i32** %reg_mask.addr, align 8
  %81 = load i32, i32* %80, align 4
  %82 = load i32, i32* %dreg, align 4
  %and142 = and i32 %81, %82
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %if.then141
  store i32 -524, i32* %retval, align 4
  br label %return

if.end145:                                        ; preds = %if.then141
  %83 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg146 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %83, i32 0, i32 1
  %bf.load147 = load i8, i8* %dst_reg146, align 1
  %bf.clear148 = and i8 %bf.load147, 15
  %conv149 = zext i8 %bf.clear148 to i32
  %cmp150 = icmp ne i32 %conv149, 10
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.end145
  store i32 0, i32* %retval, align 4
  br label %return

if.end153:                                        ; preds = %if.end145
  %84 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code154 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %84, i32 0, i32 0
  %85 = load i8, i8* %code154, align 4
  %conv155 = zext i8 %85 to i32
  %and156 = and i32 %conv155, 24
  %cmp157 = icmp ne i32 %and156, 24
  br i1 %cmp157, label %if.then159, label %if.end160

if.then159:                                       ; preds = %if.end153
  store i32 0, i32* %retval, align 4
  br label %return

if.end160:                                        ; preds = %if.end153
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off161 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %86, i32 0, i32 2
  %87 = load i16, i16* %off161, align 2
  %conv162 = sext i16 %87 to i32
  %sub163 = sub i32 0, %conv162
  %sub164 = sub i32 %sub163, 1
  %div165 = sdiv i32 %sub164, 8
  store i32 %div165, i32* %spi, align 4
  %88 = load i32, i32* %spi, align 4
  %cmp166 = icmp uge i32 %88, 64
  br i1 %cmp166, label %if.then168, label %if.end223

if.then168:                                       ; preds = %if.end160
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = bitcast %struct.bpf_verifier_env* %89 to i8*
  %91 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %90, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.243, i64 0, i64 0), i32 noundef %91) #14
  store i8 1, i8* %__ret_do_once169, align 1
  %92 = load i8, i8* %__ret_do_once169, align 1
  %tobool170 = trunc i8 %92 to i1
  br i1 %tobool170, label %land.rhs172, label %land.end176

land.rhs172:                                      ; preds = %if.then168
  %93 = load i8, i8* @backtrack_insn.__already_done.244, align 1
  %tobool173 = trunc i8 %93 to i1
  %lnot174 = xor i1 %tobool173, true
  br label %land.end176

land.end176:                                      ; preds = %land.rhs172, %if.then168
  %94 = phi i1 [ false, %if.then168 ], [ %lnot174, %land.rhs172 ]
  %lnot177 = xor i1 %94, true
  %lnot179 = xor i1 %lnot177, true
  %lnot.ext180 = zext i1 %lnot179 to i32
  %conv181 = sext i32 %lnot.ext180 to i64
  %tobool182 = icmp ne i64 %conv181, 0
  br i1 %tobool182, label %if.then183, label %if.end215

if.then183:                                       ; preds = %land.end176
  store i8 1, i8* @backtrack_insn.__already_done.244, align 1
  store i32 1, i32* %__ret_warn_on184, align 4
  %95 = load i32, i32* %__ret_warn_on184, align 4
  %tobool185 = icmp ne i32 %95, 0
  %lnot186 = xor i1 %tobool185, true
  %lnot188 = xor i1 %lnot186, true
  %lnot.ext189 = zext i1 %lnot188 to i32
  %conv190 = sext i32 %lnot.ext189 to i64
  %tobool191 = icmp ne i64 %conv190, 0
  br i1 %tobool191, label %if.then192, label %if.end207

if.then192:                                       ; preds = %if.then183
  br label %do.body193

do.body193:                                       ; preds = %if.then192
  br label %do.body194

do.body194:                                       ; preds = %do.body193
  br label %do.end195

do.end195:                                        ; preds = %do.body194
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.238, i64 0, i64 0)) #14
  br label %do.body196

do.body196:                                       ; preds = %do.end195
  br label %do.body197

do.body197:                                       ; preds = %do.body196
  br label %do.end198

do.end198:                                        ; preds = %do.body197
  br label %do.body199

do.body199:                                       ; preds = %do.end198
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2356, i32 2313, i64 12) #13, !srcloc !57
  br label %do.end200

do.end200:                                        ; preds = %do.body199
  call void asm sideeffect "470:\0A\09.pushsection .discard.reachable\0A\09.long 470b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !58
  br label %do.body201

do.body201:                                       ; preds = %do.end200
  br label %do.end202

do.end202:                                        ; preds = %do.body201
  br label %do.end203

do.end203:                                        ; preds = %do.end202
  br label %do.body204

do.body204:                                       ; preds = %do.end203
  br label %do.end205

do.end205:                                        ; preds = %do.body204
  br label %do.end206

do.end206:                                        ; preds = %do.end205
  br label %if.end207

if.end207:                                        ; preds = %do.end206, %if.then183
  %96 = load i32, i32* %__ret_warn_on184, align 4
  %tobool209 = icmp ne i32 %96, 0
  %lnot210 = xor i1 %tobool209, true
  %lnot212 = xor i1 %lnot210, true
  %lnot.ext213 = zext i1 %lnot212 to i32
  %conv214 = sext i32 %lnot.ext213 to i64
  store i64 %conv214, i64* %tmp208, align 8
  %97 = load i64, i64* %tmp208, align 8
  br label %if.end215

if.end215:                                        ; preds = %if.end207, %land.end176
  %98 = load i8, i8* %__ret_do_once169, align 1
  %tobool217 = trunc i8 %98 to i1
  %lnot218 = xor i1 %tobool217, true
  %lnot220 = xor i1 %lnot218, true
  %lnot.ext221 = zext i1 %lnot220 to i32
  %conv222 = sext i32 %lnot.ext221 to i64
  store i64 %conv222, i64* %tmp216, align 8
  %99 = load i64, i64* %tmp216, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end223:                                        ; preds = %if.end160
  %100 = load i64*, i64** %stack_mask.addr, align 8
  %101 = load i64, i64* %100, align 8
  %102 = load i32, i32* %spi, align 4
  %sh_prom224 = zext i32 %102 to i64
  %shl225 = shl i64 1, %sh_prom224
  %and226 = and i64 %101, %shl225
  %tobool227 = icmp ne i64 %and226, 0
  br i1 %tobool227, label %if.end229, label %if.then228

if.then228:                                       ; preds = %if.end223
  store i32 0, i32* %retval, align 4
  br label %return

if.end229:                                        ; preds = %if.end223
  %103 = load i32, i32* %spi, align 4
  %sh_prom230 = zext i32 %103 to i64
  %shl231 = shl i64 1, %sh_prom230
  %neg232 = xor i64 %shl231, -1
  %104 = load i64*, i64** %stack_mask.addr, align 8
  %105 = load i64, i64* %104, align 8
  %and233 = and i64 %105, %neg232
  store i64 %and233, i64* %104, align 8
  %106 = load i8, i8* %class, align 1
  %conv234 = zext i8 %106 to i32
  %cmp235 = icmp eq i32 %conv234, 3
  br i1 %cmp235, label %if.then237, label %if.end239

if.then237:                                       ; preds = %if.end229
  %107 = load i32, i32* %sreg, align 4
  %108 = load i32*, i32** %reg_mask.addr, align 8
  %109 = load i32, i32* %108, align 4
  %or238 = or i32 %109, %107
  store i32 %or238, i32* %108, align 4
  br label %if.end239

if.end239:                                        ; preds = %if.then237, %if.end229
  br label %if.end349

if.else240:                                       ; preds = %lor.lhs.false137
  %110 = load i8, i8* %class, align 1
  %conv241 = zext i8 %110 to i32
  %cmp242 = icmp eq i32 %conv241, 5
  br i1 %cmp242, label %if.then248, label %lor.lhs.false244

lor.lhs.false244:                                 ; preds = %if.else240
  %111 = load i8, i8* %class, align 1
  %conv245 = zext i8 %111 to i32
  %cmp246 = icmp eq i32 %conv245, 6
  br i1 %cmp246, label %if.then248, label %if.else327

if.then248:                                       ; preds = %lor.lhs.false244, %if.else240
  %112 = load i8, i8* %opcode, align 1
  %conv249 = zext i8 %112 to i32
  %cmp250 = icmp eq i32 %conv249, 128
  br i1 %cmp250, label %if.then252, label %if.else320

if.then252:                                       ; preds = %if.then248
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg253 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %113, i32 0, i32 1
  %bf.load254 = load i8, i8* %src_reg253, align 1
  %bf.lshr255 = lshr i8 %bf.load254, 4
  %conv256 = zext i8 %bf.lshr255 to i32
  %cmp257 = icmp eq i32 %conv256, 1
  br i1 %cmp257, label %if.then259, label %if.end260

if.then259:                                       ; preds = %if.then252
  store i32 -524, i32* %retval, align 4
  br label %return

if.end260:                                        ; preds = %if.then252
  %114 = load i32*, i32** %reg_mask.addr, align 8
  %115 = load i32, i32* %114, align 4
  %and261 = and i32 %115, -2
  store i32 %and261, i32* %114, align 4
  %116 = load i32*, i32** %reg_mask.addr, align 8
  %117 = load i32, i32* %116, align 4
  %and262 = and i32 %117, 63
  %tobool263 = icmp ne i32 %and262, 0
  br i1 %tobool263, label %if.then264, label %if.end319

if.then264:                                       ; preds = %if.end260
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %119 = bitcast %struct.bpf_verifier_env* %118 to i8*
  %120 = load i32*, i32** %reg_mask.addr, align 8
  %121 = load i32, i32* %120, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %119, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.245, i64 0, i64 0), i32 noundef %121) #14
  store i8 1, i8* %__ret_do_once265, align 1
  %122 = load i8, i8* %__ret_do_once265, align 1
  %tobool266 = trunc i8 %122 to i1
  br i1 %tobool266, label %land.rhs268, label %land.end272

land.rhs268:                                      ; preds = %if.then264
  %123 = load i8, i8* @backtrack_insn.__already_done.246, align 1
  %tobool269 = trunc i8 %123 to i1
  %lnot270 = xor i1 %tobool269, true
  br label %land.end272

land.end272:                                      ; preds = %land.rhs268, %if.then264
  %124 = phi i1 [ false, %if.then264 ], [ %lnot270, %land.rhs268 ]
  %lnot273 = xor i1 %124, true
  %lnot275 = xor i1 %lnot273, true
  %lnot.ext276 = zext i1 %lnot275 to i32
  %conv277 = sext i32 %lnot.ext276 to i64
  %tobool278 = icmp ne i64 %conv277, 0
  br i1 %tobool278, label %if.then279, label %if.end311

if.then279:                                       ; preds = %land.end272
  store i8 1, i8* @backtrack_insn.__already_done.246, align 1
  store i32 1, i32* %__ret_warn_on280, align 4
  %125 = load i32, i32* %__ret_warn_on280, align 4
  %tobool281 = icmp ne i32 %125, 0
  %lnot282 = xor i1 %tobool281, true
  %lnot284 = xor i1 %lnot282, true
  %lnot.ext285 = zext i1 %lnot284 to i32
  %conv286 = sext i32 %lnot.ext285 to i64
  %tobool287 = icmp ne i64 %conv286, 0
  br i1 %tobool287, label %if.then288, label %if.end303

if.then288:                                       ; preds = %if.then279
  br label %do.body289

do.body289:                                       ; preds = %if.then288
  br label %do.body290

do.body290:                                       ; preds = %do.body289
  br label %do.end291

do.end291:                                        ; preds = %do.body290
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.238, i64 0, i64 0)) #14
  br label %do.body292

do.body292:                                       ; preds = %do.end291
  br label %do.body293

do.body293:                                       ; preds = %do.body292
  br label %do.end294

do.end294:                                        ; preds = %do.body293
  br label %do.body295

do.body295:                                       ; preds = %do.end294
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2375, i32 2313, i64 12) #13, !srcloc !59
  br label %do.end296

do.end296:                                        ; preds = %do.body295
  call void asm sideeffect "471:\0A\09.pushsection .discard.reachable\0A\09.long 471b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !60
  br label %do.body297

do.body297:                                       ; preds = %do.end296
  br label %do.end298

do.end298:                                        ; preds = %do.body297
  br label %do.end299

do.end299:                                        ; preds = %do.end298
  br label %do.body300

do.body300:                                       ; preds = %do.end299
  br label %do.end301

do.end301:                                        ; preds = %do.body300
  br label %do.end302

do.end302:                                        ; preds = %do.end301
  br label %if.end303

if.end303:                                        ; preds = %do.end302, %if.then279
  %126 = load i32, i32* %__ret_warn_on280, align 4
  %tobool305 = icmp ne i32 %126, 0
  %lnot306 = xor i1 %tobool305, true
  %lnot308 = xor i1 %lnot306, true
  %lnot.ext309 = zext i1 %lnot308 to i32
  %conv310 = sext i32 %lnot.ext309 to i64
  store i64 %conv310, i64* %tmp304, align 8
  %127 = load i64, i64* %tmp304, align 8
  br label %if.end311

if.end311:                                        ; preds = %if.end303, %land.end272
  %128 = load i8, i8* %__ret_do_once265, align 1
  %tobool313 = trunc i8 %128 to i1
  %lnot314 = xor i1 %tobool313, true
  %lnot316 = xor i1 %lnot314, true
  %lnot.ext317 = zext i1 %lnot316 to i32
  %conv318 = sext i32 %lnot.ext317 to i64
  store i64 %conv318, i64* %tmp312, align 8
  %129 = load i64, i64* %tmp312, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end319:                                        ; preds = %if.end260
  br label %if.end326

if.else320:                                       ; preds = %if.then248
  %130 = load i8, i8* %opcode, align 1
  %conv321 = zext i8 %130 to i32
  %cmp322 = icmp eq i32 %conv321, 144
  br i1 %cmp322, label %if.then324, label %if.end325

if.then324:                                       ; preds = %if.else320
  store i32 -524, i32* %retval, align 4
  br label %return

if.end325:                                        ; preds = %if.else320
  br label %if.end326

if.end326:                                        ; preds = %if.end325, %if.end319
  br label %if.end348

if.else327:                                       ; preds = %lor.lhs.false244
  %131 = load i8, i8* %class, align 1
  %conv328 = zext i8 %131 to i32
  %cmp329 = icmp eq i32 %conv328, 0
  br i1 %cmp329, label %if.then331, label %if.end347

if.then331:                                       ; preds = %if.else327
  %132 = load i32*, i32** %reg_mask.addr, align 8
  %133 = load i32, i32* %132, align 4
  %134 = load i32, i32* %dreg, align 4
  %and332 = and i32 %133, %134
  %tobool333 = icmp ne i32 %and332, 0
  br i1 %tobool333, label %if.end335, label %if.then334

if.then334:                                       ; preds = %if.then331
  store i32 0, i32* %retval, align 4
  br label %return

if.end335:                                        ; preds = %if.then331
  %135 = load i32, i32* %dreg, align 4
  %neg336 = xor i32 %135, -1
  %136 = load i32*, i32** %reg_mask.addr, align 8
  %137 = load i32, i32* %136, align 4
  %and337 = and i32 %137, %neg336
  store i32 %and337, i32* %136, align 4
  %138 = load i8, i8* %mode, align 1
  %conv338 = zext i8 %138 to i32
  %cmp339 = icmp eq i32 %conv338, 64
  br i1 %cmp339, label %if.then345, label %lor.lhs.false341

lor.lhs.false341:                                 ; preds = %if.end335
  %139 = load i8, i8* %mode, align 1
  %conv342 = zext i8 %139 to i32
  %cmp343 = icmp eq i32 %conv342, 32
  br i1 %cmp343, label %if.then345, label %if.end346

if.then345:                                       ; preds = %lor.lhs.false341, %if.end335
  store i32 -524, i32* %retval, align 4
  br label %return

if.end346:                                        ; preds = %lor.lhs.false341
  br label %if.end347

if.end347:                                        ; preds = %if.end346, %if.else327
  br label %if.end348

if.end348:                                        ; preds = %if.end347, %if.end326
  br label %if.end349

if.end349:                                        ; preds = %if.end348, %if.end239
  br label %if.end350

if.end350:                                        ; preds = %if.end349, %if.end130
  br label %if.end351

if.end351:                                        ; preds = %if.end350, %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end351, %if.then345, %if.then334, %if.then324, %if.end311, %if.then259, %if.then228, %if.end215, %if.then159, %if.then152, %if.then144, %if.end122, %if.then80, %if.then73, %if.then63, %if.then30, %if.then
  %140 = load i32, i32* %retval, align 4
  ret i32 %140
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %for.body, label %for.end35

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc31, %for.body
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %1, %3
  br i1 %cmp, label %for.body2, label %for.end33

for.body2:                                        ; preds = %for.cond1
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %6, %struct.bpf_func_state** %func, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body2
  %7 = load i32, i32* %j, align 4
  %cmp4 = icmp slt i32 %7, 10
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %9 = load i32, i32* %j, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  store %struct.bpf_reg_state* %arrayidx7, %struct.bpf_reg_state** %reg, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type, align 8
  %cmp8 = icmp ne i32 %11, 1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body5
  br label %for.inc

if.end:                                           ; preds = %for.body5
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 18
  store i8 1, i8* %precise, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %13 = load i32, i32* %j, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  store i32 0, i32* %j, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc28, %for.end
  %14 = load i32, i32* %j, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 9
  %16 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %16, 8
  %cmp10 = icmp slt i32 %14, %div
  br i1 %cmp10, label %for.body11, label %for.end30

for.body11:                                       ; preds = %for.cond9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 10
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %19 = load i32, i32* %j, align 4
  %idxprom12 = sext i32 %19 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom12
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 1
  %arrayidx14 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %20 = load i8, i8* %arrayidx14, align 8
  %conv = zext i8 %20 to i32
  %cmp15 = icmp ne i32 %conv, 1
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body11
  br label %for.inc28

if.end18:                                         ; preds = %for.body11
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack19 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 10
  %22 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack19, align 8
  %23 = load i32, i32* %j, align 4
  %idxprom20 = sext i32 %23 to i64
  %arrayidx21 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %22, i64 %idxprom20
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx21, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type22, align 8
  %cmp23 = icmp ne i32 %25, 1
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end18
  br label %for.inc28

if.end26:                                         ; preds = %if.end18
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 18
  store i8 1, i8* %precise27, align 4
  br label %for.inc28

for.inc28:                                        ; preds = %if.end26, %if.then25, %if.then17
  %27 = load i32, i32* %j, align 4
  %inc29 = add i32 %27, 1
  store i32 %inc29, i32* %j, align 4
  br label %for.cond9

for.end30:                                        ; preds = %for.cond9
  br label %for.inc31

for.inc31:                                        ; preds = %for.end30
  %28 = load i32, i32* %i, align 4
  %inc32 = add i32 %28, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond1

for.end33:                                        ; preds = %for.cond1
  br label %for.inc34

for.inc34:                                        ; preds = %for.end33
  %29 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %29, i32 0, i32 1
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %30, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.end35:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %st, i32 noundef %i, i32* noundef %history) #0 {
entry:
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i.addr = alloca i32, align 4
  %history.addr = alloca i32*, align 8
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  store i32* %history, i32** %history.addr, align 8
  %0 = load i32*, i32** %history.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %5 = load i32, i32* %cnt, align 4
  %sub = sub i32 %5, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %4, i64 %idxprom
  %idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx, i32 0, i32 1
  %6 = load i32, i32* %idx, align 4
  %7 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 9
  %9 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history1, align 8
  %10 = load i32, i32* %cnt, align 4
  %sub2 = sub i32 %10, 1
  %idxprom3 = zext i32 %sub2 to i64
  %arrayidx4 = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %9, i64 %idxprom3
  %prev_idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx4, i32 0, i32 0
  %11 = load i32, i32* %prev_idx, align 4
  store i32 %11, i32* %i.addr, align 4
  %12 = load i32*, i32** %history.addr, align 8
  %13 = load i32, i32* %12, align 4
  %dec = add i32 %13, -1
  store i32 %dec, i32* %12, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %i.addr, align 4
  %dec5 = add i32 %14, -1
  store i32 %dec5, i32* %i.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %15 = load i32, i32* %i.addr, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bitmap_from_u64(i64* noundef %dst, i64 noundef %mask) #0 {
entry:
  %dst.addr = alloca i64*, align 8
  %mask.addr = alloca i64, align 8
  store i64* %dst, i64** %dst.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  %0 = load i64, i64* %mask.addr, align 8
  %and = and i64 %0, -1
  %1 = load i64*, i64** %dst.addr, align 8
  %arrayidx = getelementptr i64, i64* %1, i64 0
  store i64 %and, i64* %arrayidx, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @find_first_bit(i64* noundef %addr, i64 noundef %size) #0 {
entry:
  %word.addr.i = alloca i64, align 8
  %retval = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  %size.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64* %addr, i64** %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %1 = call i1 @llvm.is.constant.i64(i64 %0)
  br i1 %1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* %size.addr, align 8
  %cmp = icmp ule i64 %2, 64
  br i1 %cmp, label %land.lhs.true1, label %if.end

land.lhs.true1:                                   ; preds = %land.lhs.true
  %3 = load i64, i64* %size.addr, align 8
  %cmp2 = icmp ugt i64 %3, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true1
  %4 = load i64*, i64** %addr.addr, align 8
  %5 = load i64, i64* %4, align 8
  %6 = load i64, i64* %size.addr, align 8
  %sub = sub i64 %6, 1
  %sub3 = sub i64 63, %sub
  %shr = lshr i64 -1, %sub3
  %and = and i64 -1, %shr
  %add = add i64 0, %and
  %and4 = and i64 %5, %add
  store i64 %and4, i64* %val, align 8
  %7 = load i64, i64* %val, align 8
  %tobool = icmp ne i64 %7, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %8 = load i64, i64* %val, align 8
  store i64 %8, i64* %word.addr.i, align 8
  %9 = load i64, i64* %word.addr.i, align 8
  %10 = call i64 asm "rep; bsf $1,$0", "=r,rm,~{dirflag},~{fpsr},~{flags}"(i64 %9) #12, !srcloc !61
  store i64 %10, i64* %word.addr.i, align 8
  %11 = load i64, i64* %word.addr.i, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %12 = load i64, i64* %size.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %12, %cond.false ]
  store i64 %cond, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true1, %land.lhs.true, %entry
  %13 = load i64*, i64** %addr.addr, align 8
  %14 = load i64, i64* %size.addr, align 8
  %call5 = call i64 @_find_first_bit(i64* noundef %13, i64 noundef %14) #14
  store i64 %call5, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %15 = load i64, i64* %retval, align 8
  ret i64 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @find_next_bit(i64* noundef %addr, i64 noundef %size, i64 noundef %offset) #0 {
entry:
  %word.addr.i = alloca i64, align 8
  %retval = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  %size.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64* %addr, i64** %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %1 = call i1 @llvm.is.constant.i64(i64 %0)
  br i1 %1, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* %size.addr, align 8
  %cmp = icmp ule i64 %2, 64
  br i1 %cmp, label %land.lhs.true1, label %if.end11

land.lhs.true1:                                   ; preds = %land.lhs.true
  %3 = load i64, i64* %size.addr, align 8
  %cmp2 = icmp ugt i64 %3, 0
  br i1 %cmp2, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true1
  %4 = load i64, i64* %offset.addr, align 8
  %5 = load i64, i64* %size.addr, align 8
  %cmp3 = icmp uge i64 %4, %5
  %lnot = xor i1 %cmp3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %6 = load i64, i64* %size.addr, align 8
  store i64 %6, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i64*, i64** %addr.addr, align 8
  %8 = load i64, i64* %7, align 8
  %9 = load i64, i64* %offset.addr, align 8
  %shl = shl i64 1, %9
  %sub = sub i64 -1, %shl
  %add = add i64 %sub, 1
  %10 = load i64, i64* %size.addr, align 8
  %sub6 = sub i64 %10, 1
  %sub7 = sub i64 63, %sub6
  %shr = lshr i64 -1, %sub7
  %and = and i64 %add, %shr
  %add8 = add i64 0, %and
  %and9 = and i64 %8, %add8
  store i64 %and9, i64* %val, align 8
  %11 = load i64, i64* %val, align 8
  %tobool10 = icmp ne i64 %11, 0
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %12 = load i64, i64* %val, align 8
  store i64 %12, i64* %word.addr.i, align 8
  %13 = load i64, i64* %word.addr.i, align 8
  %14 = call i64 asm "rep; bsf $1,$0", "=r,rm,~{dirflag},~{fpsr},~{flags}"(i64 %13) #12, !srcloc !61
  store i64 %14, i64* %word.addr.i, align 8
  %15 = load i64, i64* %word.addr.i, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %16 = load i64, i64* %size.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %15, %cond.true ], [ %16, %cond.false ]
  store i64 %cond, i64* %retval, align 8
  br label %return

if.end11:                                         ; preds = %land.lhs.true1, %land.lhs.true, %entry
  %17 = load i64*, i64** %addr.addr, align 8
  %18 = load i64, i64* %size.addr, align 8
  %19 = load i64, i64* %offset.addr, align 8
  %call12 = call i64 @_find_next_bit(i64* noundef %17, i64* noundef null, i64 noundef %18, i64 noundef %19, i64 noundef 0, i64 noundef 0) #14
  store i64 %call12, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %cond.end, %if.then5
  %20 = load i64, i64* %retval, align 8
  ret i64 %20
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_find_first_bit(i64* noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_find_next_bit(i64* noundef, i64* noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @copy_array(i8* noundef %dst, i8* noundef %src, i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i8*, align 8
  %dst.addr = alloca i8*, align 8
  %src.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i8* %dst, i8** %dst.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i8*, i8** %src.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %cmp = icmp ule i64 %1, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %out

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %n.addr, align 8
  store i64 %2, i64* %__a, align 8
  %3 = load i64, i64* %size.addr, align 8
  store i64 %3, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp1 to i32
  %4 = load i64*, i64** %__d, align 8
  %cmp2 = icmp eq i64* %__a, %4
  %conv3 = zext i1 %cmp2 to i32
  %5 = load i64, i64* %__a, align 8
  %6 = load i64, i64* %__b, align 8
  %7 = load i64*, i64** %__d, align 8
  %8 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %5, i64 %6)
  %9 = extractvalue { i64, i1 } %8, 1
  %10 = extractvalue { i64, i1 } %8, 0
  store i64 %10, i64* %7, align 8
  %frombool = zext i1 %9 to i8
  store i8 %frombool, i8* %tmp, align 1
  %11 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %11 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #14
  %lnot = xor i1 %call, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i8* null, i8** %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %12 = load i8*, i8** %dst.addr, align 8
  %call9 = call i64 @ksize(i8* noundef %12) #14
  %13 = load i64, i64* %bytes, align 8
  %cmp10 = icmp ult i64 %call9, %13
  br i1 %cmp10, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end8
  %14 = load i8*, i8** %dst.addr, align 8
  call void @kfree(i8* noundef %14) #14
  %15 = load i64, i64* %bytes, align 8
  %16 = load i32, i32* %flags.addr, align 4
  %17 = call i8* @llvm.returnaddress(i32 0)
  %18 = ptrtoint i8* %17 to i64
  %call13 = call i8* @__kmalloc_track_caller(i64 noundef %15, i32 noundef %16, i64 noundef %18) #14
  store i8* %call13, i8** %dst.addr, align 8
  %19 = load i8*, i8** %dst.addr, align 8
  %tobool14 = icmp ne i8* %19, null
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.then12
  store i8* null, i8** %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.then12
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end8
  %20 = load i8*, i8** %dst.addr, align 8
  %21 = load i8*, i8** %src.addr, align 8
  %22 = load i64, i64* %bytes, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %20, i8* align 1 %21, i64 %22, i1 false)
  br label %out

out:                                              ; preds = %if.end17, %if.then
  %23 = load i8*, i8** %dst.addr, align 8
  %tobool18 = icmp ne i8* %23, null
  br i1 %tobool18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  %24 = load i8*, i8** %dst.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %24, %cond.true ], [ inttoptr (i64 16 to i8*), %cond.false ]
  store i8* %cond, i8** %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then15, %if.then7
  %25 = load i8*, i8** %retval, align 8
  ret i8* %25
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_func_state(%struct.bpf_func_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %tobool = icmp ne %struct.bpf_func_state* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 8
  %2 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %3 = bitcast %struct.bpf_reference_state* %2 to i8*
  call void @kfree(i8* noundef %3) #14
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 10
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = bitcast %struct.bpf_stack_state* %5 to i8*
  call void @kfree(i8* noundef %6) #14
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %8 = bitcast %struct.bpf_func_state* %7 to i8*
  call void @kfree(i8* noundef %8) #14
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_func_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %1 = bitcast %struct.bpf_func_state* %0 to i8*
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %3 = bitcast %struct.bpf_func_state* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1, i8* align 8 %3, i64 1340, i1 false)
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %4, %struct.bpf_func_state* noundef %5) #14
  store i32 %call, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call1 = call i32 @copy_stack_state(%struct.bpf_func_state* noundef %8, %struct.bpf_func_state* noundef %9) #14
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @ksize(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @__kmalloc_track_caller(i64 noundef, i32 noundef, i64 noundef) #1

; Function Attrs: nofree nosync nounwind readnone willreturn
declare i8* @llvm.returnaddress(i32 immarg) #11

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_reference_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 8
  %1 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %2 = bitcast %struct.bpf_reference_state* %1 to i8*
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 8
  %4 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs1, align 8
  %5 = bitcast %struct.bpf_reference_state* %4 to i8*
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 7
  %7 = load i32, i32* %acquired_refs, align 4
  %conv = sext i32 %7 to i64
  %call = call i8* @copy_array(i8* noundef %2, i8* noundef %5, i64 noundef %conv, i64 noundef 8, i32 noundef 3264) #14
  %8 = bitcast i8* %call to %struct.bpf_reference_state*
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 8
  store %struct.bpf_reference_state* %8, %struct.bpf_reference_state** %refs2, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 8
  %11 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs3, align 8
  %tobool = icmp ne %struct.bpf_reference_state* %11, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 7
  %13 = load i32, i32* %acquired_refs4, align 4
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %acquired_refs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  store i32 %13, i32* %acquired_refs5, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_stack_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %n = alloca i64, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 9
  %1 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %1, 8
  %conv = sext i32 %div to i64
  store i64 %conv, i64* %n, align 8
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 10
  %3 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %4 = bitcast %struct.bpf_stack_state* %3 to i8*
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 10
  %6 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %7 = bitcast %struct.bpf_stack_state* %6 to i8*
  %8 = load i64, i64* %n, align 8
  %call = call i8* @copy_array(i8* noundef %4, i8* noundef %7, i64 noundef %8, i64 noundef 128, i32 noundef 3264) #14
  %9 = bitcast i8* %call to %struct.bpf_stack_state*
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 10
  store %struct.bpf_stack_state* %9, %struct.bpf_stack_state** %stack2, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack3, align 8
  %tobool = icmp ne %struct.bpf_stack_state* %12, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 9
  %14 = load i32, i32* %allocated_stack4, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %allocated_stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 9
  store i32 %14, i32* %allocated_stack5, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_tsk_thread_flag(%struct.task_struct* noundef %tsk, i32 noundef %flag) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %call = call %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %0) #14
  %1 = load i32, i32* %flag.addr, align 4
  %call1 = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %call, i32 noundef %1) #14
  ret i32 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @task_sigpending(%struct.task_struct* noundef %p) #0 {
entry:
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* noundef %0, i32 noundef 2) #14
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %conv2 = trunc i64 %conv to i32
  ret i32 %conv2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_ti_thread_flag(%struct.thread_info* noundef %ti, i32 noundef %flag) #0 {
entry:
  %ti.addr = alloca %struct.thread_info*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.thread_info* %ti, %struct.thread_info** %ti.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %flag.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %1, i32 0, i32 0
  %call = call zeroext i1 @test_bit(i64 noundef %conv, i64* noundef %flags) #14
  %conv1 = zext i1 %call to i32
  ret i32 %conv1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %task) #0 {
entry:
  %task.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %task, %struct.task_struct** %task.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %task.addr, align 8
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @test_bit(i64 noundef %nr, i64* noundef %addr) #0 {
entry:
  %nr.addr.i3 = alloca i64, align 8
  %addr.addr.i4 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %v.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  store i64 %nr, i64* %nr.addr, align 8
  store i64* %addr, i64** %addr.addr, align 8
  %0 = load i64*, i64** %addr.addr, align 8
  %1 = load i64, i64* %nr.addr, align 8
  %div = sdiv i64 %1, 64
  %add.ptr = getelementptr i64, i64* %0, i64 %div
  %2 = bitcast i64* %add.ptr to i8*
  store i8* %2, i8** %v.addr.i, align 8
  store i64 8, i64* %size.addr.i, align 8
  %3 = load i8*, i8** %v.addr.i, align 8
  %4 = load i64, i64* %size.addr.i, align 8
  %conv.i = trunc i64 %4 to i32
  %call.i = call zeroext i1 @kasan_check_read(i8* noundef %3, i32 noundef %conv.i) #16
  %5 = load i8*, i8** %v.addr.i, align 8
  %6 = load i64, i64* %size.addr.i, align 8
  call void @kcsan_check_access(i8* noundef %5, i64 noundef %6, i32 noundef 4) #16
  %7 = load i64, i64* %nr.addr, align 8
  %8 = call i1 @llvm.is.constant.i64(i64 %7)
  br i1 %8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load i64, i64* %nr.addr, align 8
  %10 = load i64*, i64** %addr.addr, align 8
  store i64 %9, i64* %nr.addr.i, align 8
  store i64* %10, i64** %addr.addr.i, align 8
  %11 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %11, 63
  %shl.i = shl i64 1, %and.i
  %12 = load i64*, i64** %addr.addr.i, align 8
  %13 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %13, 6
  %arrayidx.i = getelementptr i64, i64* %12, i64 %shr.i
  %14 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %14
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv = zext i1 %cmp.i to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, i64* %nr.addr, align 8
  %16 = load i64*, i64** %addr.addr, align 8
  store i64 %15, i64* %nr.addr.i3, align 8
  store i64* %16, i64** %addr.addr.i4, align 8
  %17 = load i64*, i64** %addr.addr.i4, align 8
  %18 = load i64, i64* %nr.addr.i3, align 8
  %19 = call i8 asm sideeffect " btq  $2,$1\0A\09/* output condition code c*/\0A", "={@ccc},*m,Ir,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* elementtype(i64) %17, i64 %18) #13, !srcloc !62
  store i8 %19, i8* %oldbit.i, align 1
  %20 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %20 to i1
  %conv2 = zext i1 %tobool.i to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %conv2, %cond.false ]
  %tobool = icmp ne i32 %cond, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @kasan_check_read(i8* noundef %p, i32 noundef %size) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  ret i1 true
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @kcsan_check_access(i8* noundef %ptr, i64 noundef %size, i32 noundef %type) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @__cond_resched() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 17
  %1 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool = trunc i8 %1 to i1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %2, i32 noundef %3) #14
  %call1 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool, %struct.bpf_reg_state* noundef %call) #14
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %ptr_reg = alloca %struct.bpf_reg_state*, align 8
  %off_reg = alloca %struct.bpf_reg_state, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on99 = alloca i32, align 4
  %tmp124 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %ptr_reg, align 8
  %7 = bitcast %struct.bpf_reg_state* %off_reg to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %7, i8 0, i64 120, i1 false)
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg3, align 1
  %bf.clear = and i8 %bf.load, 15
  %idxprom4 = zext i8 %bf.clear to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %13, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* %14, %struct.bpf_reg_state** %ptr_reg, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 3
  store i32 0, i32* %id, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code7, align 4
  %conv8 = zext i8 %17 to i32
  %and9 = and i32 %conv8, 8
  %cmp10 = icmp eq i32 %and9, 8
  br i1 %cmp10, label %if.then12, label %if.else65

if.then12:                                        ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.lshr = lshr i8 %bf.load14, 4
  %idxprom15 = zext i8 %bf.lshr to i64
  %arrayidx16 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i64 %idxprom15
  store %struct.bpf_reg_state* %arrayidx16, %struct.bpf_reg_state** %src_reg, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 0
  %21 = load i32, i32* %type17, align 8
  %cmp18 = icmp ne i32 %21, 1
  br i1 %cmp18, label %if.then20, label %if.else51

if.then20:                                        ; preds = %if.then12
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %23, 1
  br i1 %cmp22, label %if.then24, label %if.else42

if.then24:                                        ; preds = %if.then20
  %24 = load i8, i8* %opcode, align 1
  %conv25 = zext i8 %24 to i32
  %cmp26 = icmp eq i32 %conv25, 16
  br i1 %cmp26, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.then24
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 17
  %26 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool = trunc i8 %26 to i1
  br i1 %tobool, label %if.then29, label %if.end34

if.then29:                                        ; preds = %land.lhs.true
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load31 = load i8, i8* %dst_reg30, align 1
  %bf.clear32 = and i8 %bf.load31, 15
  %conv33 = zext i8 %bf.clear32 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %28, i32 noundef %conv33) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %land.lhs.true, %if.then24
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, 15
  %conv38 = zext i8 %bf.clear37 to i32
  %33 = load i8, i8* %opcode, align 1
  %conv39 = zext i8 %33 to i32
  %shr = ashr i32 %conv39, 4
  %idxprom40 = sext i32 %shr to i64
  %arrayidx41 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom40
  %34 = load i8*, i8** %arrayidx41, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.256, i64 0, i64 0), i32 noundef %conv38, i8* noundef %34) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.else42:                                        ; preds = %if.then20
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, 15
  %conv46 = zext i8 %bf.clear45 to i32
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %35, i32 noundef %conv46) #14
  store i32 %call, i32* %err, align 4
  %37 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %37, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.else42
  %38 = load i32, i32* %err, align 4
  store i32 %38, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.else42
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call50 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %39, %struct.bpf_insn* noundef %40, %struct.bpf_reg_state* noundef %41, %struct.bpf_reg_state* noundef %42) #14
  store i32 %call50, i32* %retval, align 4
  br label %return

if.else51:                                        ; preds = %if.then12
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool52 = icmp ne %struct.bpf_reg_state* %43, null
  br i1 %tobool52, label %if.then53, label %if.end63

if.then53:                                        ; preds = %if.else51
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 1
  %bf.load55 = load i8, i8* %src_reg54, align 1
  %bf.lshr56 = lshr i8 %bf.load55, 4
  %conv57 = zext i8 %bf.lshr56 to i32
  %call58 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %44, i32 noundef %conv57) #14
  store i32 %call58, i32* %err, align 4
  %46 = load i32, i32* %err, align 4
  %tobool59 = icmp ne i32 %46, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.then53
  %47 = load i32, i32* %err, align 4
  store i32 %47, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.then53
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call62 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %48, %struct.bpf_insn* noundef %49, %struct.bpf_reg_state* noundef %50, %struct.bpf_reg_state* noundef %51) #14
  store i32 %call62, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.else51
  br label %if.end64

if.end64:                                         ; preds = %if.end63
  br label %if.end72

if.else65:                                        ; preds = %if.end
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %off_reg, i32 0, i32 0
  store i32 1, i32* %type66, align 8
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 3
  %53 = load i32, i32* %imm, align 4
  %conv67 = sext i32 %53 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %off_reg, i64 noundef %conv67) #14
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %src_reg, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool68 = icmp ne %struct.bpf_reg_state* %54, null
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %if.else65
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call70 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %55, %struct.bpf_insn* noundef %56, %struct.bpf_reg_state* noundef %57, %struct.bpf_reg_state* noundef %58) #14
  store i32 %call70, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.else65
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end64
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool73 = icmp ne %struct.bpf_reg_state* %59, null
  %lnot = xor i1 %tobool73, true
  %lnot74 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot74 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %60 = load i32, i32* %__ret_warn_on, align 4
  %tobool75 = icmp ne i32 %60, 0
  %lnot76 = xor i1 %tobool75, true
  %lnot78 = xor i1 %lnot76, true
  %lnot.ext79 = zext i1 %lnot78 to i32
  %conv80 = sext i32 %lnot.ext79 to i64
  %tobool81 = icmp ne i64 %conv80, 0
  br i1 %tobool81, label %if.then82, label %if.end89

if.then82:                                        ; preds = %if.end72
  br label %do.body

do.body:                                          ; preds = %if.then82
  br label %do.body83

do.body83:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body83
  br label %do.body84

do.body84:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 8294, i32 2307, i64 12) #13, !srcloc !63
  br label %do.end85

do.end85:                                         ; preds = %do.body84
  call void asm sideeffect "490:\0A\09.pushsection .discard.reachable\0A\09.long 490b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !64
  br label %do.body86

do.body86:                                        ; preds = %do.end85
  br label %do.end87

do.end87:                                         ; preds = %do.body86
  br label %do.end88

do.end88:                                         ; preds = %do.end87
  br label %if.end89

if.end89:                                         ; preds = %do.end88, %if.end72
  %61 = load i32, i32* %__ret_warn_on, align 4
  %tobool90 = icmp ne i32 %61, 0
  %lnot91 = xor i1 %tobool90, true
  %lnot93 = xor i1 %lnot91, true
  %lnot.ext94 = zext i1 %lnot93 to i32
  %conv95 = sext i32 %lnot.ext94 to i64
  store i64 %conv95, i64* %tmp, align 8
  %62 = load i64, i64* %tmp, align 8
  %tobool96 = icmp ne i64 %62, 0
  br i1 %tobool96, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end89
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %63, %struct.bpf_func_state* noundef %64) #14
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = bitcast %struct.bpf_verifier_env* %65 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %66, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.257, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.end89
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %tobool100 = icmp ne %struct.bpf_reg_state* %67, null
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  store i32 %lnot.ext106, i32* %__ret_warn_on99, align 4
  %68 = load i32, i32* %__ret_warn_on99, align 4
  %tobool107 = icmp ne i32 %68, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %tobool113 = icmp ne i64 %conv112, 0
  br i1 %tobool113, label %if.then114, label %if.end123

if.then114:                                       ; preds = %if.end98
  br label %do.body115

do.body115:                                       ; preds = %if.then114
  br label %do.body116

do.body116:                                       ; preds = %do.body115
  br label %do.end117

do.end117:                                        ; preds = %do.body116
  br label %do.body118

do.body118:                                       ; preds = %do.end117
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 8299, i32 2305, i64 12) #13, !srcloc !65
  br label %do.end119

do.end119:                                        ; preds = %do.body118
  call void asm sideeffect "491:\0A\09.pushsection .discard.reachable\0A\09.long 491b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !66
  br label %do.body120

do.body120:                                       ; preds = %do.end119
  br label %do.end121

do.end121:                                        ; preds = %do.body120
  br label %do.end122

do.end122:                                        ; preds = %do.end121
  br label %if.end123

if.end123:                                        ; preds = %do.end122, %if.end98
  %69 = load i32, i32* %__ret_warn_on99, align 4
  %tobool125 = icmp ne i32 %69, 0
  %lnot126 = xor i1 %tobool125, true
  %lnot128 = xor i1 %lnot126, true
  %lnot.ext129 = zext i1 %lnot128 to i32
  %conv130 = sext i32 %lnot.ext129 to i64
  store i64 %conv130, i64* %tmp124, align 8
  %70 = load i64, i64* %tmp124, align 8
  %tobool131 = icmp ne i64 %70, 0
  br i1 %tobool131, label %if.then132, label %if.end133

if.then132:                                       ; preds = %if.end123
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %71, %struct.bpf_func_state* noundef %72) #14
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = bitcast %struct.bpf_verifier_env* %73 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %74, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.258, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end133:                                        ; preds = %if.end123
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call134 = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %75, %struct.bpf_insn* noundef %76, %struct.bpf_reg_state* noundef %77, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %78) #14
  store i32 %call134, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end133, %if.then132, %if.then97, %if.then69, %if.end61, %if.then60, %if.end49, %if.then48, %if.end34, %if.then29
  %79 = load i32, i32* %retval, align 4
  ret i32 %79
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %off_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %smin_ptr = alloca i64, align 8
  %smax_ptr = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %umin_ptr = alloca i64, align 8
  %umax_ptr = alloca i64, align 8
  %info = alloca %struct.bpf_sanitize_info, align 8
  %opcode = alloca i8, align 1
  %dst = alloca i32, align 4
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp208 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value, align 8
  store i64 %14, i64* %smin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value, align 8
  store i64 %16, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value2, align 8
  store i64 %18, i64* %smin_ptr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 7
  %20 = load i64, i64* %smax_value3, align 8
  store i64 %20, i64* %smax_ptr, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value, align 8
  store i64 %22, i64* %umin_val, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 9
  %24 = load i64, i64* %umax_value, align 8
  store i64 %24, i64* %umax_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  %26 = load i64, i64* %umin_value4, align 8
  store i64 %26, i64* %umin_ptr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value5, align 8
  store i64 %28, i64* %umax_ptr, align 8
  %29 = bitcast %struct.bpf_sanitize_info* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %29, i8 0, i64 64, i1 false)
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 0
  %31 = load i8, i8* %code, align 4
  %conv = zext i8 %31 to i32
  %and = and i32 %conv, 240
  %conv6 = trunc i32 %and to i8
  store i8 %conv6, i8* %opcode, align 1
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg7, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv8 = zext i8 %bf.clear to i32
  store i32 %conv8, i32* %dst, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %34 = load i32, i32* %dst, align 4
  %idxprom9 = zext i32 %34 to i64
  %arrayidx10 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i64 %idxprom9
  store %struct.bpf_reg_state* %arrayidx10, %struct.bpf_reg_state** %dst_reg, align 8
  %35 = load i8, i8* %known, align 1
  %tobool = trunc i8 %35 to i1
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false15

land.lhs.true:                                    ; preds = %entry
  %36 = load i64, i64* %smin_val, align 8
  %37 = load i64, i64* %smax_val, align 8
  %cmp = icmp ne i64 %36, %37
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %38 = load i64, i64* %umin_val, align 8
  %39 = load i64, i64* %umax_val, align 8
  %cmp13 = icmp ne i64 %38, %39
  br i1 %cmp13, label %if.then, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false, %entry
  %40 = load i64, i64* %smin_val, align 8
  %41 = load i64, i64* %smax_val, align 8
  %cmp16 = icmp sgt i64 %40, %41
  br i1 %cmp16, label %if.then, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false15
  %42 = load i64, i64* %umin_val, align 8
  %43 = load i64, i64* %umax_val, align 8
  %cmp19 = icmp ugt i64 %42, %43
  br i1 %cmp19, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false18, %lor.lhs.false15, %lor.lhs.false, %land.lhs.true
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false18
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code21, align 4
  %conv22 = zext i8 %47 to i32
  %and23 = and i32 %conv22, 7
  %cmp24 = icmp ne i32 %and23, 7
  br i1 %cmp24, label %if.then26, label %if.end35

if.then26:                                        ; preds = %if.end
  %48 = load i8, i8* %opcode, align 1
  %conv27 = zext i8 %48 to i32
  %cmp28 = icmp eq i32 %conv27, 16
  br i1 %cmp28, label %land.lhs.true30, label %if.end34

land.lhs.true30:                                  ; preds = %if.then26
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 17
  %50 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool31 = trunc i8 %50 to i1
  br i1 %tobool31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %land.lhs.true30
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %51, %struct.bpf_reg_state* noundef %52) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %land.lhs.true30, %if.then26
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.259, i64 0, i64 0), i32 noundef %55) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 0
  %57 = load i32, i32* %type, align 8
  switch i32 %57, label %sw.default [
    i32 5, label %sw.bb
    i32 3, label %sw.bb39
    i32 9, label %sw.bb51
    i32 11, label %sw.bb51
    i32 12, label %sw.bb51
    i32 13, label %sw.bb51
    i32 14, label %sw.bb51
    i32 15, label %sw.bb51
    i32 16, label %sw.bb51
    i32 18, label %sw.bb51
  ]

sw.bb:                                            ; preds = %if.end35
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  %60 = load i32, i32* %dst, align 4
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type36, align 8
  %idxprom37 = zext i32 %62 to i64
  %arrayidx38 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom37
  %63 = load i8*, i8** %arrayidx38, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.260, i64 0, i64 0), i32 noundef %60, i8* noundef %63) #14
  store i32 -13, i32* %retval, align 4
  br label %return

sw.bb39:                                          ; preds = %if.end35
  %64 = load i8, i8* %known, align 1
  %tobool40 = trunc i8 %64 to i1
  br i1 %tobool40, label %land.lhs.true42, label %if.end50

land.lhs.true42:                                  ; preds = %sw.bb39
  %65 = load i64, i64* %smin_val, align 8
  %cmp43 = icmp eq i64 %65, 0
  br i1 %cmp43, label %land.lhs.true45, label %if.end50

land.lhs.true45:                                  ; preds = %land.lhs.true42
  %66 = load i8, i8* %opcode, align 1
  %conv46 = zext i8 %66 to i32
  %cmp47 = icmp eq i32 %conv46, 0
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true45
  br label %sw.epilog

if.end50:                                         ; preds = %land.lhs.true45, %land.lhs.true42, %sw.bb39
  br label %sw.bb51

sw.bb51:                                          ; preds = %if.end35, %if.end35, %if.end35, %if.end35, %if.end35, %if.end35, %if.end35, %if.end35, %if.end50
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = bitcast %struct.bpf_verifier_env* %67 to i8*
  %69 = load i32, i32* %dst, align 4
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 0
  %71 = load i32, i32* %type52, align 8
  %idxprom53 = zext i32 %71 to i64
  %arrayidx54 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom53
  %72 = load i8*, i8** %arrayidx54, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %68, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.261, i64 0, i64 0), i32 noundef %69, i8* noundef %72) #14
  store i32 -13, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end35
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then49
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 0
  %74 = load i32, i32* %type55, align 8
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 0
  store i32 %74, i32* %type56, align 8
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 3
  %77 = load i32, i32* %id, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 3
  store i32 %77, i32* %id57, align 8
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 0
  %82 = load i32, i32* %type58, align 8
  %call59 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %79, %struct.bpf_reg_state* noundef %80, i32 noundef %82) #14
  br i1 %call59, label %lor.lhs.false60, label %if.then63

lor.lhs.false60:                                  ; preds = %sw.epilog
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 0
  %86 = load i32, i32* %type61, align 8
  %call62 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %83, %struct.bpf_reg_state* noundef %84, i32 noundef %86) #14
  br i1 %call62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %lor.lhs.false60, %sw.epilog
  store i32 -22, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %lor.lhs.false60
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %87) #14
  %88 = load i8, i8* %opcode, align 1
  %call65 = call zeroext i1 @sanitize_needed(i8 noundef zeroext %88) #14
  br i1 %call65, label %if.then66, label %if.end73

if.then66:                                        ; preds = %if.end64
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call67 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %89, %struct.bpf_insn* noundef %90, %struct.bpf_reg_state* noundef %91, %struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %93, %struct.bpf_sanitize_info* noundef %info, i1 noundef zeroext false) #14
  store i32 %call67, i32* %ret, align 4
  %94 = load i32, i32* %ret, align 4
  %cmp68 = icmp slt i32 %94, 0
  br i1 %cmp68, label %if.then70, label %if.end72

if.then70:                                        ; preds = %if.then66
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %96 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %97 = load i32, i32* %ret, align 4
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call71 = call i32 @sanitize_err(%struct.bpf_verifier_env* noundef %95, %struct.bpf_insn* noundef %96, i32 noundef %97, %struct.bpf_reg_state* noundef %98, %struct.bpf_reg_state* noundef %99) #14
  store i32 %call71, i32* %retval, align 4
  br label %return

if.end72:                                         ; preds = %if.then66
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.end64
  %100 = load i8, i8* %opcode, align 1
  %conv74 = zext i8 %100 to i32
  switch i32 %conv74, label %sw.default231 [
    i32 0, label %sw.bb75
    i32 16, label %sw.bb143
    i32 80, label %sw.bb227
    i32 64, label %sw.bb227
    i32 160, label %sw.bb227
  ]

sw.bb75:                                          ; preds = %if.end73
  %101 = load i8, i8* %known, align 1
  %tobool76 = trunc i8 %101 to i1
  br i1 %tobool76, label %land.lhs.true78, label %if.end100

land.lhs.true78:                                  ; preds = %sw.bb75
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 1
  %103 = load i32, i32* %off, align 4
  %conv79 = sext i32 %103 to i64
  %104 = load i64, i64* %smin_val, align 8
  %add = add i64 %conv79, %104
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i32 0, i32 1
  %106 = load i32, i32* %off80, align 4
  %conv81 = sext i32 %106 to i64
  %107 = load i64, i64* %smin_val, align 8
  %add82 = add i64 %conv81, %107
  %conv83 = trunc i64 %add82 to i32
  %conv84 = sext i32 %conv83 to i64
  %cmp85 = icmp eq i64 %add, %conv84
  br i1 %cmp85, label %if.then87, label %if.end100

if.then87:                                        ; preds = %land.lhs.true78
  %108 = load i64, i64* %smin_ptr, align 8
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i32 0, i32 6
  store i64 %108, i64* %smin_value88, align 8
  %110 = load i64, i64* %smax_ptr, align 8
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 7
  store i64 %110, i64* %smax_value89, align 8
  %112 = load i64, i64* %umin_ptr, align 8
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i32 0, i32 8
  store i64 %112, i64* %umin_value90, align 8
  %114 = load i64, i64* %umax_ptr, align 8
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value91 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 9
  store i64 %114, i64* %umax_value91, align 8
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i32 0, i32 5
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i32 0, i32 5
  %118 = bitcast %struct.tnum* %var_off92 to i8*
  %119 = bitcast %struct.tnum* %var_off93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %118, i8* align 8 %119, i64 16, i1 false)
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %120, i32 0, i32 1
  %121 = load i32, i32* %off94, align 4
  %conv95 = sext i32 %121 to i64
  %122 = load i64, i64* %smin_val, align 8
  %add96 = add i64 %conv95, %122
  %conv97 = trunc i64 %add96 to i32
  %123 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %123, i32 0, i32 1
  store i32 %conv97, i32* %off98, align 4
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %125 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 2
  %raw = bitcast %union.anon.152* %125 to %struct.anon.155*
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 2
  %raw99 = bitcast %union.anon.152* %127 to %struct.anon.155*
  %128 = bitcast %struct.anon.155* %raw to i8*
  %129 = bitcast %struct.anon.155* %raw99 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %128, i8* align 8 %129, i64 16, i1 false)
  br label %sw.epilog236

if.end100:                                        ; preds = %land.lhs.true78, %sw.bb75
  %130 = load i64, i64* %smin_ptr, align 8
  %131 = load i64, i64* %smin_val, align 8
  %call101 = call zeroext i1 @signed_add_overflows(i64 noundef %130, i64 noundef %131) #14
  br i1 %call101, label %if.then106, label %lor.lhs.false103

lor.lhs.false103:                                 ; preds = %if.end100
  %132 = load i64, i64* %smax_ptr, align 8
  %133 = load i64, i64* %smax_val, align 8
  %call104 = call zeroext i1 @signed_add_overflows(i64 noundef %132, i64 noundef %133) #14
  br i1 %call104, label %if.then106, label %if.else

if.then106:                                       ; preds = %lor.lhs.false103, %if.end100
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %134, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value107, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %135, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value108, align 8
  br label %if.end113

if.else:                                          ; preds = %lor.lhs.false103
  %136 = load i64, i64* %smin_ptr, align 8
  %137 = load i64, i64* %smin_val, align 8
  %add109 = add i64 %136, %137
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 6
  store i64 %add109, i64* %smin_value110, align 8
  %139 = load i64, i64* %smax_ptr, align 8
  %140 = load i64, i64* %smax_val, align 8
  %add111 = add i64 %139, %140
  %141 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value112 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %141, i32 0, i32 7
  store i64 %add111, i64* %smax_value112, align 8
  br label %if.end113

if.end113:                                        ; preds = %if.else, %if.then106
  %142 = load i64, i64* %umin_ptr, align 8
  %143 = load i64, i64* %umin_val, align 8
  %add114 = add i64 %142, %143
  %144 = load i64, i64* %umin_ptr, align 8
  %cmp115 = icmp ult i64 %add114, %144
  br i1 %cmp115, label %if.then121, label %lor.lhs.false117

lor.lhs.false117:                                 ; preds = %if.end113
  %145 = load i64, i64* %umax_ptr, align 8
  %146 = load i64, i64* %umax_val, align 8
  %add118 = add i64 %145, %146
  %147 = load i64, i64* %umax_ptr, align 8
  %cmp119 = icmp ult i64 %add118, %147
  br i1 %cmp119, label %if.then121, label %if.else124

if.then121:                                       ; preds = %lor.lhs.false117, %if.end113
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value122 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 8
  store i64 0, i64* %umin_value122, align 8
  %149 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %149, i32 0, i32 9
  store i64 -1, i64* %umax_value123, align 8
  br label %if.end129

if.else124:                                       ; preds = %lor.lhs.false117
  %150 = load i64, i64* %umin_ptr, align 8
  %151 = load i64, i64* %umin_val, align 8
  %add125 = add i64 %150, %151
  %152 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %152, i32 0, i32 8
  store i64 %add125, i64* %umin_value126, align 8
  %153 = load i64, i64* %umax_ptr, align 8
  %154 = load i64, i64* %umax_val, align 8
  %add127 = add i64 %153, %154
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value128 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %155, i32 0, i32 9
  store i64 %add127, i64* %umax_value128, align 8
  br label %if.end129

if.end129:                                        ; preds = %if.else124, %if.then121
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off130 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 5
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off131 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %157, i32 0, i32 5
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 5
  %159 = bitcast %struct.tnum* %var_off131 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = load i64, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = load i64, i64* %162, align 8
  %164 = bitcast %struct.tnum* %var_off132 to { i64, i64 }*
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %164, i32 0, i32 0
  %166 = load i64, i64* %165, align 8
  %167 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %164, i32 0, i32 1
  %168 = load i64, i64* %167, align 8
  %call133 = call { i64, i64 } @tnum_add(i64 %161, i64 %163, i64 %166, i64 %168) #14
  %169 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %170 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %169, i32 0, i32 0
  %171 = extractvalue { i64, i64 } %call133, 0
  store i64 %171, i64* %170, align 8
  %172 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %169, i32 0, i32 1
  %173 = extractvalue { i64, i64 } %call133, 1
  store i64 %173, i64* %172, align 8
  %174 = bitcast %struct.tnum* %var_off130 to i8*
  %175 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %174, i8* align 8 %175, i64 16, i1 false)
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off134 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i32 0, i32 1
  %177 = load i32, i32* %off134, align 4
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 1
  store i32 %177, i32* %off135, align 4
  %179 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %180 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %179, i32 0, i32 2
  %raw136 = bitcast %union.anon.152* %180 to %struct.anon.155*
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %181, i32 0, i32 2
  %raw137 = bitcast %union.anon.152* %182 to %struct.anon.155*
  %183 = bitcast %struct.anon.155* %raw136 to i8*
  %184 = bitcast %struct.anon.155* %raw137 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %183, i8* align 8 %184, i64 16, i1 false)
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call138 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %185) #14
  br i1 %call138, label %if.then139, label %if.end142

if.then139:                                       ; preds = %if.end129
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %186, i32 0, i32 15
  %187 = load i32, i32* %id_gen, align 8
  %inc = add i32 %187, 1
  store i32 %inc, i32* %id_gen, align 8
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id140 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i32 0, i32 3
  store i32 %inc, i32* %id140, align 8
  %189 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %190 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %189, i32 0, i32 2
  %raw141 = bitcast %union.anon.152* %190 to %struct.anon.155*
  %191 = bitcast %struct.anon.155* %raw141 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %191, i8 0, i64 16, i1 false)
  br label %if.end142

if.end142:                                        ; preds = %if.then139, %if.end129
  br label %sw.epilog236

sw.bb143:                                         ; preds = %if.end73
  %192 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %cmp144 = icmp eq %struct.bpf_reg_state* %192, %193
  br i1 %cmp144, label %if.then146, label %if.end147

if.then146:                                       ; preds = %sw.bb143
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %195 = bitcast %struct.bpf_verifier_env* %194 to i8*
  %196 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %195, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.262, i64 0, i64 0), i32 noundef %196) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end147:                                        ; preds = %sw.bb143
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type148 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %197, i32 0, i32 0
  %198 = load i32, i32* %type148, align 8
  %cmp149 = icmp eq i32 %198, 6
  br i1 %cmp149, label %if.then151, label %if.end152

if.then151:                                       ; preds = %if.end147
  %199 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %200 = bitcast %struct.bpf_verifier_env* %199 to i8*
  %201 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %200, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.263, i64 0, i64 0), i32 noundef %201) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %if.end147
  %202 = load i8, i8* %known, align 1
  %tobool153 = trunc i8 %202 to i1
  br i1 %tobool153, label %land.lhs.true155, label %if.end181

land.lhs.true155:                                 ; preds = %if.end152
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i32 0, i32 1
  %204 = load i32, i32* %off156, align 4
  %conv157 = sext i32 %204 to i64
  %205 = load i64, i64* %smin_val, align 8
  %sub = sub i64 %conv157, %205
  %206 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %206, i32 0, i32 1
  %207 = load i32, i32* %off158, align 4
  %conv159 = sext i32 %207 to i64
  %208 = load i64, i64* %smin_val, align 8
  %sub160 = sub i64 %conv159, %208
  %conv161 = trunc i64 %sub160 to i32
  %conv162 = sext i32 %conv161 to i64
  %cmp163 = icmp eq i64 %sub, %conv162
  br i1 %cmp163, label %if.then165, label %if.end181

if.then165:                                       ; preds = %land.lhs.true155
  %209 = load i64, i64* %smin_ptr, align 8
  %210 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value166 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %210, i32 0, i32 6
  store i64 %209, i64* %smin_value166, align 8
  %211 = load i64, i64* %smax_ptr, align 8
  %212 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value167 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %212, i32 0, i32 7
  store i64 %211, i64* %smax_value167, align 8
  %213 = load i64, i64* %umin_ptr, align 8
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value168 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %214, i32 0, i32 8
  store i64 %213, i64* %umin_value168, align 8
  %215 = load i64, i64* %umax_ptr, align 8
  %216 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value169 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %216, i32 0, i32 9
  store i64 %215, i64* %umax_value169, align 8
  %217 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %217, i32 0, i32 5
  %218 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off171 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %218, i32 0, i32 5
  %219 = bitcast %struct.tnum* %var_off170 to i8*
  %220 = bitcast %struct.tnum* %var_off171 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %219, i8* align 8 %220, i64 16, i1 false)
  %221 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id172 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %221, i32 0, i32 3
  %222 = load i32, i32* %id172, align 8
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id173 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i32 0, i32 3
  store i32 %222, i32* %id173, align 8
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %224, i32 0, i32 1
  %225 = load i32, i32* %off174, align 4
  %conv175 = sext i32 %225 to i64
  %226 = load i64, i64* %smin_val, align 8
  %sub176 = sub i64 %conv175, %226
  %conv177 = trunc i64 %sub176 to i32
  %227 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %227, i32 0, i32 1
  store i32 %conv177, i32* %off178, align 4
  %228 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %229 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %228, i32 0, i32 2
  %raw179 = bitcast %union.anon.152* %229 to %struct.anon.155*
  %230 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %231 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %230, i32 0, i32 2
  %raw180 = bitcast %union.anon.152* %231 to %struct.anon.155*
  %232 = bitcast %struct.anon.155* %raw179 to i8*
  %233 = bitcast %struct.anon.155* %raw180 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %232, i8* align 8 %233, i64 16, i1 false)
  br label %sw.epilog236

if.end181:                                        ; preds = %land.lhs.true155, %if.end152
  %234 = load i64, i64* %smin_ptr, align 8
  %235 = load i64, i64* %smax_val, align 8
  %call182 = call zeroext i1 @signed_sub_overflows(i64 noundef %234, i64 noundef %235) #14
  br i1 %call182, label %if.then187, label %lor.lhs.false184

lor.lhs.false184:                                 ; preds = %if.end181
  %236 = load i64, i64* %smax_ptr, align 8
  %237 = load i64, i64* %smin_val, align 8
  %call185 = call zeroext i1 @signed_sub_overflows(i64 noundef %236, i64 noundef %237) #14
  br i1 %call185, label %if.then187, label %if.else190

if.then187:                                       ; preds = %lor.lhs.false184, %if.end181
  %238 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value188 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %238, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value188, align 8
  %239 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value189 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %239, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value189, align 8
  br label %if.end195

if.else190:                                       ; preds = %lor.lhs.false184
  %240 = load i64, i64* %smin_ptr, align 8
  %241 = load i64, i64* %smax_val, align 8
  %sub191 = sub i64 %240, %241
  %242 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %242, i32 0, i32 6
  store i64 %sub191, i64* %smin_value192, align 8
  %243 = load i64, i64* %smax_ptr, align 8
  %244 = load i64, i64* %smin_val, align 8
  %sub193 = sub i64 %243, %244
  %245 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value194 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %245, i32 0, i32 7
  store i64 %sub193, i64* %smax_value194, align 8
  br label %if.end195

if.end195:                                        ; preds = %if.else190, %if.then187
  %246 = load i64, i64* %umin_ptr, align 8
  %247 = load i64, i64* %umax_val, align 8
  %cmp196 = icmp ult i64 %246, %247
  br i1 %cmp196, label %if.then198, label %if.else201

if.then198:                                       ; preds = %if.end195
  %248 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %248, i32 0, i32 8
  store i64 0, i64* %umin_value199, align 8
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %249, i32 0, i32 9
  store i64 -1, i64* %umax_value200, align 8
  br label %if.end206

if.else201:                                       ; preds = %if.end195
  %250 = load i64, i64* %umin_ptr, align 8
  %251 = load i64, i64* %umax_val, align 8
  %sub202 = sub i64 %250, %251
  %252 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value203 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %252, i32 0, i32 8
  store i64 %sub202, i64* %umin_value203, align 8
  %253 = load i64, i64* %umax_ptr, align 8
  %254 = load i64, i64* %umin_val, align 8
  %sub204 = sub i64 %253, %254
  %255 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value205 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %255, i32 0, i32 9
  store i64 %sub204, i64* %umax_value205, align 8
  br label %if.end206

if.end206:                                        ; preds = %if.else201, %if.then198
  %256 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %256, i32 0, i32 5
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off209 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 5
  %258 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off210 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %258, i32 0, i32 5
  %259 = bitcast %struct.tnum* %var_off209 to { i64, i64 }*
  %260 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %259, i32 0, i32 0
  %261 = load i64, i64* %260, align 8
  %262 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %259, i32 0, i32 1
  %263 = load i64, i64* %262, align 8
  %264 = bitcast %struct.tnum* %var_off210 to { i64, i64 }*
  %265 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %264, i32 0, i32 0
  %266 = load i64, i64* %265, align 8
  %267 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %264, i32 0, i32 1
  %268 = load i64, i64* %267, align 8
  %call211 = call { i64, i64 } @tnum_sub(i64 %261, i64 %263, i64 %266, i64 %268) #14
  %269 = bitcast %struct.tnum* %tmp208 to { i64, i64 }*
  %270 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %269, i32 0, i32 0
  %271 = extractvalue { i64, i64 } %call211, 0
  store i64 %271, i64* %270, align 8
  %272 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %269, i32 0, i32 1
  %273 = extractvalue { i64, i64 } %call211, 1
  store i64 %273, i64* %272, align 8
  %274 = bitcast %struct.tnum* %var_off207 to i8*
  %275 = bitcast %struct.tnum* %tmp208 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %274, i8* align 8 %275, i64 16, i1 false)
  %276 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off212 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %276, i32 0, i32 1
  %277 = load i32, i32* %off212, align 4
  %278 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off213 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %278, i32 0, i32 1
  store i32 %277, i32* %off213, align 4
  %279 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %280 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %279, i32 0, i32 2
  %raw214 = bitcast %union.anon.152* %280 to %struct.anon.155*
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %282 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i32 0, i32 2
  %raw215 = bitcast %union.anon.152* %282 to %struct.anon.155*
  %283 = bitcast %struct.anon.155* %raw214 to i8*
  %284 = bitcast %struct.anon.155* %raw215 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %283, i8* align 8 %284, i64 16, i1 false)
  %285 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call216 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %285) #14
  br i1 %call216, label %if.then217, label %if.end226

if.then217:                                       ; preds = %if.end206
  %286 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen218 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %286, i32 0, i32 15
  %287 = load i32, i32* %id_gen218, align 8
  %inc219 = add i32 %287, 1
  store i32 %inc219, i32* %id_gen218, align 8
  %288 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id220 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %288, i32 0, i32 3
  store i32 %inc219, i32* %id220, align 8
  %289 = load i64, i64* %smin_val, align 8
  %cmp221 = icmp slt i64 %289, 0
  br i1 %cmp221, label %if.then223, label %if.end225

if.then223:                                       ; preds = %if.then217
  %290 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %291 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %290, i32 0, i32 2
  %raw224 = bitcast %union.anon.152* %291 to %struct.anon.155*
  %292 = bitcast %struct.anon.155* %raw224 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %292, i8 0, i64 16, i1 false)
  br label %if.end225

if.end225:                                        ; preds = %if.then223, %if.then217
  br label %if.end226

if.end226:                                        ; preds = %if.end225, %if.end206
  br label %sw.epilog236

sw.bb227:                                         ; preds = %if.end73, %if.end73, %if.end73
  %293 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %294 = bitcast %struct.bpf_verifier_env* %293 to i8*
  %295 = load i32, i32* %dst, align 4
  %296 = load i8, i8* %opcode, align 1
  %conv228 = zext i8 %296 to i32
  %shr = ashr i32 %conv228, 4
  %idxprom229 = sext i32 %shr to i64
  %arrayidx230 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom229
  %297 = load i8*, i8** %arrayidx230, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %294, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.264, i64 0, i64 0), i32 noundef %295, i8* noundef %297) #14
  store i32 -13, i32* %retval, align 4
  br label %return

sw.default231:                                    ; preds = %if.end73
  %298 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %299 = bitcast %struct.bpf_verifier_env* %298 to i8*
  %300 = load i32, i32* %dst, align 4
  %301 = load i8, i8* %opcode, align 1
  %conv232 = zext i8 %301 to i32
  %shr233 = ashr i32 %conv232, 4
  %idxprom234 = sext i32 %shr233 to i64
  %arrayidx235 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom234
  %302 = load i8*, i8** %arrayidx235, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %299, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.265, i64 0, i64 0), i32 noundef %300, i8* noundef %302) #14
  store i32 -13, i32* %retval, align 4
  br label %return

sw.epilog236:                                     ; preds = %if.end226, %if.then165, %if.end142, %if.then87
  %303 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %304 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %305 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type237 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %305, i32 0, i32 0
  %306 = load i32, i32* %type237, align 8
  %call238 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %303, %struct.bpf_reg_state* noundef %304, i32 noundef %306) #14
  br i1 %call238, label %if.end240, label %if.then239

if.then239:                                       ; preds = %sw.epilog236
  store i32 -22, i32* %retval, align 4
  br label %return

if.end240:                                        ; preds = %sw.epilog236
  %307 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %307) #14
  %308 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %308) #14
  %309 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %309) #14
  %310 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %311 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %312 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call241 = call i32 @sanitize_check_bounds(%struct.bpf_verifier_env* noundef %310, %struct.bpf_insn* noundef %311, %struct.bpf_reg_state* noundef %312) #14
  %cmp242 = icmp slt i32 %call241, 0
  br i1 %cmp242, label %if.then244, label %if.end245

if.then244:                                       ; preds = %if.end240
  store i32 -13, i32* %retval, align 4
  br label %return

if.end245:                                        ; preds = %if.end240
  %313 = load i8, i8* %opcode, align 1
  %call246 = call zeroext i1 @sanitize_needed(i8 noundef zeroext %313) #14
  br i1 %call246, label %if.then247, label %if.end254

if.then247:                                       ; preds = %if.end245
  %314 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %316 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %317 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %318 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call248 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %314, %struct.bpf_insn* noundef %315, %struct.bpf_reg_state* noundef %316, %struct.bpf_reg_state* noundef %317, %struct.bpf_reg_state* noundef %318, %struct.bpf_sanitize_info* noundef %info, i1 noundef zeroext true) #14
  store i32 %call248, i32* %ret, align 4
  %319 = load i32, i32* %ret, align 4
  %cmp249 = icmp slt i32 %319, 0
  br i1 %cmp249, label %if.then251, label %if.end253

if.then251:                                       ; preds = %if.then247
  %320 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %321 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %322 = load i32, i32* %ret, align 4
  %323 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %324 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call252 = call i32 @sanitize_err(%struct.bpf_verifier_env* noundef %320, %struct.bpf_insn* noundef %321, i32 noundef %322, %struct.bpf_reg_state* noundef %323, %struct.bpf_reg_state* noundef %324) #14
  store i32 %call252, i32* %retval, align 4
  br label %return

if.end253:                                        ; preds = %if.then247
  br label %if.end254

if.end254:                                        ; preds = %if.end253, %if.end245
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end254, %if.then251, %if.then244, %if.then239, %sw.default231, %sw.bb227, %if.then151, %if.then146, %if.then70, %if.then63, %sw.bb51, %sw.bb, %if.end34, %if.then33, %if.then
  %325 = load i32, i32* %retval, align 4
  ret i32 %325
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %known = alloca i8, align 1
  %val = alloca i64, align 8
  %smin = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  store i64 %9, i64* %smin, align 8
  %10 = load i8, i8* %known, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load i64, i64* %val, align 8
  %cmp = icmp sge i64 %11, 536870912
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load i64, i64* %val, align 8
  %cmp2 = icmp sle i64 %12, -536870912
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load i32, i32* %type.addr, align 4
  %idxprom = zext i32 %15 to i64
  %arrayidx = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %16 = load i8*, i8** %arrayidx, align 8
  %17 = load i64, i64* %val, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.266, i64 0, i64 0), i8* noundef %16, i64 noundef %17) #14
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 1
  %19 = load i32, i32* %off, align 4
  %cmp3 = icmp sge i32 %19, 536870912
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 1
  %21 = load i32, i32* %off5, align 4
  %cmp6 = icmp sle i32 %21, -536870912
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %type.addr, align 4
  %idxprom8 = zext i32 %24 to i64
  %arrayidx9 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom8
  %25 = load i8*, i8** %arrayidx9, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 1
  %27 = load i32, i32* %off10, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.267, i64 0, i64 0), i8* noundef %25, i32 noundef %27) #14
  store i1 false, i1* %retval, align 1
  br label %return

if.end11:                                         ; preds = %lor.lhs.false4
  %28 = load i64, i64* %smin, align 8
  %cmp12 = icmp eq i64 %28, -9223372036854775808
  br i1 %cmp12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %type.addr, align 4
  %idxprom14 = zext i32 %31 to i64
  %arrayidx15 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom14
  %32 = load i8*, i8** %arrayidx15, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.268, i64 0, i64 0), i8* noundef %32) #14
  store i1 false, i1* %retval, align 1
  br label %return

if.end16:                                         ; preds = %if.end11
  %33 = load i64, i64* %smin, align 8
  %cmp17 = icmp sge i64 %33, 536870912
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end16
  %34 = load i64, i64* %smin, align 8
  %cmp19 = icmp sle i64 %34, -536870912
  br i1 %cmp19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %lor.lhs.false18, %if.end16
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load i64, i64* %smin, align 8
  %38 = load i32, i32* %type.addr, align 4
  %idxprom21 = zext i32 %38 to i64
  %arrayidx22 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom21
  %39 = load i8*, i8** %arrayidx22, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.269, i64 0, i64 0), i64 noundef %37, i8* noundef %39) #14
  store i1 false, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %lor.lhs.false18
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end23, %if.then20, %if.then13, %if.then7, %if.then
  %40 = load i1, i1* %retval, align 1
  ret i1 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %off_reg, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_sanitize_info* noundef %info, i1 noundef zeroext %commit_window) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %info.addr = alloca %struct.bpf_sanitize_info*, align 8
  %commit_window.addr = alloca i8, align 1
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %off_is_imm = alloca i8, align 1
  %off_is_neg = alloca i8, align 1
  %ptr_is_dst_reg = alloca i8, align 1
  %opcode = alloca i8, align 1
  %alu_state = alloca i32, align 4
  %alu_limit = alloca i32, align 4
  %tmp = alloca %struct.bpf_reg_state, align 8
  %ret = alloca i8, align 1
  %err = alloca i32, align 4
  %__x = alloca i32, align 4
  %tmp51 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_sanitize_info* %info, %struct.bpf_sanitize_info** %info.addr, align 8
  %frombool = zext i1 %commit_window to i8
  store i8 %frombool, i8* %commit_window.addr, align 1
  %0 = load i8, i8* %commit_window.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %1) #14
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %2, i32 0, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_insn_aux_data* [ %call, %cond.true ], [ %aux1, %cond.false ]
  store %struct.bpf_insn_aux_data* %cond, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %4, %struct.bpf_verifier_state** %vstate, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %6 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %8, i64 %10) #14
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %off_is_imm, align 1
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  %12 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %12, 0
  %frombool4 = zext i1 %cmp to i8
  store i8 %frombool4, i8* %off_is_neg, align 1
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp5 = icmp eq %struct.bpf_reg_state* %13, %14
  %frombool6 = zext i1 %cmp5 to i8
  store i8 %frombool6, i8* %ptr_is_dst_reg, align 1
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code, align 4
  %conv = zext i8 %16 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call8 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %17, %struct.bpf_insn* noundef %18) #14
  br i1 %call8, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 6
  %20 = load i8, i8* %speculative, align 8
  %tobool9 = trunc i8 %20 to i1
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  br label %do_sim

if.end11:                                         ; preds = %if.end
  %21 = load i8, i8* %commit_window.addr, align 1
  %tobool12 = trunc i8 %21 to i1
  br i1 %tobool12, label %if.end36, label %if.then13

if.then13:                                        ; preds = %if.end11
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %23 = bitcast %struct.tnum* %var_off14 to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call15 = call zeroext i1 @tnum_is_const(i64 %25, i64 %27) #14
  br i1 %call15, label %if.end24, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then13
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 6
  %29 = load i64, i64* %smin_value16, align 8
  %cmp17 = icmp slt i64 %29, 0
  %conv18 = zext i1 %cmp17 to i32
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 7
  %31 = load i64, i64* %smax_value, align 8
  %cmp19 = icmp slt i64 %31, 0
  %conv20 = zext i1 %cmp19 to i32
  %cmp21 = icmp ne i32 %conv18, %conv20
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %land.lhs.true
  store i32 -1, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true, %if.then13
  %32 = load i8, i8* %opcode, align 1
  %conv25 = zext i8 %32 to i32
  %cmp26 = icmp eq i32 %conv25, 0
  br i1 %cmp26, label %land.lhs.true28, label %lor.rhs

land.lhs.true28:                                  ; preds = %if.end24
  %33 = load i8, i8* %off_is_neg, align 1
  %tobool29 = trunc i8 %33 to i1
  br i1 %tobool29, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true28, %if.end24
  %34 = load i8, i8* %opcode, align 1
  %conv31 = zext i8 %34 to i32
  %cmp32 = icmp eq i32 %conv31, 16
  br i1 %cmp32, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %35 = load i8, i8* %off_is_neg, align 1
  %tobool34 = trunc i8 %35 to i1
  %lnot = xor i1 %tobool34, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %36 = phi i1 [ false, %lor.rhs ], [ %lnot, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true28
  %37 = phi i1 [ true, %land.lhs.true28 ], [ %36, %land.end ]
  %38 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %mask_to_left = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %38, i32 0, i32 1
  %frombool35 = zext i1 %37 to i8
  store i8 %frombool35, i8* %mask_to_left, align 8
  br label %if.end36

if.end36:                                         ; preds = %lor.end, %if.end11
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %40 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %mask_to_left37 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %40, i32 0, i32 1
  %41 = load i8, i8* %mask_to_left37, align 8
  %tobool38 = trunc i8 %41 to i1
  %call39 = call i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %39, i32* noundef %alu_limit, i1 noundef zeroext %tobool38) #14
  store i32 %call39, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %cmp40 = icmp slt i32 %42, 0
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end36
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end36
  %44 = load i8, i8* %commit_window.addr, align 1
  %tobool44 = trunc i8 %44 to i1
  br i1 %tobool44, label %if.then45, label %if.else

if.then45:                                        ; preds = %if.end43
  %45 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %aux46 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %45, i32 0, i32 0
  %alu_state47 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %aux46, i32 0, i32 6
  %46 = load i8, i8* %alu_state47, align 2
  %conv48 = zext i8 %46 to i32
  store i32 %conv48, i32* %alu_state, align 4
  %47 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %aux49 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %47, i32 0, i32 0
  %48 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %aux49, i32 0, i32 0
  %alu_limit50 = bitcast %union.anon.163* %48 to i32*
  %49 = load i32, i32* %alu_limit50, align 8
  %50 = load i32, i32* %alu_limit, align 4
  %sub = sub i32 %49, %50
  store i32 %sub, i32* %__x, align 4
  %51 = load i32, i32* %__x, align 4
  %cmp52 = icmp slt i32 %51, 0
  br i1 %cmp52, label %cond.true54, label %cond.false56

cond.true54:                                      ; preds = %if.then45
  %52 = load i32, i32* %__x, align 4
  %sub55 = sub i32 0, %52
  br label %cond.end57

cond.false56:                                     ; preds = %if.then45
  %53 = load i32, i32* %__x, align 4
  br label %cond.end57

cond.end57:                                       ; preds = %cond.false56, %cond.true54
  %cond58 = phi i32 [ %sub55, %cond.true54 ], [ %53, %cond.false56 ]
  store i32 %cond58, i32* %tmp51, align 4
  %54 = load i32, i32* %tmp51, align 4
  store i32 %54, i32* %alu_limit, align 4
  br label %if.end72

if.else:                                          ; preds = %if.end43
  %55 = load i8, i8* %off_is_neg, align 1
  %tobool59 = trunc i8 %55 to i1
  %56 = zext i1 %tobool59 to i64
  %cond61 = select i1 %tobool59, i32 4, i32 0
  store i32 %cond61, i32* %alu_state, align 4
  %57 = load i8, i8* %off_is_imm, align 1
  %tobool62 = trunc i8 %57 to i1
  %58 = zext i1 %tobool62 to i64
  %cond64 = select i1 %tobool62, i32 16, i32 0
  %59 = load i32, i32* %alu_state, align 4
  %or = or i32 %59, %cond64
  store i32 %or, i32* %alu_state, align 4
  %60 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool65 = trunc i8 %60 to i1
  %61 = zext i1 %tobool65 to i64
  %cond67 = select i1 %tobool65, i32 1, i32 2
  %62 = load i32, i32* %alu_state, align 4
  %or68 = or i32 %62, %cond67
  store i32 %or68, i32* %alu_state, align 4
  %63 = load i8, i8* %off_is_imm, align 1
  %tobool69 = trunc i8 %63 to i1
  br i1 %tobool69, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.else
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explore_alu_limits = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 16
  store i8 1, i8* %explore_alu_limits, align 4
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.else
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %cond.end57
  %65 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %66 = load i32, i32* %alu_state, align 4
  %67 = load i32, i32* %alu_limit, align 4
  %call73 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %65, i32 noundef %66, i32 noundef %67) #14
  store i32 %call73, i32* %err, align 4
  %68 = load i32, i32* %err, align 4
  %cmp74 = icmp slt i32 %68, 0
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.end72
  %69 = load i32, i32* %err, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.end72
  br label %do_sim

do_sim:                                           ; preds = %if.end77, %if.then10
  %70 = load i8, i8* %commit_window.addr, align 1
  %tobool78 = trunc i8 %70 to i1
  br i1 %tobool78, label %if.then82, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do_sim
  %71 = load i8, i8* %off_is_imm, align 1
  %tobool80 = trunc i8 %71 to i1
  br i1 %tobool80, label %if.then82, label %if.end83

if.then82:                                        ; preds = %lor.lhs.false, %do_sim
  store i32 0, i32* %retval, align 4
  br label %return

if.end83:                                         ; preds = %lor.lhs.false
  %72 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool84 = trunc i8 %72 to i1
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %if.end83
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %74 = bitcast %struct.bpf_reg_state* %tmp to i8*
  %75 = bitcast %struct.bpf_reg_state* %73 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %74, i8* align 8 %75, i64 120, i1 false)
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %78 = bitcast %struct.bpf_reg_state* %76 to i8*
  %79 = bitcast %struct.bpf_reg_state* %77 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %78, i8* align 8 %79, i64 120, i1 false)
  br label %if.end86

if.end86:                                         ; preds = %if.then85, %if.end83
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 0
  %82 = load i32, i32* %insn_idx, align 8
  %add = add i32 %82, 1
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 0
  %84 = load i32, i32* %insn_idx87, align 8
  %call88 = call %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %80, %struct.bpf_insn* noundef null, i32 noundef %add, i32 noundef %84) #14
  %tobool89 = icmp ne %struct.bpf_verifier_state* %call88, null
  %frombool90 = zext i1 %tobool89 to i8
  store i8 %frombool90, i8* %ret, align 1
  %85 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool91 = trunc i8 %85 to i1
  br i1 %tobool91, label %if.end96, label %land.lhs.true92

land.lhs.true92:                                  ; preds = %if.end86
  %86 = load i8, i8* %ret, align 1
  %tobool93 = trunc i8 %86 to i1
  br i1 %tobool93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %land.lhs.true92
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %88 = bitcast %struct.bpf_reg_state* %87 to i8*
  %89 = bitcast %struct.bpf_reg_state* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %88, i8* align 8 %89, i64 120, i1 false)
  br label %if.end96

if.end96:                                         ; preds = %if.then95, %land.lhs.true92, %if.end86
  %90 = load i8, i8* %ret, align 1
  %tobool97 = trunc i8 %90 to i1
  %lnot98 = xor i1 %tobool97, true
  %91 = zext i1 %lnot98 to i64
  %cond99 = select i1 %lnot98, i32 -5, i32 0
  store i32 %cond99, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end96, %if.then82, %if.then76, %if.then42, %if.then23, %if.then
  %92 = load i32, i32* %retval, align 4
  ret i32 %92
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_is_pkt_pointer(i32 noundef %1) #14
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_check_bounds(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 21
  %2 = load i8, i8* %bypass_spec_v1, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 8
  switch i32 %4, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb7
  ]

sw.bb:                                            ; preds = %if.end
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %dst, align 4
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 1
  %9 = load i32, i32* %off, align 4
  %conv2 = sext i32 %9 to i64
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %add = add i64 %conv2, %11
  %conv3 = trunc i64 %add to i32
  %call = call i32 @check_stack_access_for_ptr_arithmetic(%struct.bpf_verifier_env* noundef %5, i32 noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %conv3) #14
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %sw.bb
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb7:                                           ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %dst, align 4
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 1
  %15 = load i32, i32* %off8, align 4
  %call9 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %12, i32 noundef %13, i32 noundef %15, i32 noundef 1, i1 noundef zeroext false) #14
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %sw.bb7
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([77 x i8], [77 x i8]* @.str.271, i64 0, i64 0), i32 noundef %18) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb7
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end12, %if.end6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then11, %if.then5, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %ptr_reg, i32* noundef %alu_limit, i1 noundef zeroext %mask_to_left) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %alu_limit.addr = alloca i32*, align 8
  %mask_to_left.addr = alloca i8, align 1
  %max = alloca i32, align 4
  %ptr_limit = alloca i32, align 4
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store i32* %alu_limit, i32** %alu_limit.addr, align 8
  %frombool = zext i1 %mask_to_left to i8
  store i8 %frombool, i8* %mask_to_left.addr, align 1
  store i32 0, i32* %max, align 4
  store i32 0, i32* %ptr_limit, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  switch i32 %1, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry
  %2 = load i8, i8* %mask_to_left.addr, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %add = add i32 512, %conv
  store i32 %add, i32* %max, align 4
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 1
  %6 = load i32, i32* %off, align 4
  %conv1 = sext i32 %6 to i64
  %add2 = add i64 %4, %conv1
  %sub = sub i64 0, %add2
  %conv3 = trunc i64 %sub to i32
  store i32 %conv3, i32* %ptr_limit, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 2
  %9 = bitcast %union.anon.152* %8 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %9, i32 0, i32 0
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %10, i32 0, i32 5
  %11 = load i32, i32* %value_size, align 32
  store i32 %11, i32* %max, align 4
  %12 = load i8, i8* %mask_to_left.addr, align 1
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 9
  %16 = load i64, i64* %umax_value, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %16, %cond.false ]
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 1
  %18 = load i32, i32* %off7, align 4
  %conv8 = sext i32 %18 to i64
  %add9 = add i64 %cond, %conv8
  %conv10 = trunc i64 %add9 to i32
  store i32 %conv10, i32* %ptr_limit, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %cond.end, %sw.bb
  %19 = load i32, i32* %ptr_limit, align 4
  %20 = load i32, i32* %max, align 4
  %cmp = icmp uge i32 %19, %20
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  store i32 -4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.epilog
  %21 = load i32, i32* %ptr_limit, align 4
  %22 = load i32*, i32** %alu_limit.addr, align 8
  store i32 %21, i32* %22, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then, %sw.default
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %next_idx, i32 noundef %curr_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %next_idx.addr = alloca i32, align 4
  %curr_idx.addr = alloca i32, align 4
  %branch = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %next_idx, i32* %next_idx.addr, align 4
  store i32 %curr_idx, i32* %curr_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %next_idx.addr, align 4
  %2 = load i32, i32* %curr_idx.addr, align 4
  %call = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %0, i32 noundef %1, i32 noundef %2, i1 noundef zeroext true) #14
  store %struct.bpf_verifier_state* %call, %struct.bpf_verifier_state** %branch, align 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %3, null
  br i1 %tobool, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %tobool1 = icmp ne %struct.bpf_insn* %4, null
  br i1 %tobool1, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 4
  %7 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code, align 4
  %conv = zext i8 %10 to i32
  %and = and i32 %conv, 8
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv5 = zext i8 %bf.clear to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i32 noundef %conv5) #14
  br label %if.end18

if.else:                                          ; preds = %if.then
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code6, align 4
  %conv7 = zext i8 %15 to i32
  %and8 = and i32 %conv7, 8
  %cmp9 = icmp eq i32 %and8, 8
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load13 = load i8, i8* %dst_reg12, align 1
  %bf.clear14 = and i8 %bf.load13, 15
  %conv15 = zext i8 %bf.clear14 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %16, %struct.bpf_reg_state* noundef %17, i32 noundef %conv15) #14
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 1
  %bf.load16 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load16, 4
  %conv17 = zext i8 %bf.lshr to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %19, %struct.bpf_reg_state* noundef %20, i32 noundef %conv17) #14
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.else
  br label %if.end18

if.end18:                                         ; preds = %if.end, %if.then4
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %land.lhs.true, %entry
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  ret %struct.bpf_verifier_state* %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %prev_insn_idx, i1 noundef zeroext %speculative) #0 {
entry:
  %retval = alloca %struct.bpf_verifier_state*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %prev_insn_idx.addr = alloca i32, align 4
  %speculative.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %prev_insn_idx, i32* %prev_insn_idx.addr, align 4
  %frombool = zext i1 %speculative to i8
  store i8 %frombool, i8* %speculative.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %call = call i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #14
  %2 = bitcast i8* %call to %struct.bpf_verifier_stack_elem*
  store %struct.bpf_verifier_stack_elem* %2, %struct.bpf_verifier_stack_elem** %elem, align 8
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %tobool = icmp ne %struct.bpf_verifier_stack_elem* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err28

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %insn_idx.addr, align 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %insn_idx1 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %5, i32 0, i32 1
  store i32 %4, i32* %insn_idx1, align 8
  %6 = load i32, i32* %prev_insn_idx.addr, align 4
  %7 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %7, i32 0, i32 2
  store i32 %6, i32* %prev_insn_idx2, align 4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 4
  %9 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %10 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %10, i32 0, i32 3
  store %struct.bpf_verifier_stack_elem* %9, %struct.bpf_verifier_stack_elem** %next, align 8
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 26
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 3
  %12 = load i32, i32* %len_used, align 8
  %13 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %13, i32 0, i32 4
  store i32 %12, i32* %log_pos, align 8
  %14 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %14, %struct.bpf_verifier_stack_elem** %head3, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 5
  %17 = load i32, i32* %stack_size, align 8
  %inc = add i32 %17, 1
  store i32 %inc, i32* %stack_size, align 8
  %18 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %18, i32 0, i32 0
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call4 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %st, %struct.bpf_verifier_state* noundef %19) #14
  store i32 %call4, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool5 = icmp ne i32 %20, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %err28

if.end7:                                          ; preds = %if.end
  %21 = load i8, i8* %speculative.addr, align 1
  %tobool8 = trunc i8 %21 to i1
  %conv = zext i1 %tobool8 to i32
  %22 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st9 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %22, i32 0, i32 0
  %speculative10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st9, i32 0, i32 6
  %23 = load i8, i8* %speculative10, align 8
  %tobool11 = trunc i8 %23 to i1
  %conv12 = zext i1 %tobool11 to i32
  %or = or i32 %conv12, %conv
  %tobool13 = icmp ne i32 %or, 0
  %frombool14 = zext i1 %tobool13 to i8
  store i8 %frombool14, i8* %speculative10, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 5
  %25 = load i32, i32* %stack_size15, align 8
  %cmp = icmp sgt i32 %25, 8192
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end7
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 5
  %29 = load i32, i32* %stack_size18, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.270, i64 0, i64 0), i32 noundef %29) #14
  br label %err28

if.end19:                                         ; preds = %if.end7
  %30 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st20 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %30, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st20, i32 0, i32 1
  %31 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %tobool21 = icmp ne %struct.bpf_verifier_state* %31, null
  br i1 %tobool21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end19
  %32 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st23 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %32, i32 0, i32 0
  %parent24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st23, i32 0, i32 1
  %33 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent24, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %33, i32 0, i32 2
  %34 = load i32, i32* %branches, align 8
  %inc25 = add i32 %34, 1
  store i32 %inc25, i32* %branches, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end19
  %35 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st27 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %35, i32 0, i32 0
  store %struct.bpf_verifier_state* %st27, %struct.bpf_verifier_state** %retval, align 8
  br label %return

err28:                                            ; preds = %if.then17, %if.then6, %if.then
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 8
  %37 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %37, i1 noundef zeroext true) #14
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state30, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err28
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %39, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #14
  %tobool32 = icmp ne i32 %call31, 0
  %lnot = xor i1 %tobool32, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end26
  %40 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %retval, align 8
  ret %struct.bpf_verifier_state* %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_access_for_ptr_arithmetic(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, %struct.bpf_reg_state* noundef %reg, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #14
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %9, i64 %11) #14
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %regno.addr, align 4
  %arraydecay3 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.272, i64 0, i64 0), i32 noundef %14, i8* noundef %arraydecay3, i32 noundef %15) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load i32, i32* %off.addr, align 4
  %cmp = icmp sge i32 %16, 0
  br i1 %cmp, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %cmp4 = icmp slt i32 %17, -512
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno.addr, align 4
  %21 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.273, i64 0, i64 0), i32 noundef %20, i32 noundef %21) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %regno, %struct.bpf_reg_state* noundef %reg, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regno.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %t.addr = alloca i32, align 4
  %code = alloca i8, align 1
  %class = alloca i8, align 1
  %op = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code1, align 4
  store i8 %1, i8* %code, align 1
  %2 = load i8, i8* %code, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %class, align 1
  %3 = load i8, i8* %code, align 1
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %op, align 1
  %4 = load i8, i8* %class, align 1
  %conv6 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv6, 5
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  %5 = load i8, i8* %op, align 1
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 144
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load i8, i8* %op, align 1
  %conv12 = zext i8 %6 to i32
  %cmp13 = icmp eq i32 %conv12, 128
  br i1 %cmp13, label %if.then15, label %if.end25

if.then15:                                        ; preds = %if.end
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv16 = zext i8 %bf.lshr to i32
  %cmp17 = icmp eq i32 %conv16, 1
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then15
  store i1 false, i1* %retval, align 1
  br label %return

if.end20:                                         ; preds = %if.then15
  %8 = load i32, i32* %t.addr, align 4
  %cmp21 = icmp eq i32 %8, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store i1 true, i1* %retval, align 1
  br label %return

if.end24:                                         ; preds = %if.end20
  store i1 false, i1* %retval, align 1
  br label %return

if.end25:                                         ; preds = %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %9 = load i8, i8* %class, align 1
  %conv27 = zext i8 %9 to i32
  %cmp28 = icmp eq i32 %conv27, 7
  br i1 %cmp28, label %if.then43, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end26
  %10 = load i8, i8* %class, align 1
  %conv30 = zext i8 %10 to i32
  %cmp31 = icmp eq i32 %conv30, 5
  br i1 %cmp31, label %if.then43, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %11 = load i8, i8* %class, align 1
  %conv34 = zext i8 %11 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  br i1 %cmp35, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %lor.lhs.false33
  %12 = load i8, i8* %op, align 1
  %conv37 = zext i8 %12 to i32
  %cmp38 = icmp eq i32 %conv37, 208
  br i1 %cmp38, label %land.lhs.true40, label %if.end44

land.lhs.true40:                                  ; preds = %land.lhs.true
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm, align 4
  %cmp41 = icmp eq i32 %14, 64
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true40, %lor.lhs.false, %if.end26
  store i1 true, i1* %retval, align 1
  br label %return

if.end44:                                         ; preds = %land.lhs.true40, %land.lhs.true, %lor.lhs.false33
  %15 = load i8, i8* %class, align 1
  %conv45 = zext i8 %15 to i32
  %cmp46 = icmp eq i32 %conv45, 4
  br i1 %cmp46, label %if.then52, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.end44
  %16 = load i8, i8* %class, align 1
  %conv49 = zext i8 %16 to i32
  %cmp50 = icmp eq i32 %conv49, 6
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %lor.lhs.false48, %if.end44
  store i1 false, i1* %retval, align 1
  br label %return

if.end53:                                         ; preds = %lor.lhs.false48
  %17 = load i8, i8* %class, align 1
  %conv54 = zext i8 %17 to i32
  %cmp55 = icmp eq i32 %conv54, 1
  br i1 %cmp55, label %if.then57, label %if.end66

if.then57:                                        ; preds = %if.end53
  %18 = load i32, i32* %t.addr, align 4
  %cmp58 = icmp ne i32 %18, 0
  br i1 %cmp58, label %if.then60, label %if.end65

if.then60:                                        ; preds = %if.then57
  %19 = load i8, i8* %code, align 1
  %conv61 = zext i8 %19 to i32
  %and62 = and i32 %conv61, 24
  %cmp63 = icmp eq i32 %and62, 24
  store i1 %cmp63, i1* %retval, align 1
  br label %return

if.end65:                                         ; preds = %if.then57
  store i1 true, i1* %retval, align 1
  br label %return

if.end66:                                         ; preds = %if.end53
  %20 = load i8, i8* %class, align 1
  %conv67 = zext i8 %20 to i32
  %cmp68 = icmp eq i32 %conv67, 3
  br i1 %cmp68, label %if.then70, label %if.end82

if.then70:                                        ; preds = %if.end66
  %21 = load i32, i32* %t.addr, align 4
  %cmp71 = icmp eq i32 %21, 0
  br i1 %cmp71, label %land.lhs.true73, label %if.end77

land.lhs.true73:                                  ; preds = %if.then70
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type, align 8
  %cmp74 = icmp ne i32 %23, 1
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %land.lhs.true73
  store i1 true, i1* %retval, align 1
  br label %return

if.end77:                                         ; preds = %land.lhs.true73, %if.then70
  %24 = load i8, i8* %code, align 1
  %conv78 = zext i8 %24 to i32
  %and79 = and i32 %conv78, 24
  %cmp80 = icmp eq i32 %and79, 24
  store i1 %cmp80, i1* %retval, align 1
  br label %return

if.end82:                                         ; preds = %if.end66
  %25 = load i8, i8* %class, align 1
  %conv83 = zext i8 %25 to i32
  %cmp84 = icmp eq i32 %conv83, 0
  br i1 %cmp84, label %if.then86, label %if.end103

if.then86:                                        ; preds = %if.end82
  %26 = load i8, i8* %code, align 1
  %conv87 = zext i8 %26 to i32
  %and88 = and i32 %conv87, 224
  %conv89 = trunc i32 %and88 to i8
  store i8 %conv89, i8* %mode, align 1
  %27 = load i8, i8* %mode, align 1
  %conv90 = zext i8 %27 to i32
  %cmp91 = icmp eq i32 %conv90, 0
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.then86
  store i1 true, i1* %retval, align 1
  br label %return

if.end94:                                         ; preds = %if.then86
  %28 = load i32, i32* %t.addr, align 4
  %cmp95 = icmp ne i32 %28, 0
  br i1 %cmp95, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end94
  store i1 false, i1* %retval, align 1
  br label %return

if.end98:                                         ; preds = %if.end94
  %29 = load i32, i32* %regno.addr, align 4
  %cmp99 = icmp eq i32 %29, 6
  br i1 %cmp99, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.end98
  store i1 true, i1* %retval, align 1
  br label %return

if.end102:                                        ; preds = %if.end98
  store i1 true, i1* %retval, align 1
  br label %return

if.end103:                                        ; preds = %if.end82
  %30 = load i8, i8* %class, align 1
  %conv104 = zext i8 %30 to i32
  %cmp105 = icmp eq i32 %conv104, 2
  br i1 %cmp105, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end103
  store i1 true, i1* %retval, align 1
  br label %return

if.end108:                                        ; preds = %if.end103
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end108, %if.then107, %if.end102, %if.then101, %if.then97, %if.then93, %if.end77, %if.then76, %if.end65, %if.then60, %if.then52, %if.then43, %if.end24, %if.then23, %if.then19, %if.then11
  %31 = load i1, i1* %retval, align 1
  ret i1 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %strict = alloca i8, align 1
  %pointer_desc = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 6
  %1 = load i8, i8* %strict_alignment, align 4
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool1 = trunc i8 %2 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  %frombool2 = zext i1 %3 to i8
  store i8 %frombool2, i8* %strict, align 1
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.79, i64 0, i64 0), i8** %pointer_desc, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  %5 = load i32, i32* %type, align 8
  switch i32 %5, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 10, label %sw.bb4
    i32 29, label %sw.bb5
    i32 4, label %sw.bb6
    i32 2, label %sw.bb7
    i32 6, label %sw.bb8
    i32 11, label %sw.bb9
    i32 13, label %sw.bb10
    i32 15, label %sw.bb11
    i32 18, label %sw.bb12
  ]

sw.bb:                                            ; preds = %lor.end, %lor.end
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %10 = load i8, i8* %strict, align 1
  %tobool3 = trunc i8 %10 to i1
  %call = call i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool3) #14
  store i32 %call, i32* %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.286, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.287, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.288, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.289, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.290, i64 0, i64 0), i8** %pointer_desc, align 8
  store i8 1, i8* %strict, align 1
  br label %sw.epilog

sw.bb9:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.291, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.292, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.293, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.294, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %lor.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %13 = load i8*, i8** %pointer_desc, align 8
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i8, i8* %strict, align 1
  %tobool13 = trunc i8 %16 to i1
  %call14 = call i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i8* noundef %13, i32 noundef %14, i32 noundef %15, i1 noundef zeroext %tobool13) #14
  store i32 %call14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 7
  %1 = load i32, i32* %map_flags, align 8
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %frozen = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 18
  %3 = load i8, i8* %frozen, align 1
  %tobool1 = trunc i8 %3 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_direct_read(%struct.bpf_map* noundef %map, i32 noundef %off, i32 noundef %size, i64* noundef %val) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %val.addr = alloca i64*, align 8
  %ptr = alloca i8*, align 8
  %addr = alloca i64, align 8
  %err = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i64* %val, i64** %val.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %1, i32 0, i32 27
  %2 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %4 = load i32, i32* %off.addr, align 4
  %call = call i32 %2(%struct.bpf_map* noundef %3, i64* noundef %addr, i32 noundef %4) #14
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i64, i64* %addr, align 8
  %8 = inttoptr i64 %7 to i8*
  %9 = load i32, i32* %off.addr, align 4
  %idx.ext = sext i32 %9 to i64
  %add.ptr = getelementptr i8, i8* %8, i64 %idx.ext
  store i8* %add.ptr, i8** %ptr, align 8
  %10 = load i32, i32* %size.addr, align 4
  switch i32 %10, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 4, label %sw.bb3
    i32 8, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i8*, i8** %ptr, align 8
  %12 = load i8, i8* %11, align 1
  %conv = zext i8 %12 to i64
  %13 = load i64*, i64** %val.addr, align 8
  store i64 %conv, i64* %13, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %if.end
  %14 = load i8*, i8** %ptr, align 8
  %15 = bitcast i8* %14 to i16*
  %16 = load i16, i16* %15, align 2
  %conv2 = zext i16 %16 to i64
  %17 = load i64*, i64** %val.addr, align 8
  store i64 %conv2, i64* %17, align 8
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %18 = load i8*, i8** %ptr, align 8
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19, align 4
  %conv4 = zext i32 %20 to i64
  %21 = load i64*, i64** %val.addr, align 8
  store i64 %conv4, i64* %21, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %22 = load i8*, i8** %ptr, align 8
  %23 = bitcast i8* %22 to i64*
  %24 = load i64, i64* %23, align 8
  %25 = load i64*, i64** %val.addr, align 8
  store i64 %24, i64* %25, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %off, i32 noundef %size, i32 noundef %t, i32* noundef %reg_type, %struct.btf** noundef %btf, i32* noundef %btf_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %reg_type.addr = alloca i32*, align 8
  %btf.addr = alloca %struct.btf**, align 8
  %btf_id.addr = alloca i32*, align 8
  %info = alloca %struct.bpf_insn_access_aux, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32* %reg_type, i32** %reg_type.addr, align 8
  store %struct.btf** %btf, %struct.btf*** %btf.addr, align 8
  store i32* %btf_id, i32** %btf_id.addr, align 8
  %reg_type1 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 0
  %0 = load i32*, i32** %reg_type.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %reg_type1, align 8
  %2 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %3 = bitcast %union.anon.161* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 16, i1 false)
  %log = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 2
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 26
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 3
  %6 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %is_valid_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %6, i32 0, i32 1
  %7 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)** %is_valid_access, align 8
  %tobool = icmp ne i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)* %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 3
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops3, align 8
  %is_valid_access4 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 1
  %10 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)** %is_valid_access4, align 8
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 %10(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.bpf_prog* noundef %15, %struct.bpf_insn_access_aux* noundef %info) #14
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true
  %reg_type5 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 0
  %16 = load i32, i32* %reg_type5, align 8
  %17 = load i32*, i32** %reg_type.addr, align 8
  store i32 %16, i32* %17, align 4
  %18 = load i32*, i32** %reg_type.addr, align 8
  %19 = load i32, i32* %18, align 4
  %cmp = icmp eq i32 %19, 19
  br i1 %cmp, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %20 = load i32*, i32** %reg_type.addr, align 8
  %21 = load i32, i32* %20, align 4
  %cmp6 = icmp eq i32 %21, 20
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %lor.lhs.false, %if.then
  %22 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %23 = bitcast %union.anon.161* %22 to %struct.anon.162*
  %btf8 = getelementptr inbounds %struct.anon.162, %struct.anon.162* %23, i32 0, i32 0
  %24 = load %struct.btf*, %struct.btf** %btf8, align 8
  %25 = load %struct.btf**, %struct.btf*** %btf.addr, align 8
  store %struct.btf* %24, %struct.btf** %25, align 8
  %26 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %27 = bitcast %union.anon.161* %26 to %struct.anon.162*
  %btf_id9 = getelementptr inbounds %struct.anon.162, %struct.anon.162* %27, i32 0, i32 1
  %28 = load i32, i32* %btf_id9, align 8
  %29 = load i32*, i32** %btf_id.addr, align 8
  store i32 %28, i32* %29, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %30 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %ctx_field_size = bitcast %union.anon.161* %30 to i32*
  %31 = load i32, i32* %ctx_field_size, align 8
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 24
  %33 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %34 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %34 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %33, i64 %idxprom
  %ctx_field_size10 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 2
  store i32 %31, i32* %ctx_field_size10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then7
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 2
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %prog11, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %36, i32 0, i32 10
  %37 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_ctx_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %37, i32 0, i32 3
  %38 = load i32, i32* %max_ctx_offset, align 8
  %39 = load i32, i32* %off.addr, align 4
  %40 = load i32, i32* %size.addr, align 4
  %add = add i32 %39, %40
  %cmp12 = icmp ult i32 %38, %add
  br i1 %cmp12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %if.end
  %41 = load i32, i32* %off.addr, align 4
  %42 = load i32, i32* %size.addr, align 4
  %add14 = add i32 %41, %42
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 2
  %44 = load %struct.bpf_prog*, %struct.bpf_prog** %prog15, align 8
  %aux16 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %44, i32 0, i32 10
  %45 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %max_ctx_offset17 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %45, i32 0, i32 3
  store i32 %add14, i32* %max_ctx_offset17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then13, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %entry
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = bitcast %struct.bpf_verifier_env* %46 to i8*
  %48 = load i32, i32* %off.addr, align 4
  %49 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %47, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.297, i64 0, i64 0), i32 noundef %48, i32 noundef %49) #14
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.end18
  %50 = load i32, i32* %retval, align 4
  ret i32 %50
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read(%struct.bpf_verifier_env* noundef %env, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %dst_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %var_off = alloca i8, align 1
  %tn_buf = alloca [48 x i8], align 16
  %tn_buf11 = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %ptr_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #14
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call3 = call zeroext i1 @tnum_is_const(i64 %7, i64 %9) #14
  %lnot = xor i1 %call3, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %var_off, align 1
  %10 = load i32, i32* %dst_regno.addr, align 4
  %cmp = icmp slt i32 %10, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load i8, i8* %var_off, align 1
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %15, i64 %17) #14
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %arraydecay6 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([96 x i8], [96 x i8]* @.str.298, i64 0, i64 0), i8* noundef %arraydecay6, i32 noundef %20, i32 noundef %21) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 21
  %23 = load i8, i8* %bypass_spec_v1, align 1
  %tobool7 = trunc i8 %23 to i1
  br i1 %tobool7, label %if.end16, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %if.end
  %24 = load i8, i8* %var_off, align 1
  %tobool9 = trunc i8 %24 to i1
  br i1 %tobool9, label %if.then10, label %if.end16

if.then10:                                        ; preds = %land.lhs.true8
  %arraydecay12 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf11, i64 0, i64 0
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %var_off13 to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call14 = call i32 @tnum_strn(i8* noundef %arraydecay12, i64 noundef 48, i64 %28, i64 %30) #14
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  %33 = load i32, i32* %ptr_regno.addr, align 4
  %arraydecay15 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf11, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.299, i64 0, i64 0), i32 noundef %33, i8* noundef %arraydecay15) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true8, %if.end
  %34 = load i8, i8* %var_off, align 1
  %tobool17 = trunc i8 %34 to i1
  br i1 %tobool17, label %if.else, label %if.then18

if.then18:                                        ; preds = %if.end16
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 0
  %36 = load i64, i64* %value, align 8
  %37 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %37 to i64
  %add = add i64 %conv, %36
  %conv20 = trunc i64 %add to i32
  store i32 %conv20, i32* %off.addr, align 4
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %40 = load i32, i32* %off.addr, align 4
  %41 = load i32, i32* %size.addr, align 4
  %42 = load i32, i32* %dst_regno.addr, align 4
  %call21 = call i32 @check_stack_read_fixed_off(%struct.bpf_verifier_env* noundef %38, %struct.bpf_func_state* noundef %39, i32 noundef %40, i32 noundef %41, i32 noundef %42) #14
  store i32 %call21, i32* %err, align 4
  br label %if.end23

if.else:                                          ; preds = %if.end16
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load i32, i32* %ptr_regno.addr, align 4
  %45 = load i32, i32* %off.addr, align 4
  %46 = load i32, i32* %size.addr, align 4
  %47 = load i32, i32* %dst_regno.addr, align 4
  %call22 = call i32 @check_stack_read_var_off(%struct.bpf_verifier_env* noundef %43, i32 noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef %47) #14
  store i32 %call22, i32* %err, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then18
  %48 = load i32, i32* %err, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then10, %if.then
  %49 = load i32, i32* %retval, align 4
  ret i32 %49
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write(%struct.bpf_verifier_env* noundef %env, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %ptr_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #14
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %7, i64 %9) #14
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %12 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %12 to i64
  %add = add i64 %conv, %11
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %off.addr, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %size.addr, align 4
  %17 = load i32, i32* %value_regno.addr, align 4
  %18 = load i32, i32* %insn_idx.addr, align 4
  %call5 = call i32 @check_stack_write_fixed_off(%struct.bpf_verifier_env* noundef %13, %struct.bpf_func_state* noundef %14, i32 noundef %15, i32 noundef %16, i32 noundef %17, i32 noundef %18) #14
  store i32 %call5, i32* %err, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %21 = load i32, i32* %ptr_regno.addr, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %size.addr, align 4
  %24 = load i32, i32* %value_regno.addr, align 4
  %25 = load i32, i32* %insn_idx.addr, align 4
  %call6 = call i32 @check_stack_write_var_off(%struct.bpf_verifier_env* noundef %19, %struct.bpf_func_state* noundef %20, i32 noundef %21, i32 noundef %22, i32 noundef %23, i32 noundef %24, i32 noundef %25) #14
  store i32 %call6, i32* %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %26 = load i32, i32* %err, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %t.addr = alloca i32, align 4
  %prog_type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %1) #14
  store i32 %call, i32* %prog_type, align 4
  %2 = load i32, i32* %prog_type, align 4
  switch i32 %2, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb
    i32 19, label %sw.bb
    i32 21, label %sw.bb
    i32 22, label %sw.bb
    i32 8, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb1
    i32 6, label %sw.bb1
    i32 12, label %sw.bb1
    i32 14, label %sw.bb1
    i32 16, label %sw.bb1
    i32 25, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %3 = load i32, i32* %t.addr, align 4
  %cmp = icmp eq i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb1

sw.bb1:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %if.end
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool = icmp ne %struct.bpf_call_arg_meta* %4, null
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %sw.bb1
  %5 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %5, i32 0, i32 2
  %6 = load i8, i8* %pkt_access, align 1
  %tobool3 = trunc i8 %6 to i1
  store i1 %tobool3, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb1
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 23
  store i8 1, i8* %seen_direct_write, align 1
  store i1 true, i1* %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry
  %8 = load i32, i32* %t.addr, align 4
  %cmp6 = icmp eq i32 %8, 2
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %sw.bb5
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 23
  store i8 1, i8* %seen_direct_write8, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %sw.bb5
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %if.end9, %if.end4, %if.then2, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %2 to i64
  %3 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %3 to i64
  %add = add i64 %conv, %conv3
  %cmp4 = icmp ugt i64 %add, 56
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %off.addr, align 4
  %7 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.309, i64 0, i64 0), i32 noundef %6, i32 noundef %7) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_sk_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 13
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 15
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 18
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_sock_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %info = alloca %struct.bpf_insn_access_aux, align 8
  %valid = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = bitcast %struct.bpf_insn_access_aux* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 32, i1 false)
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.31, i64 0, i64 0), i32 noundef %8) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  switch i32 %10, label %sw.default [
    i32 13, label %sw.bb
    i32 11, label %sw.bb2
    i32 15, label %sw.bb5
    i32 18, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %call1 = call zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.bpf_insn_access_aux* noundef %info) #14
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %valid, align 1
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.end
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i32, i32* %t.addr, align 4
  %call3 = call zeroext i1 @bpf_sock_is_valid_access(i32 noundef %14, i32 noundef %15, i32 noundef %16, %struct.bpf_insn_access_aux* noundef %info) #14
  %frombool4 = zext i1 %call3 to i8
  store i8 %frombool4, i8* %valid, align 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  %call6 = call zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef %17, i32 noundef %18, i32 noundef %19, %struct.bpf_insn_access_aux* noundef %info) #14
  %frombool7 = zext i1 %call6 to i8
  store i8 %frombool7, i8* %valid, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  %22 = load i32, i32* %t.addr, align 4
  %call9 = call zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef %20, i32 noundef %21, i32 noundef %22, %struct.bpf_insn_access_aux* noundef %info) #14
  %frombool10 = zext i1 %call9 to i8
  store i8 %frombool10, i8* %valid, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i8 0, i8* %valid, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb5, %sw.bb2, %sw.bb
  %23 = load i8, i8* %valid, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then11, label %if.end15

if.then11:                                        ; preds = %sw.epilog
  %24 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %ctx_field_size = bitcast %union.anon.161* %24 to i32*
  %25 = load i32, i32* %ctx_field_size, align 8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 24
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %28 = load i32, i32* %insn_idx.addr, align 4
  %idxprom12 = sext i32 %28 to i64
  %arrayidx13 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idxprom12
  %ctx_field_size14 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx13, i32 0, i32 2
  store i32 %25, i32* %ctx_field_size14, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %sw.epilog
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type16, align 8
  %idxprom17 = zext i32 %33 to i64
  %arrayidx18 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom17
  %34 = load i8*, i8** %arrayidx18, align 8
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.310, i64 0, i64 0), i32 noundef %31, i8* noundef %34, i32 noundef %35, i32 noundef %36) #14
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then11, %if.then
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %size.addr, align 4
  %call = call i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %0, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.311, i64 0, i64 0), %struct.bpf_reg_state* noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) #14
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %off.addr, align 4
  %8 = load i32, i32* %size.addr, align 4
  %add = add i32 %7, %8
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 2
  %10 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %10, i32 0, i32 10
  %11 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_tp_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %11, i32 0, i32 5
  %12 = load i32, i32* %max_tp_access, align 8
  %cmp = icmp ugt i32 %add, %12
  br i1 %cmp, label %if.then1, label %if.end6

if.then1:                                         ; preds = %if.end
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  %add2 = add i32 %13, %14
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 2
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 10
  %17 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux4, align 8
  %max_tp_access5 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %17, i32 0, i32 5
  store i32 %add2, i32* %max_tp_access5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then1, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_to_btf_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %atype, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %atype.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %btf_id3 = alloca i32, align 4
  %ret = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %atype, i32* %atype.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.152* %3 to %struct.anon.154*
  %btf = getelementptr inbounds %struct.anon.154, %struct.anon.154* %4, i32 0, i32 0
  %5 = load %struct.btf*, %struct.btf** %btf, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 2
  %8 = bitcast %union.anon.152* %7 to %struct.anon.154*
  %btf_id = getelementptr inbounds %struct.anon.154, %struct.anon.154* %8, i32 0, i32 1
  %9 = load i32, i32* %btf_id, align 8
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %5, i32 noundef %9) #14
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 2
  %12 = bitcast %union.anon.152* %11 to %struct.anon.154*
  %btf1 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %12, i32 0, i32 0
  %13 = load %struct.btf*, %struct.btf** %btf1, align 8
  %14 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %14, i32 0, i32 0
  %15 = load i32, i32* %name_off, align 4
  %call2 = call i8* @btf_name_by_offset(%struct.btf* noundef %13, i32 noundef %15) #14
  store i8* %call2, i8** %tname, align 8
  %16 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %16, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load i32, i32* %regno.addr, align 4
  %20 = load i8*, i8** %tname, align 8
  %21 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.312, i64 0, i64 0), i32 noundef %19, i8* noundef %20, i32 noundef %21) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %23 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call4 = call zeroext i1 @tnum_is_const(i64 %25, i64 %27) #14
  br i1 %call4, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %29 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %29, 0
  br i1 %tobool, label %if.then6, label %if.end10

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off7 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %call8 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %33, i64 %35) #14
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load i8*, i8** %tname, align 8
  %40 = load i32, i32* %off.addr, align 4
  %arraydecay9 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.313, i64 0, i64 0), i32 noundef %38, i8* noundef %39, i32 noundef %40, i8* noundef %arraydecay9) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 3
  %42 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %btf_struct_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %42, i32 0, i32 5
  %43 = load i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*)** %btf_struct_access, align 8
  %tobool11 = icmp ne i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*)* %43, null
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end10
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 3
  %45 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops13, align 8
  %btf_struct_access14 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %45, i32 0, i32 5
  %46 = load i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*)** %btf_struct_access14, align 8
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 26
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 2
  %50 = bitcast %union.anon.152* %49 to %struct.anon.154*
  %btf15 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %50, i32 0, i32 0
  %51 = load %struct.btf*, %struct.btf** %btf15, align 8
  %52 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %53 = load i32, i32* %off.addr, align 4
  %54 = load i32, i32* %size.addr, align 4
  %55 = load i32, i32* %atype.addr, align 4
  %call16 = call i32 %46(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %51, %struct.btf_type* noundef %52, i32 noundef %53, i32 noundef %54, i32 noundef %55, i32* noundef %btf_id3) #14
  store i32 %call16, i32* %ret, align 4
  br label %if.end23

if.else:                                          ; preds = %if.end10
  %56 = load i32, i32* %atype.addr, align 4
  %cmp17 = icmp ne i32 %56, 1
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.314, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.else
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %59, i32 0, i32 26
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 2
  %62 = bitcast %union.anon.152* %61 to %struct.anon.154*
  %btf21 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %62, i32 0, i32 0
  %63 = load %struct.btf*, %struct.btf** %btf21, align 8
  %64 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %65 = load i32, i32* %off.addr, align 4
  %66 = load i32, i32* %size.addr, align 4
  %67 = load i32, i32* %atype.addr, align 4
  %call22 = call i32 @btf_struct_access(%struct.bpf_verifier_log* noundef %log20, %struct.btf* noundef %63, %struct.btf_type* noundef %64, i32 noundef %65, i32 noundef %66, i32 noundef %67, i32* noundef %btf_id3) #14
  store i32 %call22, i32* %ret, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.end19, %if.then12
  %68 = load i32, i32* %ret, align 4
  %cmp24 = icmp slt i32 %68, 0
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end23
  %69 = load i32, i32* %ret, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end23
  %70 = load i32, i32* %atype.addr, align 4
  %cmp27 = icmp eq i32 %70, 1
  br i1 %cmp27, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %if.end26
  %71 = load i32, i32* %value_regno.addr, align 4
  %cmp28 = icmp sge i32 %71, 0
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %land.lhs.true
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %74 = load i32, i32* %value_regno.addr, align 4
  %75 = load i32, i32* %ret, align 4
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 2
  %78 = bitcast %union.anon.152* %77 to %struct.anon.154*
  %btf30 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %78, i32 0, i32 0
  %79 = load %struct.btf*, %struct.btf** %btf30, align 8
  %80 = load i32, i32* %btf_id3, align 4
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %72, %struct.bpf_reg_state* noundef %73, i32 noundef %74, i32 noundef %75, %struct.btf* noundef %79, i32 noundef %80) #14
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %land.lhs.true, %if.end26
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then25, %if.then18, %if.then6, %if.then
  %81 = load i32, i32* %retval, align 4
  ret i32 %81
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_to_map_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %atype, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %atype.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %btf_id = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %atype, i32* %atype.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.152* %3 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.315, i64 0, i64 0)) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %9, i32 0, i32 0
  %10 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_btf_id = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %10, i32 0, i32 39
  %11 = load i32*, i32** %map_btf_id, align 8
  %tobool1 = icmp ne i32* %11, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops2 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %12, i32 0, i32 0
  %13 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops2, align 64
  %map_btf_id3 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %13, i32 0, i32 39
  %14 = load i32*, i32** %map_btf_id3, align 8
  %15 = load i32, i32* %14, align 4
  %tobool4 = icmp ne i32 %15, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 3
  %19 = load i32, i32* %map_type, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.316, i64 0, i64 0), i32 noundef %19) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %20 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops7 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %21, i32 0, i32 0
  %22 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops7, align 64
  %map_btf_id8 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %22, i32 0, i32 39
  %23 = load i32*, i32** %map_btf_id8, align 8
  %24 = load i32, i32* %23, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %20, i32 noundef %24) #14
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %25 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %26 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %26, i32 0, i32 0
  %27 = load i32, i32* %name_off, align 4
  %call9 = call i8* @btf_name_by_offset(%struct.btf* noundef %25, i32 noundef %27) #14
  store i8* %call9, i8** %tname, align 8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_to_map_access = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 19
  %29 = load i8, i8* %allow_ptr_to_map_access, align 1
  %tobool10 = trunc i8 %29 to i1
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end6
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i8*, i8** %tname, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.317, i64 0, i64 0), i8* noundef %32) #14
  store i32 -1, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end6
  %33 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %33, 0
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32, i32* %regno.addr, align 4
  %37 = load i8*, i8** %tname, align 8
  %38 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.318, i64 0, i64 0), i32 noundef %36, i8* noundef %37, i32 noundef %38) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end12
  %39 = load i32, i32* %atype.addr, align 4
  %cmp15 = icmp ne i32 %39, 1
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load i8*, i8** %tname, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.319, i64 0, i64 0), i8* noundef %42) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end14
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 26
  %44 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %45 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  %48 = load i32, i32* %atype.addr, align 4
  %call18 = call i32 @btf_struct_access(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %44, %struct.btf_type* noundef %45, i32 noundef %46, i32 noundef %47, i32 noundef %48, i32* noundef %btf_id) #14
  store i32 %call18, i32* %ret, align 4
  %49 = load i32, i32* %ret, align 4
  %cmp19 = icmp slt i32 %49, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %50 = load i32, i32* %ret, align 4
  store i32 %50, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %51 = load i32, i32* %value_regno.addr, align 4
  %cmp22 = icmp sge i32 %51, 0
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %54 = load i32, i32* %value_regno.addr, align 4
  %55 = load i32, i32* %ret, align 4
  %56 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %57 = load i32, i32* %btf_id, align 4
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %52, %struct.bpf_reg_state* noundef %53, i32 noundef %54, i32 noundef %55, %struct.btf* noundef %56, i32 noundef %57) #14
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then16, %if.then13, %if.then11, %if.then5, %if.then
  %58 = load i32, i32* %retval, align 4
  ret i32 %58
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %reg, i32 noundef %size) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %size.addr = alloca i32, align 4
  %mask = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i32, i32* %size.addr, align 4
  %conv = trunc i32 %2 to i8
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_cast(i64 %5, i64 %7, i8 noundef zeroext %conv) #14
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i32, i32* %size.addr, align 4
  %mul = mul i32 %15, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  store i64 %sub, i64* %mask, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 8
  %17 = load i64, i64* %umin_value, align 8
  %18 = load i64, i64* %mask, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 9
  %20 = load i64, i64* %umax_value, align 8
  %21 = load i64, i64* %mask, align 8
  %neg2 = xor i64 %21, -1
  %and3 = and i64 %20, %neg2
  %cmp = icmp eq i64 %and, %and3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %22 = load i64, i64* %mask, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  %24 = load i64, i64* %umin_value5, align 8
  %and6 = and i64 %24, %22
  store i64 %and6, i64* %umin_value5, align 8
  %25 = load i64, i64* %mask, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value7, align 8
  %and8 = and i64 %27, %25
  store i64 %and8, i64* %umax_value7, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  store i64 0, i64* %umin_value9, align 8
  %29 = load i64, i64* %mask, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 9
  store i64 %29, i64* %umax_value10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 8
  %32 = load i64, i64* %umin_value11, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  store i64 %32, i64* %smin_value, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value12, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 7
  store i64 %35, i64* %smax_value, align 8
  %37 = load i32, i32* %size.addr, align 4
  %cmp13 = icmp sge i32 %37, 4
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  br label %return

if.end16:                                         ; preds = %if.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %38) #14
  br label %return

return:                                           ; preds = %if.end16, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %ip_align = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 2, i32* %ip_align, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load i32, i32* %ip_align, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 1
  %5 = load i32, i32* %off1, align 4
  %add = add i32 %3, %5
  %6 = load i32, i32* %off.addr, align 4
  %add2 = add i32 %add, %6
  %conv = sext i32 %add2 to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #14
  %7 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call3 = call { i64, i64 } @tnum_add(i64 %14, i64 %16, i64 %19, i64 %21) #14
  %22 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 0
  %24 = extractvalue { i64, i64 } %call3, 0
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 1
  %26 = extractvalue { i64, i64 } %call3, 1
  store i64 %26, i64* %25, align 8
  %27 = bitcast %struct.tnum* %reg_off to i8*
  %28 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %28, i64 16, i1 false)
  %29 = load i32, i32* %size.addr, align 4
  %conv4 = sext i32 %29 to i64
  %30 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call zeroext i1 @tnum_is_aligned(i64 %32, i64 %34, i64 noundef %conv4) #14
  br i1 %call5, label %if.end11, label %if.then6

if.then6:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off7 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call8 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %38, i64 %40) #14
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %ip_align, align 4
  %arraydecay9 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 1
  %45 = load i32, i32* %off10, align 4
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.295, i64 0, i64 0), i32 noundef %43, i8* noundef %arraydecay9, i32 noundef %45, i32 noundef %46, i32 noundef %47) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then6, %if.then
  %48 = load i32, i32* %retval, align 4
  ret i32 %48
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i8* noundef %pointer_desc, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %pointer_desc.addr = alloca i8*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i8* %pointer_desc, i8** %pointer_desc.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 1
  %4 = load i32, i32* %off1, align 4
  %5 = load i32, i32* %off.addr, align 4
  %add = add i32 %4, %5
  %conv = sext i32 %add to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #14
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %16 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call2 = call { i64, i64 } @tnum_add(i64 %13, i64 %15, i64 %18, i64 %20) #14
  %21 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call2, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call2, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.tnum* %reg_off to i8*
  %27 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %28 to i64
  %29 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call4 = call zeroext i1 @tnum_is_aligned(i64 %31, i64 %33, i64 noundef %conv3) #14
  br i1 %call4, label %if.end10, label %if.then5

if.then5:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 5
  %35 = bitcast %struct.tnum* %var_off6 to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 8
  %call7 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %37, i64 %39) #14
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load i8*, i8** %pointer_desc.addr, align 8
  %arraydecay8 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 1
  %44 = load i32, i32* %off9, align 4
  %45 = load i32, i32* %off.addr, align 4
  %46 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.296, i64 0, i64 0), i8* noundef %42, i8* noundef %arraydecay8, i32 noundef %44, i32 noundef %45, i32 noundef %46) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then5, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @tnum_is_aligned(i64, i64, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read_fixed_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %reg_state, i32 noundef %off, i32 noundef %size, i32 noundef %dst_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg_state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %stype = alloca i8*, align 8
  %type52 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %reg_state, %struct.bpf_func_state** %reg_state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %6
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %7 = load i32, i32* %slot, align 4
  %div = sdiv i32 %7, 8
  store i32 %div, i32* %spi, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 10
  %9 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %10 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %10 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %9, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  store i8* %arraydecay, i8** %stype, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack4, align 8
  %13 = load i32, i32* %spi, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom5
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %14 = load i8*, i8** %stype, align 8
  %arrayidx7 = getelementptr i8, i8* %14, i64 0
  %15 = load i8, i8* %arrayidx7, align 1
  %conv = zext i8 %15 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %if.then, label %if.else51

if.then:                                          ; preds = %entry
  %16 = load i32, i32* %size.addr, align 4
  %cmp9 = icmp ne i32 %16, 8
  br i1 %cmp9, label %if.then11, label %if.end23

if.then11:                                        ; preds = %if.then
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type, align 8
  %cmp12 = icmp ne i32 %18, 1
  br i1 %cmp12, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then11
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 0
  %21 = load i32, i32* %insn_idx, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %19, i32 noundef %21, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.215, i64 0, i64 0)) #14
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.300, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then11
  %24 = load i32, i32* %dst_regno.addr, align 4
  %cmp15 = icmp sge i32 %24, 0
  br i1 %cmp15, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 0
  %arraydecay18 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %27 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %25, %struct.bpf_reg_state* noundef %arraydecay18, i32 noundef %27) #14
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs19 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 0
  %29 = load i32, i32* %dst_regno.addr, align 4
  %idxprom20 = sext i32 %29 to i64
  %arrayidx21 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs19, i64 0, i64 %idxprom20
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx21, i32 0, i32 17
  %30 = load i32, i32* %live, align 8
  %or = or i32 %30, 4
  store i32 %or, i32* %live, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.end
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 14
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %31, %struct.bpf_reg_state* noundef %32, %struct.bpf_reg_state* noundef %34, i8 noundef zeroext 2) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.then
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %35 = load i32, i32* %i, align 4
  %cmp24 = icmp slt i32 %35, 8
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load i8*, i8** %stype, align 8
  %37 = load i32, i32* %slot, align 4
  %38 = load i32, i32* %i, align 4
  %sub26 = sub i32 %37, %38
  %rem = srem i32 %sub26, 8
  %idxprom27 = sext i32 %rem to i64
  %arrayidx28 = getelementptr i8, i8* %36, i64 %idxprom27
  %39 = load i8, i8* %arrayidx28, align 1
  %conv29 = zext i8 %39 to i32
  %cmp30 = icmp ne i32 %conv29, 1
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %for.body
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.301, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %42 = load i32, i32* %i, align 4
  %inc = add i32 %42, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %43 = load i32, i32* %dst_regno.addr, align 4
  %cmp34 = icmp sge i32 %43, 0
  br i1 %cmp34, label %if.then36, label %if.else

if.then36:                                        ; preds = %for.end
  %44 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %44, i32 0, i32 0
  %45 = load i32, i32* %dst_regno.addr, align 4
  %idxprom38 = sext i32 %45 to i64
  %arrayidx39 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs37, i64 0, i64 %idxprom38
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = bitcast %struct.bpf_reg_state* %arrayidx39 to i8*
  %48 = bitcast %struct.bpf_reg_state* %46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %47, i8* align 8 %48, i64 120, i1 false)
  %49 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs40 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %49, i32 0, i32 0
  %50 = load i32, i32* %dst_regno.addr, align 4
  %idxprom41 = sext i32 %50 to i64
  %arrayidx42 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs40, i64 0, i64 %idxprom41
  %live43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx42, i32 0, i32 17
  %51 = load i32, i32* %live43, align 8
  %or44 = or i32 %51, 4
  store i32 %or44, i32* %live43, align 8
  br label %if.end48

if.else:                                          ; preds = %for.end
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %52, i32 0, i32 17
  %53 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool = trunc i8 %53 to i1
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call45 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool, %struct.bpf_reg_state* noundef %54) #14
  br i1 %call45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.else
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  %57 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.302, i64 0, i64 0), i32 noundef %57) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.else
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then36
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 14
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent49, align 8
  %call50 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %58, %struct.bpf_reg_state* noundef %59, %struct.bpf_reg_state* noundef %61, i8 noundef zeroext 2) #14
  br label %if.end80

if.else51:                                        ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond53

for.cond53:                                       ; preds = %for.inc71, %if.else51
  %62 = load i32, i32* %i, align 4
  %63 = load i32, i32* %size.addr, align 4
  %cmp54 = icmp slt i32 %62, %63
  br i1 %cmp54, label %for.body56, label %for.end73

for.body56:                                       ; preds = %for.cond53
  %64 = load i8*, i8** %stype, align 8
  %65 = load i32, i32* %slot, align 4
  %66 = load i32, i32* %i, align 4
  %sub57 = sub i32 %65, %66
  %rem58 = srem i32 %sub57, 8
  %idxprom59 = sext i32 %rem58 to i64
  %arrayidx60 = getelementptr i8, i8* %64, i64 %idxprom59
  %67 = load i8, i8* %arrayidx60, align 1
  store i8 %67, i8* %type52, align 1
  %68 = load i8, i8* %type52, align 1
  %conv61 = zext i8 %68 to i32
  %cmp62 = icmp eq i32 %conv61, 2
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %for.body56
  br label %for.inc71

if.end65:                                         ; preds = %for.body56
  %69 = load i8, i8* %type52, align 1
  %conv66 = zext i8 %69 to i32
  %cmp67 = icmp eq i32 %conv66, 3
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end65
  br label %for.inc71

if.end70:                                         ; preds = %if.end65
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  %72 = load i32, i32* %off.addr, align 4
  %73 = load i32, i32* %i, align 4
  %74 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.303, i64 0, i64 0), i32 noundef %72, i32 noundef %73, i32 noundef %74) #14
  store i32 -13, i32* %retval, align 4
  br label %return

for.inc71:                                        ; preds = %if.then69, %if.then64
  %75 = load i32, i32* %i, align 4
  %inc72 = add i32 %75, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond53

for.end73:                                        ; preds = %for.cond53
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 14
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent74, align 8
  %call75 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %76, %struct.bpf_reg_state* noundef %77, %struct.bpf_reg_state* noundef %79, i8 noundef zeroext 2) #14
  %80 = load i32, i32* %dst_regno.addr, align 4
  %cmp76 = icmp sge i32 %80, 0
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %for.end73
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %82 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %83 = load i32, i32* %off.addr, align 4
  %84 = load i32, i32* %off.addr, align 4
  %85 = load i32, i32* %size.addr, align 4
  %add = add i32 %84, %85
  %86 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_stack_read(%struct.bpf_verifier_env* noundef %81, %struct.bpf_func_state* noundef %82, i32 noundef %83, i32 noundef %add, i32 noundef %86) #14
  br label %if.end79

if.end79:                                         ; preds = %if.then78, %for.end73
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %if.end48
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end80, %if.end70, %if.then46, %if.then32, %if.end22, %if.then14
  %87 = load i32, i32* %retval, align 4
  ret i32 %87
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read_var_off(%struct.bpf_verifier_env* noundef %env, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %dst_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %ptr_state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %ptr_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #14
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %ptr_state, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load i32, i32* %ptr_regno.addr, align 4
  %6 = load i32, i32* %off.addr, align 4
  %7 = load i32, i32* %size.addr, align 4
  %call2 = call i32 @check_stack_range_initialized(%struct.bpf_verifier_env* noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7, i1 noundef zeroext false, i32 noundef 1, %struct.bpf_call_arg_meta* noundef null) #14
  store i32 %call2, i32* %err, align 4
  %8 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %err, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value, align 8
  %12 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %12 to i64
  %add = add i64 %11, %conv
  %conv3 = trunc i64 %add to i32
  store i32 %conv3, i32* %min_off, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 7
  %14 = load i64, i64* %smax_value, align 8
  %15 = load i32, i32* %off.addr, align 4
  %conv4 = sext i32 %15 to i64
  %add5 = add i64 %14, %conv4
  %conv6 = trunc i64 %add5 to i32
  store i32 %conv6, i32* %max_off, align 4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %ptr_state, align 8
  %18 = load i32, i32* %min_off, align 4
  %19 = load i32, i32* %max_off, align 4
  %20 = load i32, i32* %size.addr, align 4
  %add7 = add i32 %19, %20
  %21 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_stack_read(%struct.bpf_verifier_env* noundef %16, %struct.bpf_func_state* noundef %17, i32 noundef %18, i32 noundef %add7, i32 noundef %21) #14
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_stack_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %ptr_state, i32 noundef %min_off, i32 noundef %max_off, i32 noundef %dst_regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_state.addr = alloca %struct.bpf_func_state*, align 8
  %min_off.addr = alloca i32, align 4
  %max_off.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %stype = alloca i8*, align 8
  %zeros = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %ptr_state, %struct.bpf_func_state** %ptr_state.addr, align 8
  store i32 %min_off, i32* %min_off.addr, align 4
  store i32 %max_off, i32* %max_off.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %zeros, align 4
  %6 = load i32, i32* %min_off.addr, align 4
  store i32 %6, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %max_off.addr, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %sub = sub i32 0, %9
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %10 = load i32, i32* %slot, align 4
  %div = sdiv i32 %10, 8
  store i32 %div, i32* %spi, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %ptr_state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %13 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  store i8* %arraydecay, i8** %stype, align 8
  %14 = load i8*, i8** %stype, align 8
  %15 = load i32, i32* %slot, align 4
  %rem = srem i32 %15, 8
  %idxprom4 = sext i32 %rem to i64
  %arrayidx5 = getelementptr i8, i8* %14, i64 %idxprom4
  %16 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %16 to i32
  %cmp6 = icmp ne i32 %conv, 3
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %17 = load i32, i32* %zeros, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %zeros, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i32, i32* %i, align 4
  %inc8 = add i32 %18, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %19 = load i32, i32* %zeros, align 4
  %20 = load i32, i32* %max_off.addr, align 4
  %21 = load i32, i32* %min_off.addr, align 4
  %sub9 = sub i32 %20, %21
  %cmp10 = icmp eq i32 %19, %sub9
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %for.end
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 0
  %23 = load i32, i32* %dst_regno.addr, align 4
  %idxprom13 = sext i32 %23 to i64
  %arrayidx14 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom13
  call void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %arrayidx14) #14
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %24, i32 0, i32 0
  %25 = load i32, i32* %dst_regno.addr, align 4
  %idxprom16 = sext i32 %25 to i64
  %arrayidx17 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs15, i64 0, i64 %idxprom16
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx17, i32 0, i32 18
  store i8 1, i8* %precise, align 4
  br label %if.end20

if.else:                                          ; preds = %for.end
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs18, i64 0, i64 0
  %28 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %arraydecay19, i32 noundef %28) #14
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then12
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs21 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 0
  %30 = load i32, i32* %dst_regno.addr, align 4
  %idxprom22 = sext i32 %30 to i64
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs21, i64 0, i64 %idxprom22
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx23, i32 0, i32 17
  %31 = load i32, i32* %live, align 8
  %or = or i32 %31, 4
  store i32 %or, i32* %live, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #14
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write_fixed_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %err = alloca i32, align 4
  %dst_reg = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %sanitize = alloca i8, align 1
  %type89 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %0
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %1 = load i32, i32* %slot, align 4
  %div = sdiv i32 %1, 8
  store i32 %div, i32* %spi, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 13
  %4 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom
  %dst_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg2, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst_reg, align 4
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %reg, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %6 = load i32, i32* %slot, align 4
  %add = add i32 %6, 1
  %sub3 = sub i32 %add, 1
  %or = or i32 %sub3, 7
  %add4 = add i32 %or, 1
  %call = call i32 @grow_stack_state(%struct.bpf_func_state* noundef %5, i32 noundef %add4) #14
  store i32 %call, i32* %err, align 4
  %7 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load i32, i32* %err, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 17
  %10 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool5 = trunc i8 %10 to i1
  br i1 %tobool5, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = load i32, i32* %spi, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %arrayidx8 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %14 = load i8, i8* %arrayidx8, align 8
  %conv9 = zext i8 %14 to i32
  %cmp = icmp eq i32 %conv9, 1
  br i1 %cmp, label %land.lhs.true11, label %if.end15

land.lhs.true11:                                  ; preds = %land.lhs.true
  %15 = load i32, i32* %size.addr, align 4
  %cmp12 = icmp ne i32 %15, 8
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true11
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.304, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true11, %land.lhs.true, %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 8
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state16, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 4
  %22 = load i32, i32* %curframe, align 8
  %idxprom17 = zext i32 %22 to i64
  %arrayidx18 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom17
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx18, align 8
  store %struct.bpf_func_state* %23, %struct.bpf_func_state** %cur, align 8
  %24 = load i32, i32* %value_regno.addr, align 4
  %cmp19 = icmp sge i32 %24, 0
  br i1 %cmp19, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end15
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 0
  %26 = load i32, i32* %value_regno.addr, align 4
  %idxprom22 = sext i32 %26 to i64
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom22
  store %struct.bpf_reg_state* %arrayidx23, %struct.bpf_reg_state** %reg, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end15
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 22
  %28 = load i8, i8* %bypass_spec_v4, align 2
  %tobool25 = trunc i8 %28 to i1
  br i1 %tobool25, label %if.end48, label %if.then26

if.then26:                                        ; preds = %if.end24
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool27 = icmp ne %struct.bpf_reg_state* %29, null
  br i1 %tobool27, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then26
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type, align 8
  %call28 = call zeroext i1 @is_spillable_regtype(i32 noundef %31) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then26
  %32 = phi i1 [ false, %if.then26 ], [ %call28, %land.rhs ]
  %frombool = zext i1 %32 to i8
  store i8 %frombool, i8* %sanitize, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %land.end
  %33 = load i32, i32* %i, align 4
  %34 = load i32, i32* %size.addr, align 4
  %cmp30 = icmp slt i32 %33, %34
  br i1 %cmp30, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack32 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %35, i32 0, i32 10
  %36 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack32, align 8
  %37 = load i32, i32* %spi, align 4
  %idxprom33 = sext i32 %37 to i64
  %arrayidx34 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %36, i64 %idxprom33
  %slot_type35 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx34, i32 0, i32 1
  %38 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %38 to i64
  %arrayidx37 = getelementptr [8 x i8], [8 x i8]* %slot_type35, i64 0, i64 %idxprom36
  %39 = load i8, i8* %arrayidx37, align 1
  %conv38 = zext i8 %39 to i32
  %cmp39 = icmp eq i32 %conv38, 0
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %for.body
  store i8 1, i8* %sanitize, align 1
  br label %for.end

if.end42:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end42
  %40 = load i32, i32* %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then41, %for.cond
  %41 = load i8, i8* %sanitize, align 1
  %tobool43 = trunc i8 %41 to i1
  br i1 %tobool43, label %if.then44, label %if.end47

if.then44:                                        ; preds = %for.end
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 24
  %43 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %44 = load i32, i32* %insn_idx.addr, align 4
  %idxprom45 = sext i32 %44 to i64
  %arrayidx46 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %43, i64 %idxprom45
  %sanitize_stack_spill = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx46, i32 0, i32 4
  store i8 1, i8* %sanitize_stack_spill, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.then44, %for.end
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end24
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool49 = icmp ne %struct.bpf_reg_state* %45, null
  br i1 %tobool49, label %land.lhs.true50, label %if.else

land.lhs.true50:                                  ; preds = %if.end48
  %46 = load i32, i32* %size.addr, align 4
  %cmp51 = icmp eq i32 %46, 8
  br i1 %cmp51, label %land.lhs.true53, label %if.else

land.lhs.true53:                                  ; preds = %land.lhs.true50
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call54 = call zeroext i1 @register_is_bounded(%struct.bpf_reg_state* noundef %47) #14
  br i1 %call54, label %land.lhs.true56, label %if.else

land.lhs.true56:                                  ; preds = %land.lhs.true53
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call57 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %48) #14
  br i1 %call57, label %if.else, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %land.lhs.true56
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 20
  %50 = load i8, i8* %bpf_capable, align 8
  %tobool59 = trunc i8 %50 to i1
  br i1 %tobool59, label %if.then61, label %if.else

if.then61:                                        ; preds = %land.lhs.true58
  %51 = load i32, i32* %dst_reg, align 4
  %cmp62 = icmp ne i32 %51, 10
  br i1 %cmp62, label %if.then64, label %if.end69

if.then64:                                        ; preds = %if.then61
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %value_regno.addr, align 4
  %call65 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %52, i32 noundef %53) #14
  store i32 %call65, i32* %err, align 4
  %54 = load i32, i32* %err, align 4
  %tobool66 = icmp ne i32 %54, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.then64
  %55 = load i32, i32* %err, align 4
  store i32 %55, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.then64
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.then61
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %57 = load i32, i32* %spi, align 4
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @save_register_state(%struct.bpf_func_state* noundef %56, i32 noundef %57, %struct.bpf_reg_state* noundef %58) #14
  br label %if.end151

if.else:                                          ; preds = %land.lhs.true58, %land.lhs.true56, %land.lhs.true53, %land.lhs.true50, %if.end48
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool70 = icmp ne %struct.bpf_reg_state* %59, null
  br i1 %tobool70, label %land.lhs.true71, label %if.else88

land.lhs.true71:                                  ; preds = %if.else
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 0
  %61 = load i32, i32* %type72, align 8
  %call73 = call zeroext i1 @is_spillable_regtype(i32 noundef %61) #14
  br i1 %call73, label %if.then75, label %if.else88

if.then75:                                        ; preds = %land.lhs.true71
  %62 = load i32, i32* %size.addr, align 4
  %cmp76 = icmp ne i32 %62, 8
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.then75
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %63, i32 noundef %64, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.215, i64 0, i64 0)) #14
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = bitcast %struct.bpf_verifier_env* %65 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %66, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.305, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end79:                                         ; preds = %if.then75
  %67 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %68 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %cmp80 = icmp ne %struct.bpf_func_state* %67, %68
  br i1 %cmp80, label %land.lhs.true82, label %if.end87

land.lhs.true82:                                  ; preds = %if.end79
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 0
  %70 = load i32, i32* %type83, align 8
  %cmp84 = icmp eq i32 %70, 6
  br i1 %cmp84, label %if.then86, label %if.end87

if.then86:                                        ; preds = %land.lhs.true82
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = bitcast %struct.bpf_verifier_env* %71 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %72, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.306, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end87:                                         ; preds = %land.lhs.true82, %if.end79
  %73 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %74 = load i32, i32* %spi, align 4
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @save_register_state(%struct.bpf_func_state* noundef %73, i32 noundef %74, %struct.bpf_reg_state* noundef %75) #14
  br label %if.end150

if.else88:                                        ; preds = %land.lhs.true71, %if.else
  store i8 2, i8* %type89, align 1
  %76 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack90 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %76, i32 0, i32 10
  %77 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack90, align 8
  %78 = load i32, i32* %spi, align 4
  %idxprom91 = sext i32 %78 to i64
  %arrayidx92 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %77, i64 %idxprom91
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx92, i32 0, i32 0
  %type93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  store i32 0, i32* %type93, align 8
  %79 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack94 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %79, i32 0, i32 10
  %80 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack94, align 8
  %81 = load i32, i32* %spi, align 4
  %idxprom95 = sext i32 %81 to i64
  %arrayidx96 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %80, i64 %idxprom95
  %slot_type97 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx96, i32 0, i32 1
  %arrayidx98 = getelementptr [8 x i8], [8 x i8]* %slot_type97, i64 0, i64 0
  %82 = load i8, i8* %arrayidx98, align 8
  %conv99 = zext i8 %82 to i32
  %cmp100 = icmp eq i32 %conv99, 1
  br i1 %cmp100, label %if.then102, label %if.end116

if.then102:                                       ; preds = %if.else88
  store i32 0, i32* %i, align 4
  br label %for.cond103

for.cond103:                                      ; preds = %for.inc113, %if.then102
  %83 = load i32, i32* %i, align 4
  %cmp104 = icmp slt i32 %83, 8
  br i1 %cmp104, label %for.body106, label %for.end115

for.body106:                                      ; preds = %for.cond103
  %84 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack107 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %84, i32 0, i32 10
  %85 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack107, align 8
  %86 = load i32, i32* %spi, align 4
  %idxprom108 = sext i32 %86 to i64
  %arrayidx109 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %85, i64 %idxprom108
  %slot_type110 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx109, i32 0, i32 1
  %87 = load i32, i32* %i, align 4
  %idxprom111 = sext i32 %87 to i64
  %arrayidx112 = getelementptr [8 x i8], [8 x i8]* %slot_type110, i64 0, i64 %idxprom111
  store i8 2, i8* %arrayidx112, align 1
  br label %for.inc113

for.inc113:                                       ; preds = %for.body106
  %88 = load i32, i32* %i, align 4
  %inc114 = add i32 %88, 1
  store i32 %inc114, i32* %i, align 4
  br label %for.cond103

for.end115:                                       ; preds = %for.cond103
  br label %if.end116

if.end116:                                        ; preds = %for.end115, %if.else88
  %89 = load i32, i32* %size.addr, align 4
  %cmp117 = icmp eq i32 %89, 8
  br i1 %cmp117, label %if.then119, label %if.end125

if.then119:                                       ; preds = %if.end116
  %90 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack120 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %90, i32 0, i32 10
  %91 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack120, align 8
  %92 = load i32, i32* %spi, align 4
  %idxprom121 = sext i32 %92 to i64
  %arrayidx122 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %91, i64 %idxprom121
  %spilled_ptr123 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx122, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr123, i32 0, i32 17
  %93 = load i32, i32* %live, align 8
  %or124 = or i32 %93, 4
  store i32 %or124, i32* %live, align 8
  br label %if.end125

if.end125:                                        ; preds = %if.then119, %if.end116
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool126 = icmp ne %struct.bpf_reg_state* %94, null
  br i1 %tobool126, label %land.lhs.true127, label %if.end135

land.lhs.true127:                                 ; preds = %if.end125
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call128 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %95) #14
  br i1 %call128, label %if.then130, label %if.end135

if.then130:                                       ; preds = %land.lhs.true127
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %97 = load i32, i32* %value_regno.addr, align 4
  %call131 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %96, i32 noundef %97) #14
  store i32 %call131, i32* %err, align 4
  %98 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %98, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.then130
  %99 = load i32, i32* %err, align 4
  store i32 %99, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.then130
  store i8 3, i8* %type89, align 1
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %land.lhs.true127, %if.end125
  store i32 0, i32* %i, align 4
  br label %for.cond136

for.cond136:                                      ; preds = %for.inc147, %if.end135
  %100 = load i32, i32* %i, align 4
  %101 = load i32, i32* %size.addr, align 4
  %cmp137 = icmp slt i32 %100, %101
  br i1 %cmp137, label %for.body139, label %for.end149

for.body139:                                      ; preds = %for.cond136
  %102 = load i8, i8* %type89, align 1
  %103 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack140 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %103, i32 0, i32 10
  %104 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack140, align 8
  %105 = load i32, i32* %spi, align 4
  %idxprom141 = sext i32 %105 to i64
  %arrayidx142 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %104, i64 %idxprom141
  %slot_type143 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx142, i32 0, i32 1
  %106 = load i32, i32* %slot, align 4
  %107 = load i32, i32* %i, align 4
  %sub144 = sub i32 %106, %107
  %rem = srem i32 %sub144, 8
  %idxprom145 = sext i32 %rem to i64
  %arrayidx146 = getelementptr [8 x i8], [8 x i8]* %slot_type143, i64 0, i64 %idxprom145
  store i8 %102, i8* %arrayidx146, align 1
  br label %for.inc147

for.inc147:                                       ; preds = %for.body139
  %108 = load i32, i32* %i, align 4
  %inc148 = add i32 %108, 1
  store i32 %inc148, i32* %i, align 4
  br label %for.cond136

for.end149:                                       ; preds = %for.cond136
  br label %if.end150

if.end150:                                        ; preds = %for.end149, %if.end87
  br label %if.end151

if.end151:                                        ; preds = %if.end150, %if.end69
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end151, %if.then133, %if.then86, %if.then78, %if.then67, %if.then14, %if.then
  %109 = load i32, i32* %retval, align 4
  ret i32 %109
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write_var_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_func_state*, align 8
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %ptr_reg = alloca %struct.bpf_reg_state*, align 8
  %value_reg = alloca %struct.bpf_reg_state*, align 8
  %writing_zero = alloca i8, align 1
  %zero_used = alloca i8, align 1
  %new_type = alloca i8, align 1
  %stype = alloca i8*, align 8
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %ptr_reg, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %value_reg, align 8
  store i8 0, i8* %writing_zero, align 1
  store i8 0, i8* %zero_used, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 0
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state1, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %cur, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %ptr_regno.addr, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom2
  store %struct.bpf_reg_state* %arrayidx3, %struct.bpf_reg_state** %ptr_reg, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %10 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %10 to i64
  %add = add i64 %9, %conv
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %min_off, align 4
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value, align 8
  %13 = load i32, i32* %off.addr, align 4
  %conv5 = sext i32 %13 to i64
  %add6 = add i64 %12, %conv5
  %14 = load i32, i32* %size.addr, align 4
  %conv7 = sext i32 %14 to i64
  %add8 = add i64 %add6, %conv7
  %conv9 = trunc i64 %add8 to i32
  store i32 %conv9, i32* %max_off, align 4
  %15 = load i32, i32* %value_regno.addr, align 4
  %cmp = icmp sge i32 %15, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %16, i32 0, i32 0
  %17 = load i32, i32* %value_regno.addr, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs11, i64 0, i64 %idxprom12
  store %struct.bpf_reg_state* %arrayidx13, %struct.bpf_reg_state** %value_reg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %value_reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %18, null
  br i1 %tobool, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %value_reg, align 8
  %call = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %19) #14
  br i1 %call, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true
  store i8 1, i8* %writing_zero, align 1
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %land.lhs.true, %if.end
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %21 = load i32, i32* %min_off, align 4
  %sub = sub i32 0, %21
  %sub17 = sub i32 %sub, 1
  %or = or i32 %sub17, 7
  %add18 = add i32 %or, 1
  %call19 = call i32 @grow_stack_state(%struct.bpf_func_state* noundef %20, i32 noundef %add18) #14
  store i32 %call19, i32* %err, align 4
  %22 = load i32, i32* %err, align 4
  %tobool20 = icmp ne i32 %22, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end16
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end16
  %24 = load i32, i32* %min_off, align 4
  store i32 %24, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end22
  %25 = load i32, i32* %i, align 4
  %26 = load i32, i32* %max_off, align 4
  %cmp23 = icmp slt i32 %25, %26
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load i32, i32* %i, align 4
  %sub25 = sub i32 0, %27
  %sub26 = sub i32 %sub25, 1
  store i32 %sub26, i32* %slot, align 4
  %28 = load i32, i32* %slot, align 4
  %div = sdiv i32 %28, 8
  store i32 %div, i32* %spi, align 4
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 10
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %31 = load i32, i32* %spi, align 4
  %idxprom27 = sext i32 %31 to i64
  %arrayidx28 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom27
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx28, i32 0, i32 1
  %32 = load i32, i32* %slot, align 4
  %rem = srem i32 %32, 8
  %idxprom29 = sext i32 %rem to i64
  %arrayidx30 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom29
  store i8* %arrayidx30, i8** %stype, align 8
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 17
  %34 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool31 = trunc i8 %34 to i1
  br i1 %tobool31, label %if.end41, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %for.body
  %35 = load i8*, i8** %stype, align 8
  %36 = load i8, i8* %35, align 1
  %conv33 = zext i8 %36 to i32
  %cmp34 = icmp ne i32 %conv33, 0
  br i1 %cmp34, label %land.lhs.true36, label %if.end41

land.lhs.true36:                                  ; preds = %land.lhs.true32
  %37 = load i8*, i8** %stype, align 8
  %38 = load i8, i8* %37, align 1
  %conv37 = zext i8 %38 to i32
  %cmp38 = icmp ne i32 %conv37, 1
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true36
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  %41 = load i32, i32* %insn_idx.addr, align 4
  %42 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.307, i64 0, i64 0), i32 noundef %41, i32 noundef %42) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %land.lhs.true36, %land.lhs.true32, %for.body
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %43, i32 0, i32 10
  %44 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %45 = load i32, i32* %spi, align 4
  %idxprom43 = sext i32 %45 to i64
  %arrayidx44 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %44, i64 %idxprom43
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx44, i32 0, i32 0
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  store i32 0, i32* %type, align 8
  store i8 2, i8* %new_type, align 1
  %46 = load i8, i8* %writing_zero, align 1
  %tobool45 = trunc i8 %46 to i1
  br i1 %tobool45, label %land.lhs.true47, label %if.end52

land.lhs.true47:                                  ; preds = %if.end41
  %47 = load i8*, i8** %stype, align 8
  %48 = load i8, i8* %47, align 1
  %conv48 = zext i8 %48 to i32
  %cmp49 = icmp eq i32 %conv48, 3
  br i1 %cmp49, label %if.then51, label %if.end52

if.then51:                                        ; preds = %land.lhs.true47
  store i8 3, i8* %new_type, align 1
  store i8 1, i8* %zero_used, align 1
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %land.lhs.true47, %if.end41
  %49 = load i8*, i8** %stype, align 8
  %50 = load i8, i8* %49, align 1
  %conv53 = zext i8 %50 to i32
  %cmp54 = icmp eq i32 %conv53, 0
  br i1 %cmp54, label %land.lhs.true56, label %if.end59

land.lhs.true56:                                  ; preds = %if.end52
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_uninit_stack = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 18
  %52 = load i8, i8* %allow_uninit_stack, align 2
  %tobool57 = trunc i8 %52 to i1
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %land.lhs.true56
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %insn_idx.addr, align 4
  %56 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([81 x i8], [81 x i8]* @.str.308, i64 0, i64 0), i32 noundef %55, i32 noundef %56) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end59:                                         ; preds = %land.lhs.true56, %if.end52
  %57 = load i8, i8* %new_type, align 1
  %58 = load i8*, i8** %stype, align 8
  store i8 %57, i8* %58, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end59
  %59 = load i32, i32* %i, align 4
  %inc = add i32 %59, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %60 = load i8, i8* %zero_used, align 1
  %tobool60 = trunc i8 %60 to i1
  br i1 %tobool60, label %if.then61, label %if.end66

if.then61:                                        ; preds = %for.end
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load i32, i32* %value_regno.addr, align 4
  %call62 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %61, i32 noundef %62) #14
  store i32 %call62, i32* %err, align 4
  %63 = load i32, i32* %err, align 4
  %tobool63 = icmp ne i32 %63, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.then61
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.then61
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %for.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end66, %if.then64, %if.then58, %if.then40, %if.then21
  %65 = load i32, i32* %retval, align 4
  ret i32 %65
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @grow_stack_state(%struct.bpf_func_state* noundef %state, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %size.addr = alloca i32, align 4
  %old_n = alloca i64, align 8
  %n = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 9
  %1 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %1, 8
  %conv = sext i32 %div to i64
  store i64 %conv, i64* %old_n, align 8
  %2 = load i32, i32* %size.addr, align 4
  %div1 = sdiv i32 %2, 8
  %conv2 = sext i32 %div1 to i64
  store i64 %conv2, i64* %n, align 8
  %3 = load i64, i64* %old_n, align 8
  %4 = load i64, i64* %n, align 8
  %cmp = icmp uge i64 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 10
  %6 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %7 = bitcast %struct.bpf_stack_state* %6 to i8*
  %8 = load i64, i64* %old_n, align 8
  %9 = load i64, i64* %n, align 8
  %call = call i8* @realloc_array(i8* noundef %7, i64 noundef %8, i64 noundef %9, i64 noundef 128) #14
  %10 = bitcast i8* %call to %struct.bpf_stack_state*
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  store %struct.bpf_stack_state* %10, %struct.bpf_stack_state** %stack4, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 10
  %13 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %tobool = icmp ne %struct.bpf_stack_state* %13, null
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %14 = load i32, i32* %size.addr, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 9
  store i32 %14, i32* %allocated_stack8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_spillable_regtype(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 2, label %sw.bb
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 3, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
    i32 19, label %sw.bb
    i32 20, label %sw.bb
    i32 23, label %sw.bb
    i32 24, label %sw.bb
    i32 25, label %sw.bb
    i32 26, label %sw.bb
    i32 27, label %sw.bb
    i32 21, label %sw.bb
    i32 22, label %sw.bb
    i32 28, label %sw.bb
    i32 29, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_bounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_scalar_unbounded(%struct.bpf_reg_state* noundef %2) #14
  %lnot = xor i1 %call, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @save_register_state(%struct.bpf_func_state* noundef %state, i32 noundef %spi, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %spi.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 10
  %1 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %2 = load i32, i32* %spi.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %1, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %4 = bitcast %struct.bpf_reg_state* %spilled_ptr to i8*
  %5 = bitcast %struct.bpf_reg_state* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 120, i1 false)
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 10
  %7 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %8 = load i32, i32* %spi.addr, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %7, i64 %idxprom2
  %spilled_ptr4 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr4, i32 0, i32 17
  %9 = load i32, i32* %live, align 8
  %or = or i32 %9, 4
  store i32 %or, i32* %live, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %10, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %13 = load i32, i32* %spi.addr, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %14 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %14 to i64
  %arrayidx9 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom8
  store i8 1, i8* %arrayidx9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @realloc_array(i8* noundef %arr, i64 noundef %old_n, i64 noundef %new_n, i64 noundef %size) #0 {
entry:
  %retval = alloca i8*, align 8
  %arr.addr = alloca i8*, align 8
  %old_n.addr = alloca i64, align 8
  %new_n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i8* %arr, i8** %arr.addr, align 8
  store i64 %old_n, i64* %old_n.addr, align 8
  store i64 %new_n, i64* %new_n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i64, i64* %new_n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %old_n.addr, align 8
  %2 = load i64, i64* %new_n.addr, align 8
  %cmp = icmp eq i64 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %out

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i8*, i8** %arr.addr, align 8
  %4 = load i64, i64* %new_n.addr, align 8
  %5 = load i64, i64* %size.addr, align 8
  %call = call i8* @krealloc_array(i8* noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef 3264) #14
  store i8* %call, i8** %arr.addr, align 8
  %6 = load i8*, i8** %arr.addr, align 8
  %tobool1 = icmp ne i8* %6, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i8* null, i8** %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %7 = load i64, i64* %new_n.addr, align 8
  %8 = load i64, i64* %old_n.addr, align 8
  %cmp4 = icmp ugt i64 %7, %8
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %9 = load i8*, i8** %arr.addr, align 8
  %10 = load i64, i64* %old_n.addr, align 8
  %11 = load i64, i64* %size.addr, align 8
  %mul = mul i64 %10, %11
  %add.ptr = getelementptr i8, i8* %9, i64 %mul
  %12 = load i64, i64* %new_n.addr, align 8
  %13 = load i64, i64* %old_n.addr, align 8
  %sub = sub i64 %12, %13
  %14 = load i64, i64* %size.addr, align 8
  %mul6 = mul i64 %sub, %14
  call void @llvm.memset.p0i8.i64(i8* align 1 %add.ptr, i8 0, i64 %mul6, i1 false)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  br label %out

out:                                              ; preds = %if.end7, %if.then
  %15 = load i8*, i8** %arr.addr, align 8
  %tobool8 = icmp ne i8* %15, null
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  %16 = load i8*, i8** %arr.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %16, %cond.true ], [ inttoptr (i64 16 to i8*), %cond.false ]
  store i8* %cond, i8** %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then2
  %17 = load i8*, i8** %retval, align 8
  ret i8* %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @krealloc_array(i8* noundef %p, i64 noundef %new_n, i64 noundef %new_size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %new_n.addr = alloca i64, align 8
  %new_size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i8* %p, i8** %p.addr, align 8
  store i64 %new_n, i64* %new_n.addr, align 8
  store i64 %new_size, i64* %new_size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %new_n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %new_size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #14
  %lnot = xor i1 %call, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8*, i8** %p.addr, align 8
  %11 = load i64, i64* %bytes, align 8
  %12 = load i32, i32* %flags.addr, align 4
  %call6 = call i8* @krealloc(i8* noundef %10, i64 noundef %11, i32 noundef %12) #14
  store i8* %call6, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i8*, i8** %retval, align 8
  ret i8* %13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_scalar_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_unknown(i64 %3, i64 %5) #14
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 6
  %7 = load i64, i64* %smin_value, align 8
  %cmp = icmp eq i64 %7, -9223372036854775808
  br i1 %cmp, label %land.lhs.true1, label %land.end

land.lhs.true1:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  %9 = load i64, i64* %smax_value, align 8
  %cmp2 = icmp eq i64 %9, 9223372036854775807
  br i1 %cmp2, label %land.lhs.true3, label %land.end

land.lhs.true3:                                   ; preds = %land.lhs.true1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  %11 = load i64, i64* %umin_value, align 8
  %cmp4 = icmp eq i64 %11, 0
  br i1 %cmp4, label %land.lhs.true5, label %land.end

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 9
  %13 = load i64, i64* %umax_value, align 8
  %cmp6 = icmp eq i64 %13, -1
  br i1 %cmp6, label %land.lhs.true7, label %land.end

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  %15 = load i32, i32* %s32_min_value, align 8
  %cmp8 = icmp eq i32 %15, -2147483648
  br i1 %cmp8, label %land.lhs.true9, label %land.end

land.lhs.true9:                                   ; preds = %land.lhs.true7
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 11
  %17 = load i32, i32* %s32_max_value, align 4
  %cmp10 = icmp eq i32 %17, 2147483647
  br i1 %cmp10, label %land.lhs.true11, label %land.end

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 12
  %19 = load i32, i32* %u32_min_value, align 8
  %cmp12 = icmp eq i32 %19, 0
  br i1 %cmp12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true11
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value, align 4
  %cmp13 = icmp eq i32 %21, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true11, %land.lhs.true9, %land.lhs.true7, %land.lhs.true5, %land.lhs.true3, %land.lhs.true1, %land.lhs.true, %entry
  %22 = phi i1 [ false, %land.lhs.true11 ], [ false, %land.lhs.true9 ], [ false, %land.lhs.true7 ], [ false, %land.lhs.true5 ], [ false, %land.lhs.true3 ], [ false, %land.lhs.true1 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp13, %land.rhs ]
  ret i1 %22
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_struct_access(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, %struct.btf_type* noundef, i32 noundef, i32 noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %reg_type, %struct.btf* noundef %btf, i32 noundef %btf_id) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %reg_type.addr = alloca i32, align 4
  %btf.addr = alloca %struct.btf*, align 8
  %btf_id.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %reg_type, i32* %reg_type.addr, align 4
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load i32, i32* %reg_type.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %3) #14
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6) #14
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %8 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %8 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i64 %idxprom
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 19, i32* %type, align 8
  %9 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %11 to i64
  %arrayidx2 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom1
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx2, i32 0, i32 2
  %13 = bitcast %union.anon.152* %12 to %struct.anon.154*
  %btf3 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %13, i32 0, i32 0
  store %struct.btf* %9, %struct.btf** %btf3, align 8
  %14 = load i32, i32* %btf_id.addr, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %idxprom4 = zext i32 %16 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i64 %idxprom4
  %17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx5, i32 0, i32 2
  %18 = bitcast %union.anon.152* %17 to %struct.anon.154*
  %btf_id6 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %18, i32 0, i32 1
  store i32 %14, i32* %btf_id6, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_cast(i64, i64, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch_ok(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
    i32 19, label %sw.bb
    i32 20, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 false, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %3) #14
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 10
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_sk_pointer(i32 noundef %3) #14
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_func_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx, i32 noundef %subprog, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef %set_callee_state_cb) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %subprog.addr = alloca i32, align 4
  %set_callee_state_cb.addr = alloca i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %func_info_aux = alloca %struct.bpf_func_info_aux*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %is_global = alloca i8, align 1
  %async_cb = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  store i32 %subprog, i32* %subprog.addr, align 4
  store i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* %set_callee_state_cb, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)** %set_callee_state_cb.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  store i8 0, i8* %is_global, align 1
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %add = add i32 %3, 1
  %cmp = icmp uge i32 %add, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 4
  %7 = load i32, i32* %curframe1, align 8
  %add2 = add i32 %7, 2
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.324, i64 0, i64 0), i32 noundef %add2) #14
  store i32 -7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 0
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 4
  %10 = load i32, i32* %curframe3, align 8
  %idxprom = zext i32 %10 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %11, %struct.bpf_func_state** %caller, align 8
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe5, align 8
  %add6 = add i32 %14, 1
  %idxprom7 = zext i32 %add6 to i64
  %arrayidx8 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame4, i64 0, i64 %idxprom7
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx8, align 8
  %tobool = icmp ne %struct.bpf_func_state* %15, null
  br i1 %tobool, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 4
  %19 = load i32, i32* %curframe10, align 8
  %add11 = add i32 %19, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.325, i64 0, i64 0), i32 noundef %add11) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 10
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_aux13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 49
  %23 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux13, align 8
  store %struct.bpf_func_info_aux* %23, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %24 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %tobool14 = icmp ne %struct.bpf_func_info_aux* %24, null
  br i1 %tobool14, label %if.then15, label %if.end20

if.then15:                                        ; preds = %if.end12
  %25 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %26 = load i32, i32* %subprog.addr, align 4
  %idxprom16 = sext i32 %26 to i64
  %arrayidx17 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %25, i64 %idxprom16
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx17, i32 0, i32 0
  %27 = load i16, i16* %linkage, align 2
  %conv = zext i16 %27 to i32
  %cmp18 = icmp eq i32 %conv, 1
  %frombool = zext i1 %cmp18 to i8
  store i8 %frombool, i8* %is_global, align 1
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %if.end12
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load i32, i32* %subprog.addr, align 4
  %30 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %30, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %call = call i32 @btf_check_subprog_arg_match(%struct.bpf_verifier_env* noundef %28, i32 noundef %29, %struct.bpf_reg_state* noundef %arraydecay) #14
  store i32 %call, i32* %err, align 4
  %31 = load i32, i32* %err, align 4
  %cmp21 = icmp eq i32 %31, -14
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  %32 = load i32, i32* %err, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end20
  %33 = load i8, i8* %is_global, align 1
  %tobool25 = trunc i8 %33 to i1
  br i1 %tobool25, label %if.then26, label %if.end38

if.then26:                                        ; preds = %if.end24
  %34 = load i32, i32* %err, align 4
  %tobool27 = icmp ne i32 %34, 0
  br i1 %tobool27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.then26
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load i32, i32* %subprog.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.326, i64 0, i64 0), i32 noundef %37) #14
  %38 = load i32, i32* %err, align 4
  store i32 %38, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then26
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %39, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %40 = load i32, i32* %level, align 8
  %and = and i32 %40, 3
  %tobool29 = icmp ne i32 %and, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %subprog.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.327, i64 0, i64 0), i32 noundef %43) #14
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs32 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 0
  %arraydecay33 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs32, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %arraydecay33) #14
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs34 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %47, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs34, i64 0, i64 0
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %46, %struct.bpf_reg_state* noundef %arraydecay35, i32 noundef 0) #14
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs36 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 0
  %arrayidx37 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs36, i64 0, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx37, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end24
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %49, i32 0, i32 0
  %50 = load i8, i8* %code, align 4
  %conv39 = zext i8 %50 to i32
  %cmp40 = icmp eq i32 %conv39, 133
  br i1 %cmp40, label %land.lhs.true, label %if.end69

land.lhs.true:                                    ; preds = %if.end38
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 3
  %52 = load i32, i32* %imm, align 4
  %cmp42 = icmp eq i32 %52, 170
  br i1 %cmp42, label %if.then44, label %if.end69

if.then44:                                        ; preds = %land.lhs.true
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 27
  %54 = load i32, i32* %subprog.addr, align 4
  %idxprom45 = sext i32 %54 to i64
  %arrayidx46 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom45
  %is_async_cb = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx46, i32 0, i32 6
  store i8 1, i8* %is_async_cb, align 1
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info47 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %56, i32 0, i32 27
  %57 = load i32, i32* %subprog.addr, align 4
  %idxprom48 = sext i32 %57 to i64
  %arrayidx49 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info47, i64 0, i64 %idxprom48
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx49, i32 0, i32 0
  %58 = load i32, i32* %start, align 8
  %59 = load i32*, i32** %insn_idx.addr, align 8
  %60 = load i32, i32* %59, align 4
  %61 = load i32, i32* %subprog.addr, align 4
  %call50 = call %struct.bpf_verifier_state* @push_async_cb(%struct.bpf_verifier_env* noundef %55, i32 noundef %58, i32 noundef %60, i32 noundef %61) #14
  store %struct.bpf_verifier_state* %call50, %struct.bpf_verifier_state** %async_cb, align 8
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %async_cb, align 8
  %tobool51 = icmp ne %struct.bpf_verifier_state* %62, null
  br i1 %tobool51, label %if.end53, label %if.then52

if.then52:                                        ; preds = %if.then44
  store i32 -14, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.then44
  %63 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %async_cb, align 8
  %frame54 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %63, i32 0, i32 0
  %arrayidx55 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame54, i64 0, i64 0
  %64 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx55, align 8
  store %struct.bpf_func_state* %64, %struct.bpf_func_state** %callee, align 8
  %65 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %async_entry_cnt = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %65, i32 0, i32 4
  %66 = load i32, i32* %async_entry_cnt, align 4
  %add56 = add i32 %66, 1
  %67 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %async_entry_cnt57 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %67, i32 0, i32 4
  store i32 %add56, i32* %async_entry_cnt57, align 4
  %68 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)** %set_callee_state_cb.addr, align 8
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %71 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %72 = load i32*, i32** %insn_idx.addr, align 8
  %73 = load i32, i32* %72, align 4
  %call58 = call i32 %68(%struct.bpf_verifier_env* noundef %69, %struct.bpf_func_state* noundef %70, %struct.bpf_func_state* noundef %71, i32 noundef %73) #14
  store i32 %call58, i32* %err, align 4
  %74 = load i32, i32* %err, align 4
  %tobool59 = icmp ne i32 %74, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end53
  %75 = load i32, i32* %err, align 4
  store i32 %75, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.end53
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs62 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %77, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs62, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %76, %struct.bpf_reg_state* noundef %arraydecay63) #14
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs64 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %79, i32 0, i32 0
  %arraydecay65 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs64, i64 0, i64 0
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %78, %struct.bpf_reg_state* noundef %arraydecay65, i32 noundef 0) #14
  %80 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs66 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %80, i32 0, i32 0
  %arrayidx67 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs66, i64 0, i64 0
  %subreg_def68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx67, i32 0, i32 16
  store i32 0, i32* %subreg_def68, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end69:                                         ; preds = %land.lhs.true, %if.end38
  %call70 = call i8* @kzalloc(i64 noundef 1368, i32 noundef 3264) #14
  %81 = bitcast i8* %call70 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %81, %struct.bpf_func_state** %callee, align 8
  %82 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %tobool71 = icmp ne %struct.bpf_func_state* %82, null
  br i1 %tobool71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %if.end69
  store i32 -12, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %if.end69
  %83 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %84 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame74 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %84, i32 0, i32 0
  %85 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe75 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %85, i32 0, i32 4
  %86 = load i32, i32* %curframe75, align 8
  %add76 = add i32 %86, 1
  %idxprom77 = zext i32 %add76 to i64
  %arrayidx78 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame74, i64 0, i64 %idxprom77
  store %struct.bpf_func_state* %83, %struct.bpf_func_state** %arrayidx78, align 8
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %89 = load i32*, i32** %insn_idx.addr, align 8
  %90 = load i32, i32* %89, align 4
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe79 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %91, i32 0, i32 4
  %92 = load i32, i32* %curframe79, align 8
  %add80 = add i32 %92, 1
  %93 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %87, %struct.bpf_func_state* noundef %88, i32 noundef %90, i32 noundef %add80, i32 noundef %93) #14
  %94 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %call81 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %94, %struct.bpf_func_state* noundef %95) #14
  store i32 %call81, i32* %err, align 4
  %96 = load i32, i32* %err, align 4
  %tobool82 = icmp ne i32 %96, 0
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end73
  %97 = load i32, i32* %err, align 4
  store i32 %97, i32* %retval, align 4
  br label %return

if.end84:                                         ; preds = %if.end73
  %98 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)** %set_callee_state_cb.addr, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %101 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %102 = load i32*, i32** %insn_idx.addr, align 8
  %103 = load i32, i32* %102, align 4
  %call85 = call i32 %98(%struct.bpf_verifier_env* noundef %99, %struct.bpf_func_state* noundef %100, %struct.bpf_func_state* noundef %101, i32 noundef %103) #14
  store i32 %call85, i32* %err, align 4
  %104 = load i32, i32* %err, align 4
  %tobool86 = icmp ne i32 %104, 0
  br i1 %tobool86, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.end84
  %105 = load i32, i32* %err, align 4
  store i32 %105, i32* %retval, align 4
  br label %return

if.end88:                                         ; preds = %if.end84
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs89 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %107, i32 0, i32 0
  %arraydecay90 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs89, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %106, %struct.bpf_reg_state* noundef %arraydecay90) #14
  %108 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe91 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %108, i32 0, i32 4
  %109 = load i32, i32* %curframe91, align 8
  %inc = add i32 %109, 1
  store i32 %inc, i32* %curframe91, align 8
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info92 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %110, i32 0, i32 27
  %111 = load i32, i32* %subprog.addr, align 4
  %idxprom93 = sext i32 %111 to i64
  %arrayidx94 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info92, i64 0, i64 %idxprom93
  %start95 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx94, i32 0, i32 0
  %112 = load i32, i32* %start95, align 8
  %sub = sub i32 %112, 1
  %113 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %sub, i32* %113, align 4
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log96 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %114, i32 0, i32 26
  %level97 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log96, i32 0, i32 0
  %115 = load i32, i32* %level97, align 8
  %and98 = and i32 %115, 3
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.end88
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = bitcast %struct.bpf_verifier_env* %116 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %117, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.328, i64 0, i64 0)) #14
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %119 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %118, %struct.bpf_func_state* noundef %119) #14
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %121 = bitcast %struct.bpf_verifier_env* %120 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %121, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.329, i64 0, i64 0)) #14
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %122, %struct.bpf_func_state* noundef %123) #14
  br label %if.end101

if.end101:                                        ; preds = %if.then100, %if.end88
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end101, %if.then87, %if.then83, %if.then72, %if.end61, %if.then60, %if.then52, %if.end31, %if.then28, %if.then23, %if.then9, %if.then
  %124 = load i32, i32* %retval, align 4
  ret i32 %124
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_callee_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %4 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 %idxprom2
  %5 = bitcast %struct.bpf_reg_state* %arrayidx to i8*
  %6 = bitcast %struct.bpf_reg_state* %arrayidx3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %6, i64 120, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %4) #14
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom1
  %7 = load i32, i32* %arrayidx2, align 4
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %5, i32 noundef %7, i32 noundef 2) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @push_async_cb(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %prev_insn_idx, i32 noundef %subprog) #0 {
entry:
  %retval = alloca %struct.bpf_verifier_state*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %prev_insn_idx.addr = alloca i32, align 4
  %subprog.addr = alloca i32, align 4
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %frame = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %prev_insn_idx, i32* %prev_insn_idx.addr, align 4
  store i32 %subprog, i32* %subprog.addr, align 4
  %call = call i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #14
  %0 = bitcast i8* %call to %struct.bpf_verifier_stack_elem*
  store %struct.bpf_verifier_stack_elem* %0, %struct.bpf_verifier_stack_elem** %elem, align 8
  %1 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %tobool = icmp ne %struct.bpf_verifier_stack_elem* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %insn_idx.addr, align 4
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %insn_idx1 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %3, i32 0, i32 1
  store i32 %2, i32* %insn_idx1, align 8
  %4 = load i32, i32* %prev_insn_idx.addr, align 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %5, i32 0, i32 2
  store i32 %4, i32* %prev_insn_idx2, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 4
  %7 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %8 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %8, i32 0, i32 3
  store %struct.bpf_verifier_stack_elem* %7, %struct.bpf_verifier_stack_elem** %next, align 8
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 26
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 3
  %10 = load i32, i32* %len_used, align 8
  %11 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %11, i32 0, i32 4
  store i32 %10, i32* %log_pos, align 8
  %12 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %12, %struct.bpf_verifier_stack_elem** %head3, align 8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 5
  %15 = load i32, i32* %stack_size, align 8
  %inc = add i32 %15, 1
  store i32 %inc, i32* %stack_size, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 5
  %17 = load i32, i32* %stack_size4, align 8
  %cmp = icmp sgt i32 %17, 8192
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 5
  %21 = load i32, i32* %stack_size6, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.330, i64 0, i64 0), i32 noundef %21) #14
  br label %err

if.end7:                                          ; preds = %if.end
  %22 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %22, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st, i32 0, i32 2
  store i32 1, i32* %branches, align 8
  %call8 = call i8* @kzalloc(i64 noundef 1368, i32 noundef 3264) #14
  %23 = bitcast i8* %call8 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %23, %struct.bpf_func_state** %frame, align 8
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %tobool9 = icmp ne %struct.bpf_func_state* %24, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  br label %err

if.end11:                                         ; preds = %if.end7
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %27 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %25, %struct.bpf_func_state* noundef %26, i32 noundef -1, i32 noundef 0, i32 noundef %27) #14
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %29 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st12 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %29, i32 0, i32 0
  %frame13 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st12, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame13, i64 0, i64 0
  store %struct.bpf_func_state* %28, %struct.bpf_func_state** %arrayidx, align 8
  %30 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st14 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %30, i32 0, i32 0
  store %struct.bpf_verifier_state* %st14, %struct.bpf_verifier_state** %retval, align 8
  br label %return

err:                                              ; preds = %if.then10, %if.then5, %if.then
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 8
  %32 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %32, i1 noundef zeroext true) #14
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state15, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call16 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %34, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #14
  %tobool17 = icmp ne i32 %call16, 0
  %lnot = xor i1 %tobool17, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end11
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %retval, align 8
  ret %struct.bpf_verifier_state* %35
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_kfunc_arg_match(%struct.bpf_verifier_env* noundef, %struct.btf* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_scalar(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call = call zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %0) #14
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call1 = call zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %1) #14
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i64 noundef %reg_size) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg_size.addr = alloca i64, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i64 %reg_size, i64* %reg_size.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  %1 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 17
  %4 = load i32, i32* %live, align 8
  %or = or i32 %4, 4
  store i32 %or, i32* %live, align 8
  %5 = load i64, i64* %reg_size.addr, align 8
  %cmp1 = icmp eq i64 %5, 8
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 0
  %7 = load i32, i32* %insn_idx, align 8
  %add = add i32 %7, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 16
  store i32 %cond, i32* %subreg_def, align 4
  br label %if.end8

if.else:                                          ; preds = %entry
  %9 = load i64, i64* %reg_size.addr, align 8
  %cmp2 = icmp eq i64 %9, 8
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %10, %struct.bpf_reg_state* noundef %11) #14
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 14
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call4 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %13, %struct.bpf_reg_state* noundef %15, i8 noundef zeroext 2) #14
  br label %if.end

if.else5:                                         ; preds = %if.else
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 14
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent6, align 8
  %call7 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %16, %struct.bpf_reg_state* noundef %17, %struct.bpf_reg_state* noundef %19, i8 noundef zeroext 1) #14
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then3
  br label %if.end8

if.end8:                                          ; preds = %if.end, %cond.end
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @btf_type_str(%struct.btf_type* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @func_id_name(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_proto(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call = call zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %0) #14
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call1 = call zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %1) #14
  br i1 %call1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call3 = call zeroext i1 @check_btf_id_ok(%struct.bpf_func_proto* noundef %2) #14
  br i1 %call3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true2
  %3 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %4 = load i32, i32* %func_id.addr, align 4
  %call4 = call zeroext i1 @check_refcount_ok(%struct.bpf_func_proto* noundef %3, i32 noundef %4) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true2, %land.lhs.true, %entry
  %5 = phi i1 [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %call4, %land.rhs ]
  %6 = zext i1 %5 to i64
  %cond = select i1 %5, i32 0, i32 -22
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %arg, %struct.bpf_call_arg_meta* noundef %meta, %struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %arg.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %regno = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %arg_type = alloca i32, align 4
  %type = alloca i32, align 4
  %err = alloca i32, align 4
  %zero_size_allowed = alloca i8, align 1
  %size = alloca i32, align 4
  %map = alloca %struct.bpf_map*, align 8
  %map_off = alloca i32, align 4
  %map_addr = alloca i64, align 8
  %str_ptr = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load i32, i32* %arg.addr, align 4
  %add = add i32 1, %0
  store i32 %add, i32* %regno, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %regno, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %5 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 4
  %arg_type1 = bitcast %union.anon.157* %5 to [5 x i32]*
  %6 = load i32, i32* %arg.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr [5 x i32], [5 x i32]* %arg_type1, i64 0, i64 %idxprom2
  %7 = load i32, i32* %arrayidx3, align 4
  store i32 %7, i32* %arg_type, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type4, align 8
  store i32 %9, i32* %type, align 4
  store i32 0, i32* %err, align 4
  %10 = load i32, i32* %arg_type, align 4
  %cmp = icmp eq i32 %10, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno, align 4
  %call5 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef 0) #14
  store i32 %call5, i32* %err, align 4
  %13 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %14 = load i32, i32* %err, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %15 = load i32, i32* %arg_type, align 4
  %cmp8 = icmp eq i32 %15, 13
  br i1 %cmp8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end7
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load i32, i32* %regno, align 4
  %call10 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %16, i32 noundef %17) #14
  br i1 %call10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then9
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.347, i64 0, i64 0), i32 noundef %20) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.then9
  store i32 0, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end7
  %21 = load i32, i32* %type, align 4
  %call14 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %21) #14
  br i1 %call14, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end13
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call15 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %22, %struct.bpf_call_arg_meta* noundef %23, i32 noundef 1) #14
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %land.lhs.true
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.348, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.end13
  %26 = load i32, i32* %arg_type, align 4
  %cmp18 = icmp eq i32 %26, 3
  br i1 %cmp18, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end17
  %27 = load i32, i32* %arg_type, align 4
  %cmp19 = icmp eq i32 %27, 4
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false
  %28 = load i32, i32* %arg_type, align 4
  %cmp21 = icmp eq i32 %28, 5
  br i1 %cmp21, label %if.then22, label %if.end27

if.then22:                                        ; preds = %lor.lhs.false20, %lor.lhs.false, %if.end17
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call23 = call i32 @resolve_map_arg_type(%struct.bpf_verifier_env* noundef %29, %struct.bpf_call_arg_meta* noundef %30, i32* noundef %arg_type) #14
  store i32 %call23, i32* %err, align 4
  %31 = load i32, i32* %err, align 4
  %tobool24 = icmp ne i32 %31, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then22
  %32 = load i32, i32* %err, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.then22
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %lor.lhs.false20
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call28 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %33) #14
  br i1 %call28, label %land.lhs.true29, label %if.end32

land.lhs.true29:                                  ; preds = %if.end27
  %34 = load i32, i32* %arg_type, align 4
  %call30 = call zeroext i1 @arg_type_may_be_null(i32 noundef %34) #14
  br i1 %call30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true29
  br label %skip_type_check

if.end32:                                         ; preds = %land.lhs.true29, %if.end27
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load i32, i32* %regno, align 4
  %37 = load i32, i32* %arg_type, align 4
  %38 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %39 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %38, i32 0, i32 5
  %arg_btf_id = bitcast %union.anon.159* %39 to [5 x i32*]*
  %40 = load i32, i32* %arg.addr, align 4
  %idxprom33 = zext i32 %40 to i64
  %arrayidx34 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id, i64 0, i64 %idxprom33
  %41 = load i32*, i32** %arrayidx34, align 8
  %call35 = call i32 @check_reg_type(%struct.bpf_verifier_env* noundef %35, i32 noundef %36, i32 noundef %37, i32* noundef %41) #14
  store i32 %call35, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %tobool36 = icmp ne i32 %42, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end32
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end32
  %44 = load i32, i32* %type, align 4
  %cmp39 = icmp eq i32 %44, 2
  br i1 %cmp39, label %if.then40, label %if.end45

if.then40:                                        ; preds = %if.end38
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = load i32, i32* %regno, align 4
  %call41 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %45, %struct.bpf_reg_state* noundef %46, i32 noundef %47) #14
  store i32 %call41, i32* %err, align 4
  %48 = load i32, i32* %err, align 4
  %cmp42 = icmp slt i32 %48, 0
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.then40
  %49 = load i32, i32* %err, align 4
  store i32 %49, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.then40
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end38
  br label %skip_type_check

skip_type_check:                                  ; preds = %if.end45, %if.then31
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 4
  %51 = load i32, i32* %ref_obj_id, align 4
  %tobool46 = icmp ne i32 %51, 0
  br i1 %tobool46, label %if.then47, label %if.end56

if.then47:                                        ; preds = %skip_type_check
  %52 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id48 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %52, i32 0, i32 7
  %53 = load i32, i32* %ref_obj_id48, align 8
  %tobool49 = icmp ne i32 %53, 0
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %if.then47
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load i32, i32* %regno, align 4
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 4
  %58 = load i32, i32* %ref_obj_id51, align 4
  %59 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id52 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %59, i32 0, i32 7
  %60 = load i32, i32* %ref_obj_id52, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([70 x i8], [70 x i8]* @.str.349, i64 0, i64 0), i32 noundef %56, i32 noundef %58, i32 noundef %60) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.then47
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 4
  %62 = load i32, i32* %ref_obj_id54, align 4
  %63 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id55 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %63, i32 0, i32 7
  store i32 %62, i32* %ref_obj_id55, align 8
  br label %if.end56

if.end56:                                         ; preds = %if.end53, %skip_type_check
  %64 = load i32, i32* %arg_type, align 4
  %cmp57 = icmp eq i32 %64, 1
  br i1 %cmp57, label %if.then58, label %if.else

if.then58:                                        ; preds = %if.end56
  %65 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %65, i32 0, i32 0
  %66 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %tobool59 = icmp ne %struct.bpf_map* %66, null
  br i1 %tobool59, label %if.then60, label %if.end71

if.then60:                                        ; preds = %if.then58
  %67 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr61 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %67, i32 0, i32 0
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr61, align 8
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 2
  %71 = bitcast %union.anon.152* %70 to %struct.anon.153*
  %map_ptr62 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %71, i32 0, i32 0
  %72 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr62, align 8
  %cmp63 = icmp ne %struct.bpf_map* %68, %72
  br i1 %cmp63, label %if.then67, label %lor.lhs.false64

lor.lhs.false64:                                  ; preds = %if.then60
  %73 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %73, i32 0, i32 8
  %74 = load i32, i32* %map_uid, align 4
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 2
  %77 = bitcast %union.anon.152* %76 to %struct.anon.153*
  %map_uid65 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %77, i32 0, i32 1
  %78 = load i32, i32* %map_uid65, align 8
  %cmp66 = icmp ne i32 %74, %78
  br i1 %cmp66, label %if.then67, label %if.end70

if.then67:                                        ; preds = %lor.lhs.false64, %if.then60
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %80 = bitcast %struct.bpf_verifier_env* %79 to i8*
  %81 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid68 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %81, i32 0, i32 8
  %82 = load i32, i32* %map_uid68, align 4
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %84 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 2
  %85 = bitcast %union.anon.152* %84 to %struct.anon.153*
  %map_uid69 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %85, i32 0, i32 1
  %86 = load i32, i32* %map_uid69, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %80, i8* noundef getelementptr inbounds ([75 x i8], [75 x i8]* @.str.350, i64 0, i64 0), i32 noundef %82, i32 noundef %86) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %lor.lhs.false64
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.then58
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i32 0, i32 2
  %89 = bitcast %union.anon.152* %88 to %struct.anon.153*
  %map_ptr72 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %89, i32 0, i32 0
  %90 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr72, align 8
  %91 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr73 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %91, i32 0, i32 0
  store %struct.bpf_map* %90, %struct.bpf_map** %map_ptr73, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 2
  %94 = bitcast %union.anon.152* %93 to %struct.anon.153*
  %map_uid74 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %94, i32 0, i32 1
  %95 = load i32, i32* %map_uid74, align 8
  %96 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid75 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %96, i32 0, i32 8
  store i32 %95, i32* %map_uid75, align 4
  br label %if.end245

if.else:                                          ; preds = %if.end56
  %97 = load i32, i32* %arg_type, align 4
  %cmp76 = icmp eq i32 %97, 2
  br i1 %cmp76, label %if.then77, label %if.else84

if.then77:                                        ; preds = %if.else
  %98 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr78 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %98, i32 0, i32 0
  %99 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr78, align 8
  %tobool79 = icmp ne %struct.bpf_map* %99, null
  br i1 %tobool79, label %if.end81, label %if.then80

if.then80:                                        ; preds = %if.then77
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = bitcast %struct.bpf_verifier_env* %100 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %101, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.351, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.then77
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = load i32, i32* %regno, align 4
  %104 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr82 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %104, i32 0, i32 0
  %105 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr82, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %105, i32 0, i32 4
  %106 = load i32, i32* %key_size, align 4
  %call83 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %102, i32 noundef %103, i32 noundef %106, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef null) #14
  store i32 %call83, i32* %err, align 4
  br label %if.end244

if.else84:                                        ; preds = %if.else
  %107 = load i32, i32* %arg_type, align 4
  %cmp85 = icmp eq i32 %107, 3
  br i1 %cmp85, label %if.then92, label %lor.lhs.false86

lor.lhs.false86:                                  ; preds = %if.else84
  %108 = load i32, i32* %arg_type, align 4
  %cmp87 = icmp eq i32 %108, 5
  br i1 %cmp87, label %land.lhs.true88, label %lor.lhs.false90

land.lhs.true88:                                  ; preds = %lor.lhs.false86
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call89 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %109) #14
  br i1 %call89, label %lor.lhs.false90, label %if.then92

lor.lhs.false90:                                  ; preds = %land.lhs.true88, %lor.lhs.false86
  %110 = load i32, i32* %arg_type, align 4
  %cmp91 = icmp eq i32 %110, 4
  br i1 %cmp91, label %if.then92, label %if.else100

if.then92:                                        ; preds = %lor.lhs.false90, %land.lhs.true88, %if.else84
  %111 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr93 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %111, i32 0, i32 0
  %112 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr93, align 8
  %tobool94 = icmp ne %struct.bpf_map* %112, null
  br i1 %tobool94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %if.then92
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %114 = bitcast %struct.bpf_verifier_env* %113 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %114, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.352, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end96:                                         ; preds = %if.then92
  %115 = load i32, i32* %arg_type, align 4
  %cmp97 = icmp eq i32 %115, 4
  %116 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %116, i32 0, i32 1
  %frombool = zext i1 %cmp97 to i8
  store i8 %frombool, i8* %raw_mode, align 8
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %118 = load i32, i32* %regno, align 4
  %119 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr98 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %119, i32 0, i32 0
  %120 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr98, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %120, i32 0, i32 5
  %121 = load i32, i32* %value_size, align 32
  %122 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call99 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %117, i32 noundef %118, i32 noundef %121, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %122) #14
  store i32 %call99, i32* %err, align 4
  br label %if.end243

if.else100:                                       ; preds = %lor.lhs.false90
  %123 = load i32, i32* %arg_type, align 4
  %cmp101 = icmp eq i32 %123, 25
  br i1 %cmp101, label %if.then102, label %if.else107

if.then102:                                       ; preds = %if.else100
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %125 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 2
  %126 = bitcast %union.anon.152* %125 to %struct.anon.154*
  %btf_id = getelementptr inbounds %struct.anon.154, %struct.anon.154* %126, i32 0, i32 1
  %127 = load i32, i32* %btf_id, align 8
  %tobool103 = icmp ne i32 %127, 0
  br i1 %tobool103, label %if.end105, label %if.then104

if.then104:                                       ; preds = %if.then102
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %129 = bitcast %struct.bpf_verifier_env* %128 to i8*
  %130 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %129, i8* noundef getelementptr inbounds ([34 x i8], [34 x i8]* @.str.353, i64 0, i64 0), i32 noundef %130) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %if.then102
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i32 0, i32 2
  %133 = bitcast %union.anon.152* %132 to %struct.anon.154*
  %btf = getelementptr inbounds %struct.anon.154, %struct.anon.154* %133, i32 0, i32 0
  %134 = load %struct.btf*, %struct.btf** %btf, align 8
  %135 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ret_btf = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %135, i32 0, i32 12
  store %struct.btf* %134, %struct.btf** %ret_btf, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %137 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 2
  %138 = bitcast %union.anon.152* %137 to %struct.anon.154*
  %btf_id106 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %138, i32 0, i32 1
  %139 = load i32, i32* %btf_id106, align 8
  %140 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ret_btf_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %140, i32 0, i32 13
  store i32 %139, i32* %ret_btf_id, align 8
  br label %if.end242

if.else107:                                       ; preds = %if.else100
  %141 = load i32, i32* %arg_type, align 4
  %cmp108 = icmp eq i32 %141, 14
  br i1 %cmp108, label %if.then109, label %if.else127

if.then109:                                       ; preds = %if.else107
  %142 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %142, i32 0, i32 9
  %143 = load i32, i32* %func_id, align 8
  %cmp110 = icmp eq i32 %143, 93
  br i1 %cmp110, label %if.then111, label %if.else116

if.then111:                                       ; preds = %if.then109
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %145 = load i32, i32* %regno, align 4
  %call112 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %144, i32 noundef %145, i1 noundef zeroext true) #14
  %tobool113 = icmp ne i32 %call112, 0
  br i1 %tobool113, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.then111
  store i32 -13, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %if.then111
  br label %if.end126

if.else116:                                       ; preds = %if.then109
  %146 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id117 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %146, i32 0, i32 9
  %147 = load i32, i32* %func_id117, align 8
  %cmp118 = icmp eq i32 %147, 94
  br i1 %cmp118, label %if.then119, label %if.else124

if.then119:                                       ; preds = %if.else116
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %149 = load i32, i32* %regno, align 4
  %call120 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %148, i32 noundef %149, i1 noundef zeroext false) #14
  %tobool121 = icmp ne i32 %call120, 0
  br i1 %tobool121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %if.then119
  store i32 -13, i32* %retval, align 4
  br label %return

if.end123:                                        ; preds = %if.then119
  br label %if.end125

if.else124:                                       ; preds = %if.else116
  %150 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %151 = bitcast %struct.bpf_verifier_env* %150 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %151, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.354, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end125:                                        ; preds = %if.end123
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.end115
  br label %if.end241

if.else127:                                       ; preds = %if.else107
  %152 = load i32, i32* %arg_type, align 4
  %cmp128 = icmp eq i32 %152, 29
  br i1 %cmp128, label %if.then129, label %if.else134

if.then129:                                       ; preds = %if.else127
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = load i32, i32* %regno, align 4
  %155 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call130 = call i32 @process_timer_func(%struct.bpf_verifier_env* noundef %153, i32 noundef %154, %struct.bpf_call_arg_meta* noundef %155) #14
  %tobool131 = icmp ne i32 %call130, 0
  br i1 %tobool131, label %if.then132, label %if.end133

if.then132:                                       ; preds = %if.then129
  store i32 -13, i32* %retval, align 4
  br label %return

if.end133:                                        ; preds = %if.then129
  br label %if.end240

if.else134:                                       ; preds = %if.else127
  %156 = load i32, i32* %arg_type, align 4
  %cmp135 = icmp eq i32 %156, 26
  br i1 %cmp135, label %if.then136, label %if.else138

if.then136:                                       ; preds = %if.else134
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %158 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %157, i32 0, i32 2
  %subprogno = bitcast %union.anon.152* %158 to i32*
  %159 = load i32, i32* %subprogno, align 8
  %160 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %subprogno137 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %160, i32 0, i32 14
  store i32 %159, i32* %subprogno137, align 4
  br label %if.end239

if.else138:                                       ; preds = %if.else134
  %161 = load i32, i32* %arg_type, align 4
  %call139 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %161) #14
  br i1 %call139, label %if.then140, label %if.else144

if.then140:                                       ; preds = %if.else138
  %162 = load i32, i32* %arg_type, align 4
  %cmp141 = icmp eq i32 %162, 8
  %163 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode142 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %163, i32 0, i32 1
  %frombool143 = zext i1 %cmp141 to i8
  store i8 %frombool143, i8* %raw_mode142, align 8
  br label %if.end238

if.else144:                                       ; preds = %if.else138
  %164 = load i32, i32* %arg_type, align 4
  %call145 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %164) #14
  br i1 %call145, label %if.then146, label %if.else175

if.then146:                                       ; preds = %if.else144
  %165 = load i32, i32* %arg_type, align 4
  %cmp147 = icmp eq i32 %165, 10
  %frombool148 = zext i1 %cmp147 to i8
  store i8 %frombool148, i8* %zero_size_allowed, align 1
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 9
  %167 = load i64, i64* %umax_value, align 8
  %168 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %168, i32 0, i32 6
  store i64 %167, i64* %msize_max_value, align 8
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %169, i32 0, i32 5
  %170 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %171 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %170, i32 0, i32 0
  %172 = load i64, i64* %171, align 8
  %173 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %170, i32 0, i32 1
  %174 = load i64, i64* %173, align 8
  %call149 = call zeroext i1 @tnum_is_const(i64 %172, i64 %174) #14
  br i1 %call149, label %if.end151, label %if.then150

if.then150:                                       ; preds = %if.then146
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end151

if.end151:                                        ; preds = %if.then150, %if.then146
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %175, i32 0, i32 6
  %176 = load i64, i64* %smin_value, align 8
  %cmp152 = icmp slt i64 %176, 0
  br i1 %cmp152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.end151
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %178 = bitcast %struct.bpf_verifier_env* %177 to i8*
  %179 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %178, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.355, i64 0, i64 0), i32 noundef %179) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end154:                                        ; preds = %if.end151
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %180, i32 0, i32 8
  %181 = load i64, i64* %umin_value, align 8
  %cmp155 = icmp eq i64 %181, 0
  br i1 %cmp155, label %if.then156, label %if.end162

if.then156:                                       ; preds = %if.end154
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %183 = load i32, i32* %regno, align 4
  %sub = sub i32 %183, 1
  %184 = load i8, i8* %zero_size_allowed, align 1
  %tobool157 = trunc i8 %184 to i1
  %185 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call158 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %182, i32 noundef %sub, i32 noundef 0, i1 noundef zeroext %tobool157, %struct.bpf_call_arg_meta* noundef %185) #14
  store i32 %call158, i32* %err, align 4
  %186 = load i32, i32* %err, align 4
  %tobool159 = icmp ne i32 %186, 0
  br i1 %tobool159, label %if.then160, label %if.end161

if.then160:                                       ; preds = %if.then156
  %187 = load i32, i32* %err, align 4
  store i32 %187, i32* %retval, align 4
  br label %return

if.end161:                                        ; preds = %if.then156
  br label %if.end162

if.end162:                                        ; preds = %if.end161, %if.end154
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value163 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i32 0, i32 9
  %189 = load i64, i64* %umax_value163, align 8
  %cmp164 = icmp uge i64 %189, 536870912
  br i1 %cmp164, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.end162
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %191 = bitcast %struct.bpf_verifier_env* %190 to i8*
  %192 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %191, i8* noundef getelementptr inbounds ([71 x i8], [71 x i8]* @.str.356, i64 0, i64 0), i32 noundef %192) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end166:                                        ; preds = %if.end162
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = load i32, i32* %regno, align 4
  %sub167 = sub i32 %194, 1
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value168 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %195, i32 0, i32 9
  %196 = load i64, i64* %umax_value168, align 8
  %conv = trunc i64 %196 to i32
  %197 = load i8, i8* %zero_size_allowed, align 1
  %tobool169 = trunc i8 %197 to i1
  %198 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call170 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %193, i32 noundef %sub167, i32 noundef %conv, i1 noundef zeroext %tobool169, %struct.bpf_call_arg_meta* noundef %198) #14
  store i32 %call170, i32* %err, align 4
  %199 = load i32, i32* %err, align 4
  %tobool171 = icmp ne i32 %199, 0
  br i1 %tobool171, label %if.end174, label %if.then172

if.then172:                                       ; preds = %if.end166
  %200 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %201 = load i32, i32* %regno, align 4
  %call173 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %200, i32 noundef %201) #14
  store i32 %call173, i32* %err, align 4
  br label %if.end174

if.end174:                                        ; preds = %if.then172, %if.end166
  br label %if.end237

if.else175:                                       ; preds = %if.else144
  %202 = load i32, i32* %arg_type, align 4
  %call176 = call zeroext i1 @arg_type_is_alloc_size(i32 noundef %202) #14
  br i1 %call176, label %if.then177, label %if.else184

if.then177:                                       ; preds = %if.else175
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i32 0, i32 5
  %204 = bitcast %struct.tnum* %var_off178 to { i64, i64 }*
  %205 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %204, i32 0, i32 0
  %206 = load i64, i64* %205, align 8
  %207 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %204, i32 0, i32 1
  %208 = load i64, i64* %207, align 8
  %call179 = call zeroext i1 @tnum_is_const(i64 %206, i64 %208) #14
  br i1 %call179, label %if.end181, label %if.then180

if.then180:                                       ; preds = %if.then177
  %209 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %210 = bitcast %struct.bpf_verifier_env* %209 to i8*
  %211 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %210, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.357, i64 0, i64 0), i32 noundef %211) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end181:                                        ; preds = %if.then177
  %212 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %212, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off182, i32 0, i32 0
  %213 = load i64, i64* %value, align 8
  %conv183 = trunc i64 %213 to i32
  %214 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %mem_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %214, i32 0, i32 5
  store i32 %conv183, i32* %mem_size, align 4
  br label %if.end236

if.else184:                                       ; preds = %if.else175
  %215 = load i32, i32* %arg_type, align 4
  %call185 = call zeroext i1 @arg_type_is_int_ptr(i32 noundef %215) #14
  br i1 %call185, label %if.then186, label %if.else193

if.then186:                                       ; preds = %if.else184
  %216 = load i32, i32* %arg_type, align 4
  %call187 = call i32 @int_ptr_type_to_size(i32 noundef %216) #14
  store i32 %call187, i32* %size, align 4
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %218 = load i32, i32* %regno, align 4
  %219 = load i32, i32* %size, align 4
  %220 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call188 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %217, i32 noundef %218, i32 noundef %219, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %220) #14
  store i32 %call188, i32* %err, align 4
  %221 = load i32, i32* %err, align 4
  %tobool189 = icmp ne i32 %221, 0
  br i1 %tobool189, label %if.then190, label %if.end191

if.then190:                                       ; preds = %if.then186
  %222 = load i32, i32* %err, align 4
  store i32 %222, i32* %retval, align 4
  br label %return

if.end191:                                        ; preds = %if.then186
  %223 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %225 = load i32, i32* %size, align 4
  %call192 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %223, %struct.bpf_reg_state* noundef %224, i32 noundef 0, i32 noundef %225, i1 noundef zeroext true) #14
  store i32 %call192, i32* %err, align 4
  br label %if.end235

if.else193:                                       ; preds = %if.else184
  %226 = load i32, i32* %arg_type, align 4
  %cmp194 = icmp eq i32 %226, 28
  br i1 %cmp194, label %if.then196, label %if.end234

if.then196:                                       ; preds = %if.else193
  %227 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %228 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %227, i32 0, i32 2
  %229 = bitcast %union.anon.152* %228 to %struct.anon.153*
  %map_ptr197 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %229, i32 0, i32 0
  %230 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr197, align 8
  store %struct.bpf_map* %230, %struct.bpf_map** %map, align 8
  %231 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call198 = call zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %231) #14
  br i1 %call198, label %if.end200, label %if.then199

if.then199:                                       ; preds = %if.then196
  %232 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %233 = bitcast %struct.bpf_verifier_env* %232 to i8*
  %234 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %233, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.358, i64 0, i64 0), i32 noundef %234) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end200:                                        ; preds = %if.then196
  %235 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off201 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %235, i32 0, i32 5
  %236 = bitcast %struct.tnum* %var_off201 to { i64, i64 }*
  %237 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %236, i32 0, i32 0
  %238 = load i64, i64* %237, align 8
  %239 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %236, i32 0, i32 1
  %240 = load i64, i64* %239, align 8
  %call202 = call zeroext i1 @tnum_is_const(i64 %238, i64 %240) #14
  br i1 %call202, label %if.end204, label %if.then203

if.then203:                                       ; preds = %if.end200
  %241 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %242 = bitcast %struct.bpf_verifier_env* %241 to i8*
  %243 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %242, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.359, i64 0, i64 0), i32 noundef %243) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end204:                                        ; preds = %if.end200
  %244 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %244, i32 0, i32 0
  %245 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %245, i32 0, i32 27
  %246 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool205 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %246, null
  br i1 %tobool205, label %if.end207, label %if.then206

if.then206:                                       ; preds = %if.end204
  %247 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %248 = bitcast %struct.bpf_verifier_env* %247 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %248, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.176, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end207:                                        ; preds = %if.end204
  %249 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %250 = load i32, i32* %regno, align 4
  %251 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %251, i32 0, i32 1
  %252 = load i32, i32* %off, align 4
  %253 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size208 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %253, i32 0, i32 5
  %254 = load i32, i32* %value_size208, align 32
  %255 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off209 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %255, i32 0, i32 1
  %256 = load i32, i32* %off209, align 4
  %sub210 = sub i32 %254, %256
  %call211 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %249, i32 noundef %250, i32 noundef %252, i32 noundef %sub210, i1 noundef zeroext false) #14
  store i32 %call211, i32* %err, align 4
  %257 = load i32, i32* %err, align 4
  %tobool212 = icmp ne i32 %257, 0
  br i1 %tobool212, label %if.then213, label %if.end214

if.then213:                                       ; preds = %if.end207
  %258 = load i32, i32* %err, align 4
  store i32 %258, i32* %retval, align 4
  br label %return

if.end214:                                        ; preds = %if.end207
  %259 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %259, i32 0, i32 1
  %260 = load i32, i32* %off215, align 4
  %conv216 = sext i32 %260 to i64
  %261 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off217 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %261, i32 0, i32 5
  %value218 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off217, i32 0, i32 0
  %262 = load i64, i64* %value218, align 8
  %add219 = add i64 %conv216, %262
  %conv220 = trunc i64 %add219 to i32
  store i32 %conv220, i32* %map_off, align 4
  %263 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops221 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %263, i32 0, i32 0
  %264 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops221, align 64
  %map_direct_value_addr222 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %264, i32 0, i32 27
  %265 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr222, align 8
  %266 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %267 = load i32, i32* %map_off, align 4
  %call223 = call i32 %265(%struct.bpf_map* noundef %266, i64* noundef %map_addr, i32 noundef %267) #14
  store i32 %call223, i32* %err, align 4
  %268 = load i32, i32* %err, align 4
  %tobool224 = icmp ne i32 %268, 0
  br i1 %tobool224, label %if.then225, label %if.end226

if.then225:                                       ; preds = %if.end214
  %269 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %270 = bitcast %struct.bpf_verifier_env* %269 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %270, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.360, i64 0, i64 0)) #14
  %271 = load i32, i32* %err, align 4
  store i32 %271, i32* %retval, align 4
  br label %return

if.end226:                                        ; preds = %if.end214
  %272 = load i64, i64* %map_addr, align 8
  %273 = inttoptr i64 %272 to i8*
  store i8* %273, i8** %str_ptr, align 8
  %274 = load i8*, i8** %str_ptr, align 8
  %275 = load i32, i32* %map_off, align 4
  %idx.ext = sext i32 %275 to i64
  %add.ptr = getelementptr i8, i8* %274, i64 %idx.ext
  %276 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size227 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %276, i32 0, i32 5
  %277 = load i32, i32* %value_size227, align 32
  %278 = load i32, i32* %map_off, align 4
  %sub228 = sub i32 %277, %278
  %conv229 = zext i32 %sub228 to i64
  %call230 = call i8* @strnchr(i8* noundef %add.ptr, i64 noundef %conv229, i32 noundef 0) #14
  %tobool231 = icmp ne i8* %call230, null
  br i1 %tobool231, label %if.end233, label %if.then232

if.then232:                                       ; preds = %if.end226
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %280 = bitcast %struct.bpf_verifier_env* %279 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %280, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.361, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end233:                                        ; preds = %if.end226
  br label %if.end234

if.end234:                                        ; preds = %if.end233, %if.else193
  br label %if.end235

if.end235:                                        ; preds = %if.end234, %if.end191
  br label %if.end236

if.end236:                                        ; preds = %if.end235, %if.end181
  br label %if.end237

if.end237:                                        ; preds = %if.end236, %if.end174
  br label %if.end238

if.end238:                                        ; preds = %if.end237, %if.then140
  br label %if.end239

if.end239:                                        ; preds = %if.end238, %if.then136
  br label %if.end240

if.end240:                                        ; preds = %if.end239, %if.end133
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.end126
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.end105
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.end96
  br label %if.end244

if.end244:                                        ; preds = %if.end243, %if.end81
  br label %if.end245

if.end245:                                        ; preds = %if.end244, %if.end71
  %281 = load i32, i32* %err, align 4
  store i32 %281, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end245, %if.then232, %if.then225, %if.then213, %if.then206, %if.then203, %if.then199, %if.then190, %if.then180, %if.then165, %if.then160, %if.then153, %if.then132, %if.else124, %if.then122, %if.then114, %if.then104, %if.then95, %if.then80, %if.then67, %if.then50, %if.then43, %if.then37, %if.then25, %if.then16, %if.end12, %if.then11, %if.then6, %if.then
  %282 = load i32, i32* %retval, align 4
  ret i32 %282
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_map(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %3, i32 0, i32 0
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 12
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %6, 1
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp ne i32 %7, 2
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %8, 3
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %land.lhs.true4
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %9, 87
  br i1 %cmp7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %10, 88
  br i1 %cmp9, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %11, 89
  br i1 %cmp11, label %land.lhs.true12, label %if.end

land.lhs.true12:                                  ; preds = %land.lhs.true10
  %12 = load i32, i32* %func_id.addr, align 4
  %cmp13 = icmp ne i32 %12, 164
  br i1 %cmp13, label %land.lhs.true14, label %if.end

land.lhs.true14:                                  ; preds = %land.lhs.true12
  %13 = load i32, i32* %func_id.addr, align 4
  %cmp15 = icmp ne i32 %13, 51
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true14
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true14, %land.lhs.true12, %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %14 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp16 = icmp eq %struct.bpf_map* %14, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.342, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %17 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %17, i32 0, i32 7
  %18 = load i32, i32* %map_flags, align 8
  %and = and i32 %18, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true19, label %if.end27

land.lhs.true19:                                  ; preds = %if.end18
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp20 = icmp eq i32 %19, 3
  br i1 %cmp20, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true19
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp21 = icmp eq i32 %20, 2
  br i1 %cmp21, label %if.then26, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %lor.lhs.false
  %21 = load i32, i32* %func_id.addr, align 4
  %cmp23 = icmp eq i32 %21, 87
  br i1 %cmp23, label %if.then26, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %lor.lhs.false22
  %22 = load i32, i32* %func_id.addr, align 4
  %cmp25 = icmp eq i32 %22, 88
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %lor.lhs.false24, %lor.lhs.false22, %lor.lhs.false, %land.lhs.true19
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.398, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %lor.lhs.false24, %if.end18
  %25 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %26 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %25, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.163* %26 to i64*
  %27 = load i64, i64* %map_ptr_state, align 8
  %and28 = and i64 %27, -2
  %28 = inttoptr i64 %and28 to %struct.bpf_map*
  %tobool29 = icmp ne %struct.bpf_map* %28, null
  br i1 %tobool29, label %if.else, label %if.then30

if.then30:                                        ; preds = %if.end27
  %29 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %30 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr31 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %30, i32 0, i32 0
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr31, align 8
  %32 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr32 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %32, i32 0, i32 0
  %33 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr32, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %33, i32 0, i32 17
  %34 = load i8, i8* %bypass_spec_v1, align 4
  %tobool33 = trunc i8 %34 to i1
  %lnot = xor i1 %tobool33, true
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %29, %struct.bpf_map* noundef %31, i1 noundef zeroext %lnot) #14
  br label %if.end44

if.else:                                          ; preds = %if.end27
  %35 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %36 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %35, i32 0, i32 0
  %map_ptr_state34 = bitcast %union.anon.163* %36 to i64*
  %37 = load i64, i64* %map_ptr_state34, align 8
  %and35 = and i64 %37, -2
  %38 = inttoptr i64 %and35 to %struct.bpf_map*
  %39 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr36 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %39, i32 0, i32 0
  %40 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr36, align 8
  %cmp37 = icmp ne %struct.bpf_map* %38, %40
  br i1 %cmp37, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.else
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr39 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %42, i32 0, i32 0
  %43 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr39, align 8
  %bypass_spec_v140 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %43, i32 0, i32 17
  %44 = load i8, i8* %bypass_spec_v140, align 4
  %tobool41 = trunc i8 %44 to i1
  %lnot42 = xor i1 %tobool41, true
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %41, %struct.bpf_map* noundef inttoptr (i64 -2401263026318485698 to %struct.bpf_map*), i1 noundef zeroext %lnot42) #14
  br label %if.end43

if.end43:                                         ; preds = %if.then38, %if.else
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.then30
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end44, %if.then26, %if.then17, %if.then
  %45 = load i32, i32* %retval, align 4
  ret i32 %45
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_key(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %range = alloca %struct.tnum, align 8
  %val = alloca i64, align 8
  %err = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %3) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %6, 12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %tobool = icmp ne %struct.bpf_map* %7, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %8 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %8, i32 0, i32 3
  %9 = load i32, i32* %map_type, align 8
  %cmp1 = icmp ne i32 %9, 3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.342, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %12, i32 0, i32 6
  %13 = load i32, i32* %max_entries, align 4
  %sub = sub i32 %13, 1
  %conv = zext i32 %sub to i64
  %call4 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef %conv) #14
  %14 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call4, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call4, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.tnum* %range to i8*
  %20 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 16, i1 false)
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i64 3
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %reg, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call6 = call zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %22) #14
  br i1 %call6, label %lor.lhs.false7, label %if.then9

lor.lhs.false7:                                   ; preds = %if.end3
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 5
  %24 = bitcast %struct.tnum* %range to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %29 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call8 = call zeroext i1 @tnum_in(i64 %26, i64 %28, i64 %31, i64 %33) #14
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false7, %if.end3
  %34 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %34, i64 noundef -9223372036854775808) #14
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false7
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call11 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %35, i32 noundef 3) #14
  store i32 %call11, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool12 = icmp ne i32 %36, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %37 = load i32, i32* %err, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end10
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %39 = load i64, i64* %value, align 8
  store i64 %39, i64* %val, align 8
  %40 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call16 = call zeroext i1 @bpf_map_key_unseen(%struct.bpf_insn_aux_data* noundef %40) #14
  br i1 %call16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end14
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = load i64, i64* %val, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %41, i64 noundef %42) #14
  br label %if.end24

if.else:                                          ; preds = %if.end14
  %43 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call18 = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %43) #14
  br i1 %call18, label %if.end23, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %44 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call19 = call i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %44) #14
  %45 = load i64, i64* %val, align 8
  %cmp20 = icmp ne i64 %call19, %45
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  %46 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %46, i64 noundef -9223372036854775808) #14
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %land.lhs.true, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then17
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then13, %if.then9, %if.then2, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_release_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 86
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 132
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp eq i32 %2, 133
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference(%struct.bpf_verifier_env* noundef %env, i32 noundef %ref_obj_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %err = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %2) #14
  %3 = load i32, i32* %ref_obj_id.addr, align 4
  %call1 = call i32 @release_reference_state(%struct.bpf_func_state* noundef %call, i32 noundef %3) #14
  store i32 %call1, i32* %err, align 4
  %4 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %err, align 4
  store i32 %5, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 0
  %11 = load i32, i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %13 = load i32, i32* %ref_obj_id.addr, align 4
  call void @release_reg_references(%struct.bpf_verifier_env* noundef %9, %struct.bpf_func_state* noundef %12, i32 noundef %13) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_map_elem_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %insn_aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %insn_aux, align 8
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux, align 8
  %call = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %3) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.399, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux, align 8
  %7 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %6, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.163* %7 to i64*
  %8 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %8, -2
  %9 = inttoptr i64 %and to %struct.bpf_map*
  store %struct.bpf_map* %9, %struct.bpf_map** %map, align 8
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %10, i32 0, i32 0
  %11 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_set_for_each_callback_args = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %11, i32 0, i32 36
  %12 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)** %map_set_for_each_callback_args, align 8
  %tobool = icmp ne i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)* %12, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %13, i32 0, i32 0
  %14 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops1, align 64
  %map_for_each_callback = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %14, i32 0, i32 37
  %15 = load i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i8*, i64)** %map_for_each_callback, align 8
  %tobool2 = icmp ne i32 (%struct.bpf_map*, i8*, i8*, i64)* %15, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.400, i64 0, i64 0)) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops5 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 0
  %19 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops5, align 64
  %map_set_for_each_callback_args6 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %19, i32 0, i32 36
  %20 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)** %map_set_for_each_callback_args6, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %call7 = call i32 %20(%struct.bpf_verifier_env* noundef %21, %struct.bpf_func_state* noundef %22, %struct.bpf_func_state* noundef %23) #14
  store i32 %call7, i32* %err, align 4
  %24 = load i32, i32* %err, align 4
  %tobool8 = icmp ne i32 %24, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end4
  %25 = load i32, i32* %err, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end4
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 5
  store i8 1, i8* %in_callback_fn, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then3, %if.then
  %27 = load i32, i32* %retval, align 4
  ret i32 %27
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_timer_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %map_ptr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 1
  %1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 2
  %2 = bitcast %union.anon.152* %1 to %struct.anon.153*
  %map_ptr1 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %2, i32 0, i32 0
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr1, align 8
  store %struct.bpf_map* %3, %struct.bpf_map** %map_ptr, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 1
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 0
  store i32 3, i32* %type, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arrayidx5 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs4, i64 0, i64 1
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx5) #14
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs6, i64 0, i64 1
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx7, i32 0, i32 2
  %9 = bitcast %union.anon.152* %8 to %struct.anon.153*
  %map_ptr8 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %9, i32 0, i32 0
  store %struct.bpf_map* %6, %struct.bpf_map** %map_ptr8, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 2
  %type11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx10, i32 0, i32 0
  store i32 29, i32* %type11, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 0
  %arrayidx13 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs12, i64 0, i64 2
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx13) #14
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 0
  %arrayidx15 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs14, i64 0, i64 2
  %14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx15, i32 0, i32 2
  %15 = bitcast %union.anon.152* %14 to %struct.anon.153*
  %map_ptr16 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %15, i32 0, i32 0
  store %struct.bpf_map* %12, %struct.bpf_map** %map_ptr16, align 8
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs17 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %16, i32 0, i32 0
  %arrayidx18 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs17, i64 0, i64 3
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx18, i32 0, i32 0
  store i32 4, i32* %type19, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %arrayidx21 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs20, i64 0, i64 3
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx21) #14
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 0
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs22, i64 0, i64 3
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx23, i32 0, i32 2
  %21 = bitcast %union.anon.152* %20 to %struct.anon.153*
  %map_ptr24 = getelementptr inbounds %struct.anon.153, %struct.anon.153* %21, i32 0, i32 0
  store %struct.bpf_map* %18, %struct.bpf_map** %map_ptr24, align 8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 0
  %arrayidx26 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs25, i64 0, i64 4
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %22, %struct.bpf_reg_state* noundef %arrayidx26) #14
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 0
  %arrayidx28 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs27, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %24, %struct.bpf_reg_state* noundef %arrayidx28) #14
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 6
  store i8 1, i8* %in_async_callback_fn, align 1
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_bpf_snprintf_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %fmt_reg = alloca %struct.bpf_reg_state*, align 8
  %data_len_reg = alloca %struct.bpf_reg_state*, align 8
  %fmt_map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %fmt_map_off = alloca i32, align 4
  %num_args = alloca i32, align 4
  %fmt_addr = alloca i64, align 8
  %fmt = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 3
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %fmt_reg, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx1 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 5
  store %struct.bpf_reg_state* %arrayidx1, %struct.bpf_reg_state** %data_len_reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %fmt_reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.152* %3 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %fmt_map, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %data_len_reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %7 = load i64, i64* %value, align 8
  %rem = urem i64 %7, 8
  %tobool = icmp ne i64 %rem, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %data_len_reg, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %9 = load i64, i64* %value3, align 8
  %div = udiv i64 %9, 8
  %conv = trunc i64 %div to i32
  store i32 %conv, i32* %num_args, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %fmt_reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 1
  %11 = load i32, i32* %off, align 4
  %conv4 = sext i32 %11 to i64
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %fmt_reg, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %value6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %13 = load i64, i64* %value6, align 8
  %add = add i64 %conv4, %13
  %conv7 = trunc i64 %add to i32
  store i32 %conv7, i32* %fmt_map_off, align 4
  %14 = load %struct.bpf_map*, %struct.bpf_map** %fmt_map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %14, i32 0, i32 0
  %15 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %15, i32 0, i32 27
  %16 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %17 = load %struct.bpf_map*, %struct.bpf_map** %fmt_map, align 8
  %18 = load i32, i32* %fmt_map_off, align 4
  %call = call i32 %16(%struct.bpf_map* noundef %17, i64* noundef %fmt_addr, i32 noundef %18) #14
  store i32 %call, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool8 = icmp ne i32 %19, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.401, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %22 = load i64, i64* %fmt_addr, align 8
  %23 = inttoptr i64 %22 to i8*
  %24 = load i32, i32* %fmt_map_off, align 4
  %idx.ext = sext i32 %24 to i64
  %add.ptr = getelementptr i8, i8* %23, i64 %idx.ext
  store i8* %add.ptr, i8** %fmt, align 8
  %25 = load i8*, i8** %fmt, align 8
  %26 = load i32, i32* %num_args, align 4
  %call11 = call i32 @bpf_bprintf_prepare(i8* noundef %25, i32 noundef -1, i64* noundef null, i32** noundef null, i32 noundef %26) #14
  store i32 %call11, i32* %err, align 4
  %27 = load i32, i32* %err, align 4
  %cmp = icmp slt i32 %27, 0
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.402, i64 0, i64 0)) #14
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %30 = load i32, i32* %err, align 4
  store i32 %30, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then9, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ptr_cast_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 96
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 95
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp eq i32 %2, 137
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp eq i32 %3, 136
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp eq i32 %4, 140
  br i1 %cmp7, label %lor.end, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp eq i32 %5, 138
  br i1 %cmp9, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false8
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp10 = icmp eq i32 %6, 139
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %7 = phi i1 [ true, %lor.lhs.false8 ], [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp10, %lor.rhs ]
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_acquire_function(i32 noundef %func_id, %struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i1, align 1
  %func_id.addr = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %map_type = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %map_type, align 4
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %3, 84
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp eq i32 %4, 85
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp eq i32 %5, 99
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp eq i32 %6, 131
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false5, %lor.lhs.false3, %lor.lhs.false, %cond.end
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false5
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp eq i32 %7, 1
  br i1 %cmp7, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end
  %8 = load i32, i32* %map_type, align 4
  %cmp8 = icmp eq i32 %8, 15
  br i1 %cmp8, label %if.then11, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %land.lhs.true
  %9 = load i32, i32* %map_type, align 4
  %cmp10 = icmp eq i32 %9, 18
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false9, %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end12:                                         ; preds = %lor.lhs.false9, %if.end
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %new_ofs = alloca i32, align 4
  %id = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 7
  %2 = load i32, i32* %acquired_refs, align 4
  store i32 %2, i32* %new_ofs, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 7
  %5 = load i32, i32* %acquired_refs1, align 4
  %add = add i32 %5, 1
  %conv = sext i32 %add to i64
  %call2 = call i32 @resize_reference_state(%struct.bpf_func_state* noundef %3, i64 noundef %conv) #14
  store i32 %call2, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 15
  %9 = load i32, i32* %id_gen, align 8
  %inc = add i32 %9, 1
  store i32 %inc, i32* %id_gen, align 8
  store i32 %inc, i32* %id, align 4
  %10 = load i32, i32* %id, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 8
  %12 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %13 = load i32, i32* %new_ofs, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %12, i64 %idxprom
  %id3 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx, i32 0, i32 0
  store i32 %10, i32* %id3, align 4
  %14 = load i32, i32* %insn_idx.addr, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 8
  %16 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs4, align 8
  %17 = load i32, i32* %new_ofs, align 4
  %idxprom5 = sext i32 %17 to i64
  %arrayidx6 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %16, i64 %idxprom5
  %insn_idx7 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx6, i32 0, i32 1
  store i32 %14, i32* %insn_idx7, align 4
  %18 = load i32, i32* %id, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @do_refine_retval_range(%struct.bpf_reg_state* noundef %regs, i32 noundef %ret_type, i32 noundef %func_id, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %ret_type.addr = alloca i32, align 4
  %func_id.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %ret_reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %ret_type, i32* %ret_type.addr, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 0
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %ret_reg, align 8
  %1 = load i32, i32* %ret_type.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %2, 67
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp ne i32 %3, 141
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 45
  br i1 %cmp4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp ne i32 %5, 115
  br i1 %cmp6, label %land.lhs.true7, label %if.end

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp8 = icmp ne i32 %6, 114
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true7, %entry
  br label %return

if.end:                                           ; preds = %land.lhs.true7, %land.lhs.true5, %land.lhs.true3, %land.lhs.true, %lor.lhs.false
  %7 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %7, i32 0, i32 6
  %8 = load i64, i64* %msize_max_value, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 7
  store i64 %8, i64* %smax_value, align 8
  %10 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value9 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %10, i32 0, i32 6
  %11 = load i64, i64* %msize_max_value9, align 8
  %conv = trunc i64 %11 to i32
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 11
  store i32 %conv, i32* %s32_max_value, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  store i64 -4095, i64* %smin_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -4095, i32* %s32_min_value, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %15) #14
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %16) #14
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %17) #14
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type, align 8
  switch i32 %2, label %sw.default [
    i32 3, label %sw.bb
    i32 4, label %sw.bb3
    i32 27, label %sw.bb14
    i32 7, label %sw.bb22
    i32 8, label %sw.bb26
    i32 19, label %sw.bb32
    i32 21, label %sw.bb32
    i32 14, label %sw.bb36
    i32 25, label %sw.bb36
    i32 16, label %sw.bb42
    i32 17, label %sw.bb46
    i32 12, label %sw.bb52
    i32 13, label %sw.bb52
    i32 15, label %sw.bb56
    i32 18, label %sw.bb71
    i32 20, label %sw.bb87
    i32 22, label %sw.bb91
    i32 23, label %sw.bb91
    i32 24, label %sw.bb99
    i32 28, label %sw.bb105
    i32 29, label %sw.bb111
  ]

sw.bb:                                            ; preds = %if.end
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %3, 12
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %sw.bb
  br label %error

if.end2:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 22
  br i1 %cmp4, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %sw.bb3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %5, 25
  br i1 %cmp5, label %land.lhs.true6, label %if.end13

land.lhs.true6:                                   ; preds = %land.lhs.true
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %6, 111
  br i1 %cmp7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %7, 55
  br i1 %cmp9, label %land.lhs.true10, label %if.end13

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %8, 121
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true10
  br label %error

if.end13:                                         ; preds = %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true, %sw.bb3
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp15 = icmp ne i32 %9, 130
  br i1 %cmp15, label %land.lhs.true16, label %if.end21

land.lhs.true16:                                  ; preds = %sw.bb14
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp ne i32 %10, 131
  br i1 %cmp17, label %land.lhs.true18, label %if.end21

land.lhs.true18:                                  ; preds = %land.lhs.true16
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp19 = icmp ne i32 %11, 134
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true18
  br label %error

if.end21:                                         ; preds = %land.lhs.true18, %land.lhs.true16, %sw.bb14
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end
  %12 = load i32, i32* %func_id.addr, align 4
  %cmp23 = icmp ne i32 %12, 27
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %sw.bb22
  br label %error

if.end25:                                         ; preds = %sw.bb22
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end
  %13 = load i32, i32* %func_id.addr, align 4
  %cmp27 = icmp ne i32 %13, 33
  br i1 %cmp27, label %land.lhs.true28, label %if.end31

land.lhs.true28:                                  ; preds = %sw.bb26
  %14 = load i32, i32* %func_id.addr, align 4
  %cmp29 = icmp ne i32 %14, 37
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true28
  br label %error

if.end31:                                         ; preds = %land.lhs.true28, %sw.bb26
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end, %if.end
  %15 = load i32, i32* %func_id.addr, align 4
  %cmp33 = icmp ne i32 %15, 81
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %sw.bb32
  br label %error

if.end35:                                         ; preds = %sw.bb32
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end, %if.end
  %16 = load i32, i32* %func_id.addr, align 4
  %cmp37 = icmp ne i32 %16, 51
  br i1 %cmp37, label %land.lhs.true38, label %if.end41

land.lhs.true38:                                  ; preds = %sw.bb36
  %17 = load i32, i32* %func_id.addr, align 4
  %cmp39 = icmp ne i32 %17, 1
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true38
  br label %error

if.end41:                                         ; preds = %land.lhs.true38, %sw.bb36
  br label %sw.epilog

sw.bb42:                                          ; preds = %if.end
  %18 = load i32, i32* %func_id.addr, align 4
  %cmp43 = icmp ne i32 %18, 51
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %sw.bb42
  br label %error

if.end45:                                         ; preds = %sw.bb42
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.end
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp47 = icmp ne i32 %19, 51
  br i1 %cmp47, label %land.lhs.true48, label %if.end51

land.lhs.true48:                                  ; preds = %sw.bb46
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp49 = icmp ne i32 %20, 1
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %land.lhs.true48
  br label %error

if.end51:                                         ; preds = %land.lhs.true48, %sw.bb46
  br label %sw.epilog

sw.bb52:                                          ; preds = %if.end, %if.end
  %21 = load i32, i32* %func_id.addr, align 4
  %cmp53 = icmp ne i32 %21, 1
  br i1 %cmp53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %sw.bb52
  br label %error

if.end55:                                         ; preds = %sw.bb52
  br label %sw.epilog

sw.bb56:                                          ; preds = %if.end
  %22 = load i32, i32* %func_id.addr, align 4
  %cmp57 = icmp ne i32 %22, 52
  br i1 %cmp57, label %land.lhs.true58, label %if.end70

land.lhs.true58:                                  ; preds = %sw.bb56
  %23 = load i32, i32* %func_id.addr, align 4
  %cmp59 = icmp ne i32 %23, 53
  br i1 %cmp59, label %land.lhs.true60, label %if.end70

land.lhs.true60:                                  ; preds = %land.lhs.true58
  %24 = load i32, i32* %func_id.addr, align 4
  %cmp61 = icmp ne i32 %24, 3
  br i1 %cmp61, label %land.lhs.true62, label %if.end70

land.lhs.true62:                                  ; preds = %land.lhs.true60
  %25 = load i32, i32* %func_id.addr, align 4
  %cmp63 = icmp ne i32 %25, 60
  br i1 %cmp63, label %land.lhs.true64, label %if.end70

land.lhs.true64:                                  ; preds = %land.lhs.true62
  %26 = load i32, i32* %func_id.addr, align 4
  %cmp65 = icmp ne i32 %26, 82
  br i1 %cmp65, label %land.lhs.true66, label %if.end70

land.lhs.true66:                                  ; preds = %land.lhs.true64
  %27 = load i32, i32* %func_id.addr, align 4
  %cmp67 = icmp ne i32 %27, 1
  br i1 %cmp67, label %land.lhs.true68, label %if.end70

land.lhs.true68:                                  ; preds = %land.lhs.true66
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load i32, i32* %func_id.addr, align 4
  %call = call zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %28, i32 noundef %29) #14
  br i1 %call, label %if.end70, label %if.then69

if.then69:                                        ; preds = %land.lhs.true68
  br label %error

if.end70:                                         ; preds = %land.lhs.true68, %land.lhs.true66, %land.lhs.true64, %land.lhs.true62, %land.lhs.true60, %land.lhs.true58, %sw.bb56
  br label %sw.epilog

sw.bb71:                                          ; preds = %if.end
  %30 = load i32, i32* %func_id.addr, align 4
  %cmp72 = icmp ne i32 %30, 72
  br i1 %cmp72, label %land.lhs.true73, label %if.end86

land.lhs.true73:                                  ; preds = %sw.bb71
  %31 = load i32, i32* %func_id.addr, align 4
  %cmp74 = icmp ne i32 %31, 70
  br i1 %cmp74, label %land.lhs.true75, label %if.end86

land.lhs.true75:                                  ; preds = %land.lhs.true73
  %32 = load i32, i32* %func_id.addr, align 4
  %cmp76 = icmp ne i32 %32, 3
  br i1 %cmp76, label %land.lhs.true77, label %if.end86

land.lhs.true77:                                  ; preds = %land.lhs.true75
  %33 = load i32, i32* %func_id.addr, align 4
  %cmp78 = icmp ne i32 %33, 71
  br i1 %cmp78, label %land.lhs.true79, label %if.end86

land.lhs.true79:                                  ; preds = %land.lhs.true77
  %34 = load i32, i32* %func_id.addr, align 4
  %cmp80 = icmp ne i32 %34, 82
  br i1 %cmp80, label %land.lhs.true81, label %if.end86

land.lhs.true81:                                  ; preds = %land.lhs.true79
  %35 = load i32, i32* %func_id.addr, align 4
  %cmp82 = icmp ne i32 %35, 1
  br i1 %cmp82, label %land.lhs.true83, label %if.end86

land.lhs.true83:                                  ; preds = %land.lhs.true81
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load i32, i32* %func_id.addr, align 4
  %call84 = call zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %36, i32 noundef %37) #14
  br i1 %call84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %land.lhs.true83
  br label %error

if.end86:                                         ; preds = %land.lhs.true83, %land.lhs.true81, %land.lhs.true79, %land.lhs.true77, %land.lhs.true75, %land.lhs.true73, %sw.bb71
  br label %sw.epilog

sw.bb87:                                          ; preds = %if.end
  %38 = load i32, i32* %func_id.addr, align 4
  %cmp88 = icmp ne i32 %38, 82
  br i1 %cmp88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %sw.bb87
  br label %error

if.end90:                                         ; preds = %sw.bb87
  br label %sw.epilog

sw.bb91:                                          ; preds = %if.end, %if.end
  %39 = load i32, i32* %func_id.addr, align 4
  %cmp92 = icmp ne i32 %39, 89
  br i1 %cmp92, label %land.lhs.true93, label %if.end98

land.lhs.true93:                                  ; preds = %sw.bb91
  %40 = load i32, i32* %func_id.addr, align 4
  %cmp94 = icmp ne i32 %40, 88
  br i1 %cmp94, label %land.lhs.true95, label %if.end98

land.lhs.true95:                                  ; preds = %land.lhs.true93
  %41 = load i32, i32* %func_id.addr, align 4
  %cmp96 = icmp ne i32 %41, 87
  br i1 %cmp96, label %if.then97, label %if.end98

if.then97:                                        ; preds = %land.lhs.true95
  br label %error

if.end98:                                         ; preds = %land.lhs.true95, %land.lhs.true93, %sw.bb91
  br label %sw.epilog

sw.bb99:                                          ; preds = %if.end
  %42 = load i32, i32* %func_id.addr, align 4
  %cmp100 = icmp ne i32 %42, 107
  br i1 %cmp100, label %land.lhs.true101, label %if.end104

land.lhs.true101:                                 ; preds = %sw.bb99
  %43 = load i32, i32* %func_id.addr, align 4
  %cmp102 = icmp ne i32 %43, 108
  br i1 %cmp102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %land.lhs.true101
  br label %error

if.end104:                                        ; preds = %land.lhs.true101, %sw.bb99
  br label %sw.epilog

sw.bb105:                                         ; preds = %if.end
  %44 = load i32, i32* %func_id.addr, align 4
  %cmp106 = icmp ne i32 %44, 145
  br i1 %cmp106, label %land.lhs.true107, label %if.end110

land.lhs.true107:                                 ; preds = %sw.bb105
  %45 = load i32, i32* %func_id.addr, align 4
  %cmp108 = icmp ne i32 %45, 146
  br i1 %cmp108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %land.lhs.true107
  br label %error

if.end110:                                        ; preds = %land.lhs.true107, %sw.bb105
  br label %sw.epilog

sw.bb111:                                         ; preds = %if.end
  %46 = load i32, i32* %func_id.addr, align 4
  %cmp112 = icmp ne i32 %46, 156
  br i1 %cmp112, label %land.lhs.true113, label %if.end116

land.lhs.true113:                                 ; preds = %sw.bb111
  %47 = load i32, i32* %func_id.addr, align 4
  %cmp114 = icmp ne i32 %47, 157
  br i1 %cmp114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %land.lhs.true113
  br label %error

if.end116:                                        ; preds = %land.lhs.true113, %sw.bb111
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end116, %if.end110, %if.end104, %if.end98, %if.end90, %if.end86, %if.end70, %if.end55, %if.end51, %if.end45, %if.end41, %if.end35, %if.end31, %if.end25, %if.end21, %if.end13, %if.end2
  %48 = load i32, i32* %func_id.addr, align 4
  switch i32 %48, label %sw.default213 [
    i32 12, label %sw.bb117
    i32 22, label %sw.bb127
    i32 25, label %sw.bb127
    i32 55, label %sw.bb127
    i32 111, label %sw.bb127
    i32 121, label %sw.bb127
    i32 130, label %sw.bb132
    i32 131, label %sw.bb132
    i32 134, label %sw.bb132
    i32 27, label %sw.bb137
    i32 37, label %sw.bb142
    i32 33, label %sw.bb142
    i32 51, label %sw.bb147
    i32 52, label %sw.bb161
    i32 60, label %sw.bb161
    i32 53, label %sw.bb161
    i32 72, label %sw.bb166
    i32 71, label %sw.bb166
    i32 70, label %sw.bb166
    i32 81, label %sw.bb171
    i32 82, label %sw.bb179
    i32 89, label %sw.bb190
    i32 88, label %sw.bb190
    i32 87, label %sw.bb190
    i32 107, label %sw.bb198
    i32 108, label %sw.bb198
    i32 145, label %sw.bb203
    i32 146, label %sw.bb203
    i32 156, label %sw.bb208
    i32 157, label %sw.bb208
  ]

sw.bb117:                                         ; preds = %sw.epilog
  %49 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type118 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %49, i32 0, i32 3
  %50 = load i32, i32* %map_type118, align 8
  %cmp119 = icmp ne i32 %50, 3
  br i1 %cmp119, label %if.then120, label %if.end121

if.then120:                                       ; preds = %sw.bb117
  br label %error

if.end121:                                        ; preds = %sw.bb117
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 31
  %52 = load i32, i32* %subprog_cnt, align 4
  %cmp122 = icmp ugt i32 %52, 1
  br i1 %cmp122, label %land.lhs.true123, label %if.end126

land.lhs.true123:                                 ; preds = %if.end121
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call124 = call zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %53) #14
  br i1 %call124, label %if.end126, label %if.then125

if.then125:                                       ; preds = %land.lhs.true123
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.403, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end126:                                        ; preds = %land.lhs.true123, %if.end121
  br label %sw.epilog214

sw.bb127:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog
  %56 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type128 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %56, i32 0, i32 3
  %57 = load i32, i32* %map_type128, align 8
  %cmp129 = icmp ne i32 %57, 4
  br i1 %cmp129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %sw.bb127
  br label %error

if.end131:                                        ; preds = %sw.bb127
  br label %sw.epilog214

sw.bb132:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %58 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type133 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %58, i32 0, i32 3
  %59 = load i32, i32* %map_type133, align 8
  %cmp134 = icmp ne i32 %59, 27
  br i1 %cmp134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %sw.bb132
  br label %error

if.end136:                                        ; preds = %sw.bb132
  br label %sw.epilog214

sw.bb137:                                         ; preds = %sw.epilog
  %60 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type138 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %60, i32 0, i32 3
  %61 = load i32, i32* %map_type138, align 8
  %cmp139 = icmp ne i32 %61, 7
  br i1 %cmp139, label %if.then140, label %if.end141

if.then140:                                       ; preds = %sw.bb137
  br label %error

if.end141:                                        ; preds = %sw.bb137
  br label %sw.epilog214

sw.bb142:                                         ; preds = %sw.epilog, %sw.epilog
  %62 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type143 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %62, i32 0, i32 3
  %63 = load i32, i32* %map_type143, align 8
  %cmp144 = icmp ne i32 %63, 8
  br i1 %cmp144, label %if.then145, label %if.end146

if.then145:                                       ; preds = %sw.bb142
  br label %error

if.end146:                                        ; preds = %sw.bb142
  br label %sw.epilog214

sw.bb147:                                         ; preds = %sw.epilog
  %64 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type148 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %64, i32 0, i32 3
  %65 = load i32, i32* %map_type148, align 8
  %cmp149 = icmp ne i32 %65, 14
  br i1 %cmp149, label %land.lhs.true150, label %if.end160

land.lhs.true150:                                 ; preds = %sw.bb147
  %66 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type151 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %66, i32 0, i32 3
  %67 = load i32, i32* %map_type151, align 8
  %cmp152 = icmp ne i32 %67, 25
  br i1 %cmp152, label %land.lhs.true153, label %if.end160

land.lhs.true153:                                 ; preds = %land.lhs.true150
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type154 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %68, i32 0, i32 3
  %69 = load i32, i32* %map_type154, align 8
  %cmp155 = icmp ne i32 %69, 16
  br i1 %cmp155, label %land.lhs.true156, label %if.end160

land.lhs.true156:                                 ; preds = %land.lhs.true153
  %70 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type157 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %70, i32 0, i32 3
  %71 = load i32, i32* %map_type157, align 8
  %cmp158 = icmp ne i32 %71, 17
  br i1 %cmp158, label %if.then159, label %if.end160

if.then159:                                       ; preds = %land.lhs.true156
  br label %error

if.end160:                                        ; preds = %land.lhs.true156, %land.lhs.true153, %land.lhs.true150, %sw.bb147
  br label %sw.epilog214

sw.bb161:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %72 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type162 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %72, i32 0, i32 3
  %73 = load i32, i32* %map_type162, align 8
  %cmp163 = icmp ne i32 %73, 15
  br i1 %cmp163, label %if.then164, label %if.end165

if.then164:                                       ; preds = %sw.bb161
  br label %error

if.end165:                                        ; preds = %sw.bb161
  br label %sw.epilog214

sw.bb166:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %74 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type167 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %74, i32 0, i32 3
  %75 = load i32, i32* %map_type167, align 8
  %cmp168 = icmp ne i32 %75, 18
  br i1 %cmp168, label %if.then169, label %if.end170

if.then169:                                       ; preds = %sw.bb166
  br label %error

if.end170:                                        ; preds = %sw.bb166
  br label %sw.epilog214

sw.bb171:                                         ; preds = %sw.epilog
  %76 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type172 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %76, i32 0, i32 3
  %77 = load i32, i32* %map_type172, align 8
  %cmp173 = icmp ne i32 %77, 19
  br i1 %cmp173, label %land.lhs.true174, label %if.end178

land.lhs.true174:                                 ; preds = %sw.bb171
  %78 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type175 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %78, i32 0, i32 3
  %79 = load i32, i32* %map_type175, align 8
  %cmp176 = icmp ne i32 %79, 21
  br i1 %cmp176, label %if.then177, label %if.end178

if.then177:                                       ; preds = %land.lhs.true174
  br label %error

if.end178:                                        ; preds = %land.lhs.true174, %sw.bb171
  br label %sw.epilog214

sw.bb179:                                         ; preds = %sw.epilog
  %80 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type180 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %80, i32 0, i32 3
  %81 = load i32, i32* %map_type180, align 8
  %cmp181 = icmp ne i32 %81, 20
  br i1 %cmp181, label %land.lhs.true182, label %if.end189

land.lhs.true182:                                 ; preds = %sw.bb179
  %82 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type183 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %82, i32 0, i32 3
  %83 = load i32, i32* %map_type183, align 8
  %cmp184 = icmp ne i32 %83, 15
  br i1 %cmp184, label %land.lhs.true185, label %if.end189

land.lhs.true185:                                 ; preds = %land.lhs.true182
  %84 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type186 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %84, i32 0, i32 3
  %85 = load i32, i32* %map_type186, align 8
  %cmp187 = icmp ne i32 %85, 18
  br i1 %cmp187, label %if.then188, label %if.end189

if.then188:                                       ; preds = %land.lhs.true185
  br label %error

if.end189:                                        ; preds = %land.lhs.true185, %land.lhs.true182, %sw.bb179
  br label %sw.epilog214

sw.bb190:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %86 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type191 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %86, i32 0, i32 3
  %87 = load i32, i32* %map_type191, align 8
  %cmp192 = icmp ne i32 %87, 22
  br i1 %cmp192, label %land.lhs.true193, label %if.end197

land.lhs.true193:                                 ; preds = %sw.bb190
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type194 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %88, i32 0, i32 3
  %89 = load i32, i32* %map_type194, align 8
  %cmp195 = icmp ne i32 %89, 23
  br i1 %cmp195, label %if.then196, label %if.end197

if.then196:                                       ; preds = %land.lhs.true193
  br label %error

if.end197:                                        ; preds = %land.lhs.true193, %sw.bb190
  br label %sw.epilog214

sw.bb198:                                         ; preds = %sw.epilog, %sw.epilog
  %90 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type199 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %90, i32 0, i32 3
  %91 = load i32, i32* %map_type199, align 8
  %cmp200 = icmp ne i32 %91, 24
  br i1 %cmp200, label %if.then201, label %if.end202

if.then201:                                       ; preds = %sw.bb198
  br label %error

if.end202:                                        ; preds = %sw.bb198
  br label %sw.epilog214

sw.bb203:                                         ; preds = %sw.epilog, %sw.epilog
  %92 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type204 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %92, i32 0, i32 3
  %93 = load i32, i32* %map_type204, align 8
  %cmp205 = icmp ne i32 %93, 28
  br i1 %cmp205, label %if.then206, label %if.end207

if.then206:                                       ; preds = %sw.bb203
  br label %error

if.end207:                                        ; preds = %sw.bb203
  br label %sw.epilog214

sw.bb208:                                         ; preds = %sw.epilog, %sw.epilog
  %94 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type209 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %94, i32 0, i32 3
  %95 = load i32, i32* %map_type209, align 8
  %cmp210 = icmp ne i32 %95, 29
  br i1 %cmp210, label %if.then211, label %if.end212

if.then211:                                       ; preds = %sw.bb208
  br label %error

if.end212:                                        ; preds = %sw.bb208
  br label %sw.epilog214

sw.default213:                                    ; preds = %sw.epilog
  br label %sw.epilog214

sw.epilog214:                                     ; preds = %sw.default213, %if.end212, %if.end207, %if.end202, %if.end197, %if.end189, %if.end178, %if.end170, %if.end165, %if.end160, %if.end146, %if.end141, %if.end136, %if.end131, %if.end126
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then211, %if.then206, %if.then201, %if.then196, %if.then188, %if.then177, %if.then169, %if.then164, %if.then159, %if.then145, %if.then140, %if.then135, %if.then130, %if.then120, %if.then115, %if.then109, %if.then103, %if.then97, %if.then89, %if.then85, %if.then69, %if.then54, %if.then50, %if.then44, %if.then40, %if.then34, %if.then30, %if.then24, %if.then20, %if.then12, %if.then1
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %97 = bitcast %struct.bpf_verifier_env* %96 to i8*
  %98 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type215 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %98, i32 0, i32 3
  %99 = load i32, i32* %map_type215, align 8
  %100 = load i32, i32* %func_id.addr, align 4
  %call216 = call i8* @func_id_name(i32 noundef %100) #14
  %101 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %97, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.404, i64 0, i64 0), i32 noundef %99, i8* noundef %call216, i32 noundef %101) #14
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %error, %sw.epilog214, %if.then125, %if.then
  %102 = load i32, i32* %retval, align 4
  ret i32 %102
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_callchain_buffers(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_get_func_ip(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %eatype = alloca i32, align 4
  %type = alloca i32, align 4
  %func_id = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 3
  %2 = load i32, i32* %expected_attach_type, align 8
  store i32 %2, i32* %eatype, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #14
  store i32 %call, i32* %type, align 4
  store i32 173, i32* %func_id, align 4
  %5 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %5, 26
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %eatype, align 4
  %cmp2 = icmp ne i32 %6, 24
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %7 = load i32, i32* %eatype, align 4
  %cmp3 = icmp ne i32 %7, 25
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %8 = load i32, i32* %eatype, align 4
  %cmp5 = icmp ne i32 %8, 26
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load i32, i32* %func_id, align 4
  %call7 = call i8* @func_id_name(i32 noundef %11) #14
  %12 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.406, i64 0, i64 0), i8* noundef %call7, i32 noundef %12) #14
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %13 = load i32, i32* %type, align 4
  %cmp8 = icmp eq i32 %13, 2
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end10
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %func_id, align 4
  %call12 = call i8* @func_id_name(i32 noundef %16) #14
  %17 = load i32, i32* %func_id, align 4
  %18 = load i32, i32* %type, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.407, i64 0, i64 0), i8* noundef %call12, i32 noundef %17, i32 noundef %18) #14
  store i32 -524, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then9, %if.end, %if.then6
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @__clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %5, %struct.bpf_func_state* noundef %8) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.157* %1 to %struct.anon.158*
  %arg1_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %cmp = icmp eq i32 %3, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %count, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 4
  %7 = bitcast %union.anon.157* %6 to %struct.anon.158*
  %arg2_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %7, i32 0, i32 1
  %8 = load i32, i32* %arg2_type, align 4
  %cmp1 = icmp eq i32 %8, 8
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %9 = load i32, i32* %count, align 4
  %inc3 = add i32 %9, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %11 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %10, i32 0, i32 4
  %12 = bitcast %union.anon.157* %11 to %struct.anon.158*
  %arg3_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %12, i32 0, i32 2
  %13 = load i32, i32* %arg3_type, align 8
  %cmp5 = icmp eq i32 %13, 8
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %14 = load i32, i32* %count, align 4
  %inc7 = add i32 %14, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %16 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %15, i32 0, i32 4
  %17 = bitcast %union.anon.157* %16 to %struct.anon.158*
  %arg4_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %17, i32 0, i32 3
  %18 = load i32, i32* %arg4_type, align 4
  %cmp9 = icmp eq i32 %18, 8
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %19 = load i32, i32* %count, align 4
  %inc11 = add i32 %19, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.157* %21 to %struct.anon.158*
  %arg5_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %22, i32 0, i32 4
  %23 = load i32, i32* %arg5_type, align 8
  %cmp13 = icmp eq i32 %23, 8
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %24 = load i32, i32* %count, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %25 = load i32, i32* %count, align 4
  %cmp17 = icmp sle i32 %25, 1
  ret i1 %cmp17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.157* %1 to %struct.anon.158*
  %arg1_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_is_mem_size(i32 noundef %3) #14
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %5 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 4
  %6 = bitcast %union.anon.157* %5 to %struct.anon.158*
  %arg5_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %6, i32 0, i32 4
  %7 = load i32, i32* %arg5_type, align 8
  %call1 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %7) #14
  br i1 %call1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %8 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %9 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %8, i32 0, i32 4
  %10 = bitcast %union.anon.157* %9 to %struct.anon.158*
  %arg1_type3 = getelementptr inbounds %struct.anon.158, %struct.anon.158* %10, i32 0, i32 0
  %11 = load i32, i32* %arg1_type3, align 8
  %12 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %12, i32 0, i32 4
  %14 = bitcast %union.anon.157* %13 to %struct.anon.158*
  %arg2_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %14, i32 0, i32 1
  %15 = load i32, i32* %arg2_type, align 4
  %call4 = call zeroext i1 @check_args_pair_invalid(i32 noundef %11, i32 noundef %15) #14
  br i1 %call4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false2
  %16 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %17 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %16, i32 0, i32 4
  %18 = bitcast %union.anon.157* %17 to %struct.anon.158*
  %arg2_type6 = getelementptr inbounds %struct.anon.158, %struct.anon.158* %18, i32 0, i32 1
  %19 = load i32, i32* %arg2_type6, align 4
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.157* %21 to %struct.anon.158*
  %arg3_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %22, i32 0, i32 2
  %23 = load i32, i32* %arg3_type, align 8
  %call7 = call zeroext i1 @check_args_pair_invalid(i32 noundef %19, i32 noundef %23) #14
  br i1 %call7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false5
  %24 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %25 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %24, i32 0, i32 4
  %26 = bitcast %union.anon.157* %25 to %struct.anon.158*
  %arg3_type9 = getelementptr inbounds %struct.anon.158, %struct.anon.158* %26, i32 0, i32 2
  %27 = load i32, i32* %arg3_type9, align 8
  %28 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %29 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %28, i32 0, i32 4
  %30 = bitcast %union.anon.157* %29 to %struct.anon.158*
  %arg4_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %30, i32 0, i32 3
  %31 = load i32, i32* %arg4_type, align 4
  %call10 = call zeroext i1 @check_args_pair_invalid(i32 noundef %27, i32 noundef %31) #14
  br i1 %call10, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %32 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %33 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %32, i32 0, i32 4
  %34 = bitcast %union.anon.157* %33 to %struct.anon.158*
  %arg4_type12 = getelementptr inbounds %struct.anon.158, %struct.anon.158* %34, i32 0, i32 3
  %35 = load i32, i32* %arg4_type12, align 4
  %36 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %37 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %36, i32 0, i32 4
  %38 = bitcast %union.anon.157* %37 to %struct.anon.158*
  %arg5_type13 = getelementptr inbounds %struct.anon.158, %struct.anon.158* %38, i32 0, i32 4
  %39 = load i32, i32* %arg5_type13, align 8
  %call14 = call zeroext i1 @check_args_pair_invalid(i32 noundef %35, i32 noundef %39) #14
  br i1 %call14, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false11, %lor.lhs.false8, %lor.lhs.false5, %lor.lhs.false2, %lor.lhs.false, %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false11
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %40 = load i1, i1* %retval, align 1
  ret i1 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_btf_id_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %2 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %1, i32 0, i32 4
  %arg_type = bitcast %union.anon.157* %2 to [5 x i32]*
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [5 x i32], [5 x i32]* %arg_type, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  %cmp2 = icmp eq i32 %4, 20
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 5
  %arg_btf_id = bitcast %union.anon.159* %6 to [5 x i32*]*
  %7 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %7 to i64
  %arrayidx5 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id, i64 0, i64 %idxprom4
  %8 = load i32*, i32** %arrayidx5, align 8
  %tobool = icmp ne i32* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %land.lhs.true, %for.body
  %9 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %10 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %9, i32 0, i32 4
  %arg_type6 = bitcast %union.anon.157* %10 to [5 x i32]*
  %11 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %11 to i64
  %arrayidx8 = getelementptr [5 x i32], [5 x i32]* %arg_type6, i64 0, i64 %idxprom7
  %12 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp ne i32 %12, 20
  br i1 %cmp9, label %land.lhs.true11, label %if.end17

land.lhs.true11:                                  ; preds = %if.end
  %13 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %14 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %13, i32 0, i32 5
  %arg_btf_id12 = bitcast %union.anon.159* %14 to [5 x i32*]*
  %15 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %15 to i64
  %arrayidx14 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id12, i64 0, i64 %idxprom13
  %16 = load i32*, i32** %arrayidx14, align 8
  %tobool15 = icmp ne i32* %16, null
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true11
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %land.lhs.true11, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then16, %if.then
  %18 = load i1, i1* %retval, align 1
  ret i1 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_refcount_ok(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.157* %1 to %struct.anon.158*
  %arg1_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %3) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %count, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 4
  %7 = bitcast %union.anon.157* %6 to %struct.anon.158*
  %arg2_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %7, i32 0, i32 1
  %8 = load i32, i32* %arg2_type, align 4
  %call1 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %8) #14
  br i1 %call1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %9 = load i32, i32* %count, align 4
  %inc3 = add i32 %9, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %11 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %10, i32 0, i32 4
  %12 = bitcast %union.anon.157* %11 to %struct.anon.158*
  %arg3_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %12, i32 0, i32 2
  %13 = load i32, i32* %arg3_type, align 8
  %call5 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %13) #14
  br i1 %call5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %14 = load i32, i32* %count, align 4
  %inc7 = add i32 %14, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %16 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %15, i32 0, i32 4
  %17 = bitcast %union.anon.157* %16 to %struct.anon.158*
  %arg4_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %17, i32 0, i32 3
  %18 = load i32, i32* %arg4_type, align 4
  %call9 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %18) #14
  br i1 %call9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %19 = load i32, i32* %count, align 4
  %inc11 = add i32 %19, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.157* %21 to %struct.anon.158*
  %arg5_type = getelementptr inbounds %struct.anon.158, %struct.anon.158* %22, i32 0, i32 4
  %23 = load i32, i32* %arg5_type, align 8
  %call13 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %23) #14
  br i1 %call13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %24 = load i32, i32* %count, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %25 = load i32, i32* %func_id.addr, align 4
  %call17 = call zeroext i1 @may_be_acquire_function(i32 noundef %25) #14
  br i1 %call17, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end16
  %26 = load i32, i32* %count, align 4
  %tobool = icmp ne i32 %26, 0
  br i1 %tobool, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %if.end16
  %27 = load i32, i32* %count, align 4
  %cmp = icmp sle i32 %27, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end19, %if.then18
  %28 = load i1, i1* %retval, align 1
  ret i1 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_size(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 9
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_ptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 6
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %2, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_args_pair_invalid(i32 noundef %arg_curr, i32 noundef %arg_next) #0 {
entry:
  %arg_curr.addr = alloca i32, align 4
  %arg_next.addr = alloca i32, align 4
  store i32 %arg_curr, i32* %arg_curr.addr, align 4
  store i32 %arg_next, i32* %arg_next.addr, align 4
  %0 = load i32, i32* %arg_curr.addr, align 4
  %call = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %0) #14
  br i1 %call, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %arg_next.addr, align 4
  %call1 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %1) #14
  br i1 %call1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, i32* %arg_curr.addr, align 4
  %call2 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %2) #14
  br i1 %call2, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %3 = load i32, i32* %arg_next.addr, align 4
  %call3 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %3) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %4 = phi i1 [ false, %lor.rhs ], [ %call3, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %4, %land.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_may_be_refcounted(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 15
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_be_acquire_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 84
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 85
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp eq i32 %2, 99
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp eq i32 %3, 1
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false4
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp eq i32 %4, 131
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp6, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_map_arg_type(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32* noundef %arg_type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %arg_type.addr = alloca i32*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32* %arg_type, i32** %arg_type.addr, align 8
  %0 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %0, i32 0, i32 0
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %tobool = icmp ne %struct.bpf_map* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.362, i64 0, i64 0)) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr1 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr1, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %5, i32 0, i32 3
  %6 = load i32, i32* %map_type, align 8
  switch i32 %6, label %sw.default [
    i32 15, label %sw.bb
    i32 18, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %7 = load i32*, i32** %arg_type.addr, align 8
  %8 = load i32, i32* %7, align 4
  %cmp = icmp eq i32 %8, 3
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %sw.bb
  %9 = load i32*, i32** %arg_type.addr, align 8
  store i32 24, i32* %9, align 4
  br label %if.end3

if.else:                                          ; preds = %sw.bb
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.363, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.then2
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.else, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_may_be_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 12
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 19
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp7 = icmp eq i32 %4, 22
  br i1 %cmp7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false6
  %5 = load i32, i32* %type.addr, align 4
  %cmp8 = icmp eq i32 %5, 27
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %6 = phi i1 [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp8, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %arg_type, i32* noundef %arg_btf_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %arg_type.addr = alloca i32, align 4
  %arg_btf_id.addr = alloca i32*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %expected = alloca i32, align 4
  %type = alloca i32, align 4
  %compatible = alloca %struct.bpf_reg_types*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %arg_type, i32* %arg_type.addr, align 4
  store i32* %arg_btf_id, i32** %arg_btf_id.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  store i32 %4, i32* %type, align 4
  %5 = load i32, i32* %arg_type.addr, align 4
  %idxprom2 = zext i32 %5 to i64
  %arrayidx3 = getelementptr [30 x %struct.bpf_reg_types*], [30 x %struct.bpf_reg_types*]* @compatible_reg_types, i64 0, i64 %idxprom2
  %6 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %arrayidx3, align 8
  store %struct.bpf_reg_types* %6, %struct.bpf_reg_types** %compatible, align 8
  %7 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %tobool = icmp ne %struct.bpf_reg_types* %7, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load i32, i32* %arg_type.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.364, i64 0, i64 0), i32 noundef %10) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %conv = sext i32 %11 to i64
  %cmp = icmp ult i64 %conv, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %12, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr [10 x i32], [10 x i32]* %types, i64 0, i64 %idxprom5
  %14 = load i32, i32* %arrayidx6, align 4
  store i32 %14, i32* %expected, align 4
  %15 = load i32, i32* %expected, align 4
  %cmp7 = icmp eq i32 %15, 0
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %for.body
  br label %for.end

if.end10:                                         ; preds = %for.body
  %16 = load i32, i32* %type, align 4
  %17 = load i32, i32* %expected, align 4
  %cmp11 = icmp eq i32 %16, %17
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  br label %found

if.end14:                                         ; preds = %if.end10
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then9, %for.cond
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %regno.addr, align 4
  %22 = load i32, i32* %type, align 4
  %idxprom15 = zext i32 %22 to i64
  %arrayidx16 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom15
  %23 = load i8*, i8** %arrayidx16, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.365, i64 0, i64 0), i32 noundef %21, i8* noundef %23) #14
  store i32 0, i32* %j, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %j, align 4
  %add = add i32 %24, 1
  %25 = load i32, i32* %i, align 4
  %cmp18 = icmp slt i32 %add, %25
  br i1 %cmp18, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond17
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types21 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %28, i32 0, i32 0
  %29 = load i32, i32* %j, align 4
  %idxprom22 = sext i32 %29 to i64
  %arrayidx23 = getelementptr [10 x i32], [10 x i32]* %types21, i64 0, i64 %idxprom22
  %30 = load i32, i32* %arrayidx23, align 4
  %idxprom24 = zext i32 %30 to i64
  %arrayidx25 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom24
  %31 = load i8*, i8** %arrayidx25, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.366, i64 0, i64 0), i8* noundef %31) #14
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %32 = load i32, i32* %j, align 4
  %inc27 = add i32 %32, 1
  store i32 %inc27, i32* %j, align 4
  br label %for.cond17

for.end28:                                        ; preds = %for.cond17
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types29 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %35, i32 0, i32 0
  %36 = load i32, i32* %j, align 4
  %idxprom30 = sext i32 %36 to i64
  %arrayidx31 = getelementptr [10 x i32], [10 x i32]* %types29, i64 0, i64 %idxprom30
  %37 = load i32, i32* %arrayidx31, align 4
  %idxprom32 = zext i32 %37 to i64
  %arrayidx33 = getelementptr [30 x i8*], [30 x i8*]* @reg_type_str, i64 0, i64 %idxprom32
  %38 = load i8*, i8** %arrayidx33, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.203, i64 0, i64 0), i8* noundef %38) #14
  store i32 -13, i32* %retval, align 4
  br label %return

found:                                            ; preds = %if.then13
  %39 = load i32, i32* %type, align 4
  %cmp34 = icmp eq i32 %39, 19
  br i1 %cmp34, label %if.then36, label %if.end57

if.then36:                                        ; preds = %found
  %40 = load i32*, i32** %arg_btf_id.addr, align 8
  %tobool37 = icmp ne i32* %40, null
  br i1 %tobool37, label %if.end43, label %if.then38

if.then38:                                        ; preds = %if.then36
  %41 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %btf_id = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %41, i32 0, i32 1
  %42 = load i32*, i32** %btf_id, align 8
  %tobool39 = icmp ne i32* %42, null
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.then38
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.367, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.then38
  %45 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %btf_id42 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %45, i32 0, i32 1
  %46 = load i32*, i32** %btf_id42, align 8
  store i32* %46, i32** %arg_btf_id.addr, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.end41, %if.then36
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 26
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 2
  %50 = bitcast %union.anon.152* %49 to %struct.anon.154*
  %btf = getelementptr inbounds %struct.anon.154, %struct.anon.154* %50, i32 0, i32 0
  %51 = load %struct.btf*, %struct.btf** %btf, align 8
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 2
  %54 = bitcast %union.anon.152* %53 to %struct.anon.154*
  %btf_id44 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %54, i32 0, i32 1
  %55 = load i32, i32* %btf_id44, align 8
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 1
  %57 = load i32, i32* %off, align 4
  %58 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %59 = load i32*, i32** %arg_btf_id.addr, align 8
  %60 = load i32, i32* %59, align 4
  %call45 = call zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %51, i32 noundef %55, i32 noundef %57, %struct.btf* noundef %58, i32 noundef %60) #14
  br i1 %call45, label %if.end51, label %if.then46

if.then46:                                        ; preds = %if.end43
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = bitcast %struct.bpf_verifier_env* %61 to i8*
  %63 = load i32, i32* %regno.addr, align 4
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 2
  %66 = bitcast %union.anon.152* %65 to %struct.anon.154*
  %btf47 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %66, i32 0, i32 0
  %67 = load %struct.btf*, %struct.btf** %btf47, align 8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 2
  %70 = bitcast %union.anon.152* %69 to %struct.anon.154*
  %btf_id48 = getelementptr inbounds %struct.anon.154, %struct.anon.154* %70, i32 0, i32 1
  %71 = load i32, i32* %btf_id48, align 8
  %call49 = call i8* @kernel_type_name(%struct.btf* noundef %67, i32 noundef %71) #14
  %72 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %73 = load i32*, i32** %arg_btf_id.addr, align 8
  %74 = load i32, i32* %73, align 4
  %call50 = call i8* @kernel_type_name(%struct.btf* noundef %72, i32 noundef %74) #14
  call void (i8*, i8*, ...) @verbose(i8* noundef %62, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.368, i64 0, i64 0), i32 noundef %63, i8* noundef %call49, i8* noundef %call50) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.end43
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 5
  %76 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call52 = call zeroext i1 @tnum_is_const(i64 %78, i64 %80) #14
  br i1 %call52, label %lor.lhs.false, label %if.then55

lor.lhs.false:                                    ; preds = %if.end51
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off53, i32 0, i32 0
  %82 = load i64, i64* %value, align 8
  %tobool54 = icmp ne i64 %82, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %lor.lhs.false, %if.end51
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = bitcast %struct.bpf_verifier_env* %83 to i8*
  %85 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %84, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.369, i64 0, i64 0), i32 noundef %85) #14
  store i32 -13, i32* %retval, align 4
  br label %return

if.end56:                                         ; preds = %lor.lhs.false
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %found
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end57, %if.then55, %if.then46, %if.then40, %for.end28, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i1 noundef zeroext %is_lock) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %is_lock.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %is_const = alloca i8, align 1
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_lock to i8
  store i8 %frombool, i8* %is_lock.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %4, %struct.bpf_verifier_state** %cur, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %6 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %8, i64 %10) #14
  %frombool2 = zext i1 %call1 to i8
  store i8 %frombool2, i8* %is_const, align 1
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %13 = bitcast %union.anon.152* %12 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %13, i32 0, i32 0
  %14 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %14, %struct.bpf_map** %map, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %16 = load i64, i64* %value, align 8
  store i64 %16, i64* %val, align 8
  %17 = load i8, i8* %is_const, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([82 x i8], [82 x i8]* @.str.382, i64 0, i64 0), i32 noundef %20) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %21, i32 0, i32 14
  %22 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool4 = icmp ne %struct.btf* %22, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %25, i32 0, i32 15
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.383, i64 0, i64 0), i8* noundef %arraydecay) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %26 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call7 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %26) #14
  br i1 %call7, label %if.end22, label %if.then8

if.then8:                                         ; preds = %if.end6
  %27 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %27, i32 0, i32 8
  %28 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp eq i32 %28, -7
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name10 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 15
  %arraydecay11 = getelementptr inbounds [16 x i8], [16 x i8]* %name10, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.384, i64 0, i64 0), i8* noundef %arraydecay11) #14
  br label %if.end21

if.else:                                          ; preds = %if.then8
  %32 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off12 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %32, i32 0, i32 8
  %33 = load i32, i32* %spin_lock_off12, align 4
  %cmp13 = icmp eq i32 %33, -2
  br i1 %cmp13, label %if.then14, label %if.else17

if.then14:                                        ; preds = %if.else
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name15 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %36, i32 0, i32 15
  %arraydecay16 = getelementptr inbounds [16 x i8], [16 x i8]* %name15, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.385, i64 0, i64 0), i8* noundef %arraydecay16) #14
  br label %if.end20

if.else17:                                        ; preds = %if.else
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name18 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %39, i32 0, i32 15
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %name18, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.386, i64 0, i64 0), i8* noundef %arraydecay19) #14
  br label %if.end20

if.end20:                                         ; preds = %if.else17, %if.then14
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end6
  %40 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off23 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %40, i32 0, i32 8
  %41 = load i32, i32* %spin_lock_off23, align 4
  %conv = sext i32 %41 to i64
  %42 = load i64, i64* %val, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 1
  %44 = load i32, i32* %off, align 4
  %conv24 = sext i32 %44 to i64
  %add = add i64 %42, %conv24
  %cmp25 = icmp ne i64 %conv, %add
  br i1 %cmp25, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.end22
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = bitcast %struct.bpf_verifier_env* %45 to i8*
  %47 = load i64, i64* %val, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 1
  %49 = load i32, i32* %off28, align 4
  %conv29 = sext i32 %49 to i64
  %add30 = add i64 %47, %conv29
  call void (i8*, i8*, ...) @verbose(i8* noundef %46, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.387, i64 0, i64 0), i64 noundef %add30) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end22
  %50 = load i8, i8* %is_lock.addr, align 1
  %tobool32 = trunc i8 %50 to i1
  br i1 %tobool32, label %if.then33, label %if.else38

if.then33:                                        ; preds = %if.end31
  %51 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %51, i32 0, i32 5
  %52 = load i32, i32* %active_spin_lock, align 4
  %tobool34 = icmp ne i32 %52, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then33
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.388, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then33
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 3
  %56 = load i32, i32* %id, align 8
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock37 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %57, i32 0, i32 5
  store i32 %56, i32* %active_spin_lock37, align 4
  br label %if.end50

if.else38:                                        ; preds = %if.end31
  %58 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock39 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %58, i32 0, i32 5
  %59 = load i32, i32* %active_spin_lock39, align 4
  %tobool40 = icmp ne i32 %59, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.else38
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.389, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.else38
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock43 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %62, i32 0, i32 5
  %63 = load i32, i32* %active_spin_lock43, align 4
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 3
  %65 = load i32, i32* %id44, align 8
  %cmp45 = icmp ne i32 %63, %65
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end42
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.390, i64 0, i64 0)) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end42
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock49 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %68, i32 0, i32 5
  store i32 0, i32* %active_spin_lock49, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.end48, %if.end36
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end50, %if.then47, %if.then41, %if.then35, %if.then27, %if.end21, %if.then5, %if.then
  %69 = load i32, i32* %retval, align 4
  ret i32 %69
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_timer_func(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %is_const = alloca i8, align 1
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #14
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %4 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %6, i64 %8) #14
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %is_const, align 1
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 2
  %11 = bitcast %union.anon.152* %10 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %11, i32 0, i32 0
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %12, %struct.bpf_map** %map, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  store i64 %14, i64* %val, align 8
  %15 = load i8, i8* %is_const, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.391, i64 0, i64 0), i32 noundef %18) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %19, i32 0, i32 14
  %20 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool3 = icmp ne %struct.btf* %20, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %23, i32 0, i32 15
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.392, i64 0, i64 0), i8* noundef %arraydecay) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %24 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call6 = call zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %24) #14
  br i1 %call6, label %if.end21, label %if.then7

if.then7:                                         ; preds = %if.end5
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %25, i32 0, i32 9
  %26 = load i32, i32* %timer_off, align 16
  %cmp = icmp eq i32 %26, -7
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then7
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %29, i32 0, i32 15
  %arraydecay10 = getelementptr inbounds [16 x i8], [16 x i8]* %name9, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.393, i64 0, i64 0), i8* noundef %arraydecay10) #14
  br label %if.end20

if.else:                                          ; preds = %if.then7
  %30 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off11 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %30, i32 0, i32 9
  %31 = load i32, i32* %timer_off11, align 16
  %cmp12 = icmp eq i32 %31, -2
  br i1 %cmp12, label %if.then13, label %if.else16

if.then13:                                        ; preds = %if.else
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name14 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %34, i32 0, i32 15
  %arraydecay15 = getelementptr inbounds [16 x i8], [16 x i8]* %name14, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.394, i64 0, i64 0), i8* noundef %arraydecay15) #14
  br label %if.end19

if.else16:                                        ; preds = %if.else
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name17 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %37, i32 0, i32 15
  %arraydecay18 = getelementptr inbounds [16 x i8], [16 x i8]* %name17, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.395, i64 0, i64 0), i8* noundef %arraydecay18) #14
  br label %if.end19

if.end19:                                         ; preds = %if.else16, %if.then13
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end5
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off22 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %38, i32 0, i32 9
  %39 = load i32, i32* %timer_off22, align 16
  %conv = sext i32 %39 to i64
  %40 = load i64, i64* %val, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 1
  %42 = load i32, i32* %off, align 4
  %conv23 = sext i32 %42 to i64
  %add = add i64 %40, %conv23
  %cmp24 = icmp ne i64 %conv, %add
  br i1 %cmp24, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.end21
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i64, i64* %val, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 1
  %47 = load i32, i32* %off27, align 4
  %conv28 = sext i32 %47 to i64
  %add29 = add i64 %45, %conv28
  %48 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off30 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %48, i32 0, i32 9
  %49 = load i32, i32* %timer_off30, align 16
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.396, i64 0, i64 0), i64 noundef %add29, i32 noundef %49) #14
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end21
  %50 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr32 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %50, i32 0, i32 0
  %51 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr32, align 8
  %tobool33 = icmp ne %struct.bpf_map* %51, null
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.397, i64 0, i64 0)) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end31
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 2
  %56 = bitcast %union.anon.152* %55 to %struct.anon.153*
  %map_uid = getelementptr inbounds %struct.anon.153, %struct.anon.153* %56, i32 0, i32 1
  %57 = load i32, i32* %map_uid, align 8
  %58 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid36 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %58, i32 0, i32 8
  store i32 %57, i32* %map_uid36, align 4
  %59 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %60 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr37 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %60, i32 0, i32 0
  store %struct.bpf_map* %59, %struct.bpf_map** %map_ptr37, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end35, %if.then34, %if.then26, %if.end20, %if.then4, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_alloc_size(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 23
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_int_ptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 16
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 17
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @int_ptr_type_to_size(i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 4, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 17
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store i32 8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @strnchr(i8* noundef, i64 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, i32 noundef, i32 noundef, %struct.btf* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %aux, %struct.bpf_map* noundef %map, i1 noundef zeroext %unpriv) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %unpriv.addr = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %frombool = zext i1 %unpriv to i8
  store i8 %frombool, i8* %unpriv.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %0) #14
  %conv = zext i1 %call to i32
  %1 = load i8, i8* %unpriv.addr, align 1
  %tobool = trunc i8 %1 to i1
  %conv1 = zext i1 %tobool to i32
  %or = or i32 %conv1, %conv
  %tobool2 = icmp ne i32 %or, 0
  %frombool3 = zext i1 %tobool2 to i8
  store i8 %frombool3, i8* %unpriv.addr, align 1
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %3 = ptrtoint %struct.bpf_map* %2 to i64
  %4 = load i8, i8* %unpriv.addr, align 1
  %tobool4 = trunc i8 %4 to i1
  %5 = zext i1 %tobool4 to i64
  %cond = select i1 %tobool4, i64 1, i64 0
  %or6 = or i64 %3, %cond
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %7 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %6, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.163* %7 to i64*
  store i64 %or6, i64* %map_ptr_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.163* %1 to i64*
  %2 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %2, 1
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %aux, i64 noundef %state) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %state.addr = alloca i64, align 8
  %poisoned = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i64 %state, i64* %state.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %0) #14
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %poisoned, align 1
  %1 = load i64, i64* %state.addr, align 8
  %or = or i64 %1, 4611686018427387904
  %2 = load i8, i8* %poisoned, align 1
  %tobool = trunc i8 %2 to i1
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i64 -9223372036854775808, i64 0
  %or1 = or i64 %or, %cond
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i32 0, i32 1
  store i64 %or1, i64* %map_key_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_key_unseen(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, 4611686018427387904
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, -9223372036854775808
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, 4611686018427387903
  ret i64 %and
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference_state(%struct.bpf_func_state* noundef %state, i32 noundef %ptr_id) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ptr_id.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %last_idx = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ptr_id, i32* %ptr_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 7
  %1 = load i32, i32* %acquired_refs, align 4
  %sub = sub i32 %1, 1
  store i32 %sub, i32* %last_idx, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 7
  %4 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 8
  %6 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %6, i64 %idxprom
  %id = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx, i32 0, i32 0
  %8 = load i32, i32* %id, align 4
  %9 = load i32, i32* %ptr_id.addr, align 4
  %cmp2 = icmp eq i32 %8, %9
  br i1 %cmp2, label %if.then, label %if.end15

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %last_idx, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %last_idx, align 4
  %cmp3 = icmp ne i32 %11, %12
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 8
  %14 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs5, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %14, i64 %idxprom6
  %16 = bitcast %struct.bpf_reference_state* %arrayidx7 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 8
  %18 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs8, align 8
  %19 = load i32, i32* %last_idx, align 4
  %idxprom9 = sext i32 %19 to i64
  %arrayidx10 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %18, i64 %idxprom9
  %20 = bitcast %struct.bpf_reference_state* %arrayidx10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %16, i8* align 4 %20, i64 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 8
  %22 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs11, align 8
  %23 = load i32, i32* %last_idx, align 4
  %idxprom12 = sext i32 %23 to i64
  %arrayidx13 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %22, i64 %idxprom12
  %24 = bitcast %struct.bpf_reference_state* %arrayidx13 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %24, i8 0, i64 8, i1 false)
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 7
  %26 = load i32, i32* %acquired_refs14, align 4
  %dec = add i32 %26, -1
  store i32 %dec, i32* %acquired_refs14, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %27 = load i32, i32* %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end
  %28 = load i32, i32* %retval, align 4
  ret i32 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_reg_references(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %ref_obj_id) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  %ref_obj_id2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %ref_obj_id2, align 4
  %5 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp3 = icmp eq i32 %4, %5
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %10 = load i32, i32* %i, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 9
  %12 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %12, 8
  %cmp4 = icmp slt i32 %10, %div
  br i1 %cmp4, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 10
  %14 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %14, i64 %idxprom5
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 1
  %arrayidx7 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %16 = load i8, i8* %arrayidx7, align 8
  %conv = zext i8 %16 to i32
  %cmp8 = icmp eq i32 %conv, 1
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 10
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack10, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %19 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom11
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond13

for.cond13:                                       ; preds = %cond.end47, %cond.end
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 9
  %22 = load i32, i32* %allocated_stack14, align 8
  %div15 = sdiv i32 %22, 8
  %cmp16 = icmp slt i32 %20, %div15
  br i1 %cmp16, label %for.body18, label %for.end49

for.body18:                                       ; preds = %for.cond13
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %23, null
  br i1 %tobool, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.body18
  br label %for.inc26

if.end20:                                         ; preds = %for.body18
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 4
  %25 = load i32, i32* %ref_obj_id21, align 4
  %26 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp22 = icmp eq i32 %25, %26
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end20
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %28) #14
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end20
  br label %for.inc26

for.inc26:                                        ; preds = %if.end25, %if.then19
  %29 = load i32, i32* %i, align 4
  %inc27 = add i32 %29, 1
  store i32 %inc27, i32* %i, align 4
  %30 = load i32, i32* %i, align 4
  %31 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack28 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %31, i32 0, i32 9
  %32 = load i32, i32* %allocated_stack28, align 8
  %div29 = sdiv i32 %32, 8
  %cmp30 = icmp slt i32 %30, %div29
  br i1 %cmp30, label %land.lhs.true32, label %cond.false46

land.lhs.true32:                                  ; preds = %for.inc26
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack33 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 10
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack33, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom34 = sext i32 %35 to i64
  %arrayidx35 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom34
  %slot_type36 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx35, i32 0, i32 1
  %arrayidx37 = getelementptr [8 x i8], [8 x i8]* %slot_type36, i64 0, i64 0
  %36 = load i8, i8* %arrayidx37, align 8
  %conv38 = zext i8 %36 to i32
  %cmp39 = icmp eq i32 %conv38, 1
  br i1 %cmp39, label %cond.true41, label %cond.false46

cond.true41:                                      ; preds = %land.lhs.true32
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 10
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %39 = load i32, i32* %i, align 4
  %idxprom43 = sext i32 %39 to i64
  %arrayidx44 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom43
  %spilled_ptr45 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx44, i32 0, i32 0
  br label %cond.end47

cond.false46:                                     ; preds = %land.lhs.true32, %for.inc26
  br label %cond.end47

cond.end47:                                       ; preds = %cond.false46, %cond.true41
  %cond48 = phi %struct.bpf_reg_state* [ %spilled_ptr45, %cond.true41 ], [ null, %cond.false46 ]
  store %struct.bpf_reg_state* %cond48, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond13

for.end49:                                        ; preds = %for.cond13
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.163* %1 to i64*
  %2 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %2, -2
  %3 = inttoptr i64 %and to %struct.bpf_map*
  %cmp = icmp eq %struct.bpf_map* %3, inttoptr (i64 -2401263026318485698 to %struct.bpf_map*)
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_bprintf_prepare(i8* noundef, i32 noundef, i64* noundef, i32** noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resize_reference_state(%struct.bpf_func_state* noundef %state, i64 noundef %n) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %n.addr = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 8
  %1 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %2 = bitcast %struct.bpf_reference_state* %1 to i8*
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 7
  %4 = load i32, i32* %acquired_refs, align 4
  %conv = sext i32 %4 to i64
  %5 = load i64, i64* %n.addr, align 8
  %call = call i8* @realloc_array(i8* noundef %2, i64 noundef %conv, i64 noundef %5, i64 noundef 8) #14
  %6 = bitcast i8* %call to %struct.bpf_reference_state*
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 8
  store %struct.bpf_reference_state* %6, %struct.bpf_reference_state** %refs1, align 8
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 8
  %9 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs2, align 8
  %tobool = icmp ne %struct.bpf_reference_state* %9, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %n.addr, align 8
  %conv3 = trunc i64 %10 to i32
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  store i32 %conv3, i32* %acquired_refs4, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %eatype = alloca i32, align 4
  %type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 3
  %2 = load i32, i32* %expected_attach_type, align 8
  store i32 %2, i32* %eatype, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #14
  store i32 %call, i32* %type, align 4
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %type, align 4
  switch i32 %6, label %sw.default [
    i32 26, label %sw.bb
    i32 1, label %sw.bb5
    i32 3, label %sw.bb5
    i32 4, label %sw.bb5
    i32 6, label %sw.bb5
    i32 21, label %sw.bb5
    i32 22, label %sw.bb5
    i32 30, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %7 = load i32, i32* %eatype, align 4
  %cmp2 = icmp eq i32 %7, 28
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %sw.bb
  store i1 true, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end, %if.end, %if.end, %if.end, %if.end, %if.end, %if.end
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.405, i64 0, i64 0)) #14
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb5, %if.then3, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ true, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  %call = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %arrayidx) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 9
  %10 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %10, 8
  %cmp2 = icmp slt i32 %8, %div
  br i1 %cmp2, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 10
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %13 to i64
  %arrayidx4 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom3
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx4, i32 0, i32 1
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %14 = load i8, i8* %arrayidx5, align 8
  %conv = zext i8 %14 to i32
  %cmp6 = icmp eq i32 %conv, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 10
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack8, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %17 to i64
  %arrayidx10 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom9
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx10, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %cond.end43, %cond.end
  %18 = load i32, i32* %i, align 4
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 9
  %20 = load i32, i32* %allocated_stack12, align 8
  %div13 = sdiv i32 %20, 8
  %cmp14 = icmp slt i32 %18, %div13
  br i1 %cmp14, label %for.body16, label %for.end45

for.body16:                                       ; preds = %for.cond11
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %21, null
  br i1 %tobool, label %if.end18, label %if.then17

if.then17:                                        ; preds = %for.body16
  br label %for.inc22

if.end18:                                         ; preds = %for.body16
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call19 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %22) #14
  br i1 %call19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %23, %struct.bpf_reg_state* noundef %24) #14
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end18
  br label %for.inc22

for.inc22:                                        ; preds = %if.end21, %if.then17
  %25 = load i32, i32* %i, align 4
  %inc23 = add i32 %25, 1
  store i32 %inc23, i32* %i, align 4
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 9
  %28 = load i32, i32* %allocated_stack24, align 8
  %div25 = sdiv i32 %28, 8
  %cmp26 = icmp slt i32 %26, %div25
  br i1 %cmp26, label %land.lhs.true28, label %cond.false42

land.lhs.true28:                                  ; preds = %for.inc22
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 10
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack29, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom30 = sext i32 %31 to i64
  %arrayidx31 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom30
  %slot_type32 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx31, i32 0, i32 1
  %arrayidx33 = getelementptr [8 x i8], [8 x i8]* %slot_type32, i64 0, i64 0
  %32 = load i8, i8* %arrayidx33, align 8
  %conv34 = zext i8 %32 to i32
  %cmp35 = icmp eq i32 %conv34, 1
  br i1 %cmp35, label %cond.true37, label %cond.false42

cond.true37:                                      ; preds = %land.lhs.true28
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack38 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 10
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack38, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom39 = sext i32 %35 to i64
  %arrayidx40 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom39
  %spilled_ptr41 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx40, i32 0, i32 0
  br label %cond.end43

cond.false42:                                     ; preds = %land.lhs.true28, %for.inc22
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false42, %cond.true37
  %cond44 = phi %struct.bpf_reg_state* [ %spilled_ptr41, %cond.true37 ], [ null, %cond.false42 ]
  store %struct.bpf_reg_state* %cond44, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond11

for.end45:                                        ; preds = %for.cond11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %0) #14
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %2, 9
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, %struct.tnum* noundef %range, i8* noundef %ctx, i8* noundef %reg_name) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %range.addr = alloca %struct.tnum*, align 8
  %ctx.addr = alloca i8*, align 8
  %reg_name.addr = alloca i8*, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store %struct.tnum* %range, %struct.tnum** %range.addr, align 8
  store i8* %ctx, i8** %ctx.addr, align 8
  store i8* %reg_name, i8** %reg_name.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = bitcast %struct.bpf_verifier_env* %0 to i8*
  %2 = load i8*, i8** %ctx.addr, align 8
  %3 = load i8*, i8** %reg_name.addr, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %1, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.414, i64 0, i64 0), i8* noundef %2, i8* noundef %3) #14
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call = call zeroext i1 @tnum_is_unknown(i64 %7, i64 %9) #14
  br i1 %call, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call2 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %13, i64 %15) #14
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %arraydecay3 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.415, i64 0, i64 0), i8* noundef %arraydecay3) #14
  br label %if.end

if.else:                                          ; preds = %entry
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.416, i64 0, i64 0)) #14
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %arraydecay4 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %20 = load %struct.tnum*, %struct.tnum** %range.addr, align 8
  %21 = bitcast %struct.tnum* %20 to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = load i64, i64* %24, align 8
  %call5 = call i32 @tnum_strn(i8* noundef %arraydecay4, i64 noundef 48, i64 %23, i64 %25) #14
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %arraydecay6 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.417, i64 0, i64 0), i8* noundef %arraydecay6) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_pkt_ptr_branch_taken(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %opcode.addr = alloca i8, align 1
  %pkt = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %2, %struct.bpf_reg_state** %pkt, align 8
  br label %if.end6

if.else:                                          ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  %cmp2 = icmp eq i32 %4, 9
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %5, %struct.bpf_reg_state** %pkt, align 8
  %6 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %6 to i32
  %call = call i32 @flip_opcode(i32 noundef %conv) #14
  %conv4 = trunc i32 %call to i8
  store i8 %conv4, i8* %opcode.addr, align 1
  br label %if.end

if.else5:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then3
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 2
  %range = bitcast %union.anon.152* %8 to i32*
  %9 = load i32, i32* %range, align 8
  %cmp7 = icmp sge i32 %9, 0
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  store i32 -1, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %10 = load i8, i8* %opcode.addr, align 1
  %conv11 = zext i8 %10 to i32
  switch i32 %conv11, label %sw.epilog [
    i32 176, label %sw.bb
    i32 32, label %sw.bb12
    i32 160, label %sw.bb21
    i32 48, label %sw.bb22
  ]

sw.bb:                                            ; preds = %if.end10
  br label %sw.bb12

sw.bb12:                                          ; preds = %if.end10, %sw.bb
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %range13 = bitcast %union.anon.152* %12 to i32*
  %13 = load i32, i32* %range13, align 8
  %cmp14 = icmp eq i32 %13, -2
  br i1 %cmp14, label %if.then16, label %if.end20

if.then16:                                        ; preds = %sw.bb12
  %14 = load i8, i8* %opcode.addr, align 1
  %conv17 = zext i8 %14 to i32
  %cmp18 = icmp eq i32 %conv17, 32
  %conv19 = zext i1 %cmp18 to i32
  store i32 %conv19, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %sw.bb12
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.end10
  br label %sw.bb22

sw.bb22:                                          ; preds = %if.end10, %sw.bb21
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 2
  %range23 = bitcast %union.anon.152* %16 to i32*
  %17 = load i32, i32* %range23, align 8
  %cmp24 = icmp eq i32 %17, -2
  br i1 %cmp24, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb22
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %range26 = bitcast %union.anon.152* %19 to i32*
  %20 = load i32, i32* %range26, align 8
  %cmp27 = icmp eq i32 %20, -1
  br i1 %cmp27, label %if.then29, label %if.end33

if.then29:                                        ; preds = %lor.lhs.false, %sw.bb22
  %21 = load i8, i8* %opcode.addr, align 1
  %conv30 = zext i8 %21 to i32
  %cmp31 = icmp eq i32 %conv30, 48
  %conv32 = zext i1 %cmp31 to i32
  store i32 %conv32, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %lor.lhs.false
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end10, %if.end33, %if.end20
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then29, %if.then16, %if.then9, %if.else5
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_equal_scalars(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %known_reg) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %known_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %known_reg, %struct.bpf_reg_state** %known_reg.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc61, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end63

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %6 = load i32, i32* %j, align 4
  %cmp2 = icmp slt i32 %6, 11
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %8 = load i32, i32* %j, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %reg, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  %cmp6 = icmp eq i32 %10, 1
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body3
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 3
  %12 = load i32, i32* %id, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 3
  %14 = load i32, i32* %id7, align 8
  %cmp8 = icmp eq i32 %12, %14
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %17 = bitcast %struct.bpf_reg_state* %15 to i8*
  %18 = bitcast %struct.bpf_reg_state* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %18, i64 120, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i32, i32* %j, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  store i32 0, i32* %j, align 4
  %20 = load i32, i32* %j, align 4
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 9
  %22 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %22, 8
  %cmp9 = icmp slt i32 %20, %div
  br i1 %cmp9, label %land.lhs.true10, label %cond.false

land.lhs.true10:                                  ; preds = %for.end
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 10
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %25 = load i32, i32* %j, align 4
  %idxprom11 = sext i32 %25 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %24, i64 %idxprom11
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 1
  %arrayidx13 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %26 = load i8, i8* %arrayidx13, align 8
  %conv = zext i8 %26 to i32
  %cmp14 = icmp eq i32 %conv, 1
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true10
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 10
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack16, align 8
  %29 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom17
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx18, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true10, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond19

for.cond19:                                       ; preds = %cond.end58, %cond.end
  %30 = load i32, i32* %j, align 4
  %31 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %31, i32 0, i32 9
  %32 = load i32, i32* %allocated_stack20, align 8
  %div21 = sdiv i32 %32, 8
  %cmp22 = icmp slt i32 %30, %div21
  br i1 %cmp22, label %for.body24, label %for.end60

for.body24:                                       ; preds = %for.cond19
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %33, null
  br i1 %tobool, label %if.end26, label %if.then25

if.then25:                                        ; preds = %for.body24
  br label %for.inc37

if.end26:                                         ; preds = %for.body24
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 0
  %35 = load i32, i32* %type27, align 8
  %cmp28 = icmp eq i32 %35, 1
  br i1 %cmp28, label %land.lhs.true30, label %if.end36

land.lhs.true30:                                  ; preds = %if.end26
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 3
  %37 = load i32, i32* %id31, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %id32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 3
  %39 = load i32, i32* %id32, align 8
  %cmp33 = icmp eq i32 %37, %39
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true30
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %42 = bitcast %struct.bpf_reg_state* %40 to i8*
  %43 = bitcast %struct.bpf_reg_state* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %42, i8* align 8 %43, i64 120, i1 false)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %land.lhs.true30, %if.end26
  br label %for.inc37

for.inc37:                                        ; preds = %if.end36, %if.then25
  %44 = load i32, i32* %j, align 4
  %inc38 = add i32 %44, 1
  store i32 %inc38, i32* %j, align 4
  %45 = load i32, i32* %j, align 4
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack39 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 9
  %47 = load i32, i32* %allocated_stack39, align 8
  %div40 = sdiv i32 %47, 8
  %cmp41 = icmp slt i32 %45, %div40
  br i1 %cmp41, label %land.lhs.true43, label %cond.false57

land.lhs.true43:                                  ; preds = %for.inc37
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack44 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 10
  %49 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack44, align 8
  %50 = load i32, i32* %j, align 4
  %idxprom45 = sext i32 %50 to i64
  %arrayidx46 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %49, i64 %idxprom45
  %slot_type47 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx46, i32 0, i32 1
  %arrayidx48 = getelementptr [8 x i8], [8 x i8]* %slot_type47, i64 0, i64 0
  %51 = load i8, i8* %arrayidx48, align 8
  %conv49 = zext i8 %51 to i32
  %cmp50 = icmp eq i32 %conv49, 1
  br i1 %cmp50, label %cond.true52, label %cond.false57

cond.true52:                                      ; preds = %land.lhs.true43
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack53 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %52, i32 0, i32 10
  %53 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack53, align 8
  %54 = load i32, i32* %j, align 4
  %idxprom54 = sext i32 %54 to i64
  %arrayidx55 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %53, i64 %idxprom54
  %spilled_ptr56 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx55, i32 0, i32 0
  br label %cond.end58

cond.false57:                                     ; preds = %land.lhs.true43, %for.inc37
  br label %cond.end58

cond.end58:                                       ; preds = %cond.false57, %cond.true52
  %cond59 = phi %struct.bpf_reg_state* [ %spilled_ptr56, %cond.true52 ], [ null, %cond.false57 ]
  store %struct.bpf_reg_state* %cond59, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond19

for.end60:                                        ; preds = %for.cond19
  br label %for.inc61

for.inc61:                                        ; preds = %for.end60
  %55 = load i32, i32* %i, align 4
  %inc62 = add i32 %55, 1
  store i32 %inc62, i32* %i, align 4
  br label %for.cond

for.end63:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %vstate, i32 noundef %regno, i1 noundef zeroext %is_null) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %regno.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %ref_obj_id = alloca i32, align 4
  %id = alloca i32, align 4
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom2
  %ref_obj_id4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 4
  %7 = load i32, i32* %ref_obj_id4, align 4
  store i32 %7, i32* %ref_obj_id, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idxprom5 = zext i32 %9 to i64
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idxprom5
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 3
  %10 = load i32, i32* %id7, align 8
  store i32 %10, i32* %id, align 4
  %11 = load i32, i32* %ref_obj_id, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %entry
  %12 = load i32, i32* %ref_obj_id, align 4
  %13 = load i32, i32* %id, align 4
  %cmp = icmp eq i32 %12, %13
  br i1 %cmp, label %land.lhs.true8, label %if.end31

land.lhs.true8:                                   ; preds = %land.lhs.true
  %14 = load i8, i8* %is_null.addr, align 1
  %tobool9 = trunc i8 %14 to i1
  br i1 %tobool9, label %if.then, label %if.end31

if.then:                                          ; preds = %land.lhs.true8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %16 = load i32, i32* %id, align 4
  %call = call i32 @release_reference_state(%struct.bpf_func_state* noundef %15, i32 noundef %16) #14
  %tobool10 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %17 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %17, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext16 to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then18
  br label %do.body19

do.body19:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body19
  br label %do.body20

do.body20:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9112, i32 2307, i64 12) #13, !srcloc !67
  br label %do.end21

do.end21:                                         ; preds = %do.body20
  call void asm sideeffect "538:\0A\09.pushsection .discard.reachable\0A\09.long 538b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !68
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  br label %do.end24

do.end24:                                         ; preds = %do.end23
  br label %if.end

if.end:                                           ; preds = %do.end24, %if.then
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool25 = icmp ne i32 %18, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  store i64 %conv30, i64* %tmp, align 8
  %19 = load i64, i64* %tmp, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end, %land.lhs.true8, %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end31
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe32 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 4
  %22 = load i32, i32* %curframe32, align 8
  %cmp33 = icmp ule i32 %20, %22
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame35 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %24 to i64
  %arrayidx37 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame35, i64 0, i64 %idxprom36
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx37, align 8
  %26 = load i32, i32* %id, align 4
  %27 = load i8, i8* %is_null.addr, align 1
  %tobool38 = trunc i8 %27 to i1
  call void @__mark_ptr_or_null_regs(%struct.bpf_func_state* noundef %25, i32 noundef %26, i1 noundef zeroext %tobool38) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_verifier_state* noundef %this_branch, %struct.bpf_verifier_state* noundef %other_branch) #0 {
entry:
  %retval = alloca i1, align 1
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %this_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  %other_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_verifier_state* %this_branch, %struct.bpf_verifier_state** %this_branch.addr, align 8
  store %struct.bpf_verifier_state* %other_branch, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 8
  %cmp = icmp ne i32 %and, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 7
  %cmp5 = icmp eq i32 %and4, 6
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 0
  %5 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %5 to i32
  %and11 = and i32 %conv10, 240
  switch i32 %and11, label %sw.default [
    i32 32, label %sw.bb
    i32 160, label %sw.bb48
    i32 48, label %sw.bb93
    i32 176, label %sw.bb138
  ]

sw.bb:                                            ; preds = %if.end8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp12 = icmp eq i32 %7, 8
  br i1 %cmp12, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %9, 9
  br i1 %cmp15, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %sw.bb
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type17, align 8
  %cmp18 = icmp eq i32 %11, 7
  br i1 %cmp18, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %lor.lhs.false
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %12, i32 noundef 8) #14
  br i1 %call, label %if.then22, label %if.else

if.then22:                                        ; preds = %land.lhs.true20, %land.lhs.true
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type23, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef %16, i1 noundef zeroext false) #14
  %17 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg24, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv25 = zext i8 %bf.clear to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %17, i32 noundef %conv25, i1 noundef zeroext true) #14
  br label %if.end47

if.else:                                          ; preds = %land.lhs.true20, %lor.lhs.false
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type26, align 8
  %cmp27 = icmp eq i32 %20, 9
  br i1 %cmp27, label %land.lhs.true29, label %lor.lhs.false33

land.lhs.true29:                                  ; preds = %if.else
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type30, align 8
  %cmp31 = icmp eq i32 %22, 8
  br i1 %cmp31, label %if.then40, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %land.lhs.true29, %if.else
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call34 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %23, i32 noundef 8) #14
  br i1 %call34, label %land.lhs.true36, label %if.else45

land.lhs.true36:                                  ; preds = %lor.lhs.false33
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type37, align 8
  %cmp38 = icmp eq i32 %25, 7
  br i1 %cmp38, label %if.then40, label %if.else45

if.then40:                                        ; preds = %land.lhs.true36, %land.lhs.true29
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 0
  %29 = load i32, i32* %type41, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %26, %struct.bpf_reg_state* noundef %27, i32 noundef %29, i1 noundef zeroext true) #14
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg42 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load43 = load i8, i8* %src_reg42, align 1
  %bf.lshr = lshr i8 %bf.load43, 4
  %conv44 = zext i8 %bf.lshr to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %30, i32 noundef %conv44, i1 noundef zeroext false) #14
  br label %if.end46

if.else45:                                        ; preds = %land.lhs.true36, %lor.lhs.false33
  store i1 false, i1* %retval, align 1
  br label %return

if.end46:                                         ; preds = %if.then40
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then22
  br label %sw.epilog

sw.bb48:                                          ; preds = %if.end8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %33, 8
  br i1 %cmp50, label %land.lhs.true52, label %lor.lhs.false56

land.lhs.true52:                                  ; preds = %sw.bb48
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 0
  %35 = load i32, i32* %type53, align 8
  %cmp54 = icmp eq i32 %35, 9
  br i1 %cmp54, label %if.then63, label %lor.lhs.false56

lor.lhs.false56:                                  ; preds = %land.lhs.true52, %sw.bb48
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type57, align 8
  %cmp58 = icmp eq i32 %37, 7
  br i1 %cmp58, label %land.lhs.true60, label %if.else69

land.lhs.true60:                                  ; preds = %lor.lhs.false56
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call61 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %38, i32 noundef 8) #14
  br i1 %call61, label %if.then63, label %if.else69

if.then63:                                        ; preds = %land.lhs.true60, %land.lhs.true52
  %39 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type64, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %39, %struct.bpf_reg_state* noundef %40, i32 noundef %42, i1 noundef zeroext true) #14
  %43 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 1
  %bf.load66 = load i8, i8* %dst_reg65, align 1
  %bf.clear67 = and i8 %bf.load66, 15
  %conv68 = zext i8 %bf.clear67 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %43, i32 noundef %conv68, i1 noundef zeroext false) #14
  br label %if.end92

if.else69:                                        ; preds = %land.lhs.true60, %lor.lhs.false56
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 0
  %46 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %46, 9
  br i1 %cmp71, label %land.lhs.true73, label %lor.lhs.false77

land.lhs.true73:                                  ; preds = %if.else69
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 0
  %48 = load i32, i32* %type74, align 8
  %cmp75 = icmp eq i32 %48, 8
  br i1 %cmp75, label %if.then84, label %lor.lhs.false77

lor.lhs.false77:                                  ; preds = %land.lhs.true73, %if.else69
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call78 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %49, i32 noundef 8) #14
  br i1 %call78, label %land.lhs.true80, label %if.else90

land.lhs.true80:                                  ; preds = %lor.lhs.false77
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  %51 = load i32, i32* %type81, align 8
  %cmp82 = icmp eq i32 %51, 7
  br i1 %cmp82, label %if.then84, label %if.else90

if.then84:                                        ; preds = %land.lhs.true80, %land.lhs.true73
  %52 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 0
  %55 = load i32, i32* %type85, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %52, %struct.bpf_reg_state* noundef %53, i32 noundef %55, i1 noundef zeroext false) #14
  %56 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %57, i32 0, i32 1
  %bf.load87 = load i8, i8* %src_reg86, align 1
  %bf.lshr88 = lshr i8 %bf.load87, 4
  %conv89 = zext i8 %bf.lshr88 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %56, i32 noundef %conv89, i1 noundef zeroext true) #14
  br label %if.end91

if.else90:                                        ; preds = %land.lhs.true80, %lor.lhs.false77
  store i1 false, i1* %retval, align 1
  br label %return

if.end91:                                         ; preds = %if.then84
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.then63
  br label %sw.epilog

sw.bb93:                                          ; preds = %if.end8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 0
  %59 = load i32, i32* %type94, align 8
  %cmp95 = icmp eq i32 %59, 8
  br i1 %cmp95, label %land.lhs.true97, label %lor.lhs.false101

land.lhs.true97:                                  ; preds = %sw.bb93
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 0
  %61 = load i32, i32* %type98, align 8
  %cmp99 = icmp eq i32 %61, 9
  br i1 %cmp99, label %if.then108, label %lor.lhs.false101

lor.lhs.false101:                                 ; preds = %land.lhs.true97, %sw.bb93
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 0
  %63 = load i32, i32* %type102, align 8
  %cmp103 = icmp eq i32 %63, 7
  br i1 %cmp103, label %land.lhs.true105, label %if.else114

land.lhs.true105:                                 ; preds = %lor.lhs.false101
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call106 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %64, i32 noundef 8) #14
  br i1 %call106, label %if.then108, label %if.else114

if.then108:                                       ; preds = %land.lhs.true105, %land.lhs.true97
  %65 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 0
  %68 = load i32, i32* %type109, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %65, %struct.bpf_reg_state* noundef %66, i32 noundef %68, i1 noundef zeroext true) #14
  %69 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %70 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %70, i32 0, i32 1
  %bf.load111 = load i8, i8* %dst_reg110, align 1
  %bf.clear112 = and i8 %bf.load111, 15
  %conv113 = zext i8 %bf.clear112 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %69, i32 noundef %conv113, i1 noundef zeroext false) #14
  br label %if.end137

if.else114:                                       ; preds = %land.lhs.true105, %lor.lhs.false101
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 0
  %72 = load i32, i32* %type115, align 8
  %cmp116 = icmp eq i32 %72, 9
  br i1 %cmp116, label %land.lhs.true118, label %lor.lhs.false122

land.lhs.true118:                                 ; preds = %if.else114
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type119 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 0
  %74 = load i32, i32* %type119, align 8
  %cmp120 = icmp eq i32 %74, 8
  br i1 %cmp120, label %if.then129, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118, %if.else114
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call123 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %75, i32 noundef 8) #14
  br i1 %call123, label %land.lhs.true125, label %if.else135

land.lhs.true125:                                 ; preds = %lor.lhs.false122
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 0
  %77 = load i32, i32* %type126, align 8
  %cmp127 = icmp eq i32 %77, 7
  br i1 %cmp127, label %if.then129, label %if.else135

if.then129:                                       ; preds = %land.lhs.true125, %land.lhs.true118
  %78 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type130 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 0
  %81 = load i32, i32* %type130, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %78, %struct.bpf_reg_state* noundef %79, i32 noundef %81, i1 noundef zeroext false) #14
  %82 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %83 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg131 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %83, i32 0, i32 1
  %bf.load132 = load i8, i8* %src_reg131, align 1
  %bf.lshr133 = lshr i8 %bf.load132, 4
  %conv134 = zext i8 %bf.lshr133 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %82, i32 noundef %conv134, i1 noundef zeroext true) #14
  br label %if.end136

if.else135:                                       ; preds = %land.lhs.true125, %lor.lhs.false122
  store i1 false, i1* %retval, align 1
  br label %return

if.end136:                                        ; preds = %if.then129
  br label %if.end137

if.end137:                                        ; preds = %if.end136, %if.then108
  br label %sw.epilog

sw.bb138:                                         ; preds = %if.end8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type139 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 0
  %85 = load i32, i32* %type139, align 8
  %cmp140 = icmp eq i32 %85, 8
  br i1 %cmp140, label %land.lhs.true142, label %lor.lhs.false146

land.lhs.true142:                                 ; preds = %sw.bb138
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type143 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 0
  %87 = load i32, i32* %type143, align 8
  %cmp144 = icmp eq i32 %87, 9
  br i1 %cmp144, label %if.then153, label %lor.lhs.false146

lor.lhs.false146:                                 ; preds = %land.lhs.true142, %sw.bb138
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type147 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 0
  %89 = load i32, i32* %type147, align 8
  %cmp148 = icmp eq i32 %89, 7
  br i1 %cmp148, label %land.lhs.true150, label %if.else159

land.lhs.true150:                                 ; preds = %lor.lhs.false146
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call151 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %90, i32 noundef 8) #14
  br i1 %call151, label %if.then153, label %if.else159

if.then153:                                       ; preds = %land.lhs.true150, %land.lhs.true142
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type154 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %93, i32 0, i32 0
  %94 = load i32, i32* %type154, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %91, %struct.bpf_reg_state* noundef %92, i32 noundef %94, i1 noundef zeroext false) #14
  %95 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %96 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg155 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %96, i32 0, i32 1
  %bf.load156 = load i8, i8* %dst_reg155, align 1
  %bf.clear157 = and i8 %bf.load156, 15
  %conv158 = zext i8 %bf.clear157 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %95, i32 noundef %conv158, i1 noundef zeroext true) #14
  br label %if.end182

if.else159:                                       ; preds = %land.lhs.true150, %lor.lhs.false146
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type160 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 0
  %98 = load i32, i32* %type160, align 8
  %cmp161 = icmp eq i32 %98, 9
  br i1 %cmp161, label %land.lhs.true163, label %lor.lhs.false167

land.lhs.true163:                                 ; preds = %if.else159
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type164 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %99, i32 0, i32 0
  %100 = load i32, i32* %type164, align 8
  %cmp165 = icmp eq i32 %100, 8
  br i1 %cmp165, label %if.then174, label %lor.lhs.false167

lor.lhs.false167:                                 ; preds = %land.lhs.true163, %if.else159
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call168 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %101, i32 noundef 8) #14
  br i1 %call168, label %land.lhs.true170, label %if.else180

land.lhs.true170:                                 ; preds = %lor.lhs.false167
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type171 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 0
  %103 = load i32, i32* %type171, align 8
  %cmp172 = icmp eq i32 %103, 7
  br i1 %cmp172, label %if.then174, label %if.else180

if.then174:                                       ; preds = %land.lhs.true170, %land.lhs.true163
  %104 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type175 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 0
  %107 = load i32, i32* %type175, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %104, %struct.bpf_reg_state* noundef %105, i32 noundef %107, i1 noundef zeroext true) #14
  %108 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg176 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %109, i32 0, i32 1
  %bf.load177 = load i8, i8* %src_reg176, align 1
  %bf.lshr178 = lshr i8 %bf.load177, 4
  %conv179 = zext i8 %bf.lshr178 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %108, i32 noundef %conv179, i1 noundef zeroext false) #14
  br label %if.end181

if.else180:                                       ; preds = %land.lhs.true170, %lor.lhs.false167
  store i1 false, i1* %retval, align 1
  br label %return

if.end181:                                        ; preds = %if.then174
  br label %if.end182

if.end182:                                        ; preds = %if.end181, %if.then153
  br label %sw.epilog

sw.default:                                       ; preds = %if.end8
  store i1 false, i1* %retval, align 1
  br label %return

sw.epilog:                                        ; preds = %if.end182, %if.end137, %if.end92, %if.end47
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.else180, %if.else135, %if.else90, %if.else45, %if.then7, %if.then
  %110 = load i1, i1* %retval, align 1
  ret i1 %110
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_ptr_or_null_regs(%struct.bpf_func_state* noundef %state, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 0
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %4 = load i32, i32* %id.addr, align 4
  %5 = load i8, i8* %is_null.addr, align 1
  %tobool = trunc i8 %5 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %1, %struct.bpf_reg_state* noundef %arrayidx, i32 noundef %4, i1 noundef zeroext %tobool) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %7 = load i32, i32* %i, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 9
  %9 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %9, 8
  %cmp1 = icmp slt i32 %7, %div
  br i1 %cmp1, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 10
  %11 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %11, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arrayidx4 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %13 = load i8, i8* %arrayidx4, align 8
  %conv = zext i8 %13 to i32
  %cmp5 = icmp eq i32 %conv, 1
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 10
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack7, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %15, i64 %idxprom8
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx9, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond10

for.cond10:                                       ; preds = %cond.end39, %cond.end
  %17 = load i32, i32* %i, align 4
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 9
  %19 = load i32, i32* %allocated_stack11, align 8
  %div12 = sdiv i32 %19, 8
  %cmp13 = icmp slt i32 %17, %div12
  br i1 %cmp13, label %for.body15, label %for.end41

for.body15:                                       ; preds = %for.cond10
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool16 = icmp ne %struct.bpf_reg_state* %20, null
  br i1 %tobool16, label %if.end, label %if.then

if.then:                                          ; preds = %for.body15
  br label %for.inc18

if.end:                                           ; preds = %for.body15
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %23 = load i32, i32* %id.addr, align 4
  %24 = load i8, i8* %is_null.addr, align 1
  %tobool17 = trunc i8 %24 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %21, %struct.bpf_reg_state* noundef %22, i32 noundef %23, i1 noundef zeroext %tobool17) #14
  br label %for.inc18

for.inc18:                                        ; preds = %if.end, %if.then
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 9
  %28 = load i32, i32* %allocated_stack20, align 8
  %div21 = sdiv i32 %28, 8
  %cmp22 = icmp slt i32 %26, %div21
  br i1 %cmp22, label %land.lhs.true24, label %cond.false38

land.lhs.true24:                                  ; preds = %for.inc18
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 10
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %31 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %arrayidx29 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 0
  %32 = load i8, i8* %arrayidx29, align 8
  %conv30 = zext i8 %32 to i32
  %cmp31 = icmp eq i32 %conv30, 1
  br i1 %cmp31, label %cond.true33, label %cond.false38

cond.true33:                                      ; preds = %land.lhs.true24
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack34 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 10
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack34, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %35 to i64
  %arrayidx36 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom35
  %spilled_ptr37 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx36, i32 0, i32 0
  br label %cond.end39

cond.false38:                                     ; preds = %land.lhs.true24, %for.inc18
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true33
  %cond40 = phi %struct.bpf_reg_state* [ %spilled_ptr37, %cond.true33 ], [ null, %cond.false38 ]
  store %struct.bpf_reg_state* %cond40, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond10

for.end41:                                        ; preds = %for.cond10
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %reg, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on26 = alloca i32, align 4
  %tmp53 = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @reg_type_may_be_null(i32 noundef %1) #14
  br i1 %call, label %land.lhs.true, label %if.end73

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 3
  %3 = load i32, i32* %id1, align 8
  %4 = load i32, i32* %id.addr, align 4
  %cmp = icmp eq i32 %3, %4
  br i1 %cmp, label %land.lhs.true2, label %if.end73

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 3
  %6 = load i32, i32* %id3, align 8
  %tobool = icmp ne i32 %6, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool6 = icmp ne i32 %7, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext10 to i64
  %tobool11 = icmp ne i64 %conv, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body12

do.body12:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body12
  br label %do.body13

do.body13:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9042, i32 2307, i64 12) #13, !srcloc !69
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  call void asm sideeffect "536:\0A\09.pushsection .discard.reachable\0A\09.long 536b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !70
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  br label %do.end17

do.end17:                                         ; preds = %do.end16
  br label %if.end

if.end:                                           ; preds = %do.end17, %land.lhs.true2
  %8 = load i32, i32* %__ret_warn_on, align 4
  %tobool18 = icmp ne i32 %8, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  store i64 %conv23, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  %tobool24 = icmp ne i64 %9, 0
  br i1 %tobool24, label %if.end73, label %if.then25

if.then25:                                        ; preds = %if.end
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value, align 8
  %tobool27 = icmp ne i64 %11, 0
  br i1 %tobool27, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then25
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %tobool28 = icmp ne i64 %13, 0
  br i1 %tobool28, label %lor.end, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %lor.lhs.false
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %15 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call30 = call zeroext i1 @tnum_equals_const(i64 %17, i64 %19, i64 noundef 0) #14
  br i1 %call30, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %lor.lhs.false29
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 1
  %21 = load i32, i32* %off, align 4
  %tobool31 = icmp ne i32 %21, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false29, %lor.lhs.false, %if.then25
  %22 = phi i1 [ true, %lor.lhs.false29 ], [ true, %lor.lhs.false ], [ true, %if.then25 ], [ %tobool31, %lor.rhs ]
  %lnot32 = xor i1 %22, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  store i32 %lnot.ext35, i32* %__ret_warn_on26, align 4
  %23 = load i32, i32* %__ret_warn_on26, align 4
  %tobool36 = icmp ne i32 %23, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %tobool42 = icmp ne i64 %conv41, 0
  br i1 %tobool42, label %if.then43, label %if.end52

if.then43:                                        ; preds = %lor.end
  br label %do.body44

do.body44:                                        ; preds = %if.then43
  br label %do.body45

do.body45:                                        ; preds = %do.body44
  br label %do.end46

do.end46:                                         ; preds = %do.body45
  br label %do.body47

do.body47:                                        ; preds = %do.end46
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9049, i32 2307, i64 12) #13, !srcloc !71
  br label %do.end48

do.end48:                                         ; preds = %do.body47
  call void asm sideeffect "537:\0A\09.pushsection .discard.reachable\0A\09.long 537b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !72
  br label %do.body49

do.body49:                                        ; preds = %do.end48
  br label %do.end50

do.end50:                                         ; preds = %do.body49
  br label %do.end51

do.end51:                                         ; preds = %do.end50
  br label %if.end52

if.end52:                                         ; preds = %do.end51, %lor.end
  %24 = load i32, i32* %__ret_warn_on26, align 4
  %tobool54 = icmp ne i32 %24, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  store i64 %conv59, i64* %tmp53, align 8
  %25 = load i64, i64* %tmp53, align 8
  %tobool60 = icmp ne i64 %25, 0
  br i1 %tobool60, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.end52
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %26) #14
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off62 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 1
  store i32 0, i32* %off62, align 4
  br label %if.end63

if.end63:                                         ; preds = %if.then61, %if.end52
  %28 = load i8, i8* %is_null.addr, align 1
  %tobool64 = trunc i8 %28 to i1
  br i1 %tobool64, label %if.then65, label %if.end68

if.then65:                                        ; preds = %if.end63
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 0
  store i32 1, i32* %type66, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 3
  store i32 0, i32* %id67, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 4
  store i32 0, i32* %ref_obj_id, align 4
  br label %if.end73

if.end68:                                         ; preds = %if.end63
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %32) #14
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call69 = call zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %33) #14
  br i1 %call69, label %if.end72, label %if.then70

if.then70:                                        ; preds = %if.end68
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 3
  store i32 0, i32* %id71, align 8
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %if.end68
  br label %if.end73

if.end73:                                         ; preds = %if.then65, %if.end72, %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.152* %3 to %struct.anon.153*
  %map_ptr = getelementptr inbounds %struct.anon.153, %struct.anon.153* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %call = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %5) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %reg, i32 noundef %which) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %which.addr = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %which, i32* %which.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load i32, i32* %which.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 3
  %4 = load i32, i32* %id, align 8
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 1
  %6 = load i32, i32* %off, align 4
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true2
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %10, i64 %12, i64 noundef 0) #14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true2, %land.lhs.true, %entry
  %13 = phi i1 [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i1 noundef zeroext %range_right_open) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %range_right_open.addr = alloca i8, align 1
  %new_range = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %frombool = zext i1 %range_right_open to i8
  store i8 %frombool, i8* %range_right_open.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 1
  %1 = load i32, i32* %off, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off1, align 4
  %cmp2 = icmp eq i32 %3, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, i8* %range_right_open.addr, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  %6 = load i64, i64* %umax_value, align 8
  %cmp3 = icmp ugt i64 %6, 65535
  br i1 %cmp3, label %if.then9, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 9
  %8 = load i64, i64* %umax_value5, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 1
  %10 = load i32, i32* %off6, align 4
  %conv = sext i32 %10 to i64
  %add = add i64 %8, %conv
  %cmp7 = icmp ugt i64 %add, 65535
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false4, %if.end
  br label %for.end

if.end10:                                         ; preds = %lor.lhs.false4
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 1
  %12 = load i32, i32* %off11, align 4
  store i32 %12, i32* %new_range, align 4
  %13 = load i8, i8* %range_right_open.addr, align 1
  %tobool12 = trunc i8 %13 to i1
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %14 = load i32, i32* %new_range, align 4
  %dec = add i32 %14, -1
  store i32 %dec, i32* %new_range, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %15 = load i32, i32* %i, align 4
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %16, i32 0, i32 4
  %17 = load i32, i32* %curframe, align 8
  %cmp15 = icmp ule i32 %15, %17
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 0
  %19 = load i32, i32* %i, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %22 = load i32, i32* %type.addr, align 4
  %23 = load i32, i32* %new_range, align 4
  call void @__find_good_pkt_pointers(%struct.bpf_func_state* noundef %20, %struct.bpf_reg_state* noundef %21, i32 noundef %22, i32 noundef %23) #14
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %if.then9, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_pkt_end(%struct.bpf_verifier_state* noundef %vstate, i32 noundef %regn, i1 noundef zeroext %range_open) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %regn.addr = alloca i32, align 4
  %range_open.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store i32 %regn, i32* %regn.addr, align 4
  %frombool = zext i1 %range_open to i8
  store i8 %frombool, i8* %range_open.addr, align 1
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %regn.addr, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %7, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end5

if.end:                                           ; preds = %entry
  %8 = load i8, i8* %range_open.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 2
  %range = bitcast %union.anon.152* %10 to i32*
  store i32 -2, i32* %range, align 8
  br label %if.end5

if.else:                                          ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %range4 = bitcast %union.anon.152* %12 to i32*
  store i32 -1, i32* %range4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then, %if.else, %if.then3
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__find_good_pkt_pointers(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i32 noundef %new_range) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %new_range.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %__UNIQUE_ID___x492 = alloca i32, align 4
  %__UNIQUE_ID___y493 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x494 = alloca i32, align 4
  %__UNIQUE_ID___y495 = alloca i32, align 4
  %tmp39 = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %new_range, i32* %new_range.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  %5 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %4, %5
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 3
  %7 = load i32, i32* %id, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 3
  %9 = load i32, i32* %id3, align 8
  %cmp4 = icmp eq i32 %7, %9
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 2
  %range = bitcast %union.anon.152* %11 to i32*
  %12 = load i32, i32* %range, align 8
  store i32 %12, i32* %__UNIQUE_ID___x492, align 4
  %13 = load i32, i32* %new_range.addr, align 4
  store i32 %13, i32* %__UNIQUE_ID___y493, align 4
  %14 = load i32, i32* %__UNIQUE_ID___x492, align 4
  %15 = load i32, i32* %__UNIQUE_ID___y493, align 4
  %cmp5 = icmp sgt i32 %14, %15
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %16 = load i32, i32* %__UNIQUE_ID___x492, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %17 = load i32, i32* %__UNIQUE_ID___y493, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %16, %cond.true ], [ %17, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %18 = load i32, i32* %tmp, align 4
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 2
  %range6 = bitcast %union.anon.152* %20 to i32*
  store i32 %18, i32* %range6, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 9
  %24 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %24, 8
  %cmp7 = icmp slt i32 %22, %div
  br i1 %cmp7, label %land.lhs.true8, label %cond.false18

land.lhs.true8:                                   ; preds = %for.end
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 10
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %27 to i64
  %arrayidx10 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom9
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx10, i32 0, i32 1
  %arrayidx11 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %28 = load i8, i8* %arrayidx11, align 8
  %conv = zext i8 %28 to i32
  %cmp12 = icmp eq i32 %conv, 1
  br i1 %cmp12, label %cond.true14, label %cond.false18

cond.true14:                                      ; preds = %land.lhs.true8
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 10
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %31 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom16
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 0
  br label %cond.end19

cond.false18:                                     ; preds = %land.lhs.true8, %for.end
  br label %cond.end19

cond.end19:                                       ; preds = %cond.false18, %cond.true14
  %cond20 = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true14 ], [ null, %cond.false18 ]
  store %struct.bpf_reg_state* %cond20, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond21

for.cond21:                                       ; preds = %cond.end69, %cond.end19
  %32 = load i32, i32* %i, align 4
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 9
  %34 = load i32, i32* %allocated_stack22, align 8
  %div23 = sdiv i32 %34, 8
  %cmp24 = icmp slt i32 %32, %div23
  br i1 %cmp24, label %for.body26, label %for.end71

for.body26:                                       ; preds = %for.cond21
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %35, null
  br i1 %tobool, label %if.end28, label %if.then27

if.then27:                                        ; preds = %for.body26
  br label %for.inc48

if.end28:                                         ; preds = %for.body26
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type29, align 8
  %38 = load i32, i32* %type.addr, align 4
  %cmp30 = icmp eq i32 %37, %38
  br i1 %cmp30, label %land.lhs.true32, label %if.end47

land.lhs.true32:                                  ; preds = %if.end28
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 3
  %40 = load i32, i32* %id33, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 3
  %42 = load i32, i32* %id34, align 8
  %cmp35 = icmp eq i32 %40, %42
  br i1 %cmp35, label %if.then37, label %if.end47

if.then37:                                        ; preds = %land.lhs.true32
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 2
  %range38 = bitcast %union.anon.152* %44 to i32*
  %45 = load i32, i32* %range38, align 8
  store i32 %45, i32* %__UNIQUE_ID___x494, align 4
  %46 = load i32, i32* %new_range.addr, align 4
  store i32 %46, i32* %__UNIQUE_ID___y495, align 4
  %47 = load i32, i32* %__UNIQUE_ID___x494, align 4
  %48 = load i32, i32* %__UNIQUE_ID___y495, align 4
  %cmp40 = icmp sgt i32 %47, %48
  br i1 %cmp40, label %cond.true42, label %cond.false43

cond.true42:                                      ; preds = %if.then37
  %49 = load i32, i32* %__UNIQUE_ID___x494, align 4
  br label %cond.end44

cond.false43:                                     ; preds = %if.then37
  %50 = load i32, i32* %__UNIQUE_ID___y495, align 4
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false43, %cond.true42
  %cond45 = phi i32 [ %49, %cond.true42 ], [ %50, %cond.false43 ]
  store i32 %cond45, i32* %tmp39, align 4
  %51 = load i32, i32* %tmp39, align 4
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 2
  %range46 = bitcast %union.anon.152* %53 to i32*
  store i32 %51, i32* %range46, align 8
  br label %if.end47

if.end47:                                         ; preds = %cond.end44, %land.lhs.true32, %if.end28
  br label %for.inc48

for.inc48:                                        ; preds = %if.end47, %if.then27
  %54 = load i32, i32* %i, align 4
  %inc49 = add i32 %54, 1
  store i32 %inc49, i32* %i, align 4
  %55 = load i32, i32* %i, align 4
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack50 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %56, i32 0, i32 9
  %57 = load i32, i32* %allocated_stack50, align 8
  %div51 = sdiv i32 %57, 8
  %cmp52 = icmp slt i32 %55, %div51
  br i1 %cmp52, label %land.lhs.true54, label %cond.false68

land.lhs.true54:                                  ; preds = %for.inc48
  %58 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack55 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %58, i32 0, i32 10
  %59 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack55, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom56 = sext i32 %60 to i64
  %arrayidx57 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %59, i64 %idxprom56
  %slot_type58 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx57, i32 0, i32 1
  %arrayidx59 = getelementptr [8 x i8], [8 x i8]* %slot_type58, i64 0, i64 0
  %61 = load i8, i8* %arrayidx59, align 8
  %conv60 = zext i8 %61 to i32
  %cmp61 = icmp eq i32 %conv60, 1
  br i1 %cmp61, label %cond.true63, label %cond.false68

cond.true63:                                      ; preds = %land.lhs.true54
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack64 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %62, i32 0, i32 10
  %63 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack64, align 8
  %64 = load i32, i32* %i, align 4
  %idxprom65 = sext i32 %64 to i64
  %arrayidx66 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %63, i64 %idxprom65
  %spilled_ptr67 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx66, i32 0, i32 0
  br label %cond.end69

cond.false68:                                     ; preds = %land.lhs.true54, %for.inc48
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false68, %cond.true63
  %cond70 = phi %struct.bpf_reg_state* [ %spilled_ptr67, %cond.true63 ], [ null, %cond.false68 ]
  store %struct.bpf_reg_state* %cond70, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond21

for.end71:                                        ; preds = %for.cond21
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_skb(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @might_fault() #0 {
entry:
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @llvm.read_register.i64(metadata) #12

; Function Attrs: nounwind
declare void @llvm.write_register.i64(metadata, i64) #13

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %code) #0 {
entry:
  %retval = alloca i1, align 1
  %code.addr = alloca i8, align 1
  %op = alloca i8, align 1
  store i8 %code, i8* %code.addr, align 1
  %0 = load i8, i8* %code.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  %cmp = icmp eq i32 %and, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %code.addr, align 1
  %conv2 = zext i8 %1 to i32
  %and3 = and i32 %conv2, 7
  %cmp4 = icmp ne i32 %and3, 5
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  %2 = load i8, i8* %code.addr, align 1
  %conv8 = zext i8 %2 to i32
  %and9 = and i32 %conv8, 240
  %conv10 = trunc i32 %and9 to i8
  store i8 %conv10, i8* %op, align 1
  %3 = load i8, i8* %op, align 1
  %conv11 = zext i8 %3 to i32
  %cmp12 = icmp ne i32 %conv11, 0
  br i1 %cmp12, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end7
  %4 = load i8, i8* %op, align 1
  %conv14 = zext i8 %4 to i32
  %cmp15 = icmp ne i32 %conv14, 144
  br i1 %cmp15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load i8, i8* %op, align 1
  %conv17 = zext i8 %5 to i32
  %cmp18 = icmp ne i32 %conv17, 128
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.end7
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %if.end7 ], [ %cmp18, %land.rhs ]
  store i1 %6, i1* %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then6, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_insn* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %orig_prog_len = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %orig_prog_len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %7) #14
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %10 = load i32, i32* %cnt.addr, align 4
  call void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef %8, i32 noundef %9, i32 noundef %10) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 2
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %cnt.addr, align 4
  %call3 = call i32 @bpf_remove_insns(%struct.bpf_prog* noundef %12, i32 noundef %13, i32 noundef %14) #14
  store i32 %call3, i32* %err, align 4
  %15 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %16 = load i32, i32* %err, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %off.addr, align 4
  %19 = load i32, i32* %cnt.addr, align 4
  %call6 = call i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #14
  store i32 %call6, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool7 = icmp ne i32 %20, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load i32, i32* %off.addr, align 4
  %24 = load i32, i32* %cnt.addr, align 4
  %call10 = call i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %22, i32 noundef %23, i32 noundef %24) #14
  store i32 %call10, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %25, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  %26 = load i32, i32* %err, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %28 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idx.ext
  %29 = bitcast %struct.bpf_insn_aux_data* %add.ptr to i8*
  %30 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %31 = load i32, i32* %off.addr, align 4
  %idx.ext14 = zext i32 %31 to i64
  %add.ptr15 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %30, i64 %idx.ext14
  %32 = load i32, i32* %cnt.addr, align 4
  %idx.ext16 = zext i32 %32 to i64
  %add.ptr17 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr15, i64 %idx.ext16
  %33 = bitcast %struct.bpf_insn_aux_data* %add.ptr17 to i8*
  %34 = load i32, i32* %orig_prog_len, align 4
  %35 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %34, %35
  %36 = load i32, i32* %cnt.addr, align 4
  %sub18 = sub i32 %sub, %36
  %conv = zext i32 %sub18 to i64
  %mul = mul i64 56, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %33, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then8, %if.then4
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_remove_insns(%struct.bpf_prog* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %move = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 31
  %2 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 27
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %5 = load i32, i32* %start, align 8
  %6 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp uge i32 %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %8 = load i32, i32* %i, align 4
  store i32 %8, i32* %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc13, %for.end
  %9 = load i32, i32* %j, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 31
  %11 = load i32, i32* %subprog_cnt3, align 4
  %cmp4 = icmp ult i32 %9, %11
  br i1 %cmp4, label %for.body5, label %for.end15

for.body5:                                        ; preds = %for.cond2
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 27
  %13 = load i32, i32* %j, align 4
  %idxprom7 = sext i32 %13 to i64
  %arrayidx8 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info6, i64 0, i64 %idxprom7
  %start9 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx8, i32 0, i32 0
  %14 = load i32, i32* %start9, align 8
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %15, %16
  %cmp10 = icmp uge i32 %14, %add
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body5
  br label %for.end15

if.end12:                                         ; preds = %for.body5
  br label %for.inc13

for.inc13:                                        ; preds = %if.end12
  %17 = load i32, i32* %j, align 4
  %inc14 = add i32 %17, 1
  store i32 %inc14, i32* %j, align 4
  br label %for.cond2

for.end15:                                        ; preds = %if.then11, %for.cond2
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 27
  %19 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %19 to i64
  %arrayidx18 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info16, i64 0, i64 %idxprom17
  %start19 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx18, i32 0, i32 0
  %20 = load i32, i32* %start19, align 8
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %cnt.addr, align 4
  %add20 = add i32 %21, %22
  %cmp21 = icmp ne i32 %20, %add20
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.end15
  %23 = load i32, i32* %j, align 4
  %dec = add i32 %23, -1
  store i32 %dec, i32* %j, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %for.end15
  %24 = load i32, i32* %j, align 4
  %25 = load i32, i32* %i, align 4
  %cmp24 = icmp sgt i32 %24, %25
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end23
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 2
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 10
  %28 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux26, align 8
  store %struct.bpf_prog_aux* %28, %struct.bpf_prog_aux** %aux, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 31
  %30 = load i32, i32* %subprog_cnt27, align 4
  %add28 = add i32 %30, 1
  %31 = load i32, i32* %j, align 4
  %sub = sub i32 %add28, %31
  store i32 %sub, i32* %move, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info29, i64 0, i64 0
  %33 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %33 to i64
  %add.ptr = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay, i64 %idx.ext
  %34 = bitcast %struct.bpf_subprog_info* %add.ptr to i8*
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 27
  %arraydecay31 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info30, i64 0, i64 0
  %36 = load i32, i32* %j, align 4
  %idx.ext32 = sext i32 %36 to i64
  %add.ptr33 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay31, i64 %idx.ext32
  %37 = bitcast %struct.bpf_subprog_info* %add.ptr33 to i8*
  %38 = load i32, i32* %move, align 4
  %conv = sext i32 %38 to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %34, i8* align 4 %37, i64 %mul, i1 false)
  %39 = load i32, i32* %j, align 4
  %40 = load i32, i32* %i, align 4
  %sub34 = sub i32 %39, %40
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt35 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 31
  %42 = load i32, i32* %subprog_cnt35, align 4
  %sub36 = sub i32 %42, %sub34
  store i32 %sub36, i32* %subprog_cnt35, align 4
  %43 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %43, i32 0, i32 48
  %44 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool = icmp ne %struct.bpf_func_info* %44, null
  br i1 %tobool, label %if.then37, label %if.end50

if.then37:                                        ; preds = %if.then25
  %45 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %45, i32 0, i32 52
  %46 = load i32, i32* %func_info_cnt, align 8
  %47 = load i32, i32* %j, align 4
  %sub38 = sub i32 %46, %47
  store i32 %sub38, i32* %move, align 4
  %48 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info39 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %48, i32 0, i32 48
  %49 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info39, align 8
  %50 = load i32, i32* %i, align 4
  %idx.ext40 = sext i32 %50 to i64
  %add.ptr41 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %49, i64 %idx.ext40
  %51 = bitcast %struct.bpf_func_info* %add.ptr41 to i8*
  %52 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %52, i32 0, i32 48
  %53 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info42, align 8
  %54 = load i32, i32* %j, align 4
  %idx.ext43 = sext i32 %54 to i64
  %add.ptr44 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %53, i64 %idx.ext43
  %55 = bitcast %struct.bpf_func_info* %add.ptr44 to i8*
  %56 = load i32, i32* %move, align 4
  %conv45 = sext i32 %56 to i64
  %mul46 = mul i64 8, %conv45
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %51, i8* align 4 %55, i64 %mul46, i1 false)
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* %i, align 4
  %sub47 = sub i32 %57, %58
  %59 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt48 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %59, i32 0, i32 52
  %60 = load i32, i32* %func_info_cnt48, align 8
  %sub49 = sub i32 %60, %sub47
  store i32 %sub49, i32* %func_info_cnt48, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then37, %if.then25
  br label %if.end60

if.else:                                          ; preds = %if.end23
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 27
  %62 = load i32, i32* %i, align 4
  %idxprom52 = sext i32 %62 to i64
  %arrayidx53 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info51, i64 0, i64 %idxprom52
  %start54 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx53, i32 0, i32 0
  %63 = load i32, i32* %start54, align 8
  %64 = load i32, i32* %off.addr, align 4
  %cmp55 = icmp eq i32 %63, %64
  br i1 %cmp55, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.else
  %65 = load i32, i32* %i, align 4
  %inc58 = add i32 %65, 1
  store i32 %inc58, i32* %i, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.else
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end50
  br label %for.cond61

for.cond61:                                       ; preds = %for.inc71, %if.end60
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 31
  %68 = load i32, i32* %subprog_cnt62, align 4
  %cmp63 = icmp ule i32 %66, %68
  br i1 %cmp63, label %for.body65, label %for.end73

for.body65:                                       ; preds = %for.cond61
  %69 = load i32, i32* %cnt.addr, align 4
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info66 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 27
  %71 = load i32, i32* %i, align 4
  %idxprom67 = sext i32 %71 to i64
  %arrayidx68 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info66, i64 0, i64 %idxprom67
  %start69 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx68, i32 0, i32 0
  %72 = load i32, i32* %start69, align 8
  %sub70 = sub i32 %72, %69
  store i32 %sub70, i32* %start69, align 8
  br label %for.inc71

for.inc71:                                        ; preds = %for.body65
  %73 = load i32, i32* %i, align 4
  %inc72 = add i32 %73, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond61

for.end73:                                        ; preds = %for.cond61
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %l_off = alloca i32, align 4
  %l_cnt = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %linfo = alloca %struct.bpf_line_info*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 53
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 50
  %8 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo4, align 8
  store %struct.bpf_line_info* %8, %struct.bpf_line_info** %linfo, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %nr_linfo, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %11, i64 %idxprom
  %insn_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx, i32 0, i32 0
  %13 = load i32, i32* %insn_off, align 4
  %14 = load i32, i32* %off.addr, align 4
  %cmp5 = icmp uge i32 %13, %14
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.end

if.end7:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then6, %for.cond
  %16 = load i32, i32* %i, align 4
  store i32 %16, i32* %l_off, align 4
  store i32 0, i32* %l_cnt, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc18, %for.end
  %17 = load i32, i32* %i, align 4
  %18 = load i32, i32* %nr_linfo, align 4
  %cmp9 = icmp ult i32 %17, %18
  br i1 %cmp9, label %for.body10, label %for.end20

for.body10:                                       ; preds = %for.cond8
  %19 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %20 to i64
  %arrayidx12 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %19, i64 %idxprom11
  %insn_off13 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx12, i32 0, i32 0
  %21 = load i32, i32* %insn_off13, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %22, %23
  %cmp14 = icmp ult i32 %21, %add
  br i1 %cmp14, label %if.then15, label %if.else

if.then15:                                        ; preds = %for.body10
  %24 = load i32, i32* %l_cnt, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, i32* %l_cnt, align 4
  br label %if.end17

if.else:                                          ; preds = %for.body10
  br label %for.end20

if.end17:                                         ; preds = %if.then15
  br label %for.inc18

for.inc18:                                        ; preds = %if.end17
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  br label %for.cond8

for.end20:                                        ; preds = %if.else, %for.cond8
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %26, i32 0, i32 4
  %27 = load i32, i32* %len, align 4
  %28 = load i32, i32* %off.addr, align 4
  %cmp21 = icmp ne i32 %27, %28
  br i1 %cmp21, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %for.end20
  %29 = load i32, i32* %l_cnt, align 4
  %tobool22 = icmp ne i32 %29, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end36

land.lhs.true23:                                  ; preds = %land.lhs.true
  %30 = load i32, i32* %i, align 4
  %31 = load i32, i32* %nr_linfo, align 4
  %cmp24 = icmp eq i32 %30, %31
  br i1 %cmp24, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %32 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom25 = zext i32 %33 to i64
  %arrayidx26 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %32, i64 %idxprom25
  %insn_off27 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx26, i32 0, i32 0
  %34 = load i32, i32* %insn_off27, align 4
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %cnt.addr, align 4
  %add28 = add i32 %35, %36
  %cmp29 = icmp ne i32 %34, %add28
  br i1 %cmp29, label %if.then30, label %if.end36

if.then30:                                        ; preds = %lor.lhs.false, %land.lhs.true23
  %37 = load i32, i32* %l_cnt, align 4
  %dec = add i32 %37, -1
  store i32 %dec, i32* %l_cnt, align 4
  %38 = load i32, i32* %off.addr, align 4
  %39 = load i32, i32* %cnt.addr, align 4
  %add31 = add i32 %38, %39
  %40 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %41 = load i32, i32* %i, align 4
  %dec32 = add i32 %41, -1
  store i32 %dec32, i32* %i, align 4
  %idxprom33 = zext i32 %dec32 to i64
  %arrayidx34 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %40, i64 %idxprom33
  %insn_off35 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx34, i32 0, i32 0
  store i32 %add31, i32* %insn_off35, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then30, %lor.lhs.false, %land.lhs.true, %for.end20
  %42 = load i32, i32* %l_cnt, align 4
  %tobool37 = icmp ne i32 %42, 0
  br i1 %tobool37, label %if.then38, label %if.end46

if.then38:                                        ; preds = %if.end36
  %43 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %44 = load i32, i32* %l_off, align 4
  %idx.ext = zext i32 %44 to i64
  %add.ptr = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %43, i64 %idx.ext
  %45 = bitcast %struct.bpf_line_info* %add.ptr to i8*
  %46 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %47 = load i32, i32* %i, align 4
  %idx.ext39 = zext i32 %47 to i64
  %add.ptr40 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %46, i64 %idx.ext39
  %48 = bitcast %struct.bpf_line_info* %add.ptr40 to i8*
  %49 = load i32, i32* %nr_linfo, align 4
  %50 = load i32, i32* %i, align 4
  %sub = sub i32 %49, %50
  %conv = zext i32 %sub to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %45, i8* align 4 %48, i64 %mul, i1 false)
  %51 = load i32, i32* %l_cnt, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux41 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 10
  %53 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux41, align 8
  %nr_linfo42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %53, i32 0, i32 53
  %54 = load i32, i32* %nr_linfo42, align 4
  %sub43 = sub i32 %54, %51
  store i32 %sub43, i32* %nr_linfo42, align 4
  %55 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %55, i32 0, i32 10
  %56 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux44, align 8
  %nr_linfo45 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %56, i32 0, i32 53
  %57 = load i32, i32* %nr_linfo45, align 4
  store i32 %57, i32* %nr_linfo, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then38, %if.end36
  %58 = load i32, i32* %l_off, align 4
  store i32 %58, i32* %i, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc55, %if.end46
  %59 = load i32, i32* %i, align 4
  %60 = load i32, i32* %nr_linfo, align 4
  %cmp48 = icmp ult i32 %59, %60
  br i1 %cmp48, label %for.body50, label %for.end57

for.body50:                                       ; preds = %for.cond47
  %61 = load i32, i32* %cnt.addr, align 4
  %62 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %63 = load i32, i32* %i, align 4
  %idxprom51 = zext i32 %63 to i64
  %arrayidx52 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %62, i64 %idxprom51
  %insn_off53 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx52, i32 0, i32 0
  %64 = load i32, i32* %insn_off53, align 4
  %sub54 = sub i32 %64, %61
  store i32 %sub54, i32* %insn_off53, align 4
  br label %for.inc55

for.inc55:                                        ; preds = %for.body50
  %65 = load i32, i32* %i, align 4
  %inc56 = add i32 %65, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond47

for.end57:                                        ; preds = %for.cond47
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc87, %for.end57
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 31
  %68 = load i32, i32* %subprog_cnt, align 4
  %cmp59 = icmp ule i32 %66, %68
  br i1 %cmp59, label %for.body61, label %for.end89

for.body61:                                       ; preds = %for.cond58
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 27
  %70 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %70 to i64
  %arrayidx63 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom62
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx63, i32 0, i32 1
  %71 = load i32, i32* %linfo_idx, align 4
  %72 = load i32, i32* %l_off, align 4
  %cmp64 = icmp ugt i32 %71, %72
  br i1 %cmp64, label %if.then66, label %if.end86

if.then66:                                        ; preds = %for.body61
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info67 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 27
  %74 = load i32, i32* %i, align 4
  %idxprom68 = zext i32 %74 to i64
  %arrayidx69 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info67, i64 0, i64 %idxprom68
  %linfo_idx70 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx69, i32 0, i32 1
  %75 = load i32, i32* %linfo_idx70, align 4
  %76 = load i32, i32* %l_off, align 4
  %77 = load i32, i32* %l_cnt, align 4
  %add71 = add i32 %76, %77
  %cmp72 = icmp uge i32 %75, %add71
  br i1 %cmp72, label %if.then74, label %if.else80

if.then74:                                        ; preds = %if.then66
  %78 = load i32, i32* %l_cnt, align 4
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 27
  %80 = load i32, i32* %i, align 4
  %idxprom76 = zext i32 %80 to i64
  %arrayidx77 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info75, i64 0, i64 %idxprom76
  %linfo_idx78 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx77, i32 0, i32 1
  %81 = load i32, i32* %linfo_idx78, align 4
  %sub79 = sub i32 %81, %78
  store i32 %sub79, i32* %linfo_idx78, align 4
  br label %if.end85

if.else80:                                        ; preds = %if.then66
  %82 = load i32, i32* %l_off, align 4
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 27
  %84 = load i32, i32* %i, align 4
  %idxprom82 = zext i32 %84 to i64
  %arrayidx83 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info81, i64 0, i64 %idxprom82
  %linfo_idx84 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx83, i32 0, i32 1
  store i32 %82, i32* %linfo_idx84, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.else80, %if.then74
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %for.body61
  br label %for.inc87

for.inc87:                                        ; preds = %if.end86
  %85 = load i32, i32* %i, align 4
  %inc88 = add i32 %85, 1
  store i32 %inc88, i32* %i, align 4
  br label %for.cond58

for.end89:                                        ; preds = %for.cond58
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end89, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #5

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, %struct.bpf_insn* noundef %patch, i32 noundef %len) #0 {
entry:
  %retval = alloca %struct.bpf_prog*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %patch.addr = alloca %struct.bpf_insn*, align 8
  %len.addr = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %new_data = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store %struct.bpf_insn* %patch, %struct.bpf_insn** %patch.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store %struct.bpf_insn_aux_data* null, %struct.bpf_insn_aux_data** %new_data, align 8
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp ugt i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 4
  %3 = load i32, i32* %len1, align 4
  %4 = load i32, i32* %len.addr, align 4
  %add = add i32 %3, %4
  %sub = sub i32 %add, 1
  %conv = zext i32 %sub to i64
  %call = call i64 @array_size(i64 noundef %conv, i64 noundef 56) #14
  %call2 = call i8* @vzalloc(i64 noundef %call) #14
  %5 = bitcast i8* %call2 to %struct.bpf_insn_aux_data*
  store %struct.bpf_insn_aux_data* %5, %struct.bpf_insn_aux_data** %new_data, align 8
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %tobool = icmp ne %struct.bpf_insn_aux_data* %6, null
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 2
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog5, align 8
  %9 = load i32, i32* %off.addr, align 4
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %patch.addr, align 8
  %11 = load i32, i32* %len.addr, align 4
  %call6 = call %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef %8, i32 noundef %9, %struct.bpf_insn* noundef %10, i32 noundef %11) #14
  store %struct.bpf_prog* %call6, %struct.bpf_prog** %new_prog, align 8
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %13 = bitcast %struct.bpf_prog* %12 to i8*
  %call7 = call zeroext i1 @IS_ERR(i8* noundef %13) #14
  br i1 %call7, label %if.then8, label %if.end14

if.then8:                                         ; preds = %if.end4
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %15 = bitcast %struct.bpf_prog* %14 to i8*
  %call9 = call i64 @PTR_ERR(i8* noundef %15) #14
  %cmp10 = icmp eq i64 %call9, -34
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 24
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %20 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %20 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %19, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  %21 = load i32, i32* %orig_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.446, i64 0, i64 0), i32 noundef %21) #14
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then8
  %22 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %23 = bitcast %struct.bpf_insn_aux_data* %22 to i8*
  call void @vfree(i8* noundef %23) #14
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end4
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %27 = load i32, i32* %off.addr, align 4
  %28 = load i32, i32* %len.addr, align 4
  call void @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %24, %struct.bpf_insn_aux_data* noundef %25, %struct.bpf_prog* noundef %26, i32 noundef %27, i32 noundef %28) #14
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = load i32, i32* %off.addr, align 4
  %31 = load i32, i32* %len.addr, align 4
  call void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %29, i32 noundef %30, i32 noundef %31) #14
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %33 = load i32, i32* %off.addr, align 4
  %34 = load i32, i32* %len.addr, align 4
  call void @adjust_poke_descs(%struct.bpf_prog* noundef %32, i32 noundef %33, i32 noundef %34) #14
  %35 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %35, %struct.bpf_prog** %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.end13, %if.then3
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %retval, align 8
  ret %struct.bpf_prog* %36
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_tcp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_xdp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_ctx_off_adjust_machine(i32 noundef %size) #0 {
entry:
  %size.addr = alloca i32, align 4
  %size_machine = alloca i32, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 8, i32* %size_machine, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp ugt i32 %0, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %rem = urem i32 %1, 8
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 8, i32* %size.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, i32* %size.addr, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %off, i32 noundef %size, i32 noundef %size_default) #0 {
entry:
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %size_default.addr = alloca i32, align 4
  %access_off = alloca i8, align 1
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %size_default, i32* %size_default.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %1 = load i32, i32* %size_default.addr, align 4
  %sub = sub i32 %1, 1
  %and = and i32 %0, %sub
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %access_off, align 1
  %2 = load i8, i8* %access_off, align 1
  ret i8 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef, i32 noundef, %struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn_aux_data* noundef %new_data, %struct.bpf_prog* noundef %new_prog, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %new_data.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %new_prog.addr = alloca %struct.bpf_prog*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %old_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %old_seen = alloca i32, align 4
  %prog_len = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn_aux_data* %new_data, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  store %struct.bpf_prog* %new_prog, %struct.bpf_prog** %new_prog.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %old_data, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %4 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %3, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %5 = load i32, i32* %seen, align 4
  store i32 %5, i32* %old_seen, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %8 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %8 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %7, i64 %idx.ext
  %9 = load i32, i32* %cnt.addr, align 4
  %idx.ext1 = zext i32 %9 to i64
  %add.ptr2 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext1
  %add.ptr3 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr2, i64 -1
  %call = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %6, %struct.bpf_insn* noundef %add.ptr3) #14
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %11 = load i32, i32* %off.addr, align 4
  %idxprom4 = zext i32 %11 to i64
  %arrayidx5 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom4
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx5, i32 0, i32 5
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %zext_dst, align 1
  %12 = load i32, i32* %cnt.addr, align 4
  %cmp = icmp eq i32 %12, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 4
  %14 = load i32, i32* %len, align 4
  store i32 %14, i32* %prog_len, align 4
  %15 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %16 = bitcast %struct.bpf_insn_aux_data* %15 to i8*
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %18 = bitcast %struct.bpf_insn_aux_data* %17 to i8*
  %19 = load i32, i32* %off.addr, align 4
  %conv = zext i32 %19 to i64
  %mul = mul i64 56, %conv
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %18, i64 %mul, i1 false)
  %20 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %21 = load i32, i32* %off.addr, align 4
  %idx.ext6 = zext i32 %21 to i64
  %add.ptr7 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %20, i64 %idx.ext6
  %22 = load i32, i32* %cnt.addr, align 4
  %idx.ext8 = zext i32 %22 to i64
  %add.ptr9 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr7, i64 %idx.ext8
  %add.ptr10 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr9, i64 -1
  %23 = bitcast %struct.bpf_insn_aux_data* %add.ptr10 to i8*
  %24 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %25 = load i32, i32* %off.addr, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %24, i64 %idx.ext11
  %26 = bitcast %struct.bpf_insn_aux_data* %add.ptr12 to i8*
  %27 = load i32, i32* %prog_len, align 4
  %28 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %27, %28
  %29 = load i32, i32* %cnt.addr, align 4
  %sub13 = sub i32 %sub, %29
  %add = add i32 %sub13, 1
  %conv14 = zext i32 %add to i64
  %mul15 = mul i64 56, %conv14
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %26, i64 %mul15, i1 false)
  %30 = load i32, i32* %off.addr, align 4
  store i32 %30, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %31 = load i32, i32* %i, align 4
  %32 = load i32, i32* %off.addr, align 4
  %33 = load i32, i32* %cnt.addr, align 4
  %add16 = add i32 %32, %33
  %sub17 = sub i32 %add16, 1
  %cmp18 = icmp ult i32 %31, %sub17
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load i32, i32* %old_seen, align 4
  %35 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %36 to i64
  %arrayidx21 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %35, i64 %idxprom20
  %seen22 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx21, i32 0, i32 3
  store i32 %34, i32* %seen22, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %39 = load i32, i32* %i, align 4
  %idx.ext23 = sext i32 %39 to i64
  %add.ptr24 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %38, i64 %idx.ext23
  %call25 = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %37, %struct.bpf_insn* noundef %add.ptr24) #14
  %40 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %41 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %41 to i64
  %arrayidx27 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %40, i64 %idxprom26
  %zext_dst28 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx27, i32 0, i32 5
  %frombool29 = zext i1 %call25 to i8
  store i8 %frombool29, i8* %zext_dst28, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %42 = load i32, i32* %i, align 4
  %inc = add i32 %42, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %43 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 24
  store %struct.bpf_insn_aux_data* %43, %struct.bpf_insn_aux_data** %insn_aux_data30, align 8
  %45 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %46 = bitcast %struct.bpf_insn_aux_data* %45 to i8*
  call void @vfree(i8* noundef %46) #14
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %len) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 31
  %3 = load i32, i32* %subprog_cnt, align 4
  %cmp1 = icmp ule i32 %1, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 27
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %6 = load i32, i32* %start, align 8
  %7 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp ule i32 %6, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %8 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %8, 1
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 27
  %10 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info5, i64 0, i64 %idxprom6
  %start8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %11 = load i32, i32* %start8, align 8
  %add = add i32 %11, %sub
  store i32 %add, i32* %start8, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end4, %if.then3
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_poke_descs(%struct.bpf_prog* noundef %prog, i32 noundef %off, i32 noundef %len) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %off.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %tab = alloca %struct.bpf_jit_poke_descriptor*, align 8
  %i = alloca i32, align 4
  %sz = alloca i32, align 4
  %desc = alloca %struct.bpf_jit_poke_descriptor*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 32
  %2 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  store %struct.bpf_jit_poke_descriptor* %2, %struct.bpf_jit_poke_descriptor** %tab, align 8
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 34
  %5 = load i32, i32* %size_poke_tab, align 8
  store i32 %5, i32* %sz, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %sz, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %tab, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %8, i64 %idxprom
  store %struct.bpf_jit_poke_descriptor* %arrayidx, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %10 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %10, i32 0, i32 8
  %11 = load i32, i32* %insn_idx, align 4
  %12 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp ule i32 %11, %12
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %13 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %13, 1
  %14 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %insn_idx3 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %14, i32 0, i32 8
  %15 = load i32, i32* %insn_idx3, align 4
  %add = add i32 %15, %sub
  store i32 %add, i32* %insn_idx3, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call = call i32 @insn_def_regno(%struct.bpf_insn* noundef %0) #14
  store i32 %call, i32* %dst_reg, align 4
  %1 = load i32, i32* %dst_reg, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %4 = load i32, i32* %dst_reg, align 4
  %call1 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %2, %struct.bpf_insn* noundef %3, i32 noundef %4, %struct.bpf_reg_state* noundef null, i32 noundef 1) #14
  %lnot = xor i1 %call1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i1, i1* %retval, align 1
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @insn_def_regno(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store i32 -1, i32* %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 224
  %cmp = icmp eq i32 %and4, 192
  br i1 %cmp, label %land.lhs.true, label %if.else12

land.lhs.true:                                    ; preds = %sw.bb1
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %and6 = and i32 %5, 1
  %tobool = icmp ne i32 %and6, 0
  br i1 %tobool, label %if.then, label %if.else12

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 3
  %7 = load i32, i32* %imm7, align 4
  %cmp8 = icmp eq i32 %7, 241
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv11 = zext i8 %bf.lshr to i32
  store i32 %conv11, i32* %retval, align 4
  br label %return

if.else12:                                        ; preds = %land.lhs.true, %sw.bb1
  store i32 -1, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 1
  %bf.load13 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load13, 15
  %conv14 = zext i8 %bf.clear to i32
  store i32 %conv14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.else12, %if.else, %if.then10, %sw.bb
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_jit_blinding_enabled(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  ret i1 false
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_kfunc_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %desc = alloca %struct.bpf_kfunc_desc*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 3
  %3 = load i32, i32* %imm, align 4
  %call = call %struct.bpf_kfunc_desc* @find_kfunc_desc(%struct.bpf_prog* noundef %1, i32 noundef %3) #14
  store %struct.bpf_kfunc_desc* %call, %struct.bpf_kfunc_desc** %desc, align 8
  %4 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 3
  %8 = load i32, i32* %imm1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.449, i64 0, i64 0), i32 noundef %8) #14
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %imm2 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %9, i32 0, i32 2
  %10 = load i32, i32* %imm2, align 4
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 3
  store i32 %10, i32* %imm3, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_user_rnd_init_once() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %prog, %struct.bpf_jit_poke_descriptor* noundef %poke) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %poke.addr = alloca %struct.bpf_jit_poke_descriptor*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_jit_poke_descriptor* %poke, %struct.bpf_jit_poke_descriptor** %poke.addr, align 8
  ret i32 -524
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sort_kfunc_descs_by_imm(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 33
  %2 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %2, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %3 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc_tab* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 0
  %5 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %6 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %6, i32 0, i32 1
  %7 = load i32, i32* %nr_descs, align 4
  %conv = zext i32 %7 to i64
  call void @sort(i8* noundef %5, i64 noundef %conv, i64 noundef 24, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_imm, void (i8*, i8*, i32)* noundef null) #14
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_random_int() #0 {
entry:
  %call = call i32 @get_random_u32() #14
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_cmpxchg_insn(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 7
  %cmp = icmp eq i32 %and, 3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 224
  %cmp5 = icmp eq i32 %and4, 192
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %cmp7 = icmp eq i32 %5, 241
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_random_u32() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %func = alloca %struct.bpf_prog**, align 8
  %tmp = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %len = alloca i32, align 4
  %subprog = alloca i32, align 4
  %map_ptr = alloca %struct.bpf_map*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %old_bpf_func = alloca i8*, align 8
  %err = alloca i32, align 4
  %num_exentries = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp43 = alloca i64, align 8
  %tmp51 = alloca i64, align 8
  %poke = alloca %struct.bpf_jit_poke_descriptor*, align 8
  %tmp256 = alloca i32, align 4
  %tmp340 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  store i32 0, i32* %subprog_end, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 31
  %3 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ule i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 13
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len2, align 4
  %cmp3 = icmp ult i32 %5, %7
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %8) #14
  br i1 %call, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.body
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 3
  %10 = load i32, i32* %imm, align 4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 24
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom
  %14 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 0
  %call_imm = bitcast %union.anon.163* %14 to i32*
  store i32 %10, i32* %call_imm, align 8
  br label %for.inc

if.end5:                                          ; preds = %for.body
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call6 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %15) #14
  br i1 %call6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  br label %for.inc

if.end8:                                          ; preds = %if.end5
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load i32, i32* %i, align 4
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 3
  %19 = load i32, i32* %imm9, align 4
  %add = add i32 %17, %19
  %add10 = add i32 %add, 1
  %call11 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %16, i32 noundef %add10) #14
  store i32 %call11, i32* %subprog, align 4
  %20 = load i32, i32* %subprog, align 4
  %cmp12 = icmp slt i32 %20, 0
  br i1 %cmp12, label %if.then13, label %if.end58

if.then13:                                        ; preds = %if.end8
  store i8 1, i8* %__ret_do_once, align 1
  %21 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %21 to i1
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then13
  %22 = load i8, i8* @jit_subprogs.__already_done, align 1
  %tobool14 = trunc i8 %22 to i1
  %lnot = xor i1 %tobool14, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then13
  %23 = phi i1 [ false, %if.then13 ], [ %lnot, %land.rhs ]
  %lnot15 = xor i1 %23, true
  %lnot16 = xor i1 %lnot15, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end50

if.then18:                                        ; preds = %land.end
  store i8 1, i8* @jit_subprogs.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %24 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %24, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end42

if.then26:                                        ; preds = %if.then18
  br label %do.body

do.body:                                          ; preds = %if.then26
  br label %do.body27

do.body27:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body27
  %25 = load i32, i32* %i, align 4
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 3
  %27 = load i32, i32* %imm28, align 4
  %add29 = add i32 %25, %27
  %add30 = add i32 %add29, 1
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.323, i64 0, i64 0), i32 noundef %add30) #14
  br label %do.body31

do.body31:                                        ; preds = %do.end
  br label %do.body32

do.body32:                                        ; preds = %do.body31
  br label %do.end33

do.end33:                                         ; preds = %do.body32
  br label %do.body34

do.body34:                                        ; preds = %do.end33
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 14312, i32 2313, i64 12) #13, !srcloc !73
  br label %do.end35

do.end35:                                         ; preds = %do.body34
  call void asm sideeffect "554:\0A\09.pushsection .discard.reachable\0A\09.long 554b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !74
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  br label %do.end37

do.end37:                                         ; preds = %do.body36
  br label %do.end38

do.end38:                                         ; preds = %do.end37
  br label %do.body39

do.body39:                                        ; preds = %do.end38
  br label %do.end40

do.end40:                                         ; preds = %do.body39
  br label %do.end41

do.end41:                                         ; preds = %do.end40
  br label %if.end42

if.end42:                                         ; preds = %do.end41, %if.then18
  %28 = load i32, i32* %__ret_warn_on, align 4
  %tobool44 = icmp ne i32 %28, 0
  %lnot45 = xor i1 %tobool44, true
  %lnot47 = xor i1 %lnot45, true
  %lnot.ext48 = zext i1 %lnot47 to i32
  %conv49 = sext i32 %lnot.ext48 to i64
  store i64 %conv49, i64* %tmp43, align 8
  %29 = load i64, i64* %tmp43, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.end42, %land.end
  %30 = load i8, i8* %__ret_do_once, align 1
  %tobool52 = trunc i8 %30 to i1
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  store i64 %conv57, i64* %tmp51, align 8
  %31 = load i64, i64* %tmp51, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %if.end8
  %32 = load i32, i32* %subprog, align 4
  %conv59 = trunc i32 %32 to i16
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 2
  store i16 %conv59, i16* %off, align 2
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 3
  %35 = load i32, i32* %imm60, align 4
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data61 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 24
  %37 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data61, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom62 = sext i32 %38 to i64
  %arrayidx63 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %37, i64 %idxprom62
  %39 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx63, i32 0, i32 0
  %call_imm64 = bitcast %union.anon.163* %39 to i32*
  store i32 %35, i32* %call_imm64, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 3
  store i32 1, i32* %imm65, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end58, %if.then7, %if.then4
  %41 = load i32, i32* %i, align 4
  %inc = add i32 %41, 1
  store i32 %inc, i32* %i, align 4
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %42, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %43 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call66 = call i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef %43) #14
  store i32 %call66, i32* %err, align 4
  %44 = load i32, i32* %err, align 4
  %tobool67 = icmp ne i32 %44, 0
  br i1 %tobool67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %for.end
  br label %out_undo_insn

if.end69:                                         ; preds = %for.end
  store i32 -12, i32* %err, align 4
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt70 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 31
  %46 = load i32, i32* %subprog_cnt70, align 4
  %conv71 = zext i32 %46 to i64
  %call72 = call i8* @kcalloc(i64 noundef %conv71, i64 noundef 8, i32 noundef 3264) #14
  %47 = bitcast i8* %call72 to %struct.bpf_prog**
  store %struct.bpf_prog** %47, %struct.bpf_prog*** %func, align 8
  %48 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %tobool73 = icmp ne %struct.bpf_prog** %48, null
  br i1 %tobool73, label %if.end75, label %if.then74

if.then74:                                        ; preds = %if.end69
  br label %out_undo_insn

if.end75:                                         ; preds = %if.end69
  store i32 0, i32* %i, align 4
  br label %for.cond76

for.cond76:                                       ; preds = %for.inc258, %if.end75
  %49 = load i32, i32* %i, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt77 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 31
  %51 = load i32, i32* %subprog_cnt77, align 4
  %cmp78 = icmp ult i32 %49, %51
  br i1 %cmp78, label %for.body80, label %for.end260

for.body80:                                       ; preds = %for.cond76
  %52 = load i32, i32* %subprog_end, align 4
  store i32 %52, i32* %subprog_start, align 4
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 27
  %54 = load i32, i32* %i, align 4
  %add81 = add i32 %54, 1
  %idxprom82 = sext i32 %add81 to i64
  %arrayidx83 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom82
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx83, i32 0, i32 0
  %55 = load i32, i32* %start, align 8
  store i32 %55, i32* %subprog_end, align 4
  %56 = load i32, i32* %subprog_end, align 4
  %57 = load i32, i32* %subprog_start, align 4
  %sub = sub i32 %56, %57
  store i32 %sub, i32* %len, align 4
  %58 = load i32, i32* %len, align 4
  %call84 = call i32 @bpf_prog_size(i32 noundef %58) #14
  %call85 = call %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef %call84, i32 noundef 1051840) #14
  %59 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom86 = sext i32 %60 to i64
  %arrayidx87 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %59, i64 %idxprom86
  store %struct.bpf_prog* %call85, %struct.bpf_prog** %arrayidx87, align 8
  %61 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %62 = load i32, i32* %i, align 4
  %idxprom88 = sext i32 %62 to i64
  %arrayidx89 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %61, i64 %idxprom88
  %63 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx89, align 8
  %tobool90 = icmp ne %struct.bpf_prog* %63, null
  br i1 %tobool90, label %if.end92, label %if.then91

if.then91:                                        ; preds = %for.body80
  br label %out_free

if.end92:                                         ; preds = %for.body80
  %64 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %65 = load i32, i32* %i, align 4
  %idxprom93 = sext i32 %65 to i64
  %arrayidx94 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %64, i64 %idxprom93
  %66 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx94, align 8
  %insnsi95 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %66, i32 0, i32 13
  %arraydecay96 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi95, i64 0, i64 0
  %67 = bitcast %struct.bpf_insn* %arraydecay96 to i8*
  %68 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi97 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %68, i32 0, i32 13
  %69 = load i32, i32* %subprog_start, align 4
  %idxprom98 = sext i32 %69 to i64
  %arrayidx99 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi97, i64 0, i64 %idxprom98
  %70 = bitcast %struct.bpf_insn* %arrayidx99 to i8*
  %71 = load i32, i32* %len, align 4
  %conv100 = sext i32 %71 to i64
  %mul = mul i64 %conv100, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %67, i8* align 8 %70, i64 %mul, i1 false)
  %72 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %72, i32 0, i32 2
  %73 = load i32, i32* %type, align 4
  %74 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %75 = load i32, i32* %i, align 4
  %idxprom101 = sext i32 %75 to i64
  %arrayidx102 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %74, i64 %idxprom101
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx102, align 8
  %type103 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 2
  store i32 %73, i32* %type103, align 4
  %77 = load i32, i32* %len, align 4
  %78 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %79 = load i32, i32* %i, align 4
  %idxprom104 = sext i32 %79 to i64
  %arrayidx105 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %78, i64 %idxprom104
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx105, align 8
  %len106 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %80, i32 0, i32 4
  store i32 %77, i32* %len106, align 4
  %81 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %82 = load i32, i32* %i, align 4
  %idxprom107 = sext i32 %82 to i64
  %arrayidx108 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %81, i64 %idxprom107
  %83 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx108, align 8
  %call109 = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %83) #14
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.then111, label %if.end112

if.then111:                                       ; preds = %if.end92
  br label %out_free

if.end112:                                        ; preds = %if.end92
  %84 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %85 = load i32, i32* %i, align 4
  %idxprom113 = sext i32 %85 to i64
  %arrayidx114 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %84, i64 %idxprom113
  %86 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx114, align 8
  %is_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %86, i32 0, i32 1
  %bf.load = load i16, i16* %is_func, align 2
  %bf.clear = and i16 %bf.load, -65
  %bf.set = or i16 %bf.clear, 64
  store i16 %bf.set, i16* %is_func, align 2
  %87 = load i32, i32* %i, align 4
  %88 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %89 = load i32, i32* %i, align 4
  %idxprom115 = sext i32 %89 to i64
  %arrayidx116 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %88, i64 %idxprom115
  %90 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx116, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %90, i32 0, i32 10
  %91 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_idx = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %91, i32 0, i32 9
  store i32 %87, i32* %func_idx, align 8
  %92 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux117 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %92, i32 0, i32 10
  %93 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux117, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %93, i32 0, i32 47
  %94 = load %struct.btf*, %struct.btf** %btf, align 8
  %95 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %96 = load i32, i32* %i, align 4
  %idxprom118 = sext i32 %96 to i64
  %arrayidx119 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %95, i64 %idxprom118
  %97 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx119, align 8
  %aux120 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %97, i32 0, i32 10
  %98 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux120, align 8
  %btf121 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %98, i32 0, i32 47
  store %struct.btf* %94, %struct.btf** %btf121, align 8
  %99 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux122 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %99, i32 0, i32 10
  %100 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux122, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %100, i32 0, i32 48
  %101 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %102 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %103 = load i32, i32* %i, align 4
  %idxprom123 = sext i32 %103 to i64
  %arrayidx124 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %102, i64 %idxprom123
  %104 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx124, align 8
  %aux125 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %104, i32 0, i32 10
  %105 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux125, align 8
  %func_info126 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %105, i32 0, i32 48
  store %struct.bpf_func_info* %101, %struct.bpf_func_info** %func_info126, align 8
  %106 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux127 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %106, i32 0, i32 10
  %107 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux127, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %107, i32 0, i32 32
  %108 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  %109 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %110 = load i32, i32* %i, align 4
  %idxprom128 = sext i32 %110 to i64
  %arrayidx129 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %109, i64 %idxprom128
  %111 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx129, align 8
  %aux130 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %111, i32 0, i32 10
  %112 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux130, align 8
  %poke_tab131 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %112, i32 0, i32 32
  store %struct.bpf_jit_poke_descriptor* %108, %struct.bpf_jit_poke_descriptor** %poke_tab131, align 8
  %113 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux132 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %113, i32 0, i32 10
  %114 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux132, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %114, i32 0, i32 34
  %115 = load i32, i32* %size_poke_tab, align 8
  %116 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %117 = load i32, i32* %i, align 4
  %idxprom133 = sext i32 %117 to i64
  %arrayidx134 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %116, i64 %idxprom133
  %118 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx134, align 8
  %aux135 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %118, i32 0, i32 10
  %119 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux135, align 8
  %size_poke_tab136 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %119, i32 0, i32 34
  store i32 %115, i32* %size_poke_tab136, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond137

for.cond137:                                      ; preds = %for.inc158, %if.end112
  %120 = load i32, i32* %j, align 4
  %121 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux138 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %121, i32 0, i32 10
  %122 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux138, align 8
  %size_poke_tab139 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %122, i32 0, i32 34
  %123 = load i32, i32* %size_poke_tab139, align 8
  %cmp140 = icmp ult i32 %120, %123
  br i1 %cmp140, label %for.body142, label %for.end160

for.body142:                                      ; preds = %for.cond137
  %124 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux143 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %124, i32 0, i32 10
  %125 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux143, align 8
  %poke_tab144 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %125, i32 0, i32 32
  %126 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab144, align 8
  %127 = load i32, i32* %j, align 4
  %idxprom145 = sext i32 %127 to i64
  %arrayidx146 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %126, i64 %idxprom145
  store %struct.bpf_jit_poke_descriptor* %arrayidx146, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %128 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %128, i32 0, i32 8
  %129 = load i32, i32* %insn_idx, align 4
  %130 = load i32, i32* %subprog_end, align 4
  %cmp147 = icmp ult i32 %129, %130
  br i1 %cmp147, label %land.lhs.true, label %if.end157

land.lhs.true:                                    ; preds = %for.body142
  %131 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %insn_idx149 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %131, i32 0, i32 8
  %132 = load i32, i32* %insn_idx149, align 4
  %133 = load i32, i32* %subprog_start, align 4
  %cmp150 = icmp uge i32 %132, %133
  br i1 %cmp150, label %if.then152, label %if.end157

if.then152:                                       ; preds = %land.lhs.true
  %134 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %135 = load i32, i32* %i, align 4
  %idxprom153 = sext i32 %135 to i64
  %arrayidx154 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %134, i64 %idxprom153
  %136 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx154, align 8
  %aux155 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %136, i32 0, i32 10
  %137 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux155, align 8
  %138 = bitcast %struct.bpf_prog_aux* %137 to i8*
  %139 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %aux156 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %139, i32 0, i32 3
  store i8* %138, i8** %aux156, align 8
  br label %if.end157

if.end157:                                        ; preds = %if.then152, %land.lhs.true, %for.body142
  br label %for.inc158

for.inc158:                                       ; preds = %if.end157
  %140 = load i32, i32* %j, align 4
  %inc159 = add i32 %140, 1
  store i32 %inc159, i32* %j, align 4
  br label %for.cond137

for.end160:                                       ; preds = %for.cond137
  %141 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %142 = load i32, i32* %i, align 4
  %idxprom161 = sext i32 %142 to i64
  %arrayidx162 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %141, i64 %idxprom161
  %143 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx162, align 8
  %aux163 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %143, i32 0, i32 10
  %144 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux163, align 8
  %name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %144, i32 0, i32 44
  %arrayidx164 = getelementptr [16 x i8], [16 x i8]* %name, i64 0, i64 0
  store i8 70, i8* %arrayidx164, align 8
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info165 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %145, i32 0, i32 27
  %146 = load i32, i32* %i, align 4
  %idxprom166 = sext i32 %146 to i64
  %arrayidx167 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info165, i64 0, i64 %idxprom166
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx167, i32 0, i32 2
  %147 = load i16, i16* %stack_depth, align 8
  %conv168 = zext i16 %147 to i32
  %148 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %149 = load i32, i32* %i, align 4
  %idxprom169 = sext i32 %149 to i64
  %arrayidx170 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %148, i64 %idxprom169
  %150 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx170, align 8
  %aux171 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %150, i32 0, i32 10
  %151 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux171, align 8
  %stack_depth172 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %151, i32 0, i32 6
  store i32 %conv168, i32* %stack_depth172, align 4
  %152 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %153 = load i32, i32* %i, align 4
  %idxprom173 = sext i32 %153 to i64
  %arrayidx174 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %152, i64 %idxprom173
  %154 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx174, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %154, i32 0, i32 1
  %bf.load175 = load i16, i16* %jit_requested, align 2
  %bf.clear176 = and i16 %bf.load175, -3
  %bf.set177 = or i16 %bf.clear176, 2
  store i16 %bf.set177, i16* %jit_requested, align 2
  %155 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux178 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %155, i32 0, i32 10
  %156 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux178, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %156, i32 0, i32 33
  %157 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  %158 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %159 = load i32, i32* %i, align 4
  %idxprom179 = sext i32 %159 to i64
  %arrayidx180 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %158, i64 %idxprom179
  %160 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx180, align 8
  %aux181 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %160, i32 0, i32 10
  %161 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux181, align 8
  %kfunc_tab182 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %161, i32 0, i32 33
  store %struct.bpf_kfunc_desc_tab* %157, %struct.bpf_kfunc_desc_tab** %kfunc_tab182, align 8
  %162 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux183 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %162, i32 0, i32 10
  %163 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux183, align 8
  %linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %163, i32 0, i32 50
  %164 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %165 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %166 = load i32, i32* %i, align 4
  %idxprom184 = sext i32 %166 to i64
  %arrayidx185 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %165, i64 %idxprom184
  %167 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx185, align 8
  %aux186 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %167, i32 0, i32 10
  %168 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux186, align 8
  %linfo187 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %168, i32 0, i32 50
  store %struct.bpf_line_info* %164, %struct.bpf_line_info** %linfo187, align 8
  %169 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux188 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %169, i32 0, i32 10
  %170 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux188, align 8
  %nr_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %170, i32 0, i32 53
  %171 = load i32, i32* %nr_linfo, align 4
  %172 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %173 = load i32, i32* %i, align 4
  %idxprom189 = sext i32 %173 to i64
  %arrayidx190 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %172, i64 %idxprom189
  %174 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx190, align 8
  %aux191 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %174, i32 0, i32 10
  %175 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux191, align 8
  %nr_linfo192 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %175, i32 0, i32 53
  store i32 %171, i32* %nr_linfo192, align 4
  %176 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux193 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %176, i32 0, i32 10
  %177 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux193, align 8
  %jited_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %177, i32 0, i32 51
  %178 = load i8**, i8*** %jited_linfo, align 8
  %179 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %180 = load i32, i32* %i, align 4
  %idxprom194 = sext i32 %180 to i64
  %arrayidx195 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %179, i64 %idxprom194
  %181 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx195, align 8
  %aux196 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %181, i32 0, i32 10
  %182 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux196, align 8
  %jited_linfo197 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %182, i32 0, i32 51
  store i8** %178, i8*** %jited_linfo197, align 8
  %183 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info198 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %183, i32 0, i32 27
  %184 = load i32, i32* %i, align 4
  %idxprom199 = sext i32 %184 to i64
  %arrayidx200 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info198, i64 0, i64 %idxprom199
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx200, i32 0, i32 1
  %185 = load i32, i32* %linfo_idx, align 4
  %186 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %187 = load i32, i32* %i, align 4
  %idxprom201 = sext i32 %187 to i64
  %arrayidx202 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %186, i64 %idxprom201
  %188 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx202, align 8
  %aux203 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %188, i32 0, i32 10
  %189 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux203, align 8
  %linfo_idx204 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %189, i32 0, i32 54
  store i32 %185, i32* %linfo_idx204, align 8
  store i32 0, i32* %num_exentries, align 4
  %190 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %191 = load i32, i32* %i, align 4
  %idxprom205 = sext i32 %191 to i64
  %arrayidx206 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %190, i64 %idxprom205
  %192 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx206, align 8
  %insnsi207 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %192, i32 0, i32 13
  %arraydecay208 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi207, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay208, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc228, %for.end160
  %193 = load i32, i32* %j, align 4
  %194 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %195 = load i32, i32* %i, align 4
  %idxprom210 = sext i32 %195 to i64
  %arrayidx211 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %194, i64 %idxprom210
  %196 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx211, align 8
  %len212 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %196, i32 0, i32 4
  %197 = load i32, i32* %len212, align 4
  %cmp213 = icmp ult i32 %193, %197
  br i1 %cmp213, label %for.body215, label %for.end231

for.body215:                                      ; preds = %for.cond209
  %198 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %198, i32 0, i32 0
  %199 = load i8, i8* %code, align 4
  %conv216 = zext i8 %199 to i32
  %and = and i32 %conv216, 7
  %cmp217 = icmp eq i32 %and, 1
  br i1 %cmp217, label %land.lhs.true219, label %if.end227

land.lhs.true219:                                 ; preds = %for.body215
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code220 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 0
  %201 = load i8, i8* %code220, align 4
  %conv221 = zext i8 %201 to i32
  %and222 = and i32 %conv221, 224
  %cmp223 = icmp eq i32 %and222, 32
  br i1 %cmp223, label %if.then225, label %if.end227

if.then225:                                       ; preds = %land.lhs.true219
  %202 = load i32, i32* %num_exentries, align 4
  %inc226 = add i32 %202, 1
  store i32 %inc226, i32* %num_exentries, align 4
  br label %if.end227

if.end227:                                        ; preds = %if.then225, %land.lhs.true219, %for.body215
  br label %for.inc228

for.inc228:                                       ; preds = %if.end227
  %203 = load i32, i32* %j, align 4
  %inc229 = add i32 %203, 1
  store i32 %inc229, i32* %j, align 4
  %204 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr230 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %204, i32 1
  store %struct.bpf_insn* %incdec.ptr230, %struct.bpf_insn** %insn, align 8
  br label %for.cond209

for.end231:                                       ; preds = %for.cond209
  %205 = load i32, i32* %num_exentries, align 4
  %206 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %207 = load i32, i32* %i, align 4
  %idxprom232 = sext i32 %207 to i64
  %arrayidx233 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %206, i64 %idxprom232
  %208 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx233, align 8
  %aux234 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %208, i32 0, i32 10
  %209 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux234, align 8
  %num_exentries235 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %209, i32 0, i32 55
  store i32 %205, i32* %num_exentries235, align 4
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info236 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %210, i32 0, i32 27
  %211 = load i32, i32* %i, align 4
  %idxprom237 = sext i32 %211 to i64
  %arrayidx238 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info236, i64 0, i64 %idxprom237
  %tail_call_reachable = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx238, i32 0, i32 4
  %212 = load i8, i8* %tail_call_reachable, align 1
  %tobool239 = trunc i8 %212 to i1
  %213 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %214 = load i32, i32* %i, align 4
  %idxprom240 = sext i32 %214 to i64
  %arrayidx241 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %213, i64 %idxprom240
  %215 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx241, align 8
  %aux242 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %215, i32 0, i32 10
  %216 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux242, align 8
  %tail_call_reachable243 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %216, i32 0, i32 26
  %frombool = zext i1 %tobool239 to i8
  store i8 %frombool, i8* %tail_call_reachable243, align 1
  %217 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %218 = load i32, i32* %i, align 4
  %idxprom244 = sext i32 %218 to i64
  %arrayidx245 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %217, i64 %idxprom244
  %219 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx245, align 8
  %call246 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %219) #14
  %220 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %221 = load i32, i32* %i, align 4
  %idxprom247 = sext i32 %221 to i64
  %arrayidx248 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %220, i64 %idxprom247
  store %struct.bpf_prog* %call246, %struct.bpf_prog** %arrayidx248, align 8
  %222 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %223 = load i32, i32* %i, align 4
  %idxprom249 = sext i32 %223 to i64
  %arrayidx250 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %222, i64 %idxprom249
  %224 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx250, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %224, i32 0, i32 1
  %bf.load251 = load i16, i16* %jited, align 2
  %bf.clear252 = and i16 %bf.load251, 1
  %tobool253 = icmp ne i16 %bf.clear252, 0
  br i1 %tobool253, label %if.end255, label %if.then254

if.then254:                                       ; preds = %for.end231
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end255:                                        ; preds = %for.end231
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 14397, i32 noundef 0) #14
  %call257 = call i32 @_cond_resched() #14
  store i32 %call257, i32* %tmp256, align 4
  %225 = load i32, i32* %tmp256, align 4
  br label %for.inc258

for.inc258:                                       ; preds = %if.end255
  %226 = load i32, i32* %i, align 4
  %inc259 = add i32 %226, 1
  store i32 %inc259, i32* %i, align 4
  br label %for.cond76

for.end260:                                       ; preds = %for.cond76
  store i32 0, i32* %i, align 4
  br label %for.cond261

for.cond261:                                      ; preds = %for.inc315, %for.end260
  %227 = load i32, i32* %i, align 4
  %228 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt262 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %228, i32 0, i32 31
  %229 = load i32, i32* %subprog_cnt262, align 4
  %cmp263 = icmp ult i32 %227, %229
  br i1 %cmp263, label %for.body265, label %for.end317

for.body265:                                      ; preds = %for.cond261
  %230 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %231 = load i32, i32* %i, align 4
  %idxprom266 = sext i32 %231 to i64
  %arrayidx267 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %230, i64 %idxprom266
  %232 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx267, align 8
  %insnsi268 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %232, i32 0, i32 13
  %arraydecay269 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi268, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay269, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond270

for.cond270:                                      ; preds = %for.inc303, %for.body265
  %233 = load i32, i32* %j, align 4
  %234 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %235 = load i32, i32* %i, align 4
  %idxprom271 = sext i32 %235 to i64
  %arrayidx272 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %234, i64 %idxprom271
  %236 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx272, align 8
  %len273 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %236, i32 0, i32 4
  %237 = load i32, i32* %len273, align 4
  %cmp274 = icmp ult i32 %233, %237
  br i1 %cmp274, label %for.body276, label %for.end306

for.body276:                                      ; preds = %for.cond270
  %238 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call277 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %238) #14
  br i1 %call277, label %if.then278, label %if.end292

if.then278:                                       ; preds = %for.body276
  %239 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx279 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %239, i64 1
  %imm280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx279, i32 0, i32 3
  %240 = load i32, i32* %imm280, align 4
  store i32 %240, i32* %subprog, align 4
  %241 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %242 = load i32, i32* %subprog, align 4
  %idxprom281 = sext i32 %242 to i64
  %arrayidx282 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %241, i64 %idxprom281
  %243 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx282, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %243, i32 0, i32 9
  %244 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %245 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %244 to i64
  %conv283 = trunc i64 %245 to i32
  %246 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx284 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %246, i64 0
  %imm285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx284, i32 0, i32 3
  store i32 %conv283, i32* %imm285, align 4
  %247 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %248 = load i32, i32* %subprog, align 4
  %idxprom286 = sext i32 %248 to i64
  %arrayidx287 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %247, i64 %idxprom286
  %249 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx287, align 8
  %bpf_func288 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %249, i32 0, i32 9
  %250 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func288, align 8
  %251 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %250 to i64
  %shr = lshr i64 %251, 32
  %conv289 = trunc i64 %shr to i32
  %252 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx290 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %252, i64 1
  %imm291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx290, i32 0, i32 3
  store i32 %conv289, i32* %imm291, align 4
  br label %for.inc303

if.end292:                                        ; preds = %for.body276
  %253 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call293 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %253) #14
  br i1 %call293, label %if.end295, label %if.then294

if.then294:                                       ; preds = %if.end292
  br label %for.inc303

if.end295:                                        ; preds = %if.end292
  %254 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off296 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %254, i32 0, i32 2
  %255 = load i16, i16* %off296, align 2
  %conv297 = sext i16 %255 to i32
  store i32 %conv297, i32* %subprog, align 4
  %256 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %257 = load i32, i32* %subprog, align 4
  %idxprom298 = sext i32 %257 to i64
  %arrayidx299 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %256, i64 %idxprom298
  %258 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx299, align 8
  %bpf_func300 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %258, i32 0, i32 9
  %259 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func300, align 8
  %260 = bitcast i32 (i8*, %struct.bpf_insn*)* %259 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast = ptrtoint i64 (i64, i64, i64, i64, i64)* %260 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv301 = trunc i64 %sub.ptr.sub to i32
  %261 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm302 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %261, i32 0, i32 3
  store i32 %conv301, i32* %imm302, align 4
  br label %for.inc303

for.inc303:                                       ; preds = %if.end295, %if.then294, %if.then278
  %262 = load i32, i32* %j, align 4
  %inc304 = add i32 %262, 1
  store i32 %inc304, i32* %j, align 4
  %263 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr305 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %263, i32 1
  store %struct.bpf_insn* %incdec.ptr305, %struct.bpf_insn** %insn, align 8
  br label %for.cond270

for.end306:                                       ; preds = %for.cond270
  %264 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %265 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %266 = load i32, i32* %i, align 4
  %idxprom307 = sext i32 %266 to i64
  %arrayidx308 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %265, i64 %idxprom307
  %267 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx308, align 8
  %aux309 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %267, i32 0, i32 10
  %268 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux309, align 8
  %func310 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %268, i32 0, i32 30
  store %struct.bpf_prog** %264, %struct.bpf_prog*** %func310, align 8
  %269 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt311 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %269, i32 0, i32 31
  %270 = load i32, i32* %subprog_cnt311, align 4
  %271 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %272 = load i32, i32* %i, align 4
  %idxprom312 = sext i32 %272 to i64
  %arrayidx313 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %271, i64 %idxprom312
  %273 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx313, align 8
  %aux314 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %273, i32 0, i32 10
  %274 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux314, align 8
  %func_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %274, i32 0, i32 8
  store i32 %270, i32* %func_cnt, align 4
  br label %for.inc315

for.inc315:                                       ; preds = %for.end306
  %275 = load i32, i32* %i, align 4
  %inc316 = add i32 %275, 1
  store i32 %inc316, i32* %i, align 4
  br label %for.cond261

for.end317:                                       ; preds = %for.cond261
  store i32 0, i32* %i, align 4
  br label %for.cond318

for.cond318:                                      ; preds = %for.inc342, %for.end317
  %276 = load i32, i32* %i, align 4
  %277 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt319 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %277, i32 0, i32 31
  %278 = load i32, i32* %subprog_cnt319, align 4
  %cmp320 = icmp ult i32 %276, %278
  br i1 %cmp320, label %for.body322, label %for.end344

for.body322:                                      ; preds = %for.cond318
  %279 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %280 = load i32, i32* %i, align 4
  %idxprom323 = sext i32 %280 to i64
  %arrayidx324 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %279, i64 %idxprom323
  %281 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx324, align 8
  %bpf_func325 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %281, i32 0, i32 9
  %282 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func325, align 8
  %283 = bitcast i32 (i8*, %struct.bpf_insn*)* %282 to i8*
  store i8* %283, i8** %old_bpf_func, align 8
  %284 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %285 = load i32, i32* %i, align 4
  %idxprom326 = sext i32 %285 to i64
  %arrayidx327 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %284, i64 %idxprom326
  %286 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx327, align 8
  %call328 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %286) #14
  store %struct.bpf_prog* %call328, %struct.bpf_prog** %tmp, align 8
  %287 = load %struct.bpf_prog*, %struct.bpf_prog** %tmp, align 8
  %288 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %289 = load i32, i32* %i, align 4
  %idxprom329 = sext i32 %289 to i64
  %arrayidx330 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %288, i64 %idxprom329
  %290 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx330, align 8
  %cmp331 = icmp ne %struct.bpf_prog* %287, %290
  br i1 %cmp331, label %if.then338, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body322
  %291 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %292 = load i32, i32* %i, align 4
  %idxprom333 = sext i32 %292 to i64
  %arrayidx334 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %291, i64 %idxprom333
  %293 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx334, align 8
  %bpf_func335 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %293, i32 0, i32 9
  %294 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func335, align 8
  %295 = load i8*, i8** %old_bpf_func, align 8
  %296 = bitcast i8* %295 to i32 (i8*, %struct.bpf_insn*)*
  %cmp336 = icmp ne i32 (i8*, %struct.bpf_insn*)* %294, %296
  br i1 %cmp336, label %if.then338, label %if.end339

if.then338:                                       ; preds = %lor.lhs.false, %for.body322
  %297 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %298 = bitcast %struct.bpf_verifier_env* %297 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %298, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.453, i64 0, i64 0)) #14
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end339:                                        ; preds = %lor.lhs.false
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 14442, i32 noundef 0) #14
  %call341 = call i32 @_cond_resched() #14
  store i32 %call341, i32* %tmp340, align 4
  %299 = load i32, i32* %tmp340, align 4
  br label %for.inc342

for.inc342:                                       ; preds = %if.end339
  %300 = load i32, i32* %i, align 4
  %inc343 = add i32 %300, 1
  store i32 %inc343, i32* %i, align 4
  br label %for.cond318

for.end344:                                       ; preds = %for.cond318
  store i32 0, i32* %i, align 4
  br label %for.cond345

for.cond345:                                      ; preds = %for.inc354, %for.end344
  %301 = load i32, i32* %i, align 4
  %302 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt346 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %302, i32 0, i32 31
  %303 = load i32, i32* %subprog_cnt346, align 4
  %cmp347 = icmp ult i32 %301, %303
  br i1 %cmp347, label %for.body349, label %for.end356

for.body349:                                      ; preds = %for.cond345
  %304 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %305 = load i32, i32* %i, align 4
  %idxprom350 = sext i32 %305 to i64
  %arrayidx351 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %304, i64 %idxprom350
  %306 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx351, align 8
  call void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %306) #14
  %307 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %308 = load i32, i32* %i, align 4
  %idxprom352 = sext i32 %308 to i64
  %arrayidx353 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %307, i64 %idxprom352
  %309 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx353, align 8
  call void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %309) #14
  br label %for.inc354

for.inc354:                                       ; preds = %for.body349
  %310 = load i32, i32* %i, align 4
  %inc355 = add i32 %310, 1
  store i32 %inc355, i32* %i, align 4
  br label %for.cond345

for.end356:                                       ; preds = %for.cond345
  store i32 0, i32* %i, align 4
  %311 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi357 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %311, i32 0, i32 13
  %arraydecay358 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi357, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay358, %struct.bpf_insn** %insn, align 8
  br label %for.cond359

for.cond359:                                      ; preds = %for.inc395, %for.end356
  %312 = load i32, i32* %i, align 4
  %313 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len360 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %313, i32 0, i32 4
  %314 = load i32, i32* %len360, align 4
  %cmp361 = icmp ult i32 %312, %314
  br i1 %cmp361, label %for.body363, label %for.end398

for.body363:                                      ; preds = %for.cond359
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call364 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %315) #14
  br i1 %call364, label %if.then365, label %if.end379

if.then365:                                       ; preds = %for.body363
  %316 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data366 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %316, i32 0, i32 24
  %317 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data366, align 8
  %318 = load i32, i32* %i, align 4
  %idxprom367 = sext i32 %318 to i64
  %arrayidx368 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %317, i64 %idxprom367
  %319 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx368, i32 0, i32 0
  %call_imm369 = bitcast %union.anon.163* %319 to i32*
  %320 = load i32, i32* %call_imm369, align 8
  %321 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx370 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %321, i64 0
  %imm371 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx370, i32 0, i32 3
  store i32 %320, i32* %imm371, align 4
  %322 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %323 = load i32, i32* %i, align 4
  %324 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx372 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %324, i64 0
  %imm373 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx372, i32 0, i32 3
  %325 = load i32, i32* %imm373, align 4
  %add374 = add i32 %323, %325
  %add375 = add i32 %add374, 1
  %call376 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %322, i32 noundef %add375) #14
  %326 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx377 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %326, i64 1
  %imm378 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx377, i32 0, i32 3
  store i32 %call376, i32* %imm378, align 4
  br label %for.inc395

if.end379:                                        ; preds = %for.body363
  %327 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call380 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %327) #14
  br i1 %call380, label %if.end382, label %if.then381

if.then381:                                       ; preds = %if.end379
  br label %for.inc395

if.end382:                                        ; preds = %if.end379
  %328 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data383 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %328, i32 0, i32 24
  %329 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data383, align 8
  %330 = load i32, i32* %i, align 4
  %idxprom384 = sext i32 %330 to i64
  %arrayidx385 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %329, i64 %idxprom384
  %331 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx385, i32 0, i32 0
  %call_imm386 = bitcast %union.anon.163* %331 to i32*
  %332 = load i32, i32* %call_imm386, align 8
  %conv387 = trunc i32 %332 to i16
  %333 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off388 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %333, i32 0, i32 2
  store i16 %conv387, i16* %off388, align 2
  %334 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %335 = load i32, i32* %i, align 4
  %336 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off389 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %336, i32 0, i32 2
  %337 = load i16, i16* %off389, align 2
  %conv390 = sext i16 %337 to i32
  %add391 = add i32 %335, %conv390
  %add392 = add i32 %add391, 1
  %call393 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %334, i32 noundef %add392) #14
  store i32 %call393, i32* %subprog, align 4
  %338 = load i32, i32* %subprog, align 4
  %339 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm394 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %339, i32 0, i32 3
  store i32 %338, i32* %imm394, align 4
  br label %for.inc395

for.inc395:                                       ; preds = %if.end382, %if.then381, %if.then365
  %340 = load i32, i32* %i, align 4
  %inc396 = add i32 %340, 1
  store i32 %inc396, i32* %i, align 4
  %341 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr397 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %341, i32 1
  store %struct.bpf_insn* %incdec.ptr397, %struct.bpf_insn** %insn, align 8
  br label %for.cond359

for.end398:                                       ; preds = %for.cond359
  %342 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jited399 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %342, i32 0, i32 1
  %bf.load400 = load i16, i16* %jited399, align 2
  %bf.clear401 = and i16 %bf.load400, -2
  %bf.set402 = or i16 %bf.clear401, 1
  store i16 %bf.set402, i16* %jited399, align 2
  %343 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %arrayidx403 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %343, i64 0
  %344 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx403, align 8
  %bpf_func404 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %344, i32 0, i32 9
  %345 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func404, align 8
  %346 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %bpf_func405 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %346, i32 0, i32 9
  store i32 (i8*, %struct.bpf_insn*)* %345, i32 (i8*, %struct.bpf_insn*)** %bpf_func405, align 8
  %347 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %348 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux406 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %348, i32 0, i32 10
  %349 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux406, align 8
  %func407 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %349, i32 0, i32 30
  store %struct.bpf_prog** %347, %struct.bpf_prog*** %func407, align 8
  %350 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt408 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %350, i32 0, i32 31
  %351 = load i32, i32* %subprog_cnt408, align 4
  %352 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux409 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %352, i32 0, i32 10
  %353 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux409, align 8
  %func_cnt410 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %353, i32 0, i32 8
  store i32 %351, i32* %func_cnt410, align 4
  %354 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_jit_attempt_done(%struct.bpf_prog* noundef %354) #14
  store i32 0, i32* %retval, align 4
  br label %return

out_free:                                         ; preds = %if.then338, %if.then254, %if.then111, %if.then91
  store i32 0, i32* %i, align 4
  br label %for.cond411

for.cond411:                                      ; preds = %for.inc422, %out_free
  %355 = load i32, i32* %i, align 4
  %356 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux412 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %356, i32 0, i32 10
  %357 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux412, align 8
  %size_poke_tab413 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %357, i32 0, i32 34
  %358 = load i32, i32* %size_poke_tab413, align 8
  %cmp414 = icmp ult i32 %355, %358
  br i1 %cmp414, label %for.body416, label %for.end424

for.body416:                                      ; preds = %for.cond411
  %359 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux417 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %359, i32 0, i32 10
  %360 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux417, align 8
  %poke_tab418 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %360, i32 0, i32 32
  %361 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab418, align 8
  %362 = load i32, i32* %i, align 4
  %idxprom419 = sext i32 %362 to i64
  %arrayidx420 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %361, i64 %idxprom419
  %363 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx420, i32 0, i32 4
  %tail_call = bitcast %union.anon.124* %363 to %struct.anon.125*
  %map = getelementptr inbounds %struct.anon.125, %struct.anon.125* %tail_call, i32 0, i32 0
  %364 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  store %struct.bpf_map* %364, %struct.bpf_map** %map_ptr, align 8
  %365 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %365, i32 0, i32 0
  %366 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_poke_untrack = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %366, i32 0, i32 25
  %367 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack, align 8
  %368 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %369 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux421 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %369, i32 0, i32 10
  %370 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux421, align 8
  call void %367(%struct.bpf_map* noundef %368, %struct.bpf_prog_aux* noundef %370) #14
  br label %for.inc422

for.inc422:                                       ; preds = %for.body416
  %371 = load i32, i32* %i, align 4
  %inc423 = add i32 %371, 1
  store i32 %inc423, i32* %i, align 4
  br label %for.cond411

for.end424:                                       ; preds = %for.cond411
  store i32 0, i32* %i, align 4
  br label %for.cond425

for.cond425:                                      ; preds = %for.inc441, %for.end424
  %372 = load i32, i32* %i, align 4
  %373 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt426 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %373, i32 0, i32 31
  %374 = load i32, i32* %subprog_cnt426, align 4
  %cmp427 = icmp ult i32 %372, %374
  br i1 %cmp427, label %for.body429, label %for.end443

for.body429:                                      ; preds = %for.cond425
  %375 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %376 = load i32, i32* %i, align 4
  %idxprom430 = sext i32 %376 to i64
  %arrayidx431 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %375, i64 %idxprom430
  %377 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx431, align 8
  %tobool432 = icmp ne %struct.bpf_prog* %377, null
  br i1 %tobool432, label %if.end434, label %if.then433

if.then433:                                       ; preds = %for.body429
  br label %for.inc441

if.end434:                                        ; preds = %for.body429
  %378 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %379 = load i32, i32* %i, align 4
  %idxprom435 = sext i32 %379 to i64
  %arrayidx436 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %378, i64 %idxprom435
  %380 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx436, align 8
  %aux437 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %380, i32 0, i32 10
  %381 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux437, align 8
  %poke_tab438 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %381, i32 0, i32 32
  store %struct.bpf_jit_poke_descriptor* null, %struct.bpf_jit_poke_descriptor** %poke_tab438, align 8
  %382 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %383 = load i32, i32* %i, align 4
  %idxprom439 = sext i32 %383 to i64
  %arrayidx440 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %382, i64 %idxprom439
  %384 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx440, align 8
  call void @bpf_jit_free(%struct.bpf_prog* noundef %384) #14
  br label %for.inc441

for.inc441:                                       ; preds = %if.end434, %if.then433
  %385 = load i32, i32* %i, align 4
  %inc442 = add i32 %385, 1
  store i32 %inc442, i32* %i, align 4
  br label %for.cond425

for.end443:                                       ; preds = %for.cond425
  %386 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %387 = bitcast %struct.bpf_prog** %386 to i8*
  call void @kfree(i8* noundef %387) #14
  br label %out_undo_insn

out_undo_insn:                                    ; preds = %for.end443, %if.then74, %if.then68
  %388 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested444 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %388, i32 0, i32 1
  %bf.load445 = load i16, i16* %jit_requested444, align 2
  %bf.clear446 = and i16 %bf.load445, -3
  %bf.set447 = or i16 %bf.clear446, 0
  store i16 %bf.set447, i16* %jit_requested444, align 2
  store i32 0, i32* %i, align 4
  %389 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi448 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %389, i32 0, i32 13
  %arraydecay449 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi448, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay449, %struct.bpf_insn** %insn, align 8
  br label %for.cond450

for.cond450:                                      ; preds = %for.inc464, %out_undo_insn
  %390 = load i32, i32* %i, align 4
  %391 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len451 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %391, i32 0, i32 4
  %392 = load i32, i32* %len451, align 4
  %cmp452 = icmp ult i32 %390, %392
  br i1 %cmp452, label %for.body454, label %for.end467

for.body454:                                      ; preds = %for.cond450
  %393 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call455 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %393) #14
  br i1 %call455, label %if.end457, label %if.then456

if.then456:                                       ; preds = %for.body454
  br label %for.inc464

if.end457:                                        ; preds = %for.body454
  %394 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off458 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %394, i32 0, i32 2
  store i16 0, i16* %off458, align 2
  %395 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data459 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %395, i32 0, i32 24
  %396 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data459, align 8
  %397 = load i32, i32* %i, align 4
  %idxprom460 = sext i32 %397 to i64
  %arrayidx461 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %396, i64 %idxprom460
  %398 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx461, i32 0, i32 0
  %call_imm462 = bitcast %union.anon.163* %398 to i32*
  %399 = load i32, i32* %call_imm462, align 8
  %400 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm463 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %400, i32 0, i32 3
  store i32 %399, i32* %imm463, align 4
  br label %for.inc464

for.inc464:                                       ; preds = %if.end457, %if.then456
  %401 = load i32, i32* %i, align 4
  %inc465 = add i32 %401, 1
  store i32 %inc465, i32* %i, align 4
  %402 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr466 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %402, i32 1
  store %struct.bpf_insn* %incdec.ptr466, %struct.bpf_insn** %insn, align 8
  br label %for.cond450

for.end467:                                       ; preds = %for.cond450
  %403 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_jit_attempt_done(%struct.bpf_prog* noundef %403) #14
  %404 = load i32, i32* %err, align 4
  store i32 %404, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end467, %for.end398, %if.end50, %if.then
  %405 = load i32, i32* %retval, align 4
  ret i32 %405
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %idx.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %subprog = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp34 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load i32, i32* %idx.addr, align 4
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm, align 4
  %add = add i32 %0, %2
  %add1 = add i32 %add, 1
  store i32 %add1, i32* %start, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load i32, i32* %start, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %3, i32 noundef %4) #14
  store i32 %call, i32* %subprog, align 4
  %5 = load i32, i32* %subprog, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end41

if.then:                                          ; preds = %entry
  store i8 1, i8* %__ret_do_once, align 1
  %6 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %7 = load i8, i8* @get_callee_stack_depth.__already_done, align 1
  %tobool2 = trunc i8 %7 to i1
  %lnot = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %8 = phi i1 [ false, %if.then ], [ %lnot, %land.rhs ]
  %lnot3 = xor i1 %8, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then6, label %if.end33

if.then6:                                         ; preds = %land.end
  store i8 1, i8* @get_callee_stack_depth.__already_done, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %9, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then6
  br label %do.body

do.body:                                          ; preds = %if.then14
  br label %do.body15

do.body15:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body15
  %10 = load i32, i32* %start, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.323, i64 0, i64 0), i32 noundef %10) #14
  br label %do.body16

do.body16:                                        ; preds = %do.end
  br label %do.body17

do.body17:                                        ; preds = %do.body16
  br label %do.end18

do.end18:                                         ; preds = %do.body17
  br label %do.body19

do.body19:                                        ; preds = %do.end18
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 3849, i32 2313, i64 12) #13, !srcloc !75
  br label %do.end20

do.end20:                                         ; preds = %do.body19
  call void asm sideeffect "481:\0A\09.pushsection .discard.reachable\0A\09.long 481b - .\0A\09.popsection\0A\09", "~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !76
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  br label %do.end23

do.end23:                                         ; preds = %do.end22
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  br label %do.end25

do.end25:                                         ; preds = %do.body24
  br label %do.end26

do.end26:                                         ; preds = %do.end25
  br label %if.end

if.end:                                           ; preds = %do.end26, %if.then6
  %11 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %11, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end, %land.end
  %13 = load i8, i8* %__ret_do_once, align 1
  %tobool35 = trunc i8 %13 to i1
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  store i64 %conv40, i64* %tmp34, align 8
  %14 = load i64, i64* %tmp34, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 27
  %16 = load i32, i32* %subprog, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %17 = load i16, i16* %stack_depth, align 8
  %conv42 = zext i16 %17 to i32
  store i32 %conv42, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.end33
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_patch_call_args(%struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_prog_size(i32 noundef %proglen) #0 {
entry:
  %proglen.addr = alloca i32, align 4
  %__UNIQUE_ID___x413 = alloca i64, align 8
  %__UNIQUE_ID___y414 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i32 %proglen, i32* %proglen.addr, align 4
  store i64 72, i64* %__UNIQUE_ID___x413, align 8
  %0 = load i32, i32* %proglen.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = mul i64 %conv, 8
  %2 = add i64 72, %1
  store i64 %2, i64* %__UNIQUE_ID___y414, align 8
  %3 = load i64, i64* %__UNIQUE_ID___x413, align 8
  %4 = load i64, i64* %__UNIQUE_ID___y414, align 8
  %cmp = icmp ugt i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, i64* %__UNIQUE_ID___x413, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___y414, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %conv2 = trunc i64 %7 to i32
  ret i32 %conv2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 1
  %bf.load = load i16, i16* %jited, align 2
  %bf.clear = and i16 %bf.load, 1
  %tobool = icmp ne i16 %bf.clear, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %2 = bitcast %struct.bpf_prog* %1 to i8*
  call void @set_vm_flush_reset_perms(i8* noundef %2) #14
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %4 = ptrtoint %struct.bpf_prog* %3 to i64
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %pages = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 0
  %6 = load i16, i16* %pages, align 8
  %conv = zext i16 %6 to i32
  %call = call i32 @set_memory_ro(i64 noundef %4, i32 noundef %conv) #14
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_jit_attempt_done(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_jit_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %0) #14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @set_vm_flush_reset_perms(i8* noundef %addr) #0 {
entry:
  %addr.addr = alloca i8*, align 8
  %vm = alloca %struct.vm_struct*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8*, i8** %addr.addr, align 8
  %call = call %struct.vm_struct* @find_vm_area(i8* noundef %0) #14
  store %struct.vm_struct* %call, %struct.vm_struct** %vm, align 8
  %1 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %tobool = icmp ne %struct.vm_struct* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %flags = getelementptr inbounds %struct.vm_struct, %struct.vm_struct* %2, i32 0, i32 3
  %3 = load i64, i64* %flags, align 8
  %or = or i64 %3, 256
  store i64 %or, i64* %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @set_memory_ro(i64 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.vm_struct* @find_vm_area(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @__bpf_prog_free(%struct.bpf_prog* noundef %0) #14
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_prog_free(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64(i64 noundef %dividend, i32 noundef %divisor) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder = alloca i32, align 4
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %call = call i64 @div_u64_rem(i64 noundef %0, i32 noundef %1, i32* noundef %remainder) #14
  ret i64 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64_rem(i64 noundef %dividend, i32 noundef %divisor, i32* noundef %remainder) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder.addr = alloca i32*, align 8
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  store i32* %remainder, i32** %remainder.addr, align 8
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %conv = zext i32 %1 to i64
  %rem = urem i64 %0, %conv
  %conv1 = trunc i64 %rem to i32
  %2 = load i32*, i32** %remainder.addr, align 8
  store i32 %conv1, i32* %2, align 4
  %3 = load i64, i64* %dividend.addr, align 8
  %4 = load i32, i32* %divisor.addr, align 4
  %conv2 = zext i32 %4 to i64
  %div = udiv i64 %3, %conv2
  ret i64 %div
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_free_used_maps(%struct.bpf_prog_aux* noundef, %struct.bpf_map** noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_free_used_btfs(%struct.bpf_prog_aux* noundef, %struct.btf_mod_pair* noundef, i32 noundef) #1

attributes #0 = { noinline noredzone nounwind null_pointer_is_valid sspstrong "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #1 = { noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #2 = { cold noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #3 = { nofree nosync nounwind willreturn }
attributes #4 = { argmemonly nofree nounwind willreturn writeonly }
attributes #5 = { argmemonly nofree nounwind willreturn }
attributes #6 = { convergent nofree nosync nounwind readnone willreturn }
attributes #7 = { noredzone null_pointer_is_valid "dontcall-error"="copy source size is too small" "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #8 = { noredzone null_pointer_is_valid "dontcall-error"="copy destination size is too small" "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #9 = { noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #10 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #11 = { nofree nosync nounwind readnone willreturn }
attributes #12 = { nounwind readonly }
attributes #13 = { nounwind }
attributes #14 = { noredzone }
attributes #15 = { cold noredzone }
attributes #16 = { noredzone nounwind }
attributes #17 = { noredzone nounwind readnone willreturn }
attributes #18 = { nounwind readnone }

!llvm.named.register.rsp = !{!0}
!llvm.module.flags = !{!1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{!"rsp"}
!1 = !{i32 1, !"wchar_size", i32 2}
!2 = !{i32 1, !"Code Model", i32 2}
!3 = !{i32 1, !"override-stack-alignment", i32 8}
!4 = !{i32 4, !"SkipRaxSetup", i32 1}
!5 = !{!"Ubuntu clang version 14.0.0-1ubuntu1.1"}
!6 = !{i64 2156506850, i64 2156506879, i64 2156506925, i64 2156506983, i64 2156507037, i64 2156507091, i64 2156507146, i64 2156507177}
!7 = !{i64 2156507816, i64 2156507658, i64 2156507707, i64 2156507759, i64 2156507787}
!8 = !{i32 1215393}
!9 = !{i32 1215422}
!10 = !{i64 2149510190, i64 2149510219, i64 2149510265, i64 2149510323, i64 2149510377, i64 2149510431, i64 2149510486, i64 2149510517}
!11 = !{i64 2149511159, i64 2149511004, i64 2149511053, i64 2149511105, i64 2149511133}
!12 = !{i64 2156521305, i64 2156521334, i64 2156521380, i64 2156521438, i64 2156521492, i64 2156521546, i64 2156521601, i64 2156521632}
!13 = !{i64 2156522272, i64 2156522114, i64 2156522163, i64 2156522215, i64 2156522243}
!14 = !{i64 672370}
!15 = !{i64 2150651458, i64 2150651487, i64 2150651533, i64 2150651591, i64 2150651645, i64 2150651699, i64 2150651754, i64 2150651785}
!16 = !{i64 2150652455, i64 2150652298, i64 2150652349, i64 2150652401, i64 2150652429}
!17 = !{i64 2156730390, i64 2156730419, i64 2156730465, i64 2156730523, i64 2156730577, i64 2156730631, i64 2156730686, i64 2156730717}
!18 = !{i64 2156731358, i64 2156731200, i64 2156731249, i64 2156731301, i64 2156731329}
!19 = !{i64 2156586201, i64 2156586230, i64 2156586276, i64 2156586334, i64 2156586388, i64 2156586442, i64 2156586497, i64 2156586528}
!20 = !{i64 2156587168, i64 2156587010, i64 2156587059, i64 2156587111, i64 2156587139}
!21 = !{i64 2156703980, i64 2156704009, i64 2156704055, i64 2156704113, i64 2156704167, i64 2156704221, i64 2156704276, i64 2156704307}
!22 = !{i64 2156704937, i64 2156704779, i64 2156704828, i64 2156704880, i64 2156704908}
!23 = !{i64 2156700744, i64 2156700773, i64 2156700819, i64 2156700877, i64 2156700931, i64 2156700985, i64 2156701040, i64 2156701071}
!24 = !{i64 2156701701, i64 2156701543, i64 2156701592, i64 2156701644, i64 2156701672}
!25 = !{i64 2149508288, i64 2149508317, i64 2149508363, i64 2149508421, i64 2149508475, i64 2149508529, i64 2149508584, i64 2149508615}
!26 = !{i64 2149509257, i64 2149509102, i64 2149509151, i64 2149509203, i64 2149509231}
!27 = !{i64 2156697236, i64 2156697265, i64 2156697311, i64 2156697369, i64 2156697423, i64 2156697477, i64 2156697532, i64 2156697563}
!28 = !{i64 2156698204, i64 2156698046, i64 2156698095, i64 2156698147, i64 2156698175}
!29 = !{i64 2156519011, i64 2156519040, i64 2156519086, i64 2156519144, i64 2156519198, i64 2156519252, i64 2156519307, i64 2156519338}
!30 = !{i64 2156519967, i64 2156519809, i64 2156519858, i64 2156519910, i64 2156519938}
!31 = !{i64 2156560759, i64 2156560788, i64 2156560834, i64 2156560892, i64 2156560946, i64 2156561000, i64 2156561055, i64 2156561086}
!32 = !{i64 2156561715, i64 2156561557, i64 2156561606, i64 2156561658, i64 2156561686}
!33 = !{i64 2148737784}
!34 = !{i64 2156510335}
!35 = !{i64 2156562311, i64 2156562340, i64 2156562386, i64 2156562444, i64 2156562498, i64 2156562552, i64 2156562607, i64 2156562638}
!36 = !{i64 2156563267, i64 2156563109, i64 2156563158, i64 2156563210, i64 2156563238}
!37 = !{i64 2156690263, i64 2156690292, i64 2156690338, i64 2156690396, i64 2156690450, i64 2156690504, i64 2156690559, i64 2156690590}
!38 = !{i64 2156691231, i64 2156691073, i64 2156691122, i64 2156691174, i64 2156691202}
!39 = !{i64 2156693029, i64 2156693058, i64 2156693104, i64 2156693162, i64 2156693216, i64 2156693270, i64 2156693325, i64 2156693356}
!40 = !{i64 2156693997, i64 2156693839, i64 2156693888, i64 2156693940, i64 2156693968}
!41 = !{i64 2156517152, i64 2156517181, i64 2156517227, i64 2156517285, i64 2156517339, i64 2156517393, i64 2156517448, i64 2156517479}
!42 = !{i64 2156518119, i64 2156517961, i64 2156518010, i64 2156518062, i64 2156518090}
!43 = !{i64 2156667404, i64 2156667433, i64 2156667479, i64 2156667537, i64 2156667591, i64 2156667645, i64 2156667700, i64 2156667731}
!44 = !{i64 2156668371, i64 2156668213, i64 2156668262, i64 2156668314, i64 2156668342}
!45 = !{i64 2156668998, i64 2156669027, i64 2156669073, i64 2156669131, i64 2156669185, i64 2156669239, i64 2156669294, i64 2156669325}
!46 = !{i64 2156669965, i64 2156669807, i64 2156669856, i64 2156669908, i64 2156669936}
!47 = !{i64 2156687060, i64 2156687089, i64 2156687135, i64 2156687193, i64 2156687247, i64 2156687301, i64 2156687356, i64 2156687387}
!48 = !{i64 2156688028, i64 2156687870, i64 2156687919, i64 2156687971, i64 2156687999}
!49 = !{i64 2156683232, i64 2156683261, i64 2156683307, i64 2156683365, i64 2156683419, i64 2156683473, i64 2156683528, i64 2156683559}
!50 = !{i64 2156684200, i64 2156684042, i64 2156684091, i64 2156684143, i64 2156684171}
!51 = !{i64 2156573575, i64 2156573604, i64 2156573650, i64 2156573708, i64 2156573762, i64 2156573816, i64 2156573871, i64 2156573902}
!52 = !{i64 2156574542, i64 2156574384, i64 2156574433, i64 2156574485, i64 2156574513}
!53 = !{i64 2156576155, i64 2156576184, i64 2156576230, i64 2156576288, i64 2156576342, i64 2156576396, i64 2156576451, i64 2156576482}
!54 = !{i64 2156577122, i64 2156576964, i64 2156577013, i64 2156577065, i64 2156577093}
!55 = !{i64 2156566484, i64 2156566513, i64 2156566559, i64 2156566617, i64 2156566671, i64 2156566725, i64 2156566780, i64 2156566811}
!56 = !{i64 2156567451, i64 2156567293, i64 2156567342, i64 2156567394, i64 2156567422}
!57 = !{i64 2156568874, i64 2156568903, i64 2156568949, i64 2156569007, i64 2156569061, i64 2156569115, i64 2156569170, i64 2156569201}
!58 = !{i64 2156569841, i64 2156569683, i64 2156569732, i64 2156569784, i64 2156569812}
!59 = !{i64 2156571231, i64 2156571260, i64 2156571306, i64 2156571364, i64 2156571418, i64 2156571472, i64 2156571527, i64 2156571558}
!60 = !{i64 2156572198, i64 2156572040, i64 2156572089, i64 2156572141, i64 2156572169}
!61 = !{i64 668834}
!62 = !{i64 2148201371, i64 2148201445}
!63 = !{i64 2156617482, i64 2156617511, i64 2156617557, i64 2156617615, i64 2156617669, i64 2156617723, i64 2156617778, i64 2156617809}
!64 = !{i64 2156618449, i64 2156618291, i64 2156618340, i64 2156618392, i64 2156618420}
!65 = !{i64 2156619009, i64 2156619038, i64 2156619084, i64 2156619142, i64 2156619196, i64 2156619250, i64 2156619305, i64 2156619336}
!66 = !{i64 2156619965, i64 2156619807, i64 2156619856, i64 2156619908, i64 2156619936}
!67 = !{i64 2156660793, i64 2156660822, i64 2156660868, i64 2156660926, i64 2156660980, i64 2156661034, i64 2156661089, i64 2156661120}
!68 = !{i64 2156665821, i64 2156665663, i64 2156665712, i64 2156665764, i64 2156665792}
!69 = !{i64 2156656971, i64 2156657000, i64 2156657046, i64 2156657104, i64 2156657158, i64 2156657212, i64 2156657267, i64 2156657298}
!70 = !{i64 2156657938, i64 2156657780, i64 2156657829, i64 2156657881, i64 2156657909}
!71 = !{i64 2156658610, i64 2156658639, i64 2156658685, i64 2156658743, i64 2156658797, i64 2156658851, i64 2156658906, i64 2156658937}
!72 = !{i64 2156659577, i64 2156659419, i64 2156659468, i64 2156659520, i64 2156659548}
!73 = !{i64 2156708051, i64 2156708080, i64 2156708126, i64 2156708184, i64 2156708238, i64 2156708292, i64 2156708347, i64 2156708378}
!74 = !{i64 2156709019, i64 2156708861, i64 2156708910, i64 2156708962, i64 2156708990}
!75 = !{i64 2156592729, i64 2156592758, i64 2156592804, i64 2156592862, i64 2156592916, i64 2156592970, i64 2156593025, i64 2156593056}
!76 = !{i64 2156593696, i64 2156593538, i64 2156593587, i64 2156593639, i64 2156593667}
